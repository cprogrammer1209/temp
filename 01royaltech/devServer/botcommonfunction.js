"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_2 = require("tslib");
const util_1 = require("util");
const errorInvoice_1 = require("../../errorInvoice/errorInvoice");
const product_1 = require("../../product/models/product");
let { OAuth } = require('oauth');
const twitter_api_v2_1 = require("twitter-api-v2");
const axios = require("axios");
const puppeteer = require('puppeteer');
const { Parser } = require('json2csv');
const stocks_1 = require("../models/stocks");
let PizZip = require('pizzip');
let Docxtemplater = require('docxtemplater');
//const _ = require('underscore');
var exec = require('child_process').exec;
// const cheerio = require('cheerio');
const tslib_1 = require("tslib");
var imaps = require('imap-simple');
//const _ = require('underscore')
const AdmZip = require('adm-zip');
const { Client } = require('node-scp');
const Excel = require('exceljs');
const { DateTime } = require("luxon");
const xml2js = require('xml2js');
const fetch = require('node-fetch');
const mzfs = require('mz/fs');
const { splitPDF } = require('pdf-toolz/SplitCombine');
const env_1 = require("../../../../env");
const Fuse = require('fuse.js');
const { spawn } = require('child_process');
const Logger_1 = require("../../../../decorators/Logger");
let config = require('../../../../resource/config.json');
const errWarn_1 = require("../../err-warn-master/models/errWarn");
//import { filter } from 'bluebird';
const typedi_1 = require("typedi");
const downloadUploadFileHelper_1 = require("../download-Upload-file/downloadUploadFileHelper");
const houseKeepingHelper_1 = require("../../houseKeepingProcess/houseKeepingHelper");
const maillistner_1 = require("../mail_listner/maillistner");
const EmailListnernew_1 = require("../mail_listner/EmailListnernew");
const scriptHelper_1 = require("../scripts/scriptHelper");
const nodemailer = require("nodemailer");
const twitterHelper_1 = require("../twitter/helper/twitterHelper");
const linkedInHelper_1 = require("../linkedIn/helper/linkedInHelper");
const fbHelper_1 = require("../fbPost/helpers/fbHelper");
let fs = require('fs');
const lodash_1 = require("lodash");
let fileUploadHistory = require('../fileUploadHistory/models/fileUploadHistory');
let fileQueue = require('../../fileQueue/models/fileQueue');
const io = require("socket.io-client");
const eventStatus_1 = require("../../event-statuses/models/eventStatus");
const organizationService_1 = require("../../../controllers/organization/services/organizationService");
//import { process } from '../../process/models/process';
//import * as io from 'socket.io-client';
const connectSocketService_1 = require("../../chat/services/connectSocketService");
var csvjson = require('csvjson');
//import moment = require('moment');
const auditCaHelper_1 = require("../auditCa/auditCaHelper");
const MetaDataService_1 = require("../../metaData/services/MetaDataService");
const oracalHelper_1 = require("../oracalBot/helper/oracalHelper");
const reconcileService_1 = require("../reconciliation/services/reconcileService");
const invoiceService_1 = require("../../invoice/services/invoiceService");
const smtpTransport = require('nodemailer-smtp-transport');
// const numeral = require('numeral');
var exec = require('child_process').exec;
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
const MongoClient = require('mongodb').MongoClient;
// import { dbString } from "../../../../lib/env/utils";
const reconcilationService_1 = require("../../reconcilation/services/reconcilationService");
const businessTypeService_1 = require("../../businessType/services/businessTypeService");
const mongoose = require("mongoose");
const newsService_1 = require("../../news/services/newsService");
const webCrawlerService_1 = require("../../web-crowler/services/webCrawlerService");
const fileQueueService_1 = require("../../fileQueue/services/fileQueueService");
const ObjectId = mongoose.Types.ObjectId;
const pdftk = require('node-pdftk');
const request = require("request-promise");
var XLSX = require('xlsx');
var xlsx = require('node-xlsx');
const User_1 = require("../../user/models/User");
const dmsService_1 = require("../../dms/services/dmsService");
const accountHelper_1 = require("../../account/helpers/accountHelper");
const reconciliationMapperService_1 = require("../../reconciliation-mapping/services/reconciliationMapperService");
const RuleEngineService_1 = require("../../../controllers/ruleEngine/service/RuleEngineService");
const travelCost_1 = require("../../model/travelCost");
const costCenterBuget_1 = require("../../model/costCenterBuget");
var path = require("path");
const msg91 = require("msg91-sms");
const env_2 = require("../../../../env");
const exicesPercentage_1 = require("../../model/exicesPercentage");
const exciseRate = require("../../model/exciseRates");
const pdftk_1 = require("../../model/pdftk");
const dms_1 = require("../../dms/models/dms");
const pdf = require('pdf-parse');
var XLSX = require('xlsx');
var moment = require('moment');
let parser = require('word-text-parser');
var _ = require('underscore');
const aws = require('aws-sdk');
const simpleParser = require("mailparser").simpleParser;
let docTraining = require('../models/documentTraining');
let scanField = require('../models/scanningFields');
let jwt = require('jwt-simple');
//const aws = require('aws-sdk');
const mv = require('mv');
//import { dms } from '../../dms/models/dms';
const event_1 = require("../../event/models/event");
//import { resolve } from 'bluebird';
const JWT_SECRET = 'AXRWJNqr9SjEYXdJFaFXqADq8ipb1vbf';
var exec = require('child_process').exec;
const { GoogleSpreadsheet } = require('google-spreadsheet');
const bToa = require('btoa');
let stringSimilarity = require("string-similarity");
let evalObjField, evalObjValue;
const db = require('../../../../mongooseClient').default;
const cheerio = require('cheerio');
// const { spawn } = require('child_process');
const XlsxPopulate = require('xlsx-populate');
//const { Worker } = require('worker_threads');
const yauzl = require('yauzl');
const sax = require('sax');
const util_2 = require("util");
const RequestTracker_1 = require("../../../middlewares/RequestTracker");
class botCommonFunctions {
    constructor() {
        // this.getAllSchemas();
        this.operators = {
            '<': function (a, b) { console.log(a, "<", b); return a < b; },
            '>': function (a, b) { console.log(a, ">", b); return a > b; },
            '!==': function (a, b) { if (a == 'true' || a == 'false' || b == 'true' || b == 'false') {
                console.log(a, "!==", b);
                return JSON.parse(a) == JSON.parse(b);
            }
            else {
                console.log(a, "!==", b);
                return a !== b;
            } },
            '<=': function (a, b) { console.log(a, "<=", b); return a <= b; },
            '>=': function (a, b) { console.log(a, ">=", b); return a >= b; },
            '===': function (a, b) { if (a == 'true' || a == 'false' || b == 'true' || b == 'false') {
                console.log(a, "===", b);
                return JSON.parse(a) == JSON.parse(b);
            }
            else {
                console.log(a, "===", b);
                return a === b;
            } },
            'contains': function (a, b) { console.log("a ----->", a, "----------->", b); return a.includes(b); },
            'In': function (a, b) { return a in b; },
            'between': function (value, inputRange) {
                inputRange = inputRange.trim();
                inputRange = inputRange.substring(1, inputRange.length - 2);
                let firstInput = this.Split(inputRange, ",", 0);
                let secodnInput = this.Split(inputRange, ",", 1);
                if (value > firstInput && value < secodnInput) {
                    return true;
                }
                else {
                    return false;
                }
            },
            'findIn': function (value, inputArray) {
                inputArray = inputArray.trim();
                inputArray = inputArray.substring(1, inputArray.length - 2);
                let arr = inputArray.split(",");
                if (arr.indexOf(value) === -1) {
                    return false;
                }
                else {
                    return true;
                }
            }
        };
        this.downloadUploadFileHelper = typedi_1.Container.get(downloadUploadFileHelper_1.DownloadUploadFileHelper);
        this.scriptHelper = typedi_1.Container.get(scriptHelper_1.ScriptHelper);
        this.MaillistnerHelper = typedi_1.Container.get(maillistner_1.MaillistnerHelper);
        this.EMaillistnerHelper = typedi_1.Container.get(EmailListnernew_1.EMaillistnerHelper);
        this.houseKeepingHelper = typedi_1.Container.get(houseKeepingHelper_1.HouseKeepingHelper);
        this.twitterHelper = typedi_1.Container.get(twitterHelper_1.TwitterHelper);
        this.fbHelper = typedi_1.Container.get(fbHelper_1.FbHelper);
        this.linkedInHelper = typedi_1.Container.get(linkedInHelper_1.LinkedInHelper);
        this.auditCaHelper = typedi_1.Container.get(auditCaHelper_1.AuditCaHelper);
        this.oracleHelper = typedi_1.Container.get(oracalHelper_1.OracleHelper);
        this.metaDataService = typedi_1.Container.get(MetaDataService_1.MetaDataService);
        this.metaDataService = typedi_1.Container.get(MetaDataService_1.MetaDataService);
        this.reconcile = typedi_1.Container.get(reconcileService_1.ReconcileService);
        this.invoiceService = typedi_1.Container.get(invoiceService_1.InvoiceService);
        this.reconcilationService = typedi_1.Container.get(reconcilationService_1.ReconcilationService);
        this.connectSocketService = typedi_1.Container.get(connectSocketService_1.ConnectSocketService);
        this.socket = this.connectSocketService.socket;
        this.businessTypeService = typedi_1.Container.get(businessTypeService_1.BusinessTypeService);
        this.newsServive = typedi_1.Container.get(newsService_1.NewsService);
        this.webCrawlerService = typedi_1.Container.get(webCrawlerService_1.WebCrawlerService);
        this.fileQueueService = typedi_1.Container.get(fileQueueService_1.FileQueueService);
        this.dmsServices = typedi_1.Container.get(dmsService_1.DmsService);
        this.accountHelper = typedi_1.Container.get(accountHelper_1.AccountHelper);
        this.reconciliationMapperService = typedi_1.Container.get(reconciliationMapperService_1.ReconciliationMapperService);
        this.RuleEngineService = typedi_1.Container.get(RuleEngineService_1.RuleEngineService);
        this.OrganizationService = typedi_1.Container.get(organizationService_1.OrganizationService);
        this.monitorInstances = new Map();
        //let link = config.urlLink;
        //  this.socket = io.connect(link, { transports: ['websocket'], secure: true });
    }
    GetFormattedDate(date) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let month = date.getMonth() + 1;
                let day = date.getDate();
                let year = date.getFullYear();
                return month + "/" + day + "/" + year;
            }
            catch (error) {
                return error;
            }
        });
    }
    monthDiff(d1, d2) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let checkMonthDiff = new Date(d1.getFullYear(), d1.getMonth() + 1, 0);
            let checkdate1 = yield this.GetFormattedDate(d1);
            let checkdate2 = yield this.GetFormattedDate(checkMonthDiff);
            let months;
            months = (d2.getFullYear() - d1.getFullYear()) * 12;
            months -= d1.getMonth();
            months += d2.getMonth();
            if (checkdate1 == checkdate2) {
                months = months <= 0 ? 0 : months;
            }
            else {
                months = months <= 0 ? 0 : months;
            }
            return months;
        });
    }
    loanTakenRecordForPSCFC(loan) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let temp = {};
            temp["adviceType"] = 'Reconcilition';
            temp["bankName"] = loan.bankName;
            temp["interestType"] = loan.interestType;
            temp["billReferenceNo"] = loan.billReferenceNo;
            temp["currencyType"] = loan.currencyType;
            temp["tenor"] = loan.tenor;
            temp["loanReferenceNo"] = loan.loanReferenceNo;
            temp["invoiceNumber"] = loan.invoiceNumber;
            temp["takenDate"] = new Date(loan.takenDate);
            temp["dueDate"] = new Date(loan.dueDate);
            temp["loanAmountInUSD"] = Number(loan.loanAmountInUSD);
            temp["loanAmountInINR"] = Number(loan.loanAmountInINR);
            temp["status"] = 'open';
            temp["netInt"] = loan.netInt;
            temp["netIntSub"] = loan.netIntSub;
            temp["convertedRateLoanTaken"] = Number(loan.convertedRateLoanTaken);
            temp["bankConvertedRate"] = Number(loan.bankConvertedRate);
            temp["tallyDetails"] = !util_1.isNullOrUndefined(loan.tallyDetails) ? loan.tallyDetails : [
                {
                    "paymentSerial": loan.paymentSerial || '',
                    "repaymentDate": new Date(loan.dueDate),
                    "repaymentAmountInUSD": 0,
                    "repaymentAmountInINR": 0,
                    "balanceInUSD": Number(loan.loanAmountInUSD),
                    "balanceInINR": Number(loan.loanAmountInINR),
                    "days": 0,
                    "interestInUSD": 0,
                    "interestInINR": 0,
                    "interestSub": 0,
                    "totalDays": 0,
                    "totalInterestInUSD": 0,
                    "totalInterestInINR": 0,
                    "totalInterestSub": 0,
                    "bankInterestInUSD": 0,
                    "bankInterestInINR": 0,
                    "bankInterestSub": 0,
                    "totalBankInterestInUSD": 0,
                    "totalBankInterestInINR": 0,
                    "totalBankInterestSub": 0,
                    "exchangeRate": 0,
                    "diffInUSD": 0,
                    "diffInINR": 0,
                    "diffInSub": 0,
                    "comment": ""
                }
            ];
            return temp;
        });
    }
    loanTakenRecordForPCFC(loan) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let temp = {};
            temp["adviceType"] = 'Reconcilition';
            temp["bankName"] = loan.bankName;
            temp["interestType"] = loan.interestType;
            temp["tenor"] = loan.tenor;
            temp["billReferenceNo"] = loan.billReferenceNo;
            temp["currencyType"] = loan.currencyType;
            temp["loanReferenceNo"] = loan.loanReferenceNo;
            temp["invoiceNumber"] = loan.invoiceNumber;
            temp["takenDate"] = new Date(loan.takenDate);
            temp["dueDate"] = new Date(loan.dueDate);
            temp["loanAmountInUSD"] = Number(loan.loanAmountInUSD);
            temp["loanAmountInINR"] = Number(loan.loanAmountInINR);
            temp["status"] = 'open';
            temp["netInt"] = loan.netInt;
            temp["netIntSub"] = loan.netIntSub;
            temp["convertedRateLoanTaken"] = Number(loan.convertedRateLoanTaken);
            temp["bankConvertedRate"] = Number(loan.bankConvertedRate);
            temp["tallyDetails"] = !util_1.isNullOrUndefined(loan.tallyDetails) ? loan.tallyDetails : [
                {
                    "repaymentDate": new Date(loan.dueDate),
                    "repaymentAmountInUSD": Number(0),
                    "repaymentAmountInINR": Number(0),
                    "balanceInUSD": Number(loan.loanAmountInUSD),
                    "balanceInINR": Number(loan.loanAmountInINR),
                    "days": 0,
                    "interestInUSD": 0,
                    "interestInINR": 0,
                    "interestSub": 0,
                    "totalDays": 0,
                    "totalInterestInUSD": 0,
                    "totalInterestInINR": 0,
                    "totalInterestSub": 0,
                    "bankInterestInUSD": 0,
                    "bankInterestInINR": 0,
                    "bankInterestSub": 0,
                    "totalBankInterestInUSD": 0,
                    "totalBankInterestInINR": 0,
                    "totalBankInterestSub": 0,
                    "ExchangeRate": 0,
                    "diffInUSD": 0,
                    "diffInINR": 0,
                    "diffInSub": 0,
                    "comment": ""
                }
            ];
            return temp;
        });
    }
    loanTakenRecordForPC(loan) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let temp = {};
            temp["adviceType"] = 'Reconcilition';
            temp["bankName"] = loan.bankName;
            temp["interestType"] = loan.interestType;
            temp["tenor"] = loan.tenor;
            temp["billReferenceNo"] = loan.billReferenceNo;
            temp["currencyType"] = loan.currencyType;
            temp["loanReferenceNo"] = loan.loanReferenceNo;
            temp["invoiceNumber"] = loan.invoiceNumber;
            temp["takenDate"] = new Date(loan.takenDate);
            temp["dueDate"] = new Date(loan.dueDate);
            temp["loanAmountInUSD"] = Number(loan.loanAmountInUSD);
            temp["loanAmountInINR"] = Number(loan.loanAmountInINR);
            temp["status"] = 'open';
            temp["netInt"] = loan.netInt;
            temp["netIntSub"] = loan.netIntSub;
            temp["convertedRateLoanTaken"] = Number(loan.convertedRateLoanTaken);
            temp["bankConvertedRate"] = Number(loan.bankConvertedRate);
            temp["tallyDetails"] = !util_1.isNullOrUndefined(loan.tallyDetails) ? loan.tallyDetails : [
                {
                    "repaymentDate": new Date(loan.dueDate),
                    "repaymentAmountInUSD": Number(0),
                    "repaymentAmountInINR": Number(0),
                    "balanceInUSD": Number(loan.loanAmountInUSD),
                    "balanceInINR": Number(loan.loanAmountInINR),
                    "days": 0,
                    "interestInUSD": 0,
                    "interestInINR": 0,
                    "interestSub": 0,
                    "totalDays": 0,
                    "totalInterestInUSD": 0,
                    "totalInterestInINR": 0,
                    "totalInterestSub": 0,
                    "bankInterestInUSD": 0,
                    "bankInterestInINR": 0,
                    "bankInterestSub": 0,
                    "totalBankInterestInUSD": 0,
                    "totalBankInterestInINR": 0,
                    "totalBankInterestSub": 0,
                    "ExchangeRate": 0,
                    "diffInUSD": 0,
                    "diffInINR": 0,
                    "diffInSub": 0,
                    "comment": ""
                }
            ];
            return temp;
        });
    }
    sortByLoanTakenAndLoanRepayment(dailyLoanDetailsData) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            /*
                1. sort the all dailyLoanDetailsData using fileType filed  as  Loan Taken And Loan repayment.
            */
            let repaymentAdvice = [];
            let takenAdvice = [];
            for (let loanAdvice of dailyLoanDetailsData) {
                console.log(loanAdvice.fileType);
                if (loanAdvice.fileType == "loan repayment file") {
                    repaymentAdvice.push(loanAdvice);
                }
                if (loanAdvice.fileType == "loan taken file") {
                    takenAdvice.push(loanAdvice);
                }
            }
            return { "takenAdvice": takenAdvice, "repaymentAdvice": repaymentAdvice };
        });
    }
    calculateInterest(balance, netInt, days, date, bankName) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const dateTime = require('date-and-time');
                let dayInYear = 365;
                if (bankName != 'YES BANK') {
                    dayInYear = dateTime.isLeapYear(date.getFullYear()) ? 366 : 365;
                }
                else if (bankName == 'YES BANK') {
                    netInt = netInt / 100;
                }
                let interest = Number(balance) * Number(netInt) * Number(days) / dayInYear;
                interest = Number(interest.toFixed(2));
                if (bankName != 'YES BANK') {
                    interest = interest / 100;
                }
                return interest;
            }
            catch (e) {
                console.log("inside calculateInterest", e);
                return { message: 'Data Not Found', status: 1, data: '' };
            }
        });
    }
    interestCalculationForUSD(interestRate, amount, days) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            return ((interestRate * amount) * days) / 36000;
        });
    }
    interestCalculationForINR(interestRate, amount, days) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let interest = Number(amount) * Number(interestRate) * Number(days) / 365;
                interest = Number(interest.toFixed(2));
                return interest;
            }
            catch (e) {
                console.log("inside calculateInterest", e);
                return { message: 'Data Not Found', status: 1, data: '' };
            }
        });
    }
    saveAndUpdatePSCFC(reconcilition) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            for (let loan of reconcilition) {
                let searchLoan = yield (db.collection('ReconcilitionLoanDetails')).findOne({ "invoiceNumber": loan["invoiceNumber"] });
                if (util_1.isNullOrUndefined(searchLoan)) {
                    if (typeof (loan.dueDate) == 'string') {
                        loan.dueDate = loan.dueDate.substring(0, loan.dueDate.indexOf('T'));
                    }
                    if (typeof (loan.takenDate) == 'string') {
                        loan.takenDate = loan.takenDate.substring(0, loan.takenDate.indexOf('T'));
                    }
                    let d = new Date(loan.dueDate);
                    d.setHours(d.getHours() + 5);
                    d.setMinutes(d.getMinutes() + 30);
                    let d1 = new Date(loan.takenDate);
                    d1.setHours(d1.getHours() + 5);
                    d1.setMinutes(d1.getMinutes() + 30);
                    loan.dueDate = d;
                    loan.takenDate = d1;
                    for (let updateTallyDetails of loan.tallyDetails) {
                        if (typeof (updateTallyDetails.repaymentDate) == 'string') {
                            updateTallyDetails.repaymentDate = updateTallyDetails.repaymentDate.substring(0, updateTallyDetails.repaymentDate.indexOf('T'));
                        }
                        let d3 = new Date(updateTallyDetails.repaymentDate);
                        console.log(d3.toISOString());
                        d3.setHours(d3.getHours() + 5);
                        d3.setMinutes(d3.getMinutes() + 30);
                        console.log(d3.toISOString());
                        updateTallyDetails.repaymentDate = d3;
                    }
                    let result = yield (db.collection('ReconcilitionLoanDetails')).create(loan);
                    console.log(result);
                }
                else {
                    if (typeof (loan.dueDate) == 'string') {
                        loan.dueDate = loan.dueDate.substring(0, loan.dueDate.indexOf('T'));
                    }
                    if (typeof (loan.takenDate) == 'string') {
                        loan.takenDate = loan.takenDate.substring(0, loan.takenDate.indexOf('T'));
                    }
                    let d = new Date(loan.dueDate);
                    d.setHours(d.getHours() + 5);
                    d.setMinutes(d.getMinutes() + 30);
                    let d1 = new Date(loan.takenDate);
                    d1.setHours(d1.getHours() + 5);
                    d1.setMinutes(d1.getMinutes() + 30);
                    loan.dueDate = d;
                    loan.takenDate = d1;
                    for (let updateTallyDetails of loan.tallyDetails) {
                        if (typeof (updateTallyDetails.repaymentDate) == 'string') {
                            updateTallyDetails.repaymentDate = updateTallyDetails.repaymentDate.substring(0, updateTallyDetails.repaymentDate.indexOf('T'));
                        }
                        let d3 = new Date(updateTallyDetails.repaymentDate);
                        console.log(d3.toISOString());
                        d3.setHours(d3.getHours() + 5);
                        d3.setMinutes(d3.getMinutes() + 30);
                        console.log(d3.toISOString());
                        updateTallyDetails.repaymentDate = d3;
                    }
                    const result = yield (db.collection('ReconcilitionLoanDetails')).updateOne({ "invoiceNumber": loan["invoiceNumber"] }, { $set: loan }, { upsert: true });
                    console.log(result);
                }
            }
        });
    }
    saveAndUpdatePC(reconcilition) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            for (let loan of reconcilition) {
                let searchLoan = yield (db.collection('ReconcilitionLoanDetails')).findOne({ "loanReferenceNo": loan["loanReferenceNo"] });
                if (util_1.isNullOrUndefined(searchLoan)) {
                    if (typeof (loan.dueDate) == 'string') {
                        loan.dueDate = loan.dueDate.substring(0, loan.dueDate.indexOf('T'));
                    }
                    if (typeof (loan.takenDate) == 'string') {
                        loan.takenDate = loan.takenDate.substring(0, loan.takenDate.indexOf('T'));
                    }
                    let d = new Date(loan.dueDate);
                    d.setHours(d.getHours() + 5);
                    d.setMinutes(d.getMinutes() + 30);
                    let d1 = new Date(loan.takenDate);
                    d1.setHours(d1.getHours() + 5);
                    d1.setMinutes(d1.getMinutes() + 30);
                    loan.dueDate = d;
                    loan.takenDate = d1;
                    for (let updateTallyDetails of loan.tallyDetails) {
                        if (typeof (updateTallyDetails.repaymentDate) == 'string') {
                            updateTallyDetails.repaymentDate = updateTallyDetails.repaymentDate.substring(0, updateTallyDetails.repaymentDate.indexOf('T'));
                        }
                        let d3 = new Date(updateTallyDetails.repaymentDate);
                        console.log(d3.toISOString());
                        d3.setHours(d3.getHours() + 5);
                        d3.setMinutes(d3.getMinutes() + 30);
                        console.log(d3.toISOString());
                        updateTallyDetails.repaymentDate = d3;
                    }
                    let result = yield (db.collection('ReconcilitionLoanDetails')).create(loan);
                    console.log(result);
                }
                else {
                    if (typeof (loan.dueDate) == 'string') {
                        loan.dueDate = loan.dueDate.substring(0, loan.dueDate.indexOf('T'));
                    }
                    if (typeof (loan.takenDate) == 'string') {
                        loan.takenDate = loan.takenDate.substring(0, loan.takenDate.indexOf('T'));
                    }
                    let d = new Date(loan.dueDate);
                    d.setHours(d.getHours() + 5);
                    d.setMinutes(d.getMinutes() + 30);
                    let d1 = new Date(loan.takenDate);
                    d1.setHours(d1.getHours() + 5);
                    d1.setMinutes(d1.getMinutes() + 30);
                    loan.dueDate = d;
                    loan.takenDate = d1;
                    for (let updateTallyDetails of loan.tallyDetails) {
                        if (typeof (updateTallyDetails.repaymentDate) == 'string') {
                            updateTallyDetails.repaymentDate = updateTallyDetails.repaymentDate.substring(0, updateTallyDetails.repaymentDate.indexOf('T'));
                        }
                        let d3 = new Date(updateTallyDetails.repaymentDate);
                        console.log(d3.toISOString());
                        d3.setHours(d3.getHours() + 5);
                        d3.setMinutes(d3.getMinutes() + 30);
                        console.log(d3.toISOString());
                        updateTallyDetails.repaymentDate = d3;
                    }
                    const result = yield (db.collection('ReconcilitionLoanDetails')).updateOne({ "invoiceNumber": loan["invoiceNumber"] }, { $set: loan }, { upsert: true });
                    console.log(result);
                }
            }
        });
    }
    saveAndUpdateReconcilitionPCFC(reconcilitionData, bank_Current_Account_Statement_Details, startDate, endDate, isSub, pre) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            for (let loan of reconcilitionData) {
                let searchLoan = yield (db.collection('ReconcilitionLoanDetails')).findOne({ loanReferenceNo: loan["loanReferenceNo"] });
                if (util_1.isNullOrUndefined(searchLoan)) {
                    if (typeof (loan.dueDate) == 'string') {
                        loan.dueDate = loan.dueDate.substring(0, loan.dueDate.indexOf('T'));
                    }
                    if (typeof (loan.takenDate) == 'string') {
                        loan.takenDate = loan.takenDate.substring(0, loan.takenDate.indexOf('T'));
                    }
                    let d = new Date(loan.dueDate);
                    d.setHours(d.getHours() + 5);
                    d.setMinutes(d.getMinutes() + 30);
                    let d1 = new Date(loan.takenDate);
                    d1.setHours(d1.getHours() + 5);
                    d1.setMinutes(d1.getMinutes() + 30);
                    loan.dueDate = d;
                    loan.takenDate = d1;
                    for (let updateTallyDetails of loan.tallyDetails) {
                        if (typeof (updateTallyDetails.repaymentDate) == 'string') {
                            updateTallyDetails.repaymentDate = updateTallyDetails.repaymentDate.substring(0, updateTallyDetails.repaymentDate.indexOf('T'));
                        }
                        let d3 = new Date(updateTallyDetails.repaymentDate);
                        console.log(d3.toISOString());
                        d3.setHours(d3.getHours() + 5);
                        d3.setMinutes(d3.getMinutes() + 30);
                        console.log(d3.toISOString());
                        updateTallyDetails.repaymentDate = d3;
                    }
                    let checkStatus = loan.tallyDetails[loan.tallyDetails.length - 1];
                    let balance;
                    if (loan.currencyType == 'USD') {
                        balance = checkStatus.balanceInUSD;
                    }
                    else {
                        balance = checkStatus.balanceInINR;
                    }
                    if (balance <= 0) {
                        loan.status = 'close';
                    }
                    else {
                        if (loan.status = 'open') {
                            loan = yield this.calculationOfPCFC(loan, null, bank_Current_Account_Statement_Details, startDate, endDate, isSub, pre);
                            console.log(loan);
                        }
                    }
                    let result = yield (db.collection('ReconcilitionLoanDetails')).create(loan);
                    console.log(result);
                }
                else {
                    let checkStatus = loan.tallyDetails[loan.tallyDetails.length - 1];
                    let balance;
                    if (loan.currencyType == 'USD') {
                        balance = checkStatus.balanceInUSD;
                    }
                    else {
                        balance = checkStatus.balanceInINR;
                    }
                    if (balance <= 0) {
                        loan.status = 'close';
                    }
                    else {
                        if (loan.status = 'open') {
                            loan = yield this.calculationOfPCFC(loan, null, bank_Current_Account_Statement_Details, startDate, endDate, isSub, pre);
                            console.log(loan);
                        }
                    }
                    if (typeof (loan.dueDate) == 'string') {
                        loan.dueDate = loan.dueDate.substring(0, loan.dueDate.indexOf('T'));
                    }
                    if (typeof (loan.takenDate) == 'string') {
                        loan.takenDate = loan.takenDate.substring(0, loan.takenDate.indexOf('T'));
                    }
                    let d = new Date(loan.dueDate);
                    d.setHours(d.getHours() + 5);
                    d.setMinutes(d.getMinutes() + 30);
                    let d1 = new Date(loan.takenDate);
                    d1.setHours(d1.getHours() + 5);
                    d1.setMinutes(d1.getMinutes() + 30);
                    loan.dueDate = d;
                    loan.takenDate = d1;
                    for (let updateTallyDetails of loan.tallyDetails) {
                        if (typeof (updateTallyDetails.repaymentDate) == 'string') {
                            updateTallyDetails.repaymentDate = updateTallyDetails.repaymentDate.substring(0, updateTallyDetails.repaymentDate.indexOf('T'));
                        }
                        let d3 = new Date(updateTallyDetails.repaymentDate);
                        console.log(d3.toISOString());
                        d3.setHours(d3.getHours() + 5);
                        d3.setMinutes(d3.getMinutes() + 30);
                        console.log(d3.toISOString());
                        updateTallyDetails.repaymentDate = d3;
                    }
                    const result = yield (db.collection('ReconcilitionLoanDetails')).updateOne({ loanReferenceNo: loan["loanReferenceNo"] }, { $set: loan }, { upsert: true });
                    console.log(result);
                }
            }
        });
    }
    calculationOfPSCFC(reconcilition, replaymentAdvice, bankCurrentAccountStatementDetails, isSubvention, precentage) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const dateTime = require('date-and-time');
                let updateTallyDetails = reconcilition.tallyDetails;
                //Get the last replayment details Bcoz we need the calculate the from with.
                let lastdueDate = updateTallyDetails[updateTallyDetails.length - 1].repaymentDate;
                let currentRepaymentDate = replaymentAdvice.repaymentDate;
                let Days = dateTime.subtract(new Date(lastdueDate), new Date(currentRepaymentDate)).toDays();
                let interestInUSD = 0;
                let interestInINR = 0;
                let repaymentAmountInUSD = 0;
                let repaymentAmountInINR = 0;
                let totalInterestInUSD = 0;
                let totalInterestInINR = 0;
                let balanceInUSD = 0;
                let balanceInINR = 0;
                let interestSub = 0;
                let totalInterestSub = 0;
                let bankInterestInUSD = 0;
                let bankInterestInINR = 0;
                let totalBankInterestInUSD = 0;
                let totalBankInterestInINR = 0;
                let diffInUSD = 0;
                let diffInINR = 0;
                let bankInterestSub = 0;
                let totalBankInterestSub = 0;
                let diffInSub = 0;
                let totalDays = updateTallyDetails[updateTallyDetails.length - 1].totalDays + Days;
                //check currencyType in
                if (reconcilition.currencyType == "USD") {
                    repaymentAmountInUSD = replaymentAdvice.repaymentAmountInUSD;
                    //using the formula calculate interestInUSD
                    interestInUSD = yield this.interestCalculationForUSD(reconcilition.netInt, repaymentAmountInUSD, Days);
                    //
                    totalInterestInUSD = updateTallyDetails[updateTallyDetails.length - 1].totalInterestInUSD + interestInUSD;
                    balanceInUSD = Number((updateTallyDetails[updateTallyDetails.length - 1].balanceInUSD - repaymentAmountInUSD).toFixed(2));
                    /*
                        firstly we check the bank repayment amount  present in repayment advice or not.
                        if present the we go with them else we check bankCurrentAccountStatementDetails
                    */
                    if (replaymentAdvice.bankRepaymentAmountInUSD !== 0) {
                        bankInterestInUSD = replaymentAdvice.bankRepaymentAmountInUSD;
                        totalBankInterestInUSD = updateTallyDetails[updateTallyDetails.length - 1].totalBankInterestInUSD + bankInterestInUSD;
                    }
                    else {
                        if (balanceInUSD <= 0) {
                            //filter the invoice number or billReferenceNo
                            let bankInterest = bankCurrentAccountStatementDetails.filter(data => data.description.includes(replaymentAdvice.invoiceNumber) || data.description.includes(replaymentAdvice.billReferenceNo));
                            // sum of bankInterest
                            bankInterestInUSD = bankInterest.reduce((accumulator, currentValue) => accumulator + currentValue.credit, 0);
                            //sum of all totalBankInterest
                            totalBankInterestInUSD = updateTallyDetails.reduce((accumulator, currentValue) => accumulator + currentValue.totalBankInterestInUSD, 0);
                            totalBankInterestInUSD = totalBankInterestInUSD + bankInterestInUSD;
                            let ids = bankInterest.map(a => ObjectId(a._id));
                            yield (db.collection('Bank_Current_Account_Statement')).updateMany({ "_id": { "$in": ids } }, { $set: { "status": "used" } }, { upsert: true });
                        }
                    }
                    diffInUSD = totalInterestInUSD - totalBankInterestInUSD;
                }
                //check currencyType INR
                if (reconcilition.currencyType == "INR") {
                    repaymentAmountInINR = replaymentAdvice.repaymentAmountInINR;
                    //using the formula calculate interestInINR
                    interestInINR = yield this.interestCalculationForINR(reconcilition.netInt, repaymentAmountInINR, Days);
                    //for totalInterest we take last totalInterestInUSD
                    totalInterestInINR = updateTallyDetails[updateTallyDetails.length - 1].totalInterest + interestInUSD;
                    balanceInINR = Number((updateTallyDetails[updateTallyDetails.length - 1].balanceInUSD - replaymentAdvice.repaymentAmountInINR).toFixed(2));
                    //if we get bank repayment amount in advice then we use that other wise we take in bank_current_account
                    if (replaymentAdvice.bankRepaymentAmountInINR !== 0) {
                        bankInterestInINR = replaymentAdvice.bankRepaymentAmountInINR;
                        totalBankInterestInINR = updateTallyDetails[updateTallyDetails.length - 1].totalBankInterestInINR + bankInterestInINR;
                    }
                    else {
                        if (balanceInUSD <= 0) {
                            //filter the invoice number or billReferenceNo
                            let bankInterest = bankCurrentAccountStatementDetails.filter(data => data.description.includes(replaymentAdvice.invoiceNumber) || data.description.includes(replaymentAdvice.billReferenceNo));
                            // sum of bankInterest
                            bankInterestInUSD = bankInterest.reduce((accumulator, currentValue) => accumulator + currentValue.credit, 0);
                            //sum of all totalBankInterest
                            totalBankInterestInINR = updateTallyDetails.reduce((accumulator, currentValue) => accumulator + currentValue.totalBankInterestInINR, 0);
                            totalBankInterestInINR = totalBankInterestInINR + bankInterestInUSD;
                            let ids = bankInterest.map(a => ObjectId(a._id));
                            yield (db.collection('Bank_Current_Account_Statement')).updateMany({ "_id": { "$in": ids } }, { $set: { "status": "used" } }, { upsert: true });
                        }
                    }
                    diffInINR = totalInterestInINR - totalBankInterestInINR;
                    //check issubvention true then we calculate the that
                    if (isSubvention) {
                        interestSub = yield this.interestCalculationForINR(precentage, repaymentAmountInINR, Days);
                        totalInterestSub = updateTallyDetails[updateTallyDetails.length - 1].totalInterestSub + interestSub;
                        /*
                            for subvention bank interest code is pendding after client share write the code.
                        */
                        diffInSub = totalInterestSub - totalBankInterestSub;
                    }
                }
                if (0 >= balanceInUSD) {
                    reconcilition.status = 'close';
                }
                reconcilition['tallyDetails'].push({
                    "paymentSerial": replaymentAdvice.paymentSerial || '',
                    "repaymentDate": new Date(replaymentAdvice.repaymentDate),
                    "repaymentAmountInUSD": Number(repaymentAmountInUSD),
                    "repaymentAmountInINR": Number(repaymentAmountInINR),
                    "balanceInUSD": balanceInUSD,
                    "balanceInINR": balanceInINR,
                    "days": Days,
                    "interestInUSD": interestInUSD,
                    "interestInINR": interestInINR,
                    "interestSub": interestSub,
                    "totalDays": totalDays,
                    "totalInterestInUSD": totalInterestInUSD,
                    "totalInterestInINR": totalInterestInINR,
                    "totalInterestSub": totalInterestSub,
                    "bankInterestInUSD": bankInterestInUSD,
                    "bankInterestInINR": bankInterestInINR,
                    "bankInterestSub": bankInterestSub,
                    "totalBankInterestInUSD": totalBankInterestInUSD,
                    "totalBankInterestInINR": totalBankInterestInINR,
                    "totalBankInterestSub": totalBankInterestSub,
                    "ExchangeRate": 0,
                    "diffInUSD": diffInUSD,
                    "diffInINR": diffInINR,
                    "diffInSub": diffInSub,
                    "comment": ""
                });
            }
            catch (err) {
                return err;
            }
        });
    }
    calculationOfPCFC(reconcilition, loan, bankCurrentAccountStatementDetails, startDate, endDate, isSubvention, precentage) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const dateTime = require('date-and-time');
                let updateTallyDetails = reconcilition.tallyDetails;
                let date1 = new Date(startDate);
                let date2 = new Date(endDate);
                /*
                   @First If :: Check the updatetallyDetails is length
                   @Second If ::  if array length is one then we take date takendate otherwise we tabke repaymentDate
                */
                if (!util_1.isNullOrUndefined(loan) && Object.keys(loan).length != 0) {
                    date2 = new Date(loan.repaymentDate);
                }
                if (updateTallyDetails.length == 1) {
                    date1 = reconcilition.takenDate;
                }
                else {
                    date1 = updateTallyDetails[updateTallyDetails.length - 1].repaymentDate;
                }
                /*
                    if Repayment date and last repayment date is same then we update at last array object
                 */
                if (date1 == date2) {
                    if (!util_1.isNullOrUndefined(loan)) {
                        let totalBankInterestInUSD = 0;
                        updateTallyDetails[updateTallyDetails.length - 1].repaymentAmountInUSD = updateTallyDetails[updateTallyDetails.length - 1].repaymentAmountInUSD + Number(loan.repaymentAmountInUSD);
                        updateTallyDetails[updateTallyDetails.length - 1].repaymentAmountInINR = updateTallyDetails[updateTallyDetails.length - 1].repaymentAmountInINR + Number(loan.repaymentAmountInINR);
                        updateTallyDetails[updateTallyDetails.length - 1].balanceInUSD = updateTallyDetails[updateTallyDetails.length - 1].balanceInUSD - Number(loan.repaymentAmountInUSD);
                        updateTallyDetails[updateTallyDetails.length - 1].balanceInINR = updateTallyDetails[updateTallyDetails.length - 1].balanceInINR - Number(loan.repaymentAmountInINR);
                        let interestInUSD = yield this.interestCalculationForUSD(reconcilition.netInt, updateTallyDetails[updateTallyDetails.length - 1].balanceInUSD, updateTallyDetails[updateTallyDetails.length - 1].days);
                        updateTallyDetails[updateTallyDetails.length - 1].interestInUSD = interestInUSD;
                        updateTallyDetails[updateTallyDetails.length - 1].totalInterestInUSD = updateTallyDetails[updateTallyDetails.length - 1].totalInterestInUSD + interestInUSD;
                        if (0 >= updateTallyDetails[updateTallyDetails.length - 1].balanceInUSD) {
                            reconcilition.status = 'close';
                            let bankInterest = bankCurrentAccountStatementDetails.filter(data => data.description.includes(loan.loanReferenceNo));
                            let sumOfTotal = updateTallyDetails.reduce((a, b) => a + b.bankInterestInUSD, 0);
                            // sum of bankInterest
                            let bankInterestInUSD = bankInterest.reduce((accumulator, currentValue) => accumulator + currentValue.credit, 0);
                            if (reconcilition.bankName == "CANARA BANK") {
                                totalBankInterestInUSD = sumOfTotal + (bankInterestInUSD / 75);
                            }
                            else {
                                totalBankInterestInUSD = sumOfTotal + bankInterestInUSD;
                            }
                            updateTallyDetails[updateTallyDetails.length - 1].diffInUSD = updateTallyDetails[updateTallyDetails.length - 1].totalInterestInUSD - totalBankInterestInUSD;
                            let ids = bankCurrentAccountStatementDetails.map(a => ObjectId(a._id));
                            yield (db.collection('Bank_Current_Account_Statement')).updateMany({ "_id": { "$in": ids } }, { $set: { "status": "used" } }, { upsert: true });
                        }
                        else {
                            updateTallyDetails[updateTallyDetails.length - 1].diffInUSD = updateTallyDetails[updateTallyDetails.length - 1].totalInterestInUSD - totalBankInterestInUSD;
                        }
                    }
                    return;
                }
                /*
                    @monthDiff is use for the diff of current repayment date and at last inside tallyDetails array object repayment Date.
                */
                let monthDiff = 0;
                monthDiff = yield this.monthDiff(date1, date2);
                if (monthDiff == 0 && util_1.isNullOrUndefined(loan)) {
                    return;
                }
                let i = 0;
                /*
                    In this loop iterator the @monthDiff Wise Becoz we want store the MONTHEND Data inside that tallyDetails (Reconcilition)
                */
                for (; i < monthDiff; i++) {
                    let newdate1 = new Date();
                    let newdate2 = new Date();
                    if (i != 0) {
                        newdate1 = updateTallyDetails[updateTallyDetails.length - 1].repaymentDate;
                        newdate2 = new Date(newdate1.getFullYear(), newdate1.getMonth() + 1, 0);
                    }
                    else {
                        newdate1 = date1;
                        newdate2 = new Date(newdate1.getFullYear(), newdate1.getMonth() + 1, 0);
                    }
                    let Days = dateTime.subtract(newdate2, newdate1).toDays();
                    Days = i == 0 ? Math.round(Days) + 1 : Math.round(Days);
                    let interestInUSD = 0;
                    let interestInINR = 0;
                    let replaymentInUSD = 0;
                    let replaymentInINR = 0;
                    let totalInterestInUSD = 0;
                    let totalInterestInINR = 0;
                    let balanceInUSD = 0;
                    let balanceInINR = 0;
                    let interestSub = 0;
                    let totalInterestSub = 0;
                    let bankInterestInUSD = 0;
                    let bankInterestInINR = 0;
                    let totalBankInterestInUSD = 0;
                    let totalBankInterestInINR = 0;
                    let diffInUSD = 0;
                    let diffInINR = 0;
                    let bankInterestSub = 0;
                    let totalBankInterestSub = 0;
                    let diffInSub = 0;
                    let totalDays = updateTallyDetails[updateTallyDetails.length - 1].totalDays + Days;
                    if (reconcilition.currencyType == "USD") {
                        let balance = updateTallyDetails[updateTallyDetails.length - 1].balanceInUSD;
                        balanceInUSD = Number((updateTallyDetails[updateTallyDetails.length - 1].balanceInUSD).toFixed(2));
                        interestInUSD = yield this.interestCalculationForUSD(reconcilition.netInt, balance, Days);
                        totalInterestInUSD = updateTallyDetails[updateTallyDetails.length - 1].totalInterestInUSD + interestInUSD;
                        if (util_1.isNullOrUndefined(loan)) {
                            let bankInterestSum = bankCurrentAccountStatementDetails.filter(data => data.description.includes(reconcilition.loanReferenceNo)).reduce((a, i) => a + i.credit, 0);
                            let sumOfTotal = updateTallyDetails.reduce((a, b) => a + b.bankInterestInUSD, 0);
                            if (reconcilition.bankName == "CANARA BANK") {
                                bankInterestInUSD = bankInterestSum / 75;
                                totalBankInterestInUSD = sumOfTotal + (bankInterestInUSD);
                            }
                            else {
                                totalBankInterestInUSD = sumOfTotal + bankInterestInUSD;
                            }
                            totalBankInterestInUSD = updateTallyDetails[updateTallyDetails.length - 1].totalBankInterestInUSD + bankInterestInUSD;
                            diffInUSD = totalInterestInUSD - totalBankInterestInUSD;
                            let ids = bankCurrentAccountStatementDetails.map(a => ObjectId(a._id));
                            yield (db.collection('Bank_Current_Account_Statement')).updateMany({ "_id": { "$in": ids } }, { $set: { "status": "used" } }, { upsert: true });
                        }
                    }
                    let comment = '';
                    if (reconcilition.dueDate < newdate2) {
                        comment = comment + ' ' + 'Over Due Loan';
                    }
                    reconcilition['tallyDetails'].push({
                        "repaymentDate": new Date(newdate2),
                        "repaymentAmountInUSD": replaymentInUSD,
                        "repaymentAmountInINR": replaymentInINR,
                        "balanceInUSD": balanceInUSD,
                        "balanceInINR": balanceInINR,
                        "days": Days,
                        "interestInUSD": interestInUSD,
                        "interestInINR": interestInINR,
                        "interestSub": interestSub,
                        "totalDays": totalDays,
                        "totalInterestInUSD": totalInterestInUSD,
                        "totalInterestInINR": totalInterestInINR,
                        "totalInterestSub": totalInterestSub,
                        "bankInterestInUSD": bankInterestInUSD,
                        "bankInterestInINR": bankInterestInINR,
                        "bankInterestSub": bankInterestSub,
                        "totalBankInterestInUSD": totalBankInterestInUSD,
                        "totalBankInterestInINR": totalBankInterestInINR,
                        "totalBankInterestSub": totalBankInterestSub,
                        "ExchangeRate": 0,
                        "diffInUSD": diffInUSD,
                        "diffInINR": diffInINR,
                        "diffInSub": diffInSub,
                        "comment": comment
                    });
                    if (util_1.isNullOrUndefined(loan) && i + 1 == monthDiff) {
                        return;
                    }
                }
                let interestInUSD = 0;
                let interestInINR = 0;
                let replaymentInUSD = 0;
                let replaymentInINR = 0;
                let totalInterestInUSD = 0;
                let totalInterestInINR = 0;
                let balanceInUSD = 0;
                let balanceInINR = 0;
                let interestSub = 0;
                let totalInterestSub = 0;
                let bankInterestInUSD = 0;
                let bankInterestInINR = 0;
                let totalBankInterestInUSD = 0;
                let totalBankInterestInINR = 0;
                let diffInUSD = 0;
                let diffInINR = 0;
                let bankInterestSub = 0;
                let totalBankInterestSub = 0;
                let diffInSub = 0;
                let Days = 0;
                if (i != 0) {
                    date1 = updateTallyDetails[updateTallyDetails.length - 1].repaymentDate;
                    Days = Math.round(dateTime.subtract(date2, date1).toDays()) - 1;
                }
                else {
                    Days = Math.round(dateTime.subtract(date2, date1).toDays());
                }
                let totalDays = updateTallyDetails[updateTallyDetails.length - 1].totalDays + Days;
                if (reconcilition.currencyType == "USD") {
                    //formula wise get take last balance and net int
                    replaymentInUSD = loan.credit;
                    let balance = updateTallyDetails[updateTallyDetails.length - 1].balanceInUSD;
                    balanceInUSD = Number((updateTallyDetails[updateTallyDetails.length - 1].balanceInUSD - loan.credit).toFixed(2));
                    interestInUSD = yield this.interestCalculationForUSD(reconcilition.netInt, balance, Days);
                    totalInterestInUSD = updateTallyDetails[updateTallyDetails.length - 1].totalInterestInUSD + interestInUSD;
                    if (0 >= balanceInUSD) {
                        reconcilition.status = 'close';
                        let bankInterest = bankCurrentAccountStatementDetails.filter(data => data.description.includes(reconcilition.loanReferenceNo));
                        let sumOfTotal = updateTallyDetails.reduce((a, b) => a + b.bankInterestInUSD, 0);
                        // sum of bankInterest
                        bankInterestInUSD = bankInterest.reduce((accumulator, currentValue) => accumulator + currentValue.credit, 0);
                        if (reconcilition.bankName == "CANARA BANK") {
                            totalBankInterestInUSD = sumOfTotal + (bankInterestInUSD / 75);
                        }
                        else {
                            totalBankInterestInUSD = sumOfTotal + bankInterestInUSD;
                        }
                        diffInUSD = totalInterestInUSD - totalBankInterestInUSD;
                        let ids = bankCurrentAccountStatementDetails.map(a => ObjectId(a._id));
                        yield (db.collection('Bank_Current_Account_Statement')).updateMany({ "_id": { "$in": ids } }, { $set: { "status": "used" } }, { upsert: true });
                    }
                }
                if (!util_1.isNullOrUndefined(loan)) {
                    reconcilition['tallyDetails'].push({
                        "repaymentDate": new Date(loan.repaymentDate),
                        "repaymentAmountInUSD": replaymentInUSD,
                        "repaymentAmountInINR": replaymentInINR,
                        "balanceInUSD": balanceInUSD,
                        "balanceInINR": balanceInINR,
                        "days": Days,
                        "interestInUSD": interestInUSD,
                        "interestInINR": interestInINR,
                        "interestSub": interestSub,
                        "totalDays": totalDays,
                        "totalInterestInUSD": totalInterestInUSD,
                        "totalInterestInINR": totalInterestInINR,
                        "totalInterestSub": totalInterestSub,
                        "bankInterestInUSD": bankInterestInUSD,
                        "bankInterestInINR": bankInterestInINR,
                        "bankInterestSub": bankInterestSub,
                        "totalBankInterestInUSD": totalBankInterestInUSD,
                        "totalBankInterestInINR": totalBankInterestInINR,
                        "totalBankInterestSub": totalBankInterestSub,
                        "ExchangeRate": 0,
                        "diffInUSD": diffInUSD,
                        "diffInINR": diffInINR,
                        "diffInSub": diffInSub,
                        "comment": ''
                    });
                }
            }
            catch (error) {
                console.log(error);
                return error;
            }
        });
    }
    prepareDataPSCFC(dailyLoanDetailsData, bankName, isSubvention, precentage, interestType, isLoanStatementWise, startDate, endDate) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                //sort the Daily Loan Details Data
                /*
                    1. First we sort the dailyLoanDetailsData according Loan Taken and Loan repayment.
                    2. it's help to easly create reconcilition tempelete only loan taken advices.
                */
                let repaymentAdvice = [];
                let takenAdvice = [];
                let sortByLoanTakenAndLoanRepayment = yield this.sortByLoanTakenAndLoanRepayment(dailyLoanDetailsData);
                takenAdvice = sortByLoanTakenAndLoanRepayment['takenAdvice'];
                repaymentAdvice = sortByLoanTakenAndLoanRepayment['repaymentAdvice'];
                /*
                   1. Reconcilition  Array hold the all reconcilition objects.
                   2. Create the Reconcilition Template  using the  TakenAdvice and Push the reconcilition Array.
                   3. fileName Array use for  update the dailyLoanDetailsData is status complete
                */
                let reconcilition = [];
                let fileName = [];
                for (let advice of takenAdvice) {
                    /*
                        using the loanTakenRecordForPSCFC Method Create template.
                        push the filename inside the fileName
                     */
                    reconcilition.push(yield this.loanTakenRecordForPSCFC(advice));
                    fileName.push(advice.fileName);
                }
                /*
                    Get the existance open loan and interestType  from ReconcilitionLoanDetailst data
                    We Directly use currencyType USD bcoz of PSCFC is the Post Shipment Credit in Foreign Currency
                */
                const currencyType = 'USD';
                const existanceReconcilation = { "status": "open", "bankName": bankName, "currencyType": currencyType, "interestType": interestType };
                let existanceReconcilationDetails = yield (db.collection('ReconcilitionLoanDetailst')).find(existanceReconcilation);
                existanceReconcilationDetails = JSON.parse(JSON.stringify(existanceReconcilationDetails));
                // Concat the existanceReconcilationDetails and reconcilition Array (line 258)
                reconcilition = existanceReconcilationDetails.concat(reconcilition);
                /*
                    1. Create the Query For the Get the bank_Current_Account_Statement Collection so Use the bankName, status And Currency Type
                */
                const bank_Current_Account_Statement_Query = { "bankName": bankName, "currencyType": currencyType, "status": "notUse" };
                let bankCurrentAccountStatementDetails = yield (db.collection('Bank_Current_Account_Statement')).find(bank_Current_Account_Statement_Query);
                bankCurrentAccountStatementDetails = JSON.parse(JSON.stringify(bankCurrentAccountStatementDetails));
                /*
                    Now Using repaymentAdvice (line No : 241) Create Reconcilition
                */
                for (let advice of repaymentAdvice) {
                    /*
                        find the object inside reconcilition Array matching the repayment advice
                    */
                    let recon = reconcilition.find(a => a.invoiceNumber == advice.invoiceNumber);
                    if (!util_1.isNullOrUndefined(recon)) {
                        yield this.calculationOfPSCFC(recon, advice, bankCurrentAccountStatementDetails, isSubvention, precentage);
                        fileName.push(advice.fileName);
                    }
                }
                /*
                    Save and update the reconcilition data in ReconcilitionLoanDetailst
                */
                yield this.saveAndUpdatePSCFC(reconcilition);
                /*
                    update the status of  DailyLoanDetails is complete which is use in takenloanadvice and replaymentadvice
                */
                yield (db.collection('DailyLoanDetails')).updateMany({ "fileName": { "$in": fileName } }, { $set: { "status": "complete" } }, { upsert: true });
            }
            catch (error) {
                return error;
            }
        });
    }
    sameDateSumOfCredit(loan_Statement_data) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            /*
                same data and same loan Reference data calculate
            */
            let newArray = [];
            for (let loan of loan_Statement_data) {
                let check = newArray.find((a) => a.repaymentDate == loan.repaymentDate && a.loanReferenceNo == loan.loanReferenceNo);
                if (!util_1.isNullOrUndefined(check)) {
                    check.credit = check.credit + loan.credit;
                }
                else {
                    newArray.push(loan);
                }
            }
            return newArray;
        });
    }
    sameDateAndLoanreference(advices) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            /*
                same data and same loan Reference data calculate
            */
            let newArray = [];
            for (let loan of advices) {
                let check = newArray.find((a) => a.date == loan.date && a.loanReferenceNo == loan.loanReferenceNo);
                if (!util_1.isNullOrUndefined(check)) {
                    check.remainingAmountInINR = check.remainingAmountInINR + loan.remainingAmountInINR;
                    check.bankRepaymentAmountInINR = check.remainingAmountInINR + loan.bankRepaymentAmountInINR;
                }
                else {
                    newArray.push(loan);
                }
            }
            return newArray;
        });
    }
    prepareDataWithLoanStatement(dailyLoanDetailsData, bankName, isSubvention, precentage, interestType, isLoanStatementWise, startDate, endDate) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                //with loanStatement
                /*
                    sort the Daily Loan Details Data
                    1. First we sort the dailyLoanDetailsData according Loan Taken .
                    2. it's help to easly create reconcilition tempelete only loan taken advices.
                */
                let takenAdvice = [];
                let sortByLoanTakenAndLoanRepayment = yield this.sortByLoanTakenAndLoanRepayment(dailyLoanDetailsData);
                takenAdvice = sortByLoanTakenAndLoanRepayment['takenAdvice'];
                /*
                   1. Reconcilition  Array hold the all reconcilition objects.
                   2. Create the Reconcilition Template  using the  TakenAdvice and Push the reconcilition Array.
                   3. fileName Array use for  update the dailyLoanDetailsData is status complete
                */
                let reconcilition = [];
                let fileName = [];
                for (let advice of takenAdvice) {
                    /*
                        using the loanTakenRecordForPSCFC Method Create template.
                        push the filename inside the fileName
                    */
                    reconcilition.push(yield this.loanTakenRecordForPCFC(advice));
                    fileName.push(advice.fileName);
                }
                /*
                    Get the existance open loan and interestType  from ReconcilitionLoanDetailst data
                    We Directly use currencyType USD bcoz of PSCFC is the Post Shipment Credit in Foreign Currency
                */
                const currencyType = 'USD';
                const existanceReconcilation = { "status": "open", "bankName": bankName, "currencyType": currencyType, "interestType": interestType };
                let existanceReconcilationDetails = yield (db.collection('ReconcilitionLoanDetailst')).find(existanceReconcilation);
                existanceReconcilationDetails = JSON.parse(JSON.stringify(existanceReconcilationDetails));
                // Concat the existanceReconcilationDetails and reconcilition Array
                reconcilition = existanceReconcilationDetails.concat(reconcilition);
                /*
                    Create the Query For the Get the bank_Current_Account_Statement Collection so Use the bankName, status And Currency Type
                */
                const bank_Current_Account_Statement_Query = { "bankName": bankName, "currencyType": currencyType, "status": "notUse" };
                let bankCurrentAccountStatementDetails = yield (db.collection('Bank_Current_Account_Statement')).find(bank_Current_Account_Statement_Query).sort({ "date": 1 });
                bankCurrentAccountStatementDetails = JSON.parse(JSON.stringify(bankCurrentAccountStatementDetails));
                /*
                    get the laon Stetement data bankName ,currencyType and Status
                */
                const loan_Statement_Query = { "bankName": bankName, "currencyType": currencyType, "status": "notUse" };
                let loan_Statement_Query_Details = yield (db.collection('Loan_Statement_PCFC')).find(loan_Statement_Query).sort({ "date": 1 });
                let loan_Statement_data = JSON.parse(JSON.stringify(loan_Statement_Query_Details));
                /*
                    modify the loan Statement data same date and same loan reference.
                */
                loan_Statement_data = yield this.sameDateSumOfCredit(loan_Statement_data);
                /*
                    Now Reconiliton Laon statement PCFC data wise.
                    updateLoanStatement array using update used loan Statement.
                */
                let updateLoanStatement = [];
                for (let loanStatement of loan_Statement_data) {
                    let recon = reconcilition.find(a => a.loanReferenceNo == loanStatement.loanReferenceNo);
                    if (!util_1.isNullOrUndefined(recon)) {
                        yield this.calculationOfPCFC(recon, loanStatement, bankCurrentAccountStatementDetails, startDate, endDate, isSubvention, precentage);
                        //Push the loanReferenece No for the Update .
                        updateLoanStatement.push(loanStatement.loanReferenceNo);
                    }
                }
                yield this.saveAndUpdateReconcilitionPCFC(reconcilition, bankCurrentAccountStatementDetails, startDate, endDate, isSubvention, precentage);
                /*
                    Update the loan Statement
                */
                yield (db.collection('Loan_Statement_PCFC')).updateMany({ "loanReferenceNo": { "$in": updateLoanStatement } }, { $set: { "status": "used" } }, { upsert: true });
            }
            catch (error) {
                console.log(error);
                return error;
            }
        });
    }
    prepareDataWithadvice(dailyLoanDetailsData, bankName, isSubvention, precentage, interestType, isLoanStatementWise, startDate, endDate) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                //with loanStatement
                /*
                    sort the Daily Loan Details Data
                    1. First we sort the dailyLoanDetailsData according Loan Taken .
                    2. it's help to easly create reconcilition tempelete only loan taken advices.
                */
                let takenAdvice = [];
                let repaymentAdvice = [];
                let sortByLoanTakenAndLoanRepayment = yield this.sortByLoanTakenAndLoanRepayment(dailyLoanDetailsData);
                takenAdvice = sortByLoanTakenAndLoanRepayment['takenAdvice'];
                repaymentAdvice = sortByLoanTakenAndLoanRepayment['repaymentAdvice'];
                /*
                   1. Reconcilition  Array hold the all reconcilition objects.
                   2. Create the Reconcilition Template  using the  TakenAdvice and Push the reconcilition Array.
                   3. fileName Array use for  update the dailyLoanDetailsData is status complete
                */
                let reconcilition = [];
                let fileName = [];
                for (let advice of takenAdvice) {
                    /*
                        using the loanTakenRecordForPSCFC Method Create template.
                        push the filename inside the fileName
                    */
                    reconcilition.push(yield this.loanTakenRecordForPCFC(advice));
                    fileName.push(advice.fileName);
                }
                /*
                    Get the existance open loan and interestType  from ReconcilitionLoanDetailst data
                    We Directly use currencyType USD bcoz of PSCFC is the Post Shipment Credit in Foreign Currency
                */
                const currencyType = 'USD';
                const existanceReconcilation = { "status": "open", "bankName": bankName, "currencyType": currencyType, "interestType": interestType };
                let existanceReconcilationDetails = yield (db.collection('ReconcilitionLoanDetailst')).find(existanceReconcilation);
                existanceReconcilationDetails = JSON.parse(JSON.stringify(existanceReconcilationDetails));
                // Concat the existanceReconcilationDetails and reconcilition Array
                reconcilition = existanceReconcilationDetails.concat(reconcilition);
                /*
                    Create the Query For the Get the bank_Current_Account_Statement Collection so Use the bankName, status And Currency Type
                */
                const bank_Current_Account_Statement_Query = { "bankName": bankName, "currencyType": currencyType, "status": "notUse" };
                let bankCurrentAccountStatementDetails = yield (db.collection('Bank_Current_Account_Statement')).find(bank_Current_Account_Statement_Query).sort({ "date": 1 });
                bankCurrentAccountStatementDetails = JSON.parse(JSON.stringify(bankCurrentAccountStatementDetails));
                /*
                    get the laon Stetement data bankName ,currencyType and Status
                */
                // let invoiceNumbers= []
                for (let advice of repaymentAdvice) {
                    let reconcilitionLoanAdvice;
                    let checkCalculateLoan;
                    while (true) {
                        for (let reconcilitionLoan of reconcilition) {
                            if (reconcilitionLoan.status == 'open') {
                                reconcilitionLoanAdvice = reconcilitionLoan;
                                break;
                            }
                        }
                        checkCalculateLoan = yield this.calculationOfPCFC(reconcilitionLoanAdvice, advice, bankCurrentAccountStatementDetails, startDate, endDate, isSubvention, precentage);
                        if (checkCalculateLoan.status == 'open' || advice.status == 'complete') {
                            fileName.push(advice.fileName);
                            break;
                        }
                    }
                }
                //save the reconcilition
                yield this.saveAndUpdateReconcilitionPCFC(reconcilition, bankCurrentAccountStatementDetails, startDate, endDate, isSubvention, precentage);
                /*
                    update the status of  DailyLoanDetails is complete which is use in takenloanadvice and replaymentadvice
                */
                yield (db.collection('DailyLoanDetails')).updateMany({ "fileName": { "$in": fileName } }, { $set: { "status": "complete" } }, { upsert: true });
            }
            catch (error) {
                console.log(error);
                return error;
            }
        });
    }
    monthDiff1(d1, d2) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let checkMonthDiff = new Date(d1.getFullYear(), d1.getMonth() + 1, 0);
            let checkdate1 = yield this.GetFormattedDate(d1);
            let checkdate2 = yield this.GetFormattedDate(checkMonthDiff);
            let months;
            months = (d2.getFullYear() - d1.getFullYear()) * 12;
            months -= d1.getMonth();
            months += d2.getMonth();
            if (checkdate1 == checkdate2) {
                months = months <= 0 ? 0 : months;
                months = months - 1;
            }
            else {
                months = months <= 0 ? 0 : months;
            }
            return months;
        });
    }
    calculationOfPC(reconcilition, loan, interestByBank, startDate, endDate, isSubvention, precentage) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const dateTime = require('date-and-time');
                let updateTallyDetails = reconcilition.tallyDetails;
                let date1 = new Date(startDate);
                let date2 = new Date(endDate);
                /*
                   @First If :: Check the updatetallyDetails is length
                   @Second If ::  if array length is one then we take date takendate otherwise we tabke repaymentDate
                */
                if (!util_1.isNullOrUndefined(loan) && Object.keys(loan).length != 0) {
                    date2 = new Date(loan.repaymentDate);
                }
                if (updateTallyDetails.length == 1) {
                    date1 = reconcilition.takenDate;
                }
                else {
                    date1 = updateTallyDetails[updateTallyDetails.length - 1].repaymentDate;
                }
                /*
                    @monthDiff is use for the diff of current repayment date and at last inside tallyDetails array object repayment Date.
                */
                date1 = new Date(date1);
                let checkMonthDiff = new Date(date1.getFullYear(), date1.getMonth() + 1, 0);
                let checkdate1 = yield this.GetFormattedDate(date1);
                let checkdate2 = yield this.GetFormattedDate(checkMonthDiff);
                let monthDiff = 0;
                monthDiff = yield this.monthDiff1(date1, date2);
                let i = 0;
                console.log(checkdate1, checkdate2);
                if (checkdate2 == (yield this.GetFormattedDate(date2)) && !util_1.isNullOrUndefined(loan) && loan.repaymentAmountInINR != 0) {
                    monthDiff = 0;
                }
                /*
                    In this loop iterator the @monthDiff Wise Becoz we want store the MONTHEND Data inside that tallyDetails (Reconcilition)
                */
                for (; i < monthDiff; i++) {
                    let newdate1 = new Date();
                    let newdate2 = new Date();
                    if (i != 0) {
                        newdate1 = updateTallyDetails[updateTallyDetails.length - 1].repaymentDate;
                        let checkMonthDiff = new Date(newdate1.getFullYear(), newdate1.getMonth() + 1, 0);
                        let checkdate1 = yield this.GetFormattedDate(newdate1);
                        let checkdate2 = yield this.GetFormattedDate(checkMonthDiff);
                        if (checkdate1 == checkdate2) {
                            newdate2 = new Date(newdate1.getFullYear(), newdate1.getMonth() + 2, 0);
                        }
                        else {
                            newdate2 = new Date(newdate1.getFullYear(), newdate1.getMonth() + 1, 0);
                        }
                    }
                    else {
                        newdate1 = date1;
                        let checkMonthDiff = new Date(date1.getFullYear(), date1.getMonth() + 1, 0);
                        let checkdate1 = yield this.GetFormattedDate(date1);
                        let checkdate2 = yield this.GetFormattedDate(checkMonthDiff);
                        if (checkdate1 == checkdate2 && reconcilition.bankName.toLowerCase() != 'Induslnd Bank') {
                            newdate2 = new Date(date1.getFullYear(), date1.getMonth() + 2, 0);
                        }
                        else {
                            newdate2 = new Date(date1.getFullYear(), date1.getMonth() + 1, 0);
                        }
                    }
                    let checkMonthDiff = new Date(newdate1.getFullYear(), newdate1.getMonth() + 1, 0);
                    let checkdate1 = yield this.GetFormattedDate(newdate1);
                    let checkdate2 = yield this.GetFormattedDate(checkMonthDiff);
                    console.log(checkdate1 == checkdate2);
                    let Days = dateTime.subtract(newdate2, newdate1).toDays();
                    Days = i == 0 ? Math.round(Days) + 1 : Math.round(Days);
                    //yes bank last date is endof month date
                    if (checkdate1 == checkdate2) {
                        Days = Days - 1;
                    }
                    let interestInUSD = 0;
                    let interestInINR = 0;
                    let replaymentInUSD = 0;
                    let replaymentInINR = 0;
                    let totalInterestInUSD = 0;
                    let totalInterestInINR = 0;
                    let balanceInUSD = 0;
                    let balanceInINR = 0;
                    let interestSub = 0;
                    let totalInterestSub = 0;
                    let bankInterestInUSD = 0;
                    let bankInterestInINR = 0;
                    let totalBankInterestInUSD = 0;
                    let totalBankInterestInINR = 0;
                    let diffInUSD = 0;
                    let diffInINR = 0;
                    let bankInterestSub = 0;
                    let totalBankInterestSub = 0;
                    let diffInSub = 0;
                    let isbankInterestContainAdvice = false;
                    let totalDays = updateTallyDetails[updateTallyDetails.length - 1].totalDays + Days;
                    //calculate the intertest
                    interestInINR = yield this.calculateInterest(updateTallyDetails[updateTallyDetails.length - 1].balanceInINR, reconcilition.netInt, Days, date2, reconcilition.bankName);
                    //get the balance
                    balanceInINR = updateTallyDetails[updateTallyDetails.length - 1].balanceInINR;
                    /*
                        some bank interest come into advice we check bankRepaymentAmountInINR is not Zero
                        eg. yes bank
                    */
                    if (!util_1.isNullOrUndefined(loan) && loan.repaymentAmountInINR == 0 && loan.bankRepaymentAmountInINR != 0) {
                        totalInterestInINR = updateTallyDetails[updateTallyDetails.length - 1].totalInterestInINR + interestInINR;
                        bankInterestInINR = loan.bankRepaymentAmountInINR;
                        totalBankInterestInINR = updateTallyDetails[updateTallyDetails.length - 1].totalBankInterestInINR + bankInterestInINR;
                        isbankInterestContainAdvice = true;
                    }
                    diffInINR = totalInterestInINR - totalBankInterestInINR;
                    let comment = '';
                    if (reconcilition.dueDate < newdate2) {
                        comment = comment + ' ' + 'Over Due Loan';
                    }
                    if (util_1.isNullOrUndefined(loan) || loan.repaymentAmountInINR == 0) {
                        reconcilition['tallyDetails'].push({
                            "repaymentDate": new Date(newdate2),
                            "repaymentAmountInUSD": replaymentInUSD,
                            "repaymentAmountInINR": replaymentInINR,
                            "balanceInUSD": balanceInUSD,
                            "balanceInINR": balanceInINR,
                            "days": Days,
                            "interestInUSD": interestInUSD,
                            "interestInINR": interestInINR,
                            "interestSub": interestSub,
                            "totalDays": totalDays,
                            "totalInterestInUSD": totalInterestInUSD,
                            "totalInterestInINR": totalInterestInINR,
                            "totalInterestSub": totalInterestSub,
                            "bankInterestInUSD": bankInterestInUSD,
                            "bankInterestInINR": bankInterestInINR,
                            "bankInterestSub": bankInterestSub,
                            "totalBankInterestInUSD": totalBankInterestInUSD,
                            "totalBankInterestInINR": totalBankInterestInINR,
                            "totalBankInterestSub": totalBankInterestSub,
                            "ExchangeRate": 0,
                            "diffInUSD": diffInUSD,
                            "diffInINR": diffInINR,
                            "diffInSub": diffInSub,
                            "comment": comment
                        });
                    }
                    if (isbankInterestContainAdvice) {
                        return;
                    }
                    if (util_1.isNullOrUndefined(loan) && i + 1 == monthDiff) {
                        return;
                    }
                }
                let interestInUSD = 0;
                let interestInINR = 0;
                let replaymentInUSD = 0;
                let replaymentInINR = 0;
                let totalInterestInUSD = 0;
                let totalInterestInINR = 0;
                let balanceInUSD = 0;
                let balanceInINR = 0;
                let interestSub = 0;
                let totalInterestSub = 0;
                let bankInterestInUSD = 0;
                let bankInterestInINR = 0;
                let totalBankInterestInUSD = 0;
                let totalBankInterestInINR = 0;
                let diffInUSD = 0;
                let diffInINR = 0;
                let bankInterestSub = 0;
                let totalBankInterestSub = 0;
                let diffInSub = 0;
                let Days = 0;
                //yes bank and check 1st day of month
                let checkFlag = true;
                console.log(checkFlag);
                if (i != 0) {
                    date1 = updateTallyDetails[updateTallyDetails.length - 1].repaymentDate;
                }
                let checkMonthDiff1 = new Date(date2.getFullYear(), date2.getMonth(), 0);
                let checkdate1_1 = yield this.GetFormattedDate(date1);
                let checkdate2_2 = yield this.GetFormattedDate(checkMonthDiff1);
                console.log(checkdate1_1, checkdate2_2);
                Days = dateTime.subtract(date2, date1).toDays();
                //once check for induslnd bank
                Days = i != 0 ? Math.round(Days) - 1 : Math.round(Days);
                if (checkdate1_1 == checkdate2_2) {
                    Days = Days - 1;
                }
                //total Days
                let totalDays = updateTallyDetails[updateTallyDetails.length - 1].totalDays + Days;
                //calculate the interest
                interestInINR = yield this.calculateInterest(updateTallyDetails[updateTallyDetails.length - 1].balanceInINR, reconcilition.netInt, Days, date2, reconcilition.bankName);
                //get the balance
                balanceInINR = updateTallyDetails[updateTallyDetails.length - 1].balanceInINR - loan.repaymentAmountInINR;
                if (!util_1.isNullOrUndefined(loan.repaymentAmountInINR) && loan.repaymentAmountInINR != 0) {
                    totalInterestInINR = updateTallyDetails[updateTallyDetails.length - 1].totalInterestInINR + interestInINR;
                    if (loan.bankRepaymentAmountInINR != 0) {
                        bankInterestInINR = loan.bankRepaymentAmountInINR;
                        totalBankInterestInINR = updateTallyDetails[updateTallyDetails.length - 1].totalBankInterestInINR + bankInterestInINR;
                    }
                }
                diffInINR = totalInterestInINR - totalBankInterestInINR;
                if (balanceInINR <= 0) {
                    reconcilition.status = 'close';
                }
                if (!util_1.isNullOrUndefined(loan)) {
                    reconcilition['tallyDetails'].push({
                        "repaymentDate": new Date(loan.repaymentDate),
                        "repaymentAmountInUSD": replaymentInUSD,
                        "repaymentAmountInINR": replaymentInINR,
                        "balanceInUSD": balanceInUSD,
                        "balanceInINR": balanceInINR,
                        "days": Days,
                        "interestInUSD": interestInUSD,
                        "interestInINR": interestInINR,
                        "interestSub": interestSub,
                        "totalDays": totalDays,
                        "totalInterestInUSD": totalInterestInUSD,
                        "totalInterestInINR": totalInterestInINR,
                        "totalInterestSub": totalInterestSub,
                        "bankInterestInUSD": bankInterestInUSD,
                        "bankInterestInINR": bankInterestInINR,
                        "bankInterestSub": bankInterestSub,
                        "totalBankInterestInUSD": totalBankInterestInUSD,
                        "totalBankInterestInINR": totalBankInterestInINR,
                        "totalBankInterestSub": totalBankInterestSub,
                        "ExchangeRate": 0,
                        "diffInUSD": diffInUSD,
                        "diffInINR": diffInINR,
                        "diffInSub": diffInSub,
                        "comment": ''
                    });
                }
            }
            catch (error) {
                console.log(error);
                return error;
            }
        });
    }
    fetchWeatherData(locationDateArray) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const baseUrl = 'https://weather.visualcrossing.com/VisualCrossingWebServices/rest/services/timeline/';
            const elements = 'datetime,temp,precip,conditions,description,humidity,pressure,windSpeed,windDir,cloudCover,visibility';
            // Create an array of fetch promises for each location and date
            const fetchPromises = locationDateArray.map(({ location, date }) => {
                const url = `${baseUrl}${encodeURIComponent(location)}/${date}?elements=${elements}&key=${process.env.VCROSS_API_KEY}`;
                return fetch(url)
                    .then(response => {
                    if (!response.ok) {
                        throw new Error(`Failed to fetch data for ${location} on ${date}: ${response.statusText}`);
                    }
                    return response.json();
                })
                    .then(data => ({ location, date, data }))
                    .catch(error => ({ location, date, error: error['message'] }));
            });
            // Wait for all fetch requests to complete
            const results = yield Promise.all(fetchPromises);
            // Process the fetched data
            const weatherInfo = results.map(result => {
                if (result['error']) {
                    return { location: result['location'], date: result['date'], error: result['error'] };
                }
                const location = result['location'];
                const date = result['date'];
                const data = result['data'];
                const dayData = data.days.find(day => day.datetime === date);
                if (!dayData) {
                    return {
                        location,
                        date,
                        message: 'No data available for this date.',
                    };
                }
                const { temp, precip, conditions, description } = dayData;
                return {
                    location,
                    date,
                    temperature: temp,
                    precipitation: precip,
                    conditions,
                    description,
                };
            });
            return weatherInfo;
        });
    }
    calculationOfPC1(reconcilition, loan, interestByBank, startDate, endDate, isSubvention, precentage) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                //Indusland bank
                console.log(interestByBank);
                console.log(precentage);
                const dateTime = require('date-and-time');
                let updateTallyDetails = reconcilition.tallyDetails;
                let date1 = new Date(startDate);
                let date2 = new Date(endDate);
                /*
                   @First If :: Check the updatetallyDetails is length
                   @Second If ::  if array length is one then we take date takendate otherwise we tabke repaymentDate
                */
                if (!util_1.isNullOrUndefined(loan) && Object.keys(loan).length != 0) {
                    date2 = new Date(loan.repaymentDate);
                }
                if (updateTallyDetails.length == 1) {
                    date1 = reconcilition.takenDate;
                }
                else {
                    date1 = updateTallyDetails[updateTallyDetails.length - 1].repaymentDate;
                }
                /*
                    @monthDiff is use for the diff of current repayment date and at last inside tallyDetails array object repayment Date.
                */
                date1 = new Date(date1);
                let checkMonthDiff = new Date(date1.getFullYear(), date1.getMonth() + 1, 0);
                let checkdate1 = yield this.GetFormattedDate(date1);
                let checkdate2 = yield this.GetFormattedDate(checkMonthDiff);
                let monthDiff = 0;
                monthDiff = yield this.monthDiff1(date1, date2);
                let i = 0;
                console.log(checkdate1, checkdate2);
                if (checkdate2 == (yield this.GetFormattedDate(date2)) && !util_1.isNullOrUndefined(loan) && loan.repaymentAmountInINR != 0) {
                    monthDiff = 0;
                }
                /*
                    In this loop iterator the @monthDiff Wise Becoz we want store the MONTHEND Data inside that tallyDetails (Reconcilition)
                */
                for (; i < monthDiff; i++) {
                    let newdate1 = new Date();
                    let newdate2 = new Date();
                    if (i != 0) {
                        newdate1 = updateTallyDetails[updateTallyDetails.length - 1].repaymentDate;
                        newdate2 = new Date(newdate1.getFullYear(), newdate1.getMonth() + 1, 0);
                    }
                    else {
                        newdate1 = date1;
                        newdate2 = new Date(date1.getFullYear(), date1.getMonth() + 1, 0);
                    }
                    let checkMonthDiff = new Date(newdate1.getFullYear(), newdate1.getMonth() + 1, 0);
                    let checkdate1 = yield this.GetFormattedDate(newdate1);
                    let checkdate2 = yield this.GetFormattedDate(checkMonthDiff);
                    console.log(checkdate1 == checkdate2);
                    let Days = dateTime.subtract(newdate2, newdate1).toDays();
                    Days = i == 0 ? Math.round(Days) + 1 : Math.round(Days);
                    //yes bank last date is endof month date
                    if (checkdate1 == checkdate2) {
                        Days = Days - 1;
                    }
                    let interestInUSD = 0;
                    let interestInINR = 0;
                    let replaymentInUSD = 0;
                    let replaymentInINR = 0;
                    let totalInterestInUSD = 0;
                    let totalInterestInINR = 0;
                    let balanceInUSD = 0;
                    let balanceInINR = 0;
                    let interestSub = 0;
                    let totalInterestSub = 0;
                    let bankInterestInUSD = 0;
                    let bankInterestInINR = 0;
                    let totalBankInterestInUSD = 0;
                    let totalBankInterestInINR = 0;
                    let diffInUSD = 0;
                    let diffInINR = 0;
                    let bankInterestSub = 0;
                    let totalBankInterestSub = 0;
                    let diffInSub = 0;
                    let totalDays = updateTallyDetails[updateTallyDetails.length - 1].totalDays + Days;
                    //calculate the intertest
                    interestInINR = yield this.calculateInterest(updateTallyDetails[updateTallyDetails.length - 1].balanceInINR, reconcilition.netInt, Days, date2, reconcilition.bankName);
                    totalInterestInINR = updateTallyDetails[updateTallyDetails.length - 1].totalInterestInINR + interestInINR;
                    //get the balance
                    balanceInINR = updateTallyDetails[updateTallyDetails.length - 1].balanceInINR;
                    if (isSubvention) {
                        let prec = 0;
                        if (precentage != 0) {
                            prec = precentage;
                        }
                        else {
                            prec = reconcilition.netIntSub;
                        }
                        interestSub = yield this.calculateInterest(updateTallyDetails[updateTallyDetails.length - 1].balanceInINR, prec, Days, date2, reconcilition.bankName);
                        totalInterestSub = updateTallyDetails[updateTallyDetails.length - 1].totalInterestSub + interestSub;
                    }
                    let month = new Date(newdate2).toLocaleString('default', { month: 'long' });
                    console.log(month);
                    let bankInt = interestByBank.find(a => a.month == month.toLowerCase() && a.transactionRefNo == reconcilition.loanReferenceNo && a.interestType.toLowerCase().trim() == 'interest for preshipment finance');
                    if (!util_1.isNullOrUndefined(bankInt)) {
                        bankInterestInINR = bankInt.interestAmt;
                        totalBankInterestInINR = updateTallyDetails[updateTallyDetails.length - 1].totalBankInterestInINR + bankInterestInINR;
                        if (isSubvention) {
                            let bankIntSubObj = interestByBank.find(a => a.month == month.toLowerCase() && a.transactionRefNo == reconcilition.loanReferenceNo && a.interestType.toLowerCase().trim() == 'interest subvention advise');
                            let bankIntSub = bankIntSubObj.interestAmt || 0;
                            totalBankInterestSub = updateTallyDetails[updateTallyDetails.length - 1].totalBankInterestSub + bankIntSub;
                            diffInSub = totalInterestSub - totalBankInterestSub;
                            yield (db.collection('BankInterests')).updateMany({ "_id": ObjectId(bankIntSubObj._id) }, { $set: { "status": "use" } }, { upsert: true });
                        }
                        yield (db.collection('BankInterests')).updateMany({ "_id": ObjectId(bankInt._id) }, { $set: { "status": "use" } }, { upsert: true });
                    }
                    else {
                        bankInterestSub = updateTallyDetails[updateTallyDetails.length - 1].bankInterestSub;
                        totalBankInterestSub = updateTallyDetails[updateTallyDetails.length - 1].totalBankInterestSub;
                    }
                    diffInINR = totalInterestInINR - totalBankInterestInINR;
                    let comment = '';
                    if (reconcilition.dueDate < newdate2) {
                        comment = comment + ' ' + 'Over Due Loan';
                    }
                    reconcilition['tallyDetails'].push({
                        "repaymentDate": new Date(newdate2),
                        "repaymentAmountInUSD": Number(replaymentInUSD.toFixed(2)),
                        "repaymentAmountInINR": Number(replaymentInINR.toFixed(2)),
                        "balanceInUSD": Number(balanceInUSD.toFixed(2)),
                        "balanceInINR": Number(balanceInINR.toFixed(2)),
                        "days": Days,
                        "interestInUSD": Number(interestInUSD.toFixed(2)),
                        "interestInINR": Number(interestInINR.toFixed(2)),
                        "interestSub": Number(interestSub.toFixed(2)),
                        "totalDays": totalDays,
                        "totalInterestInUSD": Number(totalInterestInUSD.toFixed(2)),
                        "totalInterestInINR": Number(totalInterestInINR.toFixed(2)),
                        "totalInterestSub": Number(totalInterestSub.toFixed(2)),
                        "bankInterestInUSD": Number(bankInterestInUSD.toFixed(2)),
                        "bankInterestInINR": Number(bankInterestInINR.toFixed(2)),
                        "bankInterestSub": Number(bankInterestSub.toFixed(2)),
                        "totalBankInterestInUSD": Number(totalBankInterestInUSD.toFixed(2)),
                        "totalBankInterestInINR": Number(totalBankInterestInINR.toFixed(2)),
                        "totalBankInterestSub": Number(totalBankInterestSub.toFixed(2)),
                        "ExchangeRate": 0,
                        "diffInUSD": Number(diffInUSD.toFixed(2)),
                        "diffInINR": Number(diffInINR.toFixed(2)),
                        "diffInSub": Number(diffInSub.toFixed(2)),
                        "comment": comment
                    });
                }
                let interestInUSD = 0;
                let interestInINR = 0;
                let replaymentInUSD = 0;
                let replaymentInINR = 0;
                let totalInterestInUSD = 0;
                let totalInterestInINR = 0;
                let balanceInUSD = 0;
                let balanceInINR = 0;
                let interestSub = 0;
                let totalInterestSub = 0;
                let bankInterestInUSD = 0;
                let bankInterestInINR = 0;
                let totalBankInterestInUSD = 0;
                let totalBankInterestInINR = 0;
                let diffInUSD = 0;
                let diffInINR = 0;
                let bankInterestSub = 0;
                let totalBankInterestSub = 0;
                let diffInSub = 0;
                let Days = 0;
                if (i != 0) {
                    date1 = updateTallyDetails[updateTallyDetails.length - 1].repaymentDate;
                }
                Days = dateTime.subtract(date2, date1).toDays();
                //once check for induslnd bank
                Days = i != 0 ? Math.round(Days) - 1 : Math.round(Days);
                //total Days
                let totalDays = updateTallyDetails[updateTallyDetails.length - 1].totalDays + Days;
                //calculate the interest
                interestInINR = yield this.calculateInterest(updateTallyDetails[updateTallyDetails.length - 1].balanceInINR, reconcilition.netInt, Days, date2, reconcilition.bankName);
                totalInterestInINR = updateTallyDetails[updateTallyDetails.length - 1].totalInterestInINR + interestInINR;
                //get the balance
                balanceInINR = updateTallyDetails[updateTallyDetails.length - 1].balanceInINR - loan.repaymentAmountInINR;
                if (isSubvention) {
                    let prec = 0;
                    if (precentage != 0) {
                        prec = precentage;
                    }
                    else {
                        prec = reconcilition.netIntSub;
                    }
                    interestSub = yield this.calculateInterest(updateTallyDetails[updateTallyDetails.length - 1].balanceInINR, prec, Days, date2, reconcilition.bankName);
                    totalInterestSub = updateTallyDetails[updateTallyDetails.length - 1].totalInterestSub + interestSub;
                }
                if (balanceInINR <= 0) {
                    let month = new Date(loan.repaymentDate).toLocaleString('default', { month: 'long' });
                    console.log(month);
                    let bankInt = interestByBank.find(a => a.month == month.toLowerCase() && a.transactionRefNo == reconcilition.loanReferenceNo);
                    if (!util_1.isNullOrUndefined(bankInt)) {
                        bankInterestInINR = bankInt.interestAmt;
                        totalBankInterestInINR = updateTallyDetails[updateTallyDetails.length - 1].totalBankInterestInINR + bankInterestInINR;
                        if (isSubvention) {
                            let bankIntSubObj = interestByBank.find(a => a.month == month.toLowerCase() && a.transactionRefNo == reconcilition.loanReferenceNo && a.interestType.toLowerCase().trim() == 'interest subvention advise');
                            let bankIntSub = bankIntSubObj.interestAmt || 0;
                            totalBankInterestSub = updateTallyDetails[updateTallyDetails.length - 1].totalBankInterestSub + bankIntSub;
                            diffInSub = totalInterestSub - totalBankInterestSub;
                        }
                    }
                    reconcilition.status = 'close';
                }
                else {
                    bankInterestSub = updateTallyDetails[updateTallyDetails.length - 1].bankInterestSub;
                    totalBankInterestSub = updateTallyDetails[updateTallyDetails.length - 1].totalBankInterestSub;
                }
                diffInINR = totalInterestInINR - totalBankInterestInINR;
                if (!util_1.isNullOrUndefined(loan)) {
                    reconcilition['tallyDetails'].push({
                        "repaymentDate": new Date(loan.repaymentDate),
                        "repaymentAmountInUSD": Number(replaymentInUSD.toFixed(2)),
                        "repaymentAmountInINR": Number(replaymentInINR.toFixed(2)),
                        "balanceInUSD": Number(balanceInUSD.toFixed(2)),
                        "balanceInINR": Number(balanceInINR.toFixed(2)),
                        "days": Days,
                        "interestInUSD": Number(interestInUSD.toFixed(2)),
                        "interestInINR": Number(interestInINR.toFixed(2)),
                        "interestSub": Number(interestSub.toFixed(2)),
                        "totalDays": totalDays,
                        "totalInterestInUSD": Number(totalInterestInUSD.toFixed(2)),
                        "totalInterestInINR": Number(totalInterestInINR.toFixed(2)),
                        "totalInterestSub": Number(totalInterestSub.toFixed(2)),
                        "bankInterestInUSD": Number(bankInterestInUSD.toFixed(2)),
                        "bankInterestInINR": Number(bankInterestInINR.toFixed(2)),
                        "bankInterestSub": Number(bankInterestSub.toFixed(2)),
                        "totalBankInterestInUSD": Number(totalBankInterestInUSD.toFixed(2)),
                        "totalBankInterestInINR": Number(totalBankInterestInINR.toFixed(2)),
                        "totalBankInterestSub": Number(totalBankInterestSub.toFixed(2)),
                        "ExchangeRate": 0,
                        "diffInUSD": Number(diffInUSD.toFixed(2)),
                        "diffInINR": Number(diffInINR.toFixed(2)),
                        "diffInSub": Number(diffInSub.toFixed(2)),
                        "comment": ''
                    });
                }
            }
            catch (error) {
                console.log(error);
                return error;
            }
        });
    }
    prepareDataPC(dailyLoanDetailsData, bankName, isSubvention, precentage, interestType, isLoanStatementWise, startDate, endDate) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                //with loanStatement
                /*
                    sort the Daily Loan Details Data
                    1. First we sort the dailyLoanDetailsData according Loan Taken .
                    2. it's help to easly create reconcilition tempelete only loan taken advices.
                */
                let takenAdvice = [];
                let repaymentAdvice = [];
                let sortByLoanTakenAndLoanRepayment = yield this.sortByLoanTakenAndLoanRepayment(dailyLoanDetailsData);
                takenAdvice = sortByLoanTakenAndLoanRepayment['takenAdvice'];
                repaymentAdvice = sortByLoanTakenAndLoanRepayment['repaymentAdvice'];
                /*
                    1. Reconcilition  Array hold the all reconcilition objects.
                    2. Create the Reconcilition Template  using the  TakenAdvice and Push the reconcilition Array.
                    3. fileName Array use for  update the dailyLoanDetailsData is status complete
                */
                let reconcilition = [];
                let fileName = [];
                for (let advice of takenAdvice) {
                    /*
                        using the loanTakenRecordForPSCFC Method Create template.
                        push the filename inside the fileName
                    */
                    reconcilition.push(yield this.loanTakenRecordForPC(advice));
                    fileName.push(advice.fileName);
                }
                /*
                    modify the repayment Advice Same date and same LoanReference No
                */
                repaymentAdvice = yield this.sameDateAndLoanreference(repaymentAdvice);
                //Get existance Reconcilition data
                const currencyType = 'INR';
                const existanceReconcilation = { "status": "open", "bankName": bankName, "currencyType": currencyType, "interestType": interestType };
                let existanceReconcilationDetails = yield (db.collection('ReconcilitionLoanDetailst')).find(existanceReconcilation);
                existanceReconcilationDetails = JSON.parse(JSON.stringify(existanceReconcilationDetails));
                // Concat the existanceReconcilationDetails and reconcilition Array
                reconcilition = existanceReconcilationDetails.concat(reconcilition);
                /*
                    Create the Query For the Get the Bank interest Collection so Use the bankName, status And Currency Type
                */
                if (bankName == 'YES BANK') {
                    for (let advice of repaymentAdvice) {
                        let recon = reconcilition.find(a => a.loanReferenceNo == advice.loanReferenceNo);
                        if (!util_1.isNullOrUndefined(recon)) {
                            yield this.calculationOfPC(recon, advice, null, startDate, endDate, isSubvention, precentage);
                            //Push the fileName which is use for recon.
                            fileName.push(advice.fileName);
                        }
                    }
                    yield this.saveAndUpdatePC(reconcilition);
                }
                else {
                    /*
                        Bank interest for indusland Bank
                    */
                    let bankInterests = yield (db.collection('BankInterests')).find({ "bankName": bankName, "status": "notUse" });
                    bankInterests = JSON.parse(JSON.stringify(bankInterests));
                    for (let advice of repaymentAdvice) {
                        let recon = reconcilition.find(a => a.loanReferenceNo == advice.loanReferenceNo);
                        if (!util_1.isNullOrUndefined(recon)) {
                            yield this.calculationOfPC1(recon, advice, bankInterests, startDate, endDate, isSubvention, precentage);
                            //Push the fileName which is use for recon.
                            fileName.push(advice.fileName);
                        }
                    }
                    yield this.saveAndUpdatePC(reconcilition);
                }
                /*
                   update the status of  DailyLoanDetails is complete which is use in takenloanadvice and replaymentadvice
               */
                yield (db.collection('DailyLoanDetails')).updateMany({ "fileName": { "$in": fileName } }, { $set: { "status": "complete" } }, { upsert: true });
            }
            catch (error) {
                return error;
            }
        });
    }
    reconcilitionNEW(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                //we Take the input startDate EndDate bankName and interestType
                let startDate = !util_1.isNullOrUndefined(input.StartDate) ? new Date(input.StartDate) : null;
                let endDate = !util_1.isNullOrUndefined(input.EndDate) ? new Date(input.EndDate) : null;
                let bankName = !util_1.isNullOrUndefined(input.BankName) ? input.BankName : null;
                let interestType = !util_1.isNullOrUndefined(input.InterestType) && input.InterestType != "" ? input.InterestType : null;
                let isSubvention = !util_1.isNullOrUndefined(input.IsSubvention) ? input.IsSubvention : false;
                let isLoanStatementWise = !util_1.isNullOrUndefined(input.isLoanStatementWise) ? JSON.parse(input.isLoanStatementWise) : false;
                if (isSubvention.toLowerCase() == 'yes') {
                    isSubvention = true;
                }
                else {
                    isSubvention = false;
                }
                let precentage = !util_1.isNullOrUndefined(input.Precentage) ? Number(input.Precentage) : null;
                if (!util_1.isNullOrUndefined(bankName) && !util_1.isNullOrUndefined(startDate) && !util_1.isNullOrUndefined(endDate) && !util_1.isNullOrUndefined(interestType)) {
                    // console.log('startDate', startDate);console.log('endDate', endDate);console.log('bankName',bankName);console.log('interestType',interestType);
                    console.log("reconcilitionPSCFC in if");
                    //create Query for fetch the data from dailyloanDetails Collection
                    // fromDate To toDate and bankName and interestType and also status in notComplete
                    const dailyLoanDetailsQuery = { "$and": [{ 'date': { "$gte": startDate, "$lte": endDate } }, { "status": { "$ne": "complete" } }, { "bankName": { "$eq": bankName } }, { "interestType": { "$eq": interestType } }] };
                    let dailyLoanDetails = yield (db.collection('DailyLoanDetails')).find(dailyLoanDetailsQuery).sort({ "date": 1 });
                    let dailyLoanDetailsData = JSON.parse(JSON.stringify(dailyLoanDetails));
                    if (dailyLoanDetailsData.length != 0) {
                        //this method we use for preparedata and reconciliton
                        //check interest Type
                        if (interestType == "PSCFC") {
                            yield this.prepareDataPSCFC(dailyLoanDetailsData, bankName, isSubvention, precentage, interestType, isLoanStatementWise, startDate, endDate);
                        }
                        else if (interestType == "PCFC") {
                            /*
                                interest Type is PCFC there is two we can reconciliton
                                    i) with repayment advice
                                    ii) without repayment (use loan statement PCFC )
                             */
                            if (!isLoanStatementWise) {
                                //without repayment advice means we use the loanStatement PCFC
                                yield this.prepareDataWithadvice(dailyLoanDetailsData, bankName, isSubvention, precentage, interestType, isLoanStatementWise, startDate, endDate);
                            }
                            else {
                                //without repayment advice means we use the loanStatement PCFC
                                yield this.prepareDataWithLoanStatement(dailyLoanDetailsData, bankName, isSubvention, precentage, interestType, isLoanStatementWise, startDate, endDate);
                            }
                        }
                        else if (interestType == "PC") {
                            yield this.prepareDataPC(dailyLoanDetailsData, bankName, isSubvention, precentage, interestType, isLoanStatementWise, startDate, endDate);
                        }
                        else if (interestType == "PSC") {
                        }
                    }
                }
            }
            catch (err) {
                console.log("err", err);
            }
        });
    }
    createPara(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let pdfData = typeof (input.pdfData) == 'string' ? JSON.parse(input.pdfData) : input.pdfData;
                for (let currentIndex = 0; currentIndex < pdfData.length - 1;) {
                    if (pdfData[currentIndex].top - pdfData[currentIndex + 1].top <= 20) {
                        if (pdfData[currentIndex + 1].line.search(/^[A-Z][\.][A-Z]/) === -1 && (pdfData[currentIndex + 1].line.search(/^[0-9a-z]{0,2}[\.)]/i) !== -1 || pdfData[currentIndex + 1].line.search(/^iii[\.)]/i) !== -1 || pdfData[currentIndex + 1].line.search(/^vii[\.)]/i) !== -1 || pdfData[currentIndex + 1].line.search(/^viii[\.)]/i) !== -1)) {
                            currentIndex++;
                        }
                        else if (!util_1.isNullOrUndefined(pdfData[currentIndex + 1].lineright) && !util_1.isNullOrUndefined(pdfData[currentIndex + 1].lineright) && pdfData[currentIndex].lineright + 3 < pdfData[currentIndex + 1].lineright) {
                            currentIndex++;
                        }
                        else {
                            pdfData[currentIndex].line = pdfData[currentIndex].line + " " + pdfData[currentIndex + 1].line;
                            pdfData[currentIndex].top = pdfData[currentIndex + 1].top;
                            pdfData[currentIndex].lineright = !util_1.isNullOrUndefined(pdfData[currentIndex + 1].lineright) ? pdfData[currentIndex + 1].lineright : pdfData[currentIndex].lineright;
                            pdfData.splice(currentIndex + 1, 1);
                        }
                    }
                    else {
                        currentIndex++;
                    }
                }
                output['pdfData'] = pdfData;
                return { message: "success", status: 0, data: output };
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    newSortParaAndHeader(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let pdf = typeof (input.pdfJson) == 'string' ? JSON.parse(input.pdfJson) : JSON.parse(JSON.stringify(input.pdfJson));
                let fileName = input.fileName;
                fileName = fileName.substring(fileName.lastIndexOf("coal") + 6);
                let data = [];
                for (let obj of pdf) {
                    let para = obj.line;
                    let header = '';
                    let subHeader1 = '';
                    let subHeader2 = '';
                    let substring = '';
                    if (typeof (obj.mainHeader) != 'undefined') {
                        header = obj.mainHeader;
                    }
                    if (typeof (obj.subHeader1) != 'undefined') {
                        subHeader1 = obj.subHeader1;
                    }
                    if (typeof (obj.subHeader2) != 'undefined') {
                        subHeader2 = obj.subHeader2;
                    }
                    if (subHeader1 != '' && subHeader1 != "''") {
                        substring = subHeader1;
                    }
                    if (subHeader2 != '' && subHeader2 != "''" && subHeader2 != subHeader1) {
                        substring = substring + ' / ' + subHeader2;
                    }
                    if (para.toLowerCase().search(/must/gmi) != -1 && para.toLowerCase().search(/should/gmi) != -1 && para.toLowerCase().search(/shall/gmi) != -1) {
                        data.push({ "keyWord": "Must,Should,Shall", "header": header, "subheader": substring, "para": para, "fileName": fileName });
                    }
                    else if (para.toLowerCase().search(/must/gmi) != -1 && para.toLowerCase().search(/should/gmi) != -1) {
                        data.push({ "keyWord": "Must,Should", "header": header, "subheader": substring, "para": para, "fileName": fileName });
                    }
                    else if (para.toLowerCase().search(/must/gmi) != -1 && para.toLowerCase().search(/shall/gmi) != -1) {
                        data.push({ "keyWord": "Must,Shall", "header": header, "subheader": substring, "para": para, "fileName": fileName });
                    }
                    else if (para.toLowerCase().search(/should/gmi) != -1 && para.toLowerCase().search(/shall/gmi) != -1) {
                        data.push({ "keyWord": "Should,Shall", "header": header, "subheader": substring, "para": para, "fileName": fileName });
                    }
                    else if (para.toLowerCase().search(/must/gmi) != -1) {
                        data.push({ "keyWord": "Must", "header": header, "subheader": substring, "para": para, "fileName": fileName });
                    }
                    else if (para.toLowerCase().search(/shall/gmi) != -1) {
                        data.push({ "keyWord": "Shall", "header": header, "subheader": substring, "para": para, "fileName": fileName });
                    }
                    else if (para.toLowerCase().search(/should/gmi) != -1) {
                        data.push({ "keyWord": "Should", "header": header, "subheader": substring, "para": para, "fileName": fileName });
                    }
                }
                yield (db.collection("coalIndia")).insertMany(data);
                output['output'] = data;
                return { message: "success", status: 0, data: output };
            }
            catch (e) {
                console.log('extractCropBoxes error : ', e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    defaultBotFunction(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log('Default Bot Function Called');
                return { message: '', status: 0, data: [] };
            }
            catch (e) {
                return { message: '', status: 1, data: [] };
            }
        });
    }
    userInput(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // let outputParameters = {
                // }
                outPut['num1'] = input.num1.toString();
                outPut['num2'] = input.num2.toString();
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                console.log('bot1 Error', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    addition(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let d = Number(input.num1) + Number(input.num2);
                // if (d > 0) {
                // } else {
                //     throw 'addition Failed';
                // }
                // let e = Number( input.num1) - Number( input.num2) ;
                // let outputParameters = {
                // }
                if (isNaN(d)) {
                    throw 'Not a Number';
                }
                outPut['result'] = d.toString();
                // outPut['subResult'] = e.toString();
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                console.log('bot2 Error', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    multiplication(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let { num1, num2 } = input;
                // Validate inputs
                num1 = num1 && !isNaN(parseFloat(num1)) ? parseFloat(num1) : 0;
                num2 = num2 && !isNaN(parseFloat(num2)) ? parseFloat(num2) : 0;
                // Multiply
                if (num1 && num2) {
                    let answer = num1 * num2;
                    outPut['result'] = answer;
                    console.log("Result is", answer);
                    //Send result
                    return { message: 'Multiplication Done', status: 0, data: outPut };
                }
                else {
                    outPut['result'] = 0;
                    console.log("Numbers must be valid integers and greater than 0");
                    return { message: 'Numbers must be valid integers and greater than 0', status: 1, data: outPut };
                }
            }
            catch (e) {
                return { message: e["message"], status: 1, data: e };
            }
        });
    }
    AuthBot(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const getOAuthTokens = () => {
                    return new Promise((resolve, reject) => {
                        oauth.getOAuthRequestToken((error, oauthToken, oauthTokenSecret) => {
                            if (error) {
                                reject(error);
                            }
                            else {
                                resolve({ oauthToken, oauthTokenSecret });
                            }
                        });
                    });
                };
                const { API_KEY, API_SECRET, TWITTER_CALLBACK_URL } = input;
                function encodeURLParams(params) {
                    return Object.keys(params)
                        .map(key => encodeURIComponent(key) + '=' + encodeURIComponent(params[key]))
                        .join('&');
                }
                const callbackParams = {
                    api_key: API_KEY,
                    api_secret: API_SECRET
                };
                const TWITTER_CALLBACK_URL_WITH_PARAMS = `${TWITTER_CALLBACK_URL}?${encodeURLParams(callbackParams)}`;
                const oauth = new OAuth("https://api.twitter.com/oauth/request_token", "https://api.twitter.com/oauth/access_token", API_KEY, API_SECRET, "1.0A", TWITTER_CALLBACK_URL_WITH_PARAMS, "HMAC-SHA1");
                const oauthTokens = yield getOAuthTokens();
                output['twitterAuthUrl'] = `https://api.twitter.com/oauth/authenticate?oauth_token=${oauthTokens.oauthToken}`;
                return { message: '', status: 0, data: output };
            }
            catch (error) {
                this.log.error("Error Message" + error);
                return { message: 'Authentication failed', status: 1, data: output };
            }
        });
    }
    XPost(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let mediaId = null;
            try {
                const client = new twitter_api_v2_1.TwitterApi({
                    appKey: input.API_KEY,
                    appSecret: input.API_SECRET,
                    accessToken: input.AccessToken,
                    accessSecret: input.AccessTokenSecret,
                });
                const twitterClient = client.readWrite;
                if (input.file) {
                    mediaId = yield twitterClient.v1.uploadMedia(input.file.path);
                    yield twitterClient.v2.tweet({
                        text: input.text,
                        media: {
                            media_ids: [mediaId],
                        },
                    });
                    fs.unlinkSync(input.file.path);
                }
                else {
                    yield twitterClient.v2.tweet(input.text);
                }
                output = {};
                let message = "Tweet posted";
                output["message"] = message;
                return { message: "Successfully posted", status: 0, data: output };
            }
            catch (error) {
                let message = "Failed posted";
                output["message"] = message;
                output["error"] = error;
                return { message: "Tweet failed", status: 1, data: output };
            }
        });
    }
    FaceBookAuthBot(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const authURL = `https://www.facebook.com/v13.0/dialog/oauth?client_id=${input.FACEBOOK_APP_ID}&redirect_uri=${encodeURIComponent(input.callbackURL)}&scope=pages_manage_posts`;
                output["authURL"] = authURL;
                return { message: "", status: 0, data: output };
            }
            catch (error) {
                this.log.error("Error Message" + error);
                return { message: "Authentication failed", status: 1, data: output };
            }
        });
    }
    FaceBookPostBot(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                function postToFacebook(message) {
                    return tslib_2.__awaiter(this, void 0, void 0, function* () {
                        let data = {
                            access_token: input.access_token,
                            message: message,
                        };
                        const ans = JSON.stringify(data);
                        const url = `https://graph.facebook.com/v20.0/${input.PAGE_ID}/feed`;
                        const curlCommand = `curl -s -X POST ${url} -H "Content-Type: application/json" -d '${ans}'`;
                        return new Promise((resolve, reject) => {
                            exec(curlCommand, (error, stdout, stderr) => {
                                if (error || stderr) {
                                    reject(error || stderr);
                                    return;
                                }
                                resolve(stdout);
                            });
                        });
                    });
                }
                const resultVal = yield postToFacebook(input.message);
                if (resultVal) {
                    let message = "post message done";
                    output["message"] = message;
                    return { message: "post successful", status: 0, data: output };
                }
                else {
                    let message = "server err";
                    output["message"] = message;
                    return { message: "post failed", status: 1, data: output };
                }
            }
            catch (error) {
                return { message: "post failed", status: 1, data: error };
            }
        });
    }
    FBMediaPostBot(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                function postPhotoToFacebook() {
                    return tslib_2.__awaiter(this, void 0, void 0, function* () {
                        let data = {
                            url: input.image,
                            access_token: input.access_token,
                        };
                        const ans = JSON.stringify(data);
                        const url = `https://graph.facebook.com/${input.PAGE_ID}/photos?url=${input.image}`;
                        const curlCommand = `curl -s -X POST ${url} -H "Content-Type: application/json" -d '${ans}'`;
                        return new Promise((resolve, reject) => {
                            exec(curlCommand, (error, stdout, stderr) => {
                                if (error || stderr) {
                                    reject(error || stderr);
                                    return;
                                }
                                resolve(stdout);
                            });
                        });
                    });
                }
                const resultVal = yield postPhotoToFacebook();
                if (resultVal) {
                    let message = "post media done";
                    output["message"] = message;
                    return { message: "post successful", status: 0, data: output };
                }
                else {
                    let result = "server err";
                    output["result"] = result;
                    return { message: "post failed", status: 1, data: output };
                }
            }
            catch (error) {
                return { message: "post failed", status: 1, data: error };
            }
        });
    }
    InstaPost(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            function executeCurlCommand(curlCommand) {
                return new Promise((resolve, reject) => {
                    exec(curlCommand, (error, stdout, stderr) => {
                        if (error) {
                            return reject(error);
                        }
                        if (stderr) {
                            return reject(new Error(stderr));
                        }
                        try {
                            const jsonResponse = JSON.parse(stdout);
                            resolve(jsonResponse);
                        }
                        catch (e) {
                            resolve(stdout);
                        }
                    });
                });
            }
            function postToInstagram() {
                return tslib_2.__awaiter(this, void 0, void 0, function* () {
                    try {
                        const data = {
                            image_url: input.image_url,
                            caption: input.caption.replace(/'/g, "\\'"),
                            access_token: input.access_token
                        };
                        const ans = JSON.stringify(data);
                        const urlOne = `https://graph.facebook.com/v16.0/${input.INSTRGRAM_APP_ID}/media`;
                        const curlCommandOne = `curl -s -X POST ${urlOne} -H "Content-Type: application/json" -d "${ans.replace(/"/g, '\\"')}"`;
                        const uploadResponse = yield executeCurlCommand(curlCommandOne);
                        const id = uploadResponse ? uploadResponse.id : null;
                        if (!id) {
                            return { message: "Failed to retrieve media ID", status: 1, data: null };
                        }
                        const dataOne = {
                            creation_id: id,
                            access_token: input.access_token,
                        };
                        const ansTwo = JSON.stringify(dataOne);
                        const urlTwo = `https://graph.facebook.com/v16.0/${input.INSTRGRAM_APP_ID}/media_publish`;
                        const curlCommandTwo = `curl -s -X POST ${urlTwo} -H "Content-Type: application/json" -d "${ansTwo.replace(/"/g, '\\"')}"`;
                        const publishResponse = yield executeCurlCommand(curlCommandTwo);
                        if (publishResponse) {
                            output["message"] = "Post was done!!";
                            return { message: "Media published successfully", status: 0, data: output };
                        }
                        else {
                            output["message"] = "Post not done!!";
                            return { message: "Failed to publish media", status: 1, data: output };
                        }
                    }
                    catch (error) {
                        return { message: "Error posting to Instagram", status: 1, data: error };
                    }
                });
            }
            yield postToInstagram();
            output["message"] = "Post was done!!";
            return { message: "Media published successfully", status: 0, data: output };
        });
    }
    LinkedInPost(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const author = `urn:li:person:${input.personId}`;
                const postData = {
                    author,
                    lifecycleState: 'PUBLISHED',
                    specificContent: {
                        'com.linkedin.ugc.ShareContent': {
                            shareCommentary: {
                                text: input.content,
                            },
                            shareMediaCategory: input.fileType && input.fileType !== 'none' ? input.fileType.toUpperCase() : 'NONE',
                            media: [],
                        },
                    },
                    visibility: {
                        'com.linkedin.ugc.MemberNetworkVisibility': 'PUBLIC',
                    },
                };
                if (input.fileType && input.fileType !== 'none' && input.file) {
                    const mediaUploadResponse = yield axios.post(`https://api.linkedin.com/v2/assets?action=registerUpload`, {
                        registerUploadRequest: {
                            recipes: [`urn:li:digitalmediaRecipe:feedshare-${input.fileType.toLowerCase()}`],
                            owner: author,
                            serviceRelationships: [
                                {
                                    relationshipType: 'OWNER',
                                    identifier: 'urn:li:userGeneratedContent',
                                },
                            ],
                        },
                    }, {
                        headers: {
                            'Authorization': `Bearer ${input.AccessToken}`,
                            'Content-Type': 'application/json',
                        },
                    });
                    const uploadUrl = mediaUploadResponse.data.value.uploadMechanism['com.linkedin.digitalmedia.uploading.MediaUploadHttpRequest'].uploadUrl;
                    const asset = mediaUploadResponse.data.value.asset;
                    const fileData = fs.readFileSync(input.file.path);
                    yield axios.put(uploadUrl, fileData, {
                        headers: {
                            'Authorization': `Bearer ${input.AccessToken}`,
                            'Content-Type': input.file.mimetype,
                        },
                    });
                    postData.specificContent['com.linkedin.ugc.ShareContent'].media = [
                        {
                            status: 'READY',
                            media: asset,
                            title: {
                                text: 'Media title',
                            },
                        },
                    ];
                    fs.unlinkSync(input.file.path);
                }
                const response = yield axios.post('https://api.linkedin.com/v2/ugcPosts', postData, {
                    headers: {
                        'Authorization': `Bearer ${input.AccessToken}`,
                        'Content-Type': 'application/json',
                    },
                });
                if (response) {
                    let message = "post media done";
                    output["message"] = message;
                    return { message: "LinkedIn post successful", status: 0, data: output };
                }
                else {
                    let message = "LinkedIn Post Error ";
                    output["message"] = message;
                    return { message: "LinkedIn post failed", status: 1, data: output };
                }
            }
            catch (error) {
                return { message: "post failed", status: 1, data: error };
            }
        });
    }
    substraction(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // let d =Number( input.num1) + Number( input.num2) ;
                let e = Number(input.num2) - Number(input.num1);
                // let outputParameters = {
                // }
                // outPut['result'] = d.toString();
                outPut['result'] = e.toString();
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                console.log('bot2 Error', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    displayOnConsole(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // console.log('addition---->',input.addResult)
                // console.log('substraction---->',input.subResult)
                console.log('substraction or Addition---->', input.result);
                // let outputParameters = {
                // }
                // outPut['addResult'] = input.addResult;
                // outPut['subResult'] = input.subResult;
                outPut['result'] = input.result;
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                return { message: '', status: 1, data: e };
            }
        });
    }
    processFile(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                return { message: '', status: 0, data: [] };
            }
            catch (e) {
                return { message: '', status: 1, data: [] };
            }
        });
    }
    cleanEventStatus(input) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                //let token = await this.createToken(input.userId, input.subscriberId, input.orgId);
                let result = yield this.houseKeepingHelper.cleanEventStatus(input);
                return { message: result.info, status: result.status, data: result.data };
            }
            catch (ex) {
                return { status: 1, message: "Problem in restart bot." + ex, data: ex };
            }
        });
    }
    restartProcess(input) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let token = yield this.createToken(input.userId, input.subscriberId, input.orgId);
                let result = yield this.houseKeepingHelper.restartProcess(input, token);
                return { message: result.info, status: result.status, data: result.data };
            }
            catch (ex) {
                return { status: 1, message: "Problem in restart bot." + ex, data: ex };
            }
        });
    }
    deletePNGFiles(input, output) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // let mongoUri = 'mongodb://tata:tata123@server.gibots.com:2700/tatacomm-test'
                // let mClient = await MongoClient.connect(mongoUri);
                // //  console.log(mongoUri.split('/')[mongoUri.split('/').length - 1]);
                // let db = mClient.db(mongoUri.split('/')[mongoUri.split('/').length - 1]);
                if (util_1.isNullOrUndefined(input.documentType)) {
                    return { message: 'documentType not pass', status: 1, data: input };
                }
                else {
                    var timesec = (!util_1.isNullOrUndefined(input.day) ? input.day : 15) * 24 * 60 * 60 * 1000;
                    let data = yield db.collection('fileuploadhistories').aggregate([
                        {
                            $match: {
                                "createdAt": {
                                    $lte: new Date((new Date().getTime() - (timesec)))
                                },
                                documentType: input.documentType
                            }
                        },
                        {
                            $unwind: {
                                path: "$imagesPath",
                                "preserveNullAndEmptyArrays": true,
                            }
                        },
                        {
                            $project: {
                                // fileRefNum:1,
                                imagesPath: "$imagesPath.imageFilePath"
                            }
                        }
                    ]);
                    //   mClient.close()
                    var startPoint = 0;
                    var endPoint = 0;
                    while (endPoint < data.length) {
                        let deletepath = '';
                        startPoint = endPoint;
                        endPoint += 50;
                        if (endPoint > data.length)
                            endPoint = data.length;
                        for (startPoint; startPoint < endPoint; startPoint++) {
                            if (data[startPoint]['path'] !== '') {
                                deletepath = deletepath + ' ' + data[startPoint]['imagesPath'];
                            }
                        }
                        // console.log(endPoint)
                        if (deletepath.trim() !== '') {
                            yield this.sh("sudo find " + deletepath + " -print0 | xargs -0 rm");
                        }
                    }
                    return data;
                }
            }
            catch (e) {
                console.log(e);
                return e;
            }
        });
    }
    poCompare(input, outputParameters, fromBotId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let poData = yield errorInvoice_1.errorInv.findOne({ isDeleted: 0, referenceNumber: input._id });
                this.log.info('Get PO data');
                let matchThreshole = config.fuzzyThreshole;
                let poDataItems = poData['invoiceItems'];
                if (!util_1.isNullOrUndefined(poData)) {
                    this.log.info('Get Product data');
                    const data = yield product_1.Product.find({ isDelete: false, isProduct: true });
                    if (!util_1.isNullOrUndefined(data)) {
                        this.log.info('Fuzzy options defined');
                        const options = {
                            shouldSort: true,
                            includeScore: true,
                            threshold: 0.4,
                            tokenize: true,
                            location: 0,
                            distance: 100,
                            maxPatternLength: 32,
                            minMatchCharLength: 1,
                            keys: [
                                'description', 'productName',
                            ],
                        };
                        _.each(poDataItems, function (elem) {
                            const fuse = new Fuse(data, options);
                            const result = fuse.search(elem.description);
                            result.filter((re) => {
                                if (re.score <= matchThreshole) {
                                    elem.matchList.push(re);
                                }
                            });
                        });
                        this.log.info('Matchlist returned');
                        return { info: 'matchlist found', status: 0, data: poDataItems };
                    }
                    else {
                        return { info: 'matchlist not found', status: 1, data: [] };
                    }
                }
                else {
                    return { info: 'data not found', status: 1, data: [] };
                }
            }
            catch (err) {
                return { info: 'internal server error', status: 1, data: [] };
            }
        });
    }
    downloadFileUsingScp(input, outputParameters, fromBotId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                input['iterationId'] = iterationId;
                let result = yield this.downloadUploadFileHelper.downloadFileUsingScp(input);
                if (!util_1.isNullOrUndefined(result) && !util_1.isNullOrUndefined(result.status) && result.status === 0) {
                    outputParameters['result'] = result;
                    return { message: result.info, status: result.status, data: outputParameters };
                }
                else {
                    throw result.info;
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + fromBotId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    uploadFileUsingScp(input, outputParameters, fromBotId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                input['iterationId'] = iterationId;
                let result = yield this.downloadUploadFileHelper.uploadFileUsingScp(input);
                if (!util_1.isNullOrUndefined(result) && !util_1.isNullOrUndefined(result.status) && result.status === 0) {
                    outputParameters['result'] = result;
                    return { message: result.info, status: result.status, data: outputParameters };
                }
                else {
                    throw result.info;
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + fromBotId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    drawImage(Input, output, fromBotId, projectId, iterationId) {
        try {
            const dr = require('dxf-writer');
            let d = new dr();
            let input = JSON.parse(Input['shapesInput']);
            let lableInput = JSON.parse(Input['ocrInput']);
            let key;
            const height = input['height'];
            d.setUnits('Meter');
            for (key in input) {
                const circles = input['circles'];
                const lines = input['lines'];
                const rectangles = input['rectangles'];
                const squares = input['squares'];
                const polygons = input['polygons'];
                const pentagons = input['pentagons'];
                circles.forEach(item => {
                    d.drawCircle(item[0][0], item[0][1], item[1]);
                });
                lines.forEach(item => {
                    d.drawLine(item[0][0], height - item[0][1], item[1][0], height - item[1][1]);
                });
                rectangles.forEach(item => {
                    for (let i = 0; i < item.length; i++) {
                        if (i != item.length - 1) {
                            d.drawLine(item[i][0], height - item[i][1], item[i + 1][0], height - item[i + 1][1]);
                        }
                        else if (i == item.length - 1) {
                            d.drawLine(item[i][0], height - item[i][1], item[0][0], height - item[0][1]);
                        }
                    }
                });
                squares.forEach(item => {
                    for (let i = 0; i < item.length; i++) {
                        if (i != item.length - 1) {
                            d.drawLine(item[i][0], height - item[i][1], item[i + 1][0], height - item[i + 1][1]);
                        }
                        else if (i == item.length - 1) {
                            d.drawLine(item[i][0], height - item[i][1], item[0][0], height - item[0][1]);
                        }
                    }
                });
                pentagons.forEach(item => {
                    for (let i = 0; i < item.length; i++) {
                        if (i != item.length - 1) {
                            d.drawLine(item[i][0], height - item[i][1], item[i + 1][0], height - item[i + 1][1]);
                        }
                        else if (i == item.length - 1) {
                            d.drawLine(item[i][0], height - item[i][1], item[0][0], height - item[0][1]);
                        }
                    }
                });
                polygons.forEach(item => {
                    for (let i = 0; i < item.length; i++) {
                        if (i != item.length - 1) {
                            d.drawLine(item[i][0], height - item[i][1], item[i + 1][0], height - item[i + 1][1]);
                        }
                        else if (i == item.length - 1) {
                            d.drawLine(item[i][0], height - item[i][1], item[0][0], height - item[0][1]);
                        }
                    }
                });
            }
            d.setUnits('Meter');
            let labels = lableInput;
            labels.forEach(item => {
                d.drawText(item['X'], height - item['Y'], 50, item['angle'], item['LABEL']);
            });
            let path = '/var/www/cuda-fs/';
            fs.writeFileSync(path + 'output_' + Date.now() + '.dxf', d.toDxfString());
            output['path'] = path + 'output' + Date.now() + '.dxf';
            return { message: 'Bot written sucessfully', status: 0, data: output };
        }
        catch (err) {
            return { message: '', status: 1, data: err };
        }
    }
    downloadFileUsingFtp(input, outputParameters, fromBotId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.downloadUploadFileHelper.downloadFileUsingFtp(input);
            }
            catch (e) {
                return { message: '', status: 1, data: [] };
            }
        });
    }
    uploadFileUsingFtp(input, outputParameters, fromBotId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.downloadUploadFileHelper.uploadFileUsingFtp(input);
            }
            catch (e) {
                return { message: '', status: 1, data: [] };
            }
        });
    }
    executeRemoteScript(input, outputParameters, fromBotId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info('Inside Execute remote job Execution--' + JSON.stringify(input));
                input['iterationId'] = iterationId;
                const result = yield this.scriptHelper.executeUnixScript(input, outputParameters, fromBotId, projectId);
                if (!util_1.isNullOrUndefined(result) && !util_1.isNullOrUndefined(result.status) && result.status === 0) {
                    outputParameters['result'] = result;
                    return { message: result.info, status: result.status, data: outputParameters };
                }
                else {
                    throw result.info;
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + fromBotId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    downloadFileUsingSftp(input, outputParameters, fromBotId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.downloadUploadFileHelper.downloadFileUsingSftp(input);
            }
            catch (e) {
                return { message: '', status: 1, data: [] };
            }
        });
    }
    uploadFileUsingSftp(input, outputParameters, fromBotId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.downloadUploadFileHelper.uploadFileUsingSftp(input);
            }
            catch (e) {
                return { message: '', status: 1, data: [] };
            }
        });
    }
    // public async emailNotify(input: any, outputParameters, fromBotId, projectId) {
    //     try {
    //         let emailData: any;
    //         let attachments = [];
    //         if (!Array.isArray(input.attachments)) {
    //             emailData = input.attachments;
    //         }
    //         const transport = nodemailer.createTransport(smtpTransport({
    //             service: input.service,
    //             auth: {
    //                 user: input.user,
    //                 pass: input.pass,
    //             },
    //         }));
    //         if (!isNullOrUndefined(input.attachments)) {
    //             if (Array.isArray(input.attachments)) {
    //                 for (let i = 0; i < input.attachments.length; i++) {
    //                     const fileName = input.attachments[i].replace(/^.*[\\\/]/, '');
    //                     attachments.push({ 'filename': fileName, 'content': fs.readFileSync(input.attachments[i]) });
    //                 }
    //             }
    //         }
    //         if (!isNullOrUndefined(emailData)) {
    //             const fileName = emailData.replace(/^.*[\\\/]/, '');
    //             let filePath = JSON.parse(JSON.stringify(emailData));
    //             let a = fs.readFileSync(filePath);
    //             let b = fileName
    //             attachments.push({ 'filename': b, 'content': a });
    //         }
    //         const emailOptions = {
    //             from: input.from,
    //             to: input.to,
    //             cc: input.cc,
    //             bcc: input.bcc,
    //             subject: input.subject,
    //             text: input.text,
    //             html: input.html,
    //             attachments: attachments
    //         };
    //         console.log("attach", attachments)
    //         const response = await transport.sendMail(emailOptions);
    //         if (isNullOrUndefined(response)) {
    //             return { info: 'error occured', status: 1, data: 'email not sent' };
    //         } else {
    //             outputParameters['response'] = ' ';
    //             console.log("responce", response);
    //             return { info: 'mail sent successfully', status: 0, data: outputParameters };
    //         }
    //     } catch (err) {
    //         return { info: 'Internal server error', status: 1, data: err };
    //     }
    // }
    emailNotify(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info('Inside email notify -- ' + JSON.stringify(input));
                let attachments = [];
                let config;
                let transport;
                let isArray;
                if (!input['projectVar']) {
                    if (!util_1.isNullOrUndefined(input['pass'])) {
                        input['pass'] = Buffer.from(input['pass'], 'base64').toString();
                    }
                }
                input.messageId = input.messageId ? input.messageId : '';
                if ((!util_1.isNullOrUndefined(input.service) && input.service.toLowerCase().trim() == 'gmail') || (!util_1.isNullOrUndefined(input.host) && input.host !== "")) {
                    config = {
                        host: util_1.isNullOrUndefined(input.host) || input.host == "" ? "smtp.gmail.com" : input.host,
                        port: util_1.isNullOrUndefined(input.port) || input.port == "" ? 587 : input.port,
                        secure: !util_1.isNullOrUndefined(input.secure) && input.secure == "true" ? true : false,
                        ignoreTLS: !util_1.isNullOrUndefined(input.ignoreTLS) && input.ignoreTLS == "true" ? true : false,
                    };
                    if (!util_1.isNullOrUndefined(input.user) && input.user !== "") {
                        config["auth"] = { user: input.user };
                    }
                    ;
                    if (!util_1.isNullOrUndefined(input.service) && input.service !== "") {
                        config["service"] = input.service;
                    }
                    if (!util_1.isNullOrUndefined(input.pass) && input.pass !== "") {
                        config["auth"]["pass"] = input.pass;
                    }
                    ;
                    console.log(JSON.parse(JSON.stringify(config)));
                    if (!util_1.isNullOrUndefined(input.useAccessToken) && (input.useAccessToken || input.useAccessToken == 'true')) {
                        let userData = yield User_1.UserModel.findOne({ _id: ObjectId(input.userId) });
                        transport = nodemailer.createTransport({
                            service: input.service,
                            auth: {
                                type: 'OAuth2',
                                user: input.from,
                                clientId: userData['client_id'],
                                clientSecret: userData['client_secret'],
                                refreshToken: userData['refresh_token'],
                                accessToken: userData['access_token'],
                            },
                        });
                    }
                    else {
                        transport = nodemailer.createTransport(smtpTransport(config));
                    }
                }
                else {
                    process.env.NODE_TLS_REJECT_UNAUTHORIZED = input.REJECT_UNAUTHORIZED;
                    config = (input.secureConnection != undefined && (input.secureConnection.toString().toLowerCase().trim() == "true" || input.secureConnection.toString().toLowerCase().trim() == "yes") ? "smtps" : "smtp") + "://" + input.from + ":" + encodeURIComponent(input.pass) + "@" + input.host + ":" + input.port;
                    this.log.info("configuartion string==" + config);
                    transport = nodemailer.createTransport(config);
                }
                if (!util_1.isNullOrUndefined(input.attachments) && input.attachments !== "") {
                    let attDoc = input.attachments;
                    if (!util_1.isNullOrUndefined(attDoc) && attDoc.length > 0) {
                        isArray = Array.isArray(attDoc); // checked attDoc isArray dataType
                        if (!isArray) {
                            isArray = attDoc[0] == "[" ? true : false; // checked array in string dataType
                        }
                        if (!util_1.isNullOrUndefined(attDoc) && attDoc.length > 0 && isArray) {
                            if (typeof attDoc == 'string') { // checked attDoc is string or not
                                attDoc = JSON.parse(attDoc);
                            }
                            for (let i = 0; i < attDoc.length; i++) {
                                const fileName = attDoc[i].replace(/^.*[\\\/]/, '');
                                attachments.push({ 'filename': fileName, 'path': attDoc[i] });
                            }
                        }
                        else {
                            attachments.push({ 'filename': input.attachments.replace(/^.*[\\\/]/, ''), 'path': attDoc });
                        }
                    }
                }
                if (!util_1.isNullOrUndefined(input.track) && input.track == "true") {
                    if (!util_1.isNullOrUndefined(input.campaignId) && input.campaignId !== "") { }
                    else {
                        const unixTimestamp = Math.floor(Date.now() / 1000);
                        const timestampHexString = unixTimestamp.toString(16);
                        input.campaignId = timestampHexString;
                    }
                    let emailHtml = input.html;
                    const callbackUrl = `${process.env.Application_URL}gibots-api/email`;
                    // const callbackUrl = "http://localhost:2224/gibots-api/email"; // Local callback URL
                    // Find URLs in the HTML content and replace them with tracked URLs
                    const urlRegex = /(?:https?:\/\/|www\.)[^\s<>"']+/gi; // Match all URLs
                    const urls = emailHtml.match(urlRegex);
                    if (urls) {
                        console.log("Found URLs:", urls);
                        // Store replacements in an array to process them later
                        const replacements = [];
                        urls.forEach((url) => {
                            console.log(`Processing URL: ${url}`);
                            // Ensure the URL starts with https:// if it doesn't already
                            const ensureHttps = (url) => (!/^https?:\/\//i.test(url) ? `https://${url}` : url);
                            const nUrl = ensureHttps(url);
                            // Create the tracked URL
                            const trackedUrl = `${callbackUrl}/log-external-click?externalURL=${encodeURIComponent(nUrl)}&emailId=${input.to}&fromEmail=${input.from}&campaignId=${input.campaignId}&orgId=${input.orgId}&subscriberId=${input.subscriberId}&userId=${input.userId}`;
                            // Skip replacement if the URL is in a src attribute
                            const srcRegex = new RegExp(`src=["']${url}["']`, "gi");
                            if (srcRegex.test(emailHtml)) {
                                console.log(`Skipping URL in src: ${url}`);
                                return;
                            }
                            // Collect the replacement (do not replace immediately)
                            const urlRegexGlobal = new RegExp(url, "g"); // Global regex for multiple occurrences
                            let match;
                            while ((match = urlRegexGlobal.exec(emailHtml)) !== null) {
                                replacements.push({
                                    index: match.index,
                                    length: match[0].length,
                                    replacement: `<a href="${trackedUrl}">${url}</a>`,
                                });
                            }
                        });
                        // Sort replacements in reverse order of index to handle overlapping replacements
                        replacements.sort((a, b) => b.index - a.index);
                        // Apply replacements to the emailHtml
                        replacements.forEach(({ index, length, replacement }) => {
                            emailHtml = emailHtml.slice(0, index) + replacement + emailHtml.slice(index + length);
                        });
                        console.log("Processed emailHtml:", emailHtml);
                    }
                    else {
                        console.log("No URLs found.");
                    }
                    if (!emailHtml.includes('</body>')) {
                        emailHtml = `<html><body>${emailHtml}</body></html>`;
                    }
                    emailHtml = emailHtml.replace('</body>', `<img src="${callbackUrl}/tracking_pixel?emailId=${input.to}&fromEmail=${input.from}&campaignId=${input.campaignId}&orgId=${input.orgId}&subscriberId=${input.subscriberId}&userId=${input.userId}" width="1" height="1" style="display:none;"></body>`);
                    //console.log(emailHtml);
                    input.html = emailHtml;
                }
                if (!util_1.isNullOrUndefined(input.unsubText) && input.unsubText !== "") {
                    const callbackUrl = `${process.env.Application_URL}gibots-api/email`;
                    if (input.html.includes('</body>')) {
                        input.html = input.html.replace('</body>', `<p>${input.unsubText} click <a href="${callbackUrl}/unsubscribe?emailId=${input.to}&orgId=${input.orgId}&subscriberId=${input.subscriberId}&userId=${input.userId}" style="color: #ff0000; text-decoration: underline;">here</a> to unsubscribe.</p></body>`);
                    }
                    else {
                        input.html = input.html + `<p>${input.unsubText} click <a href="${callbackUrl}/unsubscribe?emailId=${input.to}&orgId=${input.orgId}&subscriberId=${input.subscriberId}&userId=${input.userId}" style="color: #ff0000; text-decoration: underline;">here</a> to unsubscribe.</p>`;
                    }
                }
                const regex = /<[^>]*>/;
                if (regex.test(input.html)) {
                }
                else {
                    input.html = `<html>${input.html}</html>`;
                }
                // Prepare the email options
                const emailOptions = {
                    from: input.from,
                    to: input.to,
                    replyTo: input.replyTo || '',
                    cc: input.cc || '',
                    bcc: input.bcc || '',
                    subject: input.subject,
                    text: input.text,
                    html: input.html,
                    attachments: attachments,
                    headers: {
                        'In-Reply-To': input.messageId,
                        References: input.messageId,
                    },
                };
                if (!util_1.isNullOrUndefined(input.appendOld) && input.appendOld == "true") {
                    const emailToMatch = emailOptions.to;
                    const regex = new RegExp(`<${emailToMatch}>|^${emailToMatch}$`, 'i');
                    const sentEmails = yield db.collection('emails_sent_logs')
                        .find({
                        subscriberId: ObjectId(input.subscriberId),
                        orgId: ObjectId(input.orgId),
                        receiverEmailId: emailOptions.to,
                    })
                        .lean();
                    const receivedEmails = yield db.collection('emails_received_logs')
                        .aggregate([
                        {
                            $match: {
                                from: { $regex: regex },
                            },
                        },
                        {
                            $lookup: {
                                from: 'emails_sent_logs',
                                localField: 'inReplyTo',
                                foreignField: 'messageId',
                                as: 'matchingSentLogs',
                            },
                        },
                        {
                            $match: {
                                'matchingSentLogs.subscriberId': ObjectId(input.subscriberId),
                                'matchingSentLogs.orgId': ObjectId(input.orgId),
                            },
                        },
                        {
                            $project: {
                                matchingSentLogs: 0,
                            },
                        },
                    ])
                        .exec();
                    const allEmails = [
                        ...sentEmails.map((email) => (Object.assign({}, email, { type: 'sent', sortDate: new Date(email.createdAt) }))),
                        ...receivedEmails.map((email) => (Object.assign({}, email, { type: 'received', sortDate: new Date(email.date) }))),
                    ];
                    const sortedEmails = allEmails.sort((a, b) => b.sortDate - a.sortDate);
                    if (sortedEmails.length > 0) {
                        const topEmail = sortedEmails[0];
                        let subject;
                        if (topEmail.type === 'received') {
                            subject = topEmail.subject;
                            emailOptions['subject'] = subject;
                        }
                        else if (topEmail.type === 'sent') {
                            const campaignData = yield db.collection('campaigns')
                                .findOne({ eventId: ObjectId(topEmail.campaignId) }, { Subject: 1 }).lean();
                            if (campaignData) {
                                subject = campaignData.Subject;
                                subject = `Re: ${subject}`;
                                emailOptions['subject'] = subject;
                            }
                            else {
                                console.warn('No campaign found for the given campaignId.');
                            }
                        }
                        emailOptions['inReplyTo'] = `<${topEmail.messageId}>`;
                        emailOptions['references'] = [`<${topEmail.messageId}>`];
                    }
                }
                let response;
                const retries = 3;
                // Send the email
                for (let attempt = 1; attempt <= retries; attempt++) {
                    try {
                        response = yield transport.sendMail(emailOptions);
                        // console.log(`Email sent successfully on attempt ${attempt}`);
                        break; // Exit loop on success, but allow further code to run
                    }
                    catch (error) {
                        if (attempt < retries && error.code === 'EAI_AGAIN') {
                            console.warn(`Attempt ${attempt} failed: ${error.message}. Retrying in ${delay}ms...`);
                            yield new Promise(resolve => setTimeout(resolve, 2000)); // Wait before retrying
                        }
                        else {
                            console.error(`Failed to send email after ${attempt} attempts.`);
                            break;
                        }
                    }
                }
                if ((!util_1.isNullOrUndefined(input.MinGapBetTwoEmails) && input.MinGapBetTwoEmails !== "") ||
                    (!util_1.isNullOrUndefined(input.MaxGapBetTwoEmails) && input.MaxGapBetTwoEmails !== "")) {
                    const minGap = !util_1.isNullOrUndefined(input.MinGapBetTwoEmails) && input.MinGapBetTwoEmails !== "" ? parseInt(input.MinGapBetTwoEmails, 10) : null;
                    const maxGap = !util_1.isNullOrUndefined(input.MaxGapBetTwoEmails) && input.MaxGapBetTwoEmails !== "" ? parseInt(input.MaxGapBetTwoEmails, 10) : null;
                    let gap;
                    if (minGap !== null && maxGap !== null) {
                        gap = Math.floor(Math.random() * (maxGap - minGap + 1)) + minGap;
                    }
                    else if (minGap !== null) {
                        gap = minGap;
                    }
                    else if (maxGap !== null) {
                        gap = maxGap;
                    }
                    yield new Promise(resolve => setTimeout(resolve, gap * 1000));
                }
                if (util_1.isNullOrUndefined(response)) {
                    return { info: 'error occurred', status: 0, data: outputParameters };
                }
                else {
                    outputParameters['messageId'] = response.messageId;
                    return { info: 'mail sent successfully', status: 0, data: outputParameters };
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    readExcelInvoices(input, output, botId, projectId, iterationId) {
        try {
            let startHeader = input.startHeader;
            let excelPath = input.filePath;
            let workbook = XLSX.readFile(excelPath);
            let sheet_name_list = workbook.SheetNames;
            if ([true, 'true'].includes(input.allsheet)) {
                output['jsonData'] = [];
                for (let sheet_name of sheet_name_list) {
                    let xlData = XLSX.utils.sheet_to_json(workbook.Sheets[sheet_name]);
                    let obj = {
                        data: xlData,
                        sheetName: sheet_name,
                        filePath: excelPath,
                    };
                    output["jsonData"].push(obj);
                }
            }
            else {
                let xlData = XLSX.utils.sheet_to_json(workbook.Sheets[sheet_name_list[0]]);
                let reformattedArray = [];
                let invoiceData = {};
                for (let i = 1; i < xlData.length; i++) {
                    let obj = {};
                    if (i > startHeader && xlData[i]['__EMPTY'] != undefined) {
                        obj[xlData[startHeader]['__EMPTY']] = !util_1.isNullOrUndefined(xlData[i]['__EMPTY']) ? xlData[i]['__EMPTY'].toString() : xlData[i]['__EMPTY'];
                        obj[xlData[startHeader]['__EMPTY_1']] = !util_1.isNullOrUndefined(xlData[i]['__EMPTY_1']) ? xlData[i]['__EMPTY_1'].toString() : xlData[i]['__EMPTY_1'];
                        obj[xlData[startHeader]['__EMPTY_2']] = !util_1.isNullOrUndefined(xlData[i]['__EMPTY_2']) ? xlData[i]['__EMPTY_2'].toString() : xlData[i]['__EMPTY_2'];
                        obj["AGENT_PRICE"] = !util_1.isNullOrUndefined(xlData[i]['__EMPTY_3']) ? xlData[i]['__EMPTY_3'].toString() : xlData[i]['__EMPTY_3'];
                        obj[xlData[startHeader]['__EMPTY_4']] = !util_1.isNullOrUndefined(xlData[i]['__EMPTY_4']) ? xlData[i]['__EMPTY_4'].toString() : xlData[i]['__EMPTY_4'];
                        obj[xlData[startHeader]['__EMPTY_5']] = !util_1.isNullOrUndefined(xlData[i]['__EMPTY_5']) ? xlData[i]['__EMPTY_5'].toString() : xlData[i]['__EMPTY_5'];
                        obj["TOTAL_COST"] = !util_1.isNullOrUndefined(xlData[i]['__EMPTY_6']) ? xlData[i]['__EMPTY_6'].toString() : xlData[i]['__EMPTY_6'];
                        obj[xlData[startHeader]['__EMPTY_7']] = !util_1.isNullOrUndefined(xlData[i]['__EMPTY_7']) ? xlData[i]['__EMPTY_7'].toString() : xlData[i]['__EMPTY_7'];
                        obj["GROSS_PROFIT"] = !util_1.isNullOrUndefined(xlData[i]['__EMPTY_8']) ? xlData[i]['__EMPTY_8'].toString() : xlData[i]['__EMPTY_8'];
                        obj["GROSS_MARGIN"] = !util_1.isNullOrUndefined(xlData[i]['__EMPTY_9']) ? xlData[i]['__EMPTY_9'].toString() : xlData[i]['__EMPTY_9'];
                        reformattedArray.push(obj);
                    }
                    else if (i < startHeader - 2) {
                        invoiceData[xlData[i]['__EMPTY_1']] = !util_1.isNullOrUndefined(xlData[i]['__EMPTY_4']) ? xlData[i]['__EMPTY_4'].toString() : xlData[i]['__EMPTY_4'];
                    }
                    else if (i != startHeader && i >= startHeader - 2 && xlData[i]['__EMPTY'] != undefined) {
                        invoiceData[xlData[i]['__EMPTY']] = !util_1.isNullOrUndefined(xlData[i]['__EMPTY_1']) ? xlData[i]['__EMPTY_1'].toString() : xlData[i]['__EMPTY_1']; //xlData$
                        invoiceData[xlData[i]['__EMPTY_5']] = !util_1.isNullOrUndefined(xlData[i]['__EMPTY_6']) ? xlData[i]['__EMPTY_6'].toString() : xlData[i]['__EMPTY_6']; //xlDa$
                    }
                }
                invoiceData['invoiceItems'] = reformattedArray;
                output['excelData'] = invoiceData;
                output['jsonData'] = xlData;
            }
            return { message: 'Excel Invoices Read successfull', status: 0, data: output };
        }
        catch (e) {
            this.log.error("Error in  read excel file." + e);
            return { message: e, status: 1, data: e };
        }
    }
    insertExcelDataIntoDb(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                return tslib_2.__asyncGenerator(this, arguments, function* () {
                    try {
                        let tablename = input.tablename;
                        let excelData = input.excelData;
                        let uniqueKey = input.uniqueKey;
                        let resp = yield tslib_2.__await(this.metaDataService.saveExcelData(excelData, tablename, uniqueKey));
                        if (resp.status == 0) {
                            return yield tslib_2.__await({ message: 'Excel data Insertion successfull', status: 0, data: output });
                        }
                        else {
                            return yield tslib_2.__await({ message: 'Excel data Insertion failed', status: 1, data: [] });
                        }
                    }
                    catch (error) {
                        return yield tslib_2.__await({ message: 'Internal server error', status: 1, data: error });
                    }
                });
            });
        });
    }
    insertDataIntoDb(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let tablename = input.tablename;
                let excelData = input.excelData;
                for (let obj of excelData) {
                    for (let key in obj) {
                        obj[key] = String(obj[key]);
                    }
                }
                let resp = yield (db.collection(tablename)).insertMany(excelData);
                console.log("Res--------", resp);
                return { message: 'Excel data Insertion successfull', status: 0, data: output };
            }
            catch (error) {
                return { message: 'Internal server error', status: 1, data: error };
            }
        });
    }
    postImageOnTwitter(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info("Inside post twitter.." + input);
                return new Promise((resolve, reject) => {
                    return resolve(this.twitterHelper.postImageOnTwitter(input, outPut, botId, projectId, iterationId));
                });
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    fetchRepliesTwitter(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info("Inside fetch replies twitter.." + input);
                return new Promise((resolve, reject) => {
                    return resolve(this.twitterHelper.fetchRepliesTwitter(input, outPut, botId, projectId, iterationId));
                });
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    replyOnTwit(input, outputParameters, fromBotId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                return new Promise((resolve, reject) => {
                    // input['tweetId'] = '1037607150418243584';
                    // input['CONSUMER_KEY'] = "2sKOGPLMF7qonw6wnBenmpY5j";
                    // input['CONSUMER_SECRET'] = "BntzkmhcJtkxRF1hIx61wkdcWVC4m7Q2mxbtt4yKio4Ov67vST";
                    // input['TOKEN_KEY'] = "304445343-12LYa2evrm35nuSWQfH8TjOytTSWWtc86XdMiUL5";
                    // input['TOKEN_SECRET'] = "woxCjPWd459m7pS44vQMMqarKgIgEmIGEFu29oMELh6UE";
                    // input['filePath'] = '/home/mahesh/Desktop/Genius.jpg';
                    // input['comment'] = 'replied22!';
                    // input['comment'] = [{ "commentId": 1063008587696398300, "comment": "reply100", "isNew": true, "from": { "name": "ajinkya rana" } }];
                    input['comment'] = (!util_1.isNullOrUndefined(input.comment) && input.comment.trim() !== '') ? JSON.parse(input.comment) : [];
                    this.twitterHelper.replyOnTwit(input, function (err, response) {
                        if (err) {
                            throw err;
                        }
                        else if (!util_1.isNullOrUndefined(response)) {
                            outputParameters['replyId'] = !util_1.isNullOrUndefined(response.id_str) ? response.id_str : "";
                            resolve({ message: 'Reply posted on Twitter', status: 0, data: outputParameters });
                        }
                        else {
                            resolve({ message: 'Something Went Wrong.Please try after sometime.', status: 1, data: [] });
                        }
                    });
                });
            }
            catch (e) {
                //return { info: 'Internal server error', status: 1, data: err };
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    postFacebook(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.fbHelper.postFbPost(input);
                outPut['postId'] = data.status === 0 ? data.data : '';
                if (data.status === 0) {
                    return { message: data.info, status: data.status, data: outPut };
                }
                else {
                    throw data.info;
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    passAccData(input, outPut, botId, projectId, iterationId) {
        try {
            this.log.info('Inside pass account data to remote job--' + JSON.stringify(input));
            outPut['userEmail'] = input.userList[iterationId].email;
            outPut['account_no'] = input.userList[iterationId].account_no;
            outPut['email_cc'] = input.userList[iterationId].email_cc;
            outPut['email_bcc'] = input.userList[iterationId].email_bcc;
            outPut['email_subject'] = input.userList[iterationId].email_subject;
            outPut['email_body'] = input.userList[iterationId].email_body;
            if (input.fromToDate !== '') {
                let x = input.fromToDate;
                let y = x.split(" ");
                if (!util_1.isNullOrUndefined(y[0])) {
                    let date = y[0];
                    let d = date.slice(0, 2);
                    let m = date.slice(2, 4);
                    let yr = date.slice(4, 8);
                    outPut['email_subject'] = outPut['email_subject'] + " " + d + "/" + m + "/" + yr;
                }
            }
            return { message: 'output write successfull', status: 0, data: outPut };
        }
        catch (e) {
            console.log('Error in fetching details from bank', e);
            //return { message: '', status: 1, data: e };
            return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
        }
    }
    getBankFiles(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info('Inside get bank files' + JSON.stringify(input));
                let obj = {};
                obj['transactions'] = fs.readFileSync(input.transactions, { encoding: 'utf8' });
                obj['accDetails'] = fs.readFileSync(input.accDetails, { encoding: 'utf8' }); // account details
                obj['personDetails'] = fs.readFileSync(input.personDetails, { encoding: 'utf8' }); // account holder details
                outPut['bankData'] = JSON.stringify(obj);
                // outPut['userEmail'] = input.userList[iterationId].email;
                // outPut['account_no'] = input.userList[iterationId].account_no;
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                console.log('Error in fetching details from bank', e);
                //  return { message: '', status: 1, data: e };
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    htmlEditor(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                outPut['htmlPage'] = input['htmlPage'];
                outPut['result'] = input['result'];
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                console.log('Error in fetching details from bank', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    toJsonConversion(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info('Inside to json conversion--' + JSON.stringify(input));
                input['bankData'] = JSON.parse(input.bankData);
                let files = [];
                files.push(input.bankData.transactions);
                files.push(input.bankData.accDetails);
                files.push(input.bankData.personDetails);
                if (!util_1.isNullOrUndefined(input.delimiter) && input.delimiter != '') {
                    let options = {
                        delimiter: input.delimiter,
                        quote: '"' // optional
                    };
                    let data = {};
                    for (let i = 0; i < files.length; i++) {
                        let rec = csvjson.toObject(files[i], options);
                        let filename = "file" + i;
                        data[filename] = rec;
                    }
                    data = JSON.stringify(data);
                    outPut['result'] = data;
                    return { message: '', status: 0, data: outPut };
                }
                else {
                    return { message: 'Delimiter not provided', status: 1, data: 'Delimiter not providedi' + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
                }
            }
            catch (e) {
                console.log('bot2 Error', e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
                // return { message: '', status: 1, data: e };
            }
        });
    }
    jsonMerge(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info('Inside json merge Bot-');
                input['result'] = JSON.parse(input.result);
                let totalCredit = 0, totalDebit = 0, debitCount = 0, creditCount = 0, openingBalance = 0;
                if (!util_1.isNullOrUndefined(input.result.file1[0])) {
                    input.result.file1[0].KEY_1 = input.result.file1[0].KEY_1.slice(4);
                    // input.result.file0 = input.result.file0.reverse();
                    if (input.result.file1[0].KEY_1 == input.account_no) {
                        for (let i = 0; i < input.result.file0.length; i++) {
                            let obj = input.result.file0[i];
                            if (obj.TRAN_AMOUNT < 0) {
                                let a = parseFloat(obj.TRAN_AMOUNT);
                                a -= a * 2;
                                // let str = numeral(a).format('0,0.00');
                                let str = this.fmt(a);
                                obj['debit'] = str;
                                //obj['debit'] = a.toFixed(2);
                                totalDebit = totalDebit + a;
                                debitCount++;
                            }
                            else if (obj.TRAN_AMOUNT > 0) {
                                let c = parseFloat(obj.TRAN_AMOUNT);
                                // let str = numeral(obj.TRAN_AMOUNT).format('0,0.00');
                                let str = this.fmt(obj.TRAN_AMOUNT);
                                obj['credit'] = str;
                                // obj['credit'] = c.toFixed(2);
                                totalCredit = totalCredit + c;
                                creditCount++;
                            }
                            if (!util_1.isNullOrUndefined(i) && i == 0) {
                                let no1 = Number(obj.BALANCE);
                                let no2 = Number(obj.TRAN_AMOUNT);
                                openingBalance = no1 - no2;
                            }
                            //  let b = parseFloat(obj.BALANCE);
                            // obj['BALANCE'] = b.toFixed(2);
                            // obj['BALANCE'] = numeral(obj.BALANCE).format('0,0.00');
                            obj['BALANCE'] = this.fmt(obj.BALANCE);
                            obj['TRAN_DATE'] = moment(obj['TRAN_DATE']).format('DD-MMM-YYYY');
                        }
                        // input.result.file1[0]['totalCredit'] = numeral(totalCredit).format('0,0.00');
                        input.result.file1[0]['totalCredit'] = this.fmt(totalCredit);
                        // input.result.file1[0]['totalDebit'] = numeral(totalDebit).format('0,0.00');
                        input.result.file1[0]['totalDebit'] = this.fmt(totalDebit);
                        input.result.file1[0]['debitCount'] = debitCount;
                        input.result.file1[0]['creditCount'] = creditCount;
                        if (!util_1.isNullOrUndefined(openingBalance)) {
                            // input.result.file1[0]['openingBalance'] = numeral(openingBalance).format('0,0.00');
                            input.result.file1[0]['openingBalance'] = this.fmt(openingBalance);
                        }
                        input.result.file1 = _.extend(input.result.file1[0], input.result.file2[0]);
                        outPut['result'] = JSON.stringify(input.result);
                        return { message: '', status: 0, data: outPut };
                    }
                    else {
                        console.log('Error in account number checking..', '');
                        //return { message: 'account Number not matched', status: 1, data: '' };
                        return { message: 'Error in account number checking..', status: 1, data: 'Error in account number checking, For account no -> ' + input.account_no };
                    }
                }
                else {
                    return { message: 'Error in account number checking..', status: 1, data: 'Data not found for account no -> ' + input.account_no };
                }
            }
            catch (e) {
                console.log('Error in fetching details from bank', e);
                // return { message: 'JSON Merged failed.', status: 1, data: e };
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    fmt(val) {
        return (Number(val)).toFixed(2).replace(/(\d)(?=(\d{2})+\d\.)/g, '$1,');
    }
    // public async remoteJobExecution(input, output, botId, projectId, iterationId) {
    //     try {
    //         let obj = {
    //             "command": input.cmdArgument,
    //             "excelData": input.ExcelData,
    //             "username": input.LoginId,
    //             "userpassword": input.Password,
    //             "projectId": projectId,
    //             "botId": botId,
    //             "iterationId": iterationId,
    //             "eventId": input.eventId,
    //             "from": 'remoteJobExecution',
    //             "accessControlList": input.accessControlList
    //         };
    //         this.socket.emit('trigger-event2', JSON.stringify(obj));
    //         return { message: 'Socket triggering to run commands.', status: 0, data: null };
    //     } catch (e) {
    //         this.log.error("Error in Socket triggering to read excel file utility." + e);
    //         return { message: e, status: 1, data: e };
    //     }
    // }
    htmlToPdfConvertor(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info('Inside html to pdf convertor--');
                // input['HTMLPage'] = fs.readFileSync('/home/administrator/staticpage.html', 'utf8');
                const html = input['HTMLPage'];
                const path = input['path'];
                const options = { format: 'Letter', footer: { height: 25 + 'px', contents: '<div style="text-align: right;"><span style="color: black; font-size: 9px;">Page {{page}}</span></div>' }, childProcessOptions: { env: { OPENSSL_CONF: '/dev/null' } } };
                const data = yield this.downloadUploadFileHelper.fileCovertor(html, options, path);
                let arr = [];
                arr.push(data["filename"]);
                outPut['attachments'] = arr;
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                console.log('Error while converting to PDF', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    reconcilationParser(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info('Inside Reconcilation parser--' + input);
                let obj = JSON.parse(input['data']);
                let htmlString;
                if (input.showSubject == 'true' && util_1.isNullOrUndefined(obj[0]['devNum'])) {
                    htmlString = "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <title>Bootstrap Example<\/title>\r\n  <meta charset=\"utf-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n  <style>\r\n  table { \r\n  width: 100%; \r\n  border-collapse: collapse; \r\n}\r\n\r\ntd { \r\n  padding: 6px; \r\n  border: 1px solid #ccc; \r\n  text-align: left; \r\n}\r\n\r\n  <\/style>\r\n <p><b>Dear,<\/b><\/p> \r\n <p> We regret to inform that there was a discrepancy in the Invoice which was shared against the PO " + obj[0].poNum + " we had raised. Please find the details in the mail below<\/p>\r\n<\/head>\r\n<body>\r\n\r\n<div>           \r\n  <table border=\"1\">\r\n    \r\n        <head>\r\n          \r\n        <tr>\r\n                <td> <\/td>\r\n                <td> <\/td>\r\n                <td colspan=\"3\">Po Details<\/td>\r\n                <td colspan=\"3\">Invoice No." + obj[0].invNum + "<\/td>\r\n";
                }
                else if (input.showSubject == 'true' && !util_1.isNullOrUndefined(obj[0]['devNum'])) {
                    htmlString = "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <title>Bootstrap Example<\/title>\r\n  <meta charset=\"utf-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n  <style>\r\n  table { \r\n  width: 100%; \r\n  border-collapse: collapse; \r\n}\r\n\r\ntd { \r\n  padding: 6px; \r\n  border: 1px solid #ccc; \r\n  text-align: left; \r\n}\r\n\r\n  <\/style>\r\n <p><b>Dear,<\/b><\/p> \r\n <p>  We regret to inform that there was a discrepancy in the Invoice\/Delivery Challan which was shared against the PO " + obj[0].poNum + " we had raised. Please find the details in the mail below<\/p>\r\n<\/head>\r\n<body>\r\n\r\n<div>           \r\n  <table border=\"1\">\r\n    \r\n        <head>\r\n          \r\n        <tr>\r\n                <td> <\/td>\r\n                <td> <\/td>\r\n                <td colspan=\"3\">Po Details<\/td>\r\n                <td colspan=\"3\">Invoice No." + obj[0].invNum + "<\/td>\r\n";
                }
                else {
                    htmlString = "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <title>Bootstrap Example<\/title>\r\n  <meta charset=\"utf-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n  <style>\r\n  table { \r\n  width: 100%; \r\n  border-collapse: collapse; \r\n}\r\n\r\ntd { \r\n  padding: 6px; \r\n  border: 1px solid #ccc; \r\n  text-align: left; \r\n}\r\n\r\n  <\/style>\r\n<\/head>\r\n<body>\r\n\r\n<div>           \r\n  <table border=\"1\">\r\n        \r\n        <head>\r\n        <tr>\r\n                <td> <\/td>\r\n                <td> <\/td>\r\n                <td colspan=\"3\">Po Details<\/td>\r\n                <td colspan=\"3\">Invoice No." + obj[0].invNum + "<\/td>\r\n";
                }
                if (!util_1.isNullOrUndefined(obj[0]['devNum'])) {
                    if (!util_1.isNullOrUndefined(obj[0]['receiptNumber'])) {
                        htmlString = htmlString + "<td colspan=\"3\">Receipt Details";
                    }
                    else {
                        htmlString = htmlString + "<td colspan=\"3\">DC No." + obj[0]['devNum'];
                    }
                }
                htmlString = htmlString + "<\/td>\r\n        <\/tr>\r\n    <\/head> \r\n    \r\n      \r\n      <tbody>    \r\n      <tr style=\"background:blue;color:white\">\r\n        <td>Po No<\/td>\r\n        <td>product name<\/td>\r\n        <td>Quantity<\/td>\r\n        <td>Rate<\/td>\r\n        <td>Amount<\/td>\r\n        <td>Quantity<\/td>\r\n        <td>Rate<\/td>\r\n        <td>Amount<\/td>\r\n";
                if (!util_1.isNullOrUndefined(obj[0]['devNum'])) {
                    if (!util_1.isNullOrUndefined(obj[0]['receiptNumber'])) {
                        htmlString = htmlString + " <td>Quantity<\/td>\r\n        <td>Rate<\/td>\r\n        <td>Amount<\/td>\r\n      <td>Receipt Number<\/td>\r\n      <\/tr>";
                    }
                    else {
                        htmlString = htmlString + " <td>Quantity<\/td>\r\n        <td>Rate<\/td>\r\n        <td>Amount<\/td>\r\n      <\/tr>";
                    }
                }
                for (let i = 0; i < obj.length; i++) {
                    htmlString = htmlString + "<tr> <td>" + obj[i].poNum + "</td><td>" + obj[i].productName + "</td>";
                    if (obj[i].poQtyFlag) {
                        htmlString = htmlString + "<td style=\"color:red\">\r\n" + obj[i].poQty + "</td>";
                    }
                    else {
                        htmlString = htmlString + "<td>\r\n" + obj[i].poQty + "</td>";
                    }
                    if (obj[i].poRateFlag) {
                        htmlString = htmlString + "<td style=\"color:red\">\r\n" + obj[i].poRate + "</td>";
                    }
                    else {
                        htmlString = htmlString + "<td>\r\n" + obj[i].poRate + "</td>";
                    }
                    if (obj[i].poItemAmtFlag) {
                        htmlString = htmlString + "<td style=\"color:red\">\r\n" + obj[i].poItemAmt + "</td>";
                    }
                    else {
                        htmlString = htmlString + "<td>\r\n" + obj[i].poItemAmt + "</td>";
                    }
                    if (obj[i].rqtyFlag) {
                        htmlString = htmlString + "<td style=\"color:red\">\r\n" + obj[i].rqty + "</td>";
                    }
                    else {
                        htmlString = htmlString + "<td>\r\n" + obj[i].rqty + "</td>";
                    }
                    if (obj[i].rrateFlag) {
                        htmlString = htmlString + "<td style=\"color:red\">\r\n" + obj[i].rrate + "</td>";
                    }
                    else {
                        htmlString = htmlString + "<td>\r\n" + obj[i].rrate + "</td>";
                    }
                    if (obj[i].ritemAmtFlag) {
                        htmlString = htmlString + "<td style=\"color:red\">\r\n" + obj[i].ritemAmt + "</td>";
                    }
                    else {
                        htmlString = htmlString + "<td>\r\n" + obj[i].ritemAmt + "</td>";
                    }
                    if (!util_1.isNullOrUndefined(obj[0]['devNum'])) {
                        if (obj[i].rqtyFlag) {
                            htmlString = htmlString + "<td style=\"color:red\">\r\n" + obj[i].qty + "</td>";
                        }
                        else {
                            htmlString = htmlString + "<td>\r\n" + obj[i].qty + "</td>";
                        }
                        if (obj[i].rrateFlag) {
                            htmlString = htmlString + "<td style=\"color:red\">\r\n" + obj[i].rate + "</td>";
                        }
                        else {
                            htmlString = htmlString + "<td>\r\n" + obj[i].rate + "</td>";
                        }
                        if (obj[i].ritemAmtFlag) {
                            htmlString = htmlString + "<td style=\"color:red\">\r\n" + obj[i].itemAmt + "</td>";
                        }
                        else {
                            htmlString = htmlString + "<td>\r\n" + obj[i].itemAmt + "</td>";
                        }
                        if (!util_1.isNullOrUndefined(obj[0]['receiptNumber'])) {
                            htmlString = htmlString + "<td>\r\n" + obj[i].receiptNumber + "</td>";
                        }
                    }
                }
                htmlString = htmlString + "<\/tbody>  \r\n  <\/table>\r\n<\/div>\r\n\r\n<\/body>\r\n<\/html>\r\n";
                outPut['htmlString'] = htmlString;
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                console.log('Error in Reconcilation report', e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    // async reconcilationParser(input, outPut, botId, projectId, iterationId) {
    //     try {
    //         this.log.info('Inside Reconcilation parser--' + input);
    //         let htmlString = "<!DOCTYPE html>\r\n<html lang=\"en-US\">\r\n\r\n<head>\r\n    <meta charset=\"utf-8\">\r\n    <style>\r\n        @page {\r\n            /* switch to landscape */\r\n            size: landscape;\r\n            /* set page margins */\r\n            margin: 0.5cm;\r\n\r\n            @top-center {\r\n                content: element(header);\r\n            }\r\n\r\n            @bottom-center {\r\n                content: element(footer);\r\n            }\r\n\r\n            @bottom-right {\r\n                content: counter(page) \" of \"counter(pages);\r\n            }\r\n        }\r\n\r\n        div.footer {\r\n            display: block;\r\n            text-align: center;\r\n            position: running(footer);\r\n            width: 100%;\r\n        }\r\n    </style>\r\n</head>\r\n\r\n<body style=\"font-family:'Open Sans', sans-serif\">\r\n    <header></header>\r\n    <div style=\"width: 100%;padding: 8px;\">\r\n\r\n        <div style=\"font-size: 10px\">\r\n\r\n            <div style=\"text-align: center;margin-top: 5px;margin-bottom: 5px; font-size: 22px; font-weight: 900;\">\r\n                <div><span>Reconcilation Report</span></div>\r\n            </div>\r\n\r\n            <div style=\"margin-top: 10px;width: 100%\">\r\n            </div>\r\n            <div>\r\n                <table style=\"width:95%; border: 1px solid black;border-collapse: collapse;\">\r\n                    <thead>\r\n\r\n                        <tr>\r\n                            <th style=\"border: 1px solid black;border-collapse: collapse;width: 7%\"></th>\r\n                            <th style=\"border: 1px solid black;border-collapse: collapse;width: 7%\">Product Name</th>\r\n                            <th style=\"border: 1px solid black;border-collapse: collapse;width: 7%\">Quantity</th>\r\n                            <th style=\"border: 1px solid black;border-collapse: collapse;width: 7%\">Rate</th>\r\n                            <th style=\"border: 1px solid black;border-collapse: collapse;width: 7%\">Amount</th>\r\n                        </tr>\r\n                    </thead>\r\n                    <tbody>";
    //          let obj = JSON.parse(input['data']);
    //         for (let i = 0; i < obj.length; i++) {
    //             htmlString = htmlString + "\r\n                        <tr>\r\n                            <th\r\n                                style=\"border: 1px solid black;word-break: break-word;border-collapse: collapse;text-align: center;padding-right: 5px;font-size:xx-small\">\r\n     Purchase Order<\/th>\r\n                         ";
    //             if (!isNullOrUndefined(obj[i]['poProductNameFlag']) && obj[i]['poProductNameFlag']) {
    //                 htmlString = htmlString + "<td style=\"border: 1px solid black;border-collapse: collapse;width: 7%; color: red;\">";
    //             } else {
    //                 htmlString = htmlString + "<td style=\"border: 1px solid black;border-collapse: collapse;width: 7%\">";
    //             }
    //             htmlString = htmlString + obj[i].poProductName;
    //             if (!isNullOrUndefined(obj[i]['poQtyFlag']) && obj[i]['poQtyFlag']) {
    //                 htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%; color: red;\">";
    //             } else {
    //                 htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%\">";
    //             }
    //             htmlString = htmlString + obj[i].poQty;
    //             if (!isNullOrUndefined(obj[i]['poRateFlag']) && obj[i]['poRateFlag']) {
    //                 htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%; color:red;\">";
    //             } else {
    //                 htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%\">";
    //             }
    //             htmlString = htmlString + obj[i].poRate;
    //             if (!isNullOrUndefined(obj[i]['poItemAmtFlag']) && obj[i]['poItemAmtFlag']) {
    //                 htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%; color: red;\">";
    //             } else {
    //                 htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%\">";
    //             }
    //             htmlString = htmlString + obj[i]['poItemAmt'] + "</td></tr>";
    //             if (!isNullOrUndefined(obj[i]['productName']) && obj[i]['productName'] != "") {
    //                 htmlString = htmlString + "<tr >\r\n                            <th\r\n                                style=\"border: 1px solid black;word-wrap: break-word;border-collapse: collapse;text-align: center;font-size:xx-small;word-break: break-word;\">\r\n            Invoice<\/th>\r\n";
    //             } else {
    //                 htmlString = htmlString + "<tr style=\"border-bottom: 2px solid black;\">\r\n                            <th\r\n                                style=\"border: 1px solid black;word-wrap: break-word;border-collapse: collapse;text-align: center;font-size:xx-small;word-break: break-word;\">\r\n                                Invoice<\/th>\r\n";
    //             }
    //             if (!isNullOrUndefined(obj[i]['rproductName']) && obj[i]['rproductNameFlag']) {
    //                 htmlString = htmlString + "<td style=\"border: 1px solid black;border-collapse: collapse;width: 7%;color:red;\">";
    //             } else {
    //                 htmlString = htmlString + "<td style=\"border: 1px solid black;border-collapse: collapse;width: 7%;\">";
    //             }
    //             htmlString = htmlString + obj[i].rproductName;
    //             if (!isNullOrUndefined(obj[i]['rqtyFlag']) && obj[i]['rqtyFlag']) {
    //                 htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%;color:red;\">";
    //             } else {
    //                 htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%;\">";
    //             }
    //             htmlString = htmlString + obj[i].rqty;
    //             if (!isNullOrUndefined(obj[i]['rrateFlag']) && obj[i]['rrateFlag']) {
    //                 htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%;color:red;\">";
    //             } else {
    //                 htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%;\">";
    //             }
    //             htmlString = htmlString + obj[i].rrate;
    //             if (!isNullOrUndefined(obj[i]['ritemAmtFlag']) && obj[i]['ritemAmtFlag']) {
    //                 htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%;color: red;\">";
    //             } else {
    //                 htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%;\">";
    //             }
    //             htmlString = htmlString + obj[i].ritemAmt + "</td></tr>";
    //             // 2-way completed
    //             if (!isNullOrUndefined(obj[i]['productName'])) {
    //                 htmlString = htmlString + "<tr style=\"border-bottom: 2px solid black;\">\r\n                            <th\r\n                                style=\"border: 1px solid black;word-wrap: break-word;border-collapse: collapse;text-align: center;font-size:xx-small;word-break: break-word;\">\r\n                                Delivery Chalan<\/th>\r\n";
    //                 if (!isNullOrUndefined(obj[i]['productNameFlag']) && obj[i]['productNameFlag']) {
    //                     htmlString = htmlString + "<td style=\"border: 1px solid black;border-collapse: collapse;width: 7%;color:red;\">";
    //                 } else {
    //                     htmlString = htmlString + "<td style=\"border: 1px solid black;border-collapse: collapse;width: 7%\">";
    //                 }
    //                 htmlString = htmlString + obj[i]['productName'];
    //                 if (!isNullOrUndefined(obj[i]['qtyFlag']) && obj[i]['qtyFlag']) {
    //                     htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%;color:red;\">";
    //                 } else {
    //                     htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%;\">";
    //                 }
    //                 htmlString = htmlString + obj[i]['qty'];
    //                 if (!isNullOrUndefined(obj[i]['rateFlag']) && obj[i]['rateFlag']) {
    //                     htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%;color:red;\">";
    //                 } else {
    //                     htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%;\">";
    //                 }
    //                 htmlString = htmlString + obj[i]['poRate'];
    //                 if (!isNullOrUndefined(obj[i]['itemAmtFlag']) && obj[i]['itemAmtFlag']) {
    //                     htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%; color: red;\">";
    //                 } else {
    //                     htmlString = htmlString + "<\/td>\r\n                            <td style=\"border: 1px solid black;border-collapse: collapse;width: 7%;\">";
    //                 }
    //                 htmlString = htmlString + obj[i]['poItemAmt'] + "</td></tr>";
    //             }
    //         }
    //         htmlString = htmlString + " <\/tbody>\r\n                <\/table>\r\n                <div style=\"width: 100%;text-align: left;margin-top: 60px\">  <\/div>\r\n\r\n            <\/div>\r\n        <\/div>\r\n    <\/div>\r\n    <footer><\/footer>\r\n<\/body>\r\n\r\n<\/html>";
    //         outPut['htmlString'] = htmlString;
    //         return { message: '', status: 0, data: outPut };
    //     } catch (e) {
    //         console.log('Error in Reconcilation report', e);
    //         return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
    //         // return { message: '', status: 1, data: e };
    //     }
    // }
    htmlParser(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // this.log.info('Inside html parser--' + JSON.stringify(input));
                // input = JSON.parse(JSON.stringify(this.constant));
                let htmlTable = input.htmlPage.replace(/[\n]/g, " ");
                let htmlPage = htmlTable;
                var htmlTable2 = htmlTable.match("<table style=\"width:100%; border: 1px solid black;border-collapse: collapse;table-layout:fixed;height:380px\">(.*)</table>");
                htmlTable = htmlTable.match("<tbody>(.*)</tbody>");
                input['result'] = JSON.parse(input['result']);
                let accTransactions = input.result.file0;
                let accDetails = input.result.file1;
                if (accTransactions.length < 8) {
                    let heightF = 31;
                    heightF = heightF * accTransactions.length;
                    let newHTML = input.htmlPage.replace("height:380px", "height:" + heightF + "px");
                    htmlTable = newHTML.replace(/[\n]/g, " ");
                    htmlPage = htmlTable;
                    htmlTable2 = htmlTable.match("<table style=\"width:100%; border: 1px solid black;border-collapse: collapse;table-layout:fixed; \">(.*)</table>");
                    htmlTable = htmlTable.match("<tbody>(.*)</tbody>");
                }
                let a = true;
                do {
                    let mySubString = htmlPage.substring(htmlPage.lastIndexOf("[") + 1, htmlPage.lastIndexOf("]"));
                    if (util_1.isNullOrUndefined(mySubString) || mySubString == '') {
                        a = false;
                    }
                    let mySubString2 = mySubString;
                    mySubString = '[' + mySubString + ']';
                    let x = accDetails[mySubString2];
                    if (!util_1.isNullOrUndefined(x)) {
                        if (mySubString2 == 'DESCRIPTION' && accTransactions.length == 0) {
                            htmlPage = htmlPage.replace(mySubString, "No Transaction for the Generated Date");
                        }
                        else if (mySubString2 == 'openingBalance' && accTransactions.length == 0) {
                            htmlPage = htmlPage.replace("<div style=\"width: 59%;text-align: center;margin-top: -15px;\"> <span style=\"font-size: 12px;font-weight: 300;\">Opening Balance as on [LST_CUST_CR_DT]: [openingBalance]</span> </div>", "");
                        }
                        else {
                            htmlPage = htmlPage.replace(mySubString, accDetails[mySubString2]);
                        }
                    }
                    else {
                        htmlPage = htmlPage.replace(mySubString, '');
                    }
                } while (a);
                // table formatting
                input.htmlPage = input.htmlPage.replace(/[\n]/g, " ");
                var tableArray = JSON.parse(JSON.stringify(accTransactions));
                if (!util_1.isNullOrUndefined(htmlTable)) {
                    let tempArray;
                    var rowsPerPage;
                    let flag = true;
                    let firstPageHeight = config.templateConfig.firstPage;
                    let rowHeight = config.templateConfig.rowHeight;
                    let allPageHeight = config.templateConfig.remainingPages;
                    let colWidth = config.templateConfig.columnWidth;
                    let fixedHeight = allPageHeight;
                    if (firstPageHeight > rowHeight) {
                        rowsPerPage = this.getRowsPerPage(firstPageHeight, rowHeight);
                    }
                    else {
                        rowsPerPage = this.getRowsPerPage(allPageHeight, rowHeight);
                    }
                    let mainCounter = accTransactions.length;
                    while (mainCounter > 0) {
                        if (flag) {
                            tempArray = JSON.parse(JSON.stringify(tableArray.slice(0, rowsPerPage)));
                            let getTableRows = this.replaceTableVariables(htmlTable[1], tempArray, firstPageHeight, allPageHeight, rowHeight, colWidth);
                            tableArray = JSON.parse(JSON.stringify(tableArray.slice(getTableRows.counterForRowsAdded)));
                            mainCounter = mainCounter - getTableRows.counterForRowsAdded;
                            let newPageData;
                            if (mainCounter === 0) {
                                newPageData = "<table style=\"width:100%; border: 1px solid black;border-collapse: collapse;table-layout:fixed\">" + "</table>";
                                let index = htmlTable.lastIndexOf('<table style="width:100%;margin-top: 10px">');
                                if (index > -1) {
                                    htmlTable = htmlTable.substring(0, index - 8) + newPageData + htmlTable.substring(index - 8);
                                }
                            }
                            let replacePart = htmlPage.match("<tbody>(.*)</tbody>");
                            htmlPage = htmlPage.replace(replacePart[1], getTableRows.rows);
                            firstPageHeight = getTableRows.firstPageHeight;
                        }
                        if (mainCounter !== 0) {
                            let height = 37;
                            let getNewPage = this.startNewPage(JSON.parse(JSON.stringify(htmlTable2)), tableArray, firstPageHeight, fixedHeight, rowHeight, colWidth);
                            flag = false;
                            tableArray = JSON.parse(JSON.stringify(getNewPage.json));
                            if (tableArray.length == 0) {
                                height = height * mainCounter;
                            }
                            mainCounter = tableArray.length;
                            let newPageData;
                            let newTable = getNewPage.html; // new table values
                            if (mainCounter == 0) {
                                newPageData = "<div style=\"page-break-before: always\">" + "</div><div style=\"margin-top:25px\"></div><table style=\"width:100%; border: 1px solid black;border-collapse: collapse;table-layout:fixed;height:" + height + "px\">" + newTable[1] + "</table>";
                            }
                            else {
                                newPageData = "<div style=\"page-break-before: always\">" + "</div><div style=\"margin-top:25px\"></div><table style=\"width:100%; border: 1px solid black;border-collapse: collapse;table-layout:fixed;height:720px\">" + newTable[1] + "</table>";
                            }
                            let index = htmlPage.lastIndexOf('<table style="width:100%;margin-top: 10px">');
                            if (index > -1) {
                                htmlPage = htmlPage.substring(0, index - 8) + newPageData + htmlPage.substring(index - 8); // insert new table in html page
                            }
                            newTable = [];
                            newPageData = '';
                        }
                    }
                }
                outPut['htmlCode'] = htmlPage;
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                console.log('Error in fetching details from bank', e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
                // return { message: '', status: 1, data: e };
            }
        });
    }
    parseHtml(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                //  input['htmlPage'] = fs.readFileSync('/home/mahesh/Desktop/bankapp.html', 'utf8');
                // let htmlTable = input.htmlPage.replace(/[\n]/g, " ");
                //input['result'] = JSON.parse(input['result']);
                /*  input['result'] = {
                      "adharNo": "9509 2788 1305",
                      "name": "SACHIN TULARAM KAPGATE",
                      "fatherName": "TULARAM SAKHARAM KAPGATE",
                      "birthDate": "23/08/1994",
                      "panNo": "EENPK9507P",
                      "city": "Gondiya",
                      "state": "Maharashtra",
                      "pin": "441701",
                      "gender": "Male",
                      "nationality": "Indian",
                      "address": "S/O: Tularam Kapgate, Ward No.5, Mahagaon, Mahagaon, Mohgaon R.s., Gondiya, Maharashtra, 441701",
                  };*/
                // let accTransactions = input.result.file0;
                //  let accDetails = input.result;
                let a = true;
                do {
                    let mySubString = input['htmlPage'].substring(input['htmlPage'].lastIndexOf("[") + 1, input['htmlPage'].lastIndexOf("]"));
                    if (util_1.isNullOrUndefined(mySubString) || mySubString == '') {
                        a = false;
                    }
                    let mySubString2 = mySubString;
                    mySubString = '[' + mySubString + ']';
                    input['htmlPage'] = input['htmlPage'].replace(mySubString, input.result[mySubString2]);
                } while (a);
                //     fs.writeFileSync('/home/mahesh/Desktop/htmlfile2.html', input['htmlPage']);
                outPut['htmlUrl'] = input['htmlPage'];
                // outPut['path'] = '';
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                console.log('Error in fetching details from bank', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    xmlToJson(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.downloadUploadFileHelper.xmlToJsonData(input);
                if (data.status === 0) {
                    outPut['JSON'] = data.data;
                    return { message: data.info, status: data.status, data: outPut };
                }
                else {
                    throw data.info;
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    convertToXMLObject(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let data;
                data = yield this.downloadUploadFileHelper.getXMLData(input);
                if (data.status === 0) {
                    outPut['XMLData'] = !util_1.isNullOrUndefined(data.data) ? data.data : "";
                    return { message: data.info, status: data.status, data: outPut };
                }
                else {
                    throw data.info;
                }
            }
            catch (e) {
                console.log('Error in fetching details from bank', e);
                return { message: e, status: 1, data: JSON.stringify(e) + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    jSONCUBData(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const data = JSON.parse(input['JSON']);
                let entryData = (!util_1.isNullOrUndefined(data.feed) && !util_1.isNullOrUndefined(data.feed.entry)) ? data.feed.entry : [];
                const result = yield this.downloadUploadFileHelper.convertoObject(entryData);
                if (result.status === 0) {
                    outPut['result'] = JSON.stringify(result.data);
                    return { message: result.info, status: result.status, data: outPut };
                }
                else {
                    throw result.info;
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    sharePostOnLinkedIn(input, outputParameters, fromBotId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                return new Promise((resolve, reject) => {
                    this.linkedInHelper.sharePostOnLinkedIn(input, function (err, response) {
                        if (err) {
                            throw err;
                        }
                        else if (!util_1.isNullOrUndefined(response)) {
                            outputParameters['postId'] = !util_1.isNullOrUndefined(response.updateKey) ? response.updateKey : "";
                            resolve({ message: 'Post Shared on LinkedIn', status: 0, data: outputParameters });
                        }
                        else {
                            throw 'Something Went Wrong.Please try after sometime.';
                        }
                    });
                });
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + fromBotId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    LinkedInTokenGeneration(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                return new Promise((resolve, reject) => {
                    this.linkedInHelper.LinkedInTokenGeneration(input, function (err, response) {
                        if (err) {
                            throw err;
                        }
                        else if (!util_1.isNullOrUndefined(response)) {
                            resolve({ message: 'Post Shared on LinkedIn', status: 0, data: outPut });
                        }
                        else {
                            resolve({ message: 'Something Went Wrong.Please try after sometime.', status: 1, data: [] });
                        }
                    });
                });
            }
            catch (err) {
                return { info: 'Internal server error', status: 1, data: err };
            }
        });
    }
    uiRecorder_headless(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            var self = this;
            try {
                var datanew = "false";
                let data = yield eventStatus_1.eventStatus.findOne({ 'projectId': projectId, 'botId': botId, $or: [{ eventId: input.eventId }, {}, { parentEventId: input.eventId }] });
                if (!util_1.isNullOrUndefined(data)) {
                    let a = JSON.parse(JSON.stringify(data));
                    let obj = {
                        "scriptFile": a.scriptFile,
                        "vars": input,
                        "projectId": projectId,
                        "botId": botId,
                        "eventId": input.eventId,
                        "iterationId": iterationId,
                        "from": 'get_excel',
                    };
                    // let scriptpath = ' ';
                    // if (!isNullOrUndefined(obj.vars.scriptpath)) {
                    let scriptpath = obj.vars.scriptpath;
                    // }
                    // else {
                    //     scriptpath = env.dbConfig.Recorder_path;
                    // }
                    var readTextScript = scriptpath + 'textread.json';
                    if (obj.vars.headless == "true") {
                        var path = require('path');
                        let rootPath = path.resolve();
                        let pathSampleConfig = scriptpath + 'sampleconfig.json';
                        let pathConfig = scriptpath + 'config.json';
                        console.log('pathConfig......', pathConfig);
                        readTextScript = scriptpath + 'textread.json';
                        fs.writeFileSync(rootPath + '/jsFile.js', obj.vars.scriptFile);
                        let configData = JSON.parse(fs.readFileSync(scriptpath + 'sampleconfig.json', "utf8"));
                        configData = JSON.parse(fs.readFileSync(pathSampleConfig, "utf8"));
                        fs.writeFileSync(scriptpath + 'config.json', JSON.stringify(configData) + "\n");
                        let sampleConfigdata = JSON.parse(fs.readFileSync(scriptpath + 'sampleconfig.json', "utf8"));
                        let s = obj.vars.excelArray;
                        var prsedata;
                        if (s !== 'false') {
                            console.log("----excelArray is true");
                            let ui;
                            if (obj.vars.excelArray === 'true') {
                                ui = {
                                    "new": "Obj"
                                };
                                ui['iterationId'] = obj.iterationId;
                                ui['Client_excelPath'] = JSON.parse(JSON.stringify(obj.vars.Client_excelPath[0]));
                                ui['Client_excelPath'] = obj.vars.Client_excelPath;
                                ui['Fromdate'] = obj.vars.Fromdate;
                                ui['DownloadedfileLoc'] = obj.vars.DownloadedfileLoc;
                                ui['outputDirectory'] = obj.vars.outputDirectory;
                                sampleConfigdata.vars = obj.vars;
                                sampleConfigdata.vars['Client_excelPath'] = obj.vars.Client_excelPath;
                                sampleConfigdata.vars['iterationId'] = obj.iterationId;
                            }
                            else {
                                ui = prsedata[obj.iterationId];
                                ui['Client_excelPath'] = obj.vars.Client_excelPath;
                                ui['iterationId'] = obj.iterationId;
                                ui['Fromdate'] = obj.vars.Fromdate;
                                ui['Todate'] = obj.vars.Todate;
                                ui['headless'] = obj.vars.headless;
                                ui['DownloadedfileLoc'] = obj.vars.DownloadedfileLoc;
                                ui['outputDirectory'] = obj.vars.outputDirectory;
                                sampleConfigdata.vars = ui;
                                sampleConfigdata.vars['Client_excelPath'] = obj.vars.Client_excelPath;
                                sampleConfigdata.vars['iterationId'] = obj.iterationId;
                            }
                            if (obj.vars.scriptName == "Axis_maker_status" || obj.vars.scriptName == "anubhav" || obj.vars.scriptName == "Axis_checker") {
                                obj.iterationId = 0;
                            }
                            prsedata = JSON.parse(obj.vars.excelArray);
                            ui['iterationId'] = obj.iterationId;
                            ui['Fromdate'] = obj.vars.Fromdate;
                            ui['Todate'] = obj.vars.Todate;
                            ui['headless'] = obj.vars.headless;
                            ui['scriptpath'] = obj.vars.scriptpath;
                            for (let [key, value] of Object.entries(ui)) {
                                if (typeof (value) === 'number') {
                                    value = value.toString();
                                    ui[key] = value;
                                }
                            }
                        }
                        else {
                            if (obj.vars.credentials !== 'false') {
                                let credentials = JSON.parse(obj.vars.credentials);
                                let login = credentials.login_id;
                                let password = credentials.password;
                                if (credentials.url.match(/axis|sbi/g)) {
                                    login = login.split('|;|');
                                    password = password.split('|;|');
                                    if (obj.vars.type.toLowerCase().includes('it')) {
                                        login = login[0];
                                        password = password[0];
                                    }
                                    else if (obj.vars.type.toLowerCase().includes('mobile')) {
                                        login = login[1];
                                        password = password[1];
                                    }
                                    else if (obj.vars.type.toLowerCase().includes('not required')) {
                                        console.error("from else throw erroroo!", obj.vars.type);
                                    }
                                }
                                else {
                                }
                                sampleConfigdata.vars = obj.vars;
                                sampleConfigdata.vars['iterationId'] = 0;
                                sampleConfigdata.vars['Invoice No'] = 'LOGIN';
                                sampleConfigdata.vars['headless'] = obj.vars.headless;
                                sampleConfigdata.vars['username'] = login;
                                sampleConfigdata.vars['password'] = password;
                                sampleConfigdata.vars['scriptpath'] = scriptpath;
                            }
                            else {
                                sampleConfigdata.vars = obj.vars;
                                sampleConfigdata.vars['headless'] = obj.vars.headless;
                            }
                        }
                        sampleConfigdata.vars['Fromdate'] = obj.vars.Fromdate;
                        sampleConfigdata.vars['Todate'] = obj.vars.Todate;
                        sampleConfigdata.vars['headless'] = obj.vars.headless;
                        sampleConfigdata.vars['scriptpath'] = obj.vars.scriptpath;
                        fs.writeFileSync(scriptpath + 'config.json', JSON.stringify(sampleConfigdata) + "\n");
                        var MI;
                        let scriptName = obj.vars.scriptName;
                        if (scriptName !== "") {
                            if (!util_1.isNullOrUndefined(scriptName.match(/.js/g))) {
                                MI = `sudo mocha ${scriptpath}` + scriptName;
                            }
                            else {
                                MI = 'sudo mocha ' + 'jsFile.js';
                            }
                        }
                        else {
                            MI = 'sudo mocha ' + 'jsFile.js';
                        }
                        const self = this;
                        let dataNext = yield self.executeUI(MI);
                        console.log("After Exec", dataNext);
                        if (!util_1.isNullOrUndefined(datanew)) {
                        }
                    }
                    else {
                        self.socket.emit('trigger-event2', JSON.stringify(obj));
                    }
                }
                let readvalue = JSON.parse(fs.readFileSync(readTextScript, "utf8"));
                for (var i = 0; i < readvalue.length; i++) {
                    outputParameters[readvalue[i].key] = readvalue[i].value;
                }
                this.log.info("recorder is working.");
                return { message: 'recorder working ', status: 0, data: outputParameters };
            }
            catch (e) {
                this.log.error("Error. Recorder not working." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    executeUI(MI) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("Call hora ya nahi--------------------");
                return new Promise((resolve, reject) => {
                    exec(MI, { maxBuffer: 1024 * 500 }, function (error, stdout, stderr) {
                        if (error) {
                            console.log('this err sec of recorder excution_part----------------------->>>>', error);
                            console.log('this stderr sec of recorder excution_part----------------------->>>>', stderr);
                            reject({ info: error, status: 1, data: '' });
                            console.log("Error in execution" + error);
                        }
                        else {
                            console.log('this sucsess sec of recorder excution_part');
                            resolve({ info: 'Data saved successfully', status: 0, data: 'donee' });
                            console.log("Bhej diyaaaa");
                        }
                    });
                });
            }
            catch (err) {
                console.log("Data not saved" + err);
                return { info: 'Internal Server Error', status: 1, data: [] };
            }
        });
    }
    uiRecorder(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let data = yield eventStatus_1.eventStatus.findOne({ 'projectId': projectId, 'botId': botId, $or: [{ eventId: input.eventId }, { parentEventId: input.eventId }] });
                if (!util_1.isNullOrUndefined(data)) {
                    let a = JSON.parse(JSON.stringify(data));
                    let obj = {
                        "scriptFile": a.scriptFile,
                        "vars": input,
                        "projectId": projectId,
                        "botId": botId,
                        "eventId": input.eventId,
                        "iterationId": iterationId,
                        "from": 'get_excel',
                        "userId": input.userId,
                        "accessControlList": input.accessControlList
                    };
                    this.socket.emit('trigger-event2', JSON.stringify(obj));
                }
                let outPut;
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                console.log('Error in fetching details from bank', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    fetchDataFromPlayStore(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let data;
                data = yield this.downloadUploadFileHelper.fetchData(input);
                if (data.status === 0) {
                    outPut['reviewData'] = JSON.stringify(data.data.reviews);
                    outPut['access_token'] = input['access_token'];
                    outPut['package_name'] = input['package_name'];
                    return { message: 'Reviews Found Successfully', status: 0, data: outPut };
                }
                else {
                    throw data.message;
                }
            }
            catch (e) {
                console.log('Reviews Not Found Successfully', e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    postDataToPlayStore(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let data;
                data = yield this.downloadUploadFileHelper.postReviewReply(input);
                outPut['reviewData'] = JSON.stringify(data.data);
                if (data.status === 0) {
                    return { message: data.info, status: data.status, data: outPut };
                }
                else {
                    throw data.info;
                }
            }
            catch (e) {
                console.log('Reviews Not Found Successfully', e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    getFbComment(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.fbHelper.getFbPost(input);
                outPut['result'] = data.status === 0 ? JSON.stringify(data.data) : '';
                if (data.status === 0) {
                    return { message: data.info, status: data.status, data: outPut };
                }
                else {
                    throw data.info;
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    postFbComments(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.fbHelper.postFbComment(input);
                outPut['commentId'] = data.status === 0 ? data.data : '';
                console.log('commentId: ' + data.data);
                if (data.status === 0) {
                    return { message: data.info, status: data.status, data: outPut };
                }
                else {
                    throw data.info;
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    generateRefreshTokenPlayStore(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let data;
                data = yield this.downloadUploadFileHelper.refreshToken(input);
                if (data.status === 0) {
                    const fetchData = JSON.parse(data.data);
                    outPut['access_token'] = (fetchData.access_token);
                    outPut['package_name'] = input['package_name'];
                    return { message: data.message, status: data.status, data: outPut };
                }
                else {
                    throw data.message;
                }
            }
            catch (e) {
                console.log('Token Not Found Successfully', e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    toOracleUpload(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("toOracleUpload bot====>>>>>", input);
                if (!util_1.isNullOrUndefined(input.invoice_filePath) && input.invoice_filePath != '' && !util_1.isNullOrUndefined(input.inserted_data) && input.inserted_data.length == 1) {
                    let filePath;
                    let multipleObj = [];
                    let nonInvoice_filePath;
                    let invoice_filePath = input.invoice_filePath;
                    if (typeof invoice_filePath == 'string') {
                        invoice_filePath = JSON.parse(invoice_filePath);
                    }
                    console.log("INVOICE_FILEPATH=====>>>>>", invoice_filePath);
                    if (!util_1.isNullOrUndefined(input.invoice_filePath) && !util_1.isNullOrUndefined(input.nonInvoice_filePath) && input.nonInvoice_filePath !== '') {
                        nonInvoice_filePath = input.nonInvoice_filePath;
                        console.log("Before JSON.parse NonInvoiceArray=====>>>", nonInvoice_filePath);
                        if (typeof nonInvoice_filePath == 'string') {
                            nonInvoice_filePath = JSON.parse(input.nonInvoice_filePath);
                            console.log("After JSON.parse NonInvoiceArray=====>>>", nonInvoice_filePath);
                        }
                        filePath = invoice_filePath.concat(nonInvoice_filePath);
                        console.log("After Concat FILEPATH", filePath);
                    }
                    else {
                        filePath = invoice_filePath;
                    }
                    if (filePath.length > 1) {
                        console.log("IN IF condition where filePath.length > 1", filePath.length > 1);
                        for (let i = 0; i < filePath.length; i++) {
                            console.log("for Loop filepath=====>>>>", filePath[i]);
                            const filename = path.basename(filePath[i]);
                            const file_extension = path.extname(filePath[i]);
                            let document = fs.readFileSync(filePath[i]);
                            let toBase64string = bToa(document);
                            let today = new Date();
                            let date = today.getDate() + '-' + today.toLocaleString('en-us', { month: 'short' }) + '-' + today.getFullYear();
                            let invoice_num;
                            let docType_value;
                            if (typeof input.inserted_data[0].INVOICE_NUM !== 'string') {
                                invoice_num = JSON.stringify(input.inserted_data[0].INVOICE_NUM);
                            }
                            else {
                                invoice_num = input.inserted_data[0].INVOICE_NUM;
                            }
                            console.log("invoice_num", invoice_num);
                            console.log("nonInvoice_filePath", nonInvoice_filePath);
                            if (nonInvoice_filePath.includes(filePath[i])) {
                                docType_value = 'OTHERS';
                            }
                            else {
                                docType_value = 'INVOICE';
                            }
                            console.log("docType_value=====>>>>", docType_value);
                            let obj = {
                                fileId_value: yield this.oracleLookUp('select gibots_ap_invoices_doc_s.NEXTVAL from dual', null, null, 'NextDate', null, null, null, null, null),
                                fileName_value: filename,
                                invoiceNumber_value: invoice_num,
                                documentType_value: docType_value,
                                fileData_value: toBase64string,
                                uploadDate_value: date,
                                vendorId_value: input.inserted_data[0].VENDOR_ID,
                                invoiceId_value: input.inserted_data[0].INVOICE_ID,
                                fileFormat_value: file_extension
                            };
                            multipleObj.push(obj);
                            outPut['bindObj'] = multipleObj;
                            console.log("toOracleUpload=====>>>bindObj", outPut);
                        }
                    }
                    else {
                        console.log("in ELSE Condition for invoice filePath only");
                        const filename = path.basename(filePath[0]);
                        const file_extension = path.extname(filePath[0]);
                        let document = fs.readFileSync(filePath[0]);
                        let toBase64string = bToa(document);
                        let today = new Date();
                        let date = today.getDate() + '-' + today.toLocaleString('en-us', { month: 'short' }) + '-' + today.getFullYear();
                        let obj = {
                            fileId_value: yield this.oracleLookUp('select gibots_ap_invoices_doc_s.NEXTVAL from dual', null, null, 'NextDate', null, null, null, null, null),
                            fileName_value: filename,
                            invoiceNumber_value: input.inserted_data[0].INVOICE_NUM,
                            documentType_value: 'INVOICE',
                            fileData_value: toBase64string,
                            uploadDate_value: date,
                            vendorId_value: input.inserted_data[0].VENDOR_ID,
                            invoiceId_value: input.inserted_data[0].INVOICE_ID,
                            fileFormat_value: file_extension
                        };
                        outPut['bindObj'] = obj;
                    }
                    console.log("this is final  putput bindObj", outPut);
                    return { message: '', status: 0, data: outPut };
                }
                else {
                    let obj;
                    if (Array.isArray(input.invoice_filePath) && input.invoice_filePath.length) {
                        obj = { message: 'Invoice FilePath is Null or Undefined', status: 1 };
                    }
                    if (util_1.isNullOrUndefined(input.inserted_data)) {
                        obj = { message: 'No rows Fetched', status: 1 };
                    }
                    else if (input.inserted_data.length > 1) {
                        obj = { message: 'Multiple records fetched for single INVOICE_NUM', status: 1 };
                    }
                    return obj;
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    oracleDBConnector(input, outputParameters, fromBotId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("oracleDBConnector======>>>>>>>>>>>>>", input);
                var result;
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    let self = this;
                    if (!util_1.isNullOrUndefined(input["password"]) && input["password"] !== "") {
                        input["password"] = Buffer.from(input["password"], 'base64').toString();
                    }
                    console.log("decryption========>>>>>>>><<<<<<<<<<<<<", input);
                    result = yield self.oracleHelper.oracleDBConnector(input);
                    if (input.parameter == 'sql1' || input.parameter == 'sql2' || input.parameter == 'sql3' || input.parameter == 'singleKeyValue' || input.parameter == 'between') {
                        if (!util_1.isNullOrUndefined(result.data) && !util_1.isNullOrUndefined(result.data.rows) && result.data.rows.length) {
                            function getValues() {
                                let metaData = result.data.metaData;
                                let rows = result.data.rows;
                                let converted = rows.reduce((result, row) => {
                                    let convertedObj = {};
                                    row.forEach((element, index) => {
                                        convertedObj[metaData[index]["name"]] = element;
                                    });
                                    result.push(convertedObj);
                                    return result;
                                }, []);
                                return {
                                    metaData, rows, converted
                                };
                            }
                            outputParameters['result'] = getValues();
                            let convertedResult = outputParameters['result'].converted;
                            outputParameters['converted'] = convertedResult;
                            let displaySinglevalue = input.displayName;
                            outputParameters['displaySingleValue'] = convertedResult[0][displaySinglevalue];
                            outputParameters['convertedLength'] = convertedResult.length;
                            //console.log("Output of outputParameters['result']", outputParameters['result']);
                            //console.log("Output of outputParameters['result']", outputParameters['result']);
                        }
                        else {
                            this.log.error("No rows fetched");
                            var message = null;
                            outputParameters['result'] = message;
                        }
                    }
                    else if (input.parameter == 'other' || input.parameter == 'upload' || input.parameter == 'procedure') {
                        if (result.data) {
                            function getValues() {
                                let completeResult = result.data;
                                return {
                                    completeResult
                                };
                            }
                            outputParameters['result'] = getValues();
                            //console.log("Output of outputParameters['result']", outputParameters['result']);
                        }
                    }
                    resolve({ message: result.info, status: result.status, data: outputParameters });
                }));
            }
            catch (e) {
                this.log.error("Error in executing query in bot common function=" + e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' fromBotId - ' + fromBotId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    appendKeyValueInObject(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let mainOutput = [];
                let mainInput;
                if (!util_1.isNullOrUndefined(input.incomingArray) && input.incomingArray.length > 0) {
                    if (typeof input.incomingArray == 'string') {
                        mainInput = JSON.parse(input.incomingArray);
                    }
                    else {
                        mainInput = input.incomingArray;
                    }
                    mainInput.forEach((obj) => {
                        if (!util_1.isNullOrUndefined(input.addValue) && input.addValue !== '') {
                            obj[input.addKey] = input.addValue;
                        }
                        else {
                            obj[input.addKey] = '';
                        }
                        mainOutput.push(obj);
                    });
                    outPut['outgoingArray'] = mainOutput;
                }
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                return { message: '', status: 1, data: {} };
            }
        });
    }
    checkDataType(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                if ((!util_1.isNullOrUndefined(input.CompleteQuery) || input.CompleteQuery !== '') && (!util_1.isNullOrUndefined(input.mongoFields) || input.mongoFields !== '') && (!util_1.isNullOrUndefined(input.predefinedDatatype) || input.predefinedDatatype !== '')) {
                    console.log(input);
                    let tawazunDocType;
                    if (!util_1.isNullOrUndefined(input.tawazunDocType)) {
                        if (typeof input.tawazunDocType === 'string') {
                            tawazunDocType = JSON.parse(input.tawazunDocType);
                        }
                        else {
                            tawazunDocType = input.tawazunDocType;
                        }
                    }
                    let query = input.CompleteQuery;
                    function getPosition(string, subString, index) {
                        return string.split(subString, index).join(subString).length;
                    }
                    query = query.substring(query.lastIndexOf(')'), getPosition(query, '(', 2) + 1);
                    // console.log("raw Query", query)
                    // let splitQuery = query.split(',')
                    const regex = /','/ig;
                    query = query.replace(regex, "'~'");
                    console.log("raw Query", query);
                    let splitQuery = query.split('~');
                    console.log("QUERY VALUES==>>", splitQuery, splitQuery.length);
                    let column = input.mongoFields;
                    column = column.split(',');
                    let mongoArray = [];
                    column.forEach(el => {
                        let ele = el.replace(/'/g, "").trim();
                        mongoArray.push(ele);
                    });
                    console.log("MONGO ARRAY===>>>", mongoArray, mongoArray.length);
                    let splitDataType = input.predefinedDatatype;
                    splitDataType = splitDataType.split(',');
                    let dataType = [];
                    splitDataType.forEach(el => {
                        let ele = el.replace(/'/g, "").trim();
                        dataType.push(ele);
                    });
                    console.log("DATATYPE===>>>", dataType, dataType.length);
                    let errorArray = [];
                    let respDatatype = splitQuery.map((el, i) => {
                        let ele = el.replace(/'/g, "");
                        if (ele == '') {
                            return dataType[i];
                        }
                        else if (isNaN(Number(ele)) && !moment(ele, ['DD-MMM-YYYY', 'D-MMM-YYYY'], true).isValid()) {
                            if (dataType[i] !== 'string') {
                                let obj = {};
                                obj[mongoArray[i]] = `INVALID ${mongoArray[i]}`;
                                errorArray.push(obj);
                            }
                            return 'string';
                        }
                        else if (!isNaN(Number(ele)) && !moment(ele, ['DD-MMM-YYYY', 'D-MMM-YYYY'], true).isValid()) {
                            let type;
                            if (dataType[i] == 'string') {
                                type = 'string';
                            }
                            else {
                                type = 'number';
                            }
                            let obj = {};
                            if (dataType[i] !== type) {
                                obj[mongoArray[i]] = `INVALID ${mongoArray[i]}`;
                                errorArray.push(obj);
                            }
                            return type;
                        }
                        else if (moment(ele, ['DD-MMM-YYYY', 'D-MMM-YYYY'], true).isValid()) {
                            if (dataType[i] !== 'date') {
                                let obj = {};
                                obj[mongoArray[i]] = `INVALID ${mongoArray[i]}`;
                                errorArray.push(obj);
                            }
                            return 'date';
                        }
                    });
                    console.log("finalResp", respDatatype);
                    console.log("errorArray", errorArray);
                    let finalErrorArray = [];
                    errorArray.reduce((final, cur) => {
                        if (!final.includes(Object.keys(cur)[0])) {
                            final.push(Object.keys(cur)[0]);
                            finalErrorArray.push(cur);
                        }
                        return final;
                    }, []);
                    console.log("FINAL ERROR OBJECT WITH NO DUPLICATES", finalErrorArray);
                    // outPut['queryToOr'] = input.CompleteQuery
                    if (input.CompleteQuery.includes('TO_DATE')) {
                        let qr = input.CompleteQuery.substring(0, input.CompleteQuery.indexOf('TO_DATE') - 1);
                        let toDatePart = input.CompleteQuery.substring(input.CompleteQuery.lastIndexOf(')') - 1, input.CompleteQuery.indexOf('TO_DATE'));
                        outPut['queryToOr'] = `${qr}${toDatePart})`;
                        console.log("Query after removing qutoes from todate==============<<<<<<<", `${qr}${toDatePart})`);
                    }
                    else {
                        outPut['queryToOr'] = input.CompleteQuery;
                    }
                    if (dataType.length == respDatatype.length) {
                        if (JSON.stringify(dataType) == JSON.stringify(respDatatype)) {
                            outPut['proceed'] = true;
                            console.log("PROCEED TO NEXT BOT", outPut['proceed']);
                        }
                        else {
                            outPut['proceed'] = false;
                            console.log("PROCEED TO DISPLAY DOCUMENT1", outPut['proceed']);
                            console.log();
                            if (finalErrorArray.length > 0) {
                                let er;
                                let tawazunObjKeys = Object.keys(tawazunDocType);
                                tawazunObjKeys.forEach(el => {
                                    if (el.includes('Error')) {
                                        er = tawazunDocType.Error.concat(finalErrorArray);
                                        tawazunDocType.Error = er;
                                    }
                                    else if (el.includes('error')) {
                                        er = tawazunDocType.error.concat(finalErrorArray);
                                        tawazunDocType.error = er;
                                    }
                                });
                                outPut['document'] = tawazunDocType;
                            }
                        }
                    }
                    else {
                        outPut['proceed'] = false;
                        console.log("PROCEED TO DISPLAY DOCUMENT2", outPut['proceed']);
                    }
                }
                else {
                    outPut['proceed'] = false;
                    console.log("PROCEED TO DISPLAY DOCUMENT3", outPut['proceed']);
                }
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                return { message: '', status: 1, data: {} };
            }
        });
    }
    // public async oracleDBConnector(input: any, outputParameters, fromBotId, projectId, iterationId) {
    // try {
    //     const result = await this.oracleHelper.oracleDBConnector(input);
    //     if (!isNullOrUndefined(result) && !isNullOrUndefined(result.status) && result.status === 0) {
    //         outputParameters['result'] = result;
    //         return { message: result.info, status: result.status, data: outputParameters };
    //     } else {
    //         throw result.info;
    //     }
    // } catch (e) {
    //     this.log.error("Error in executing query in bot common function=" + e);
    //     return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' fromBotId - ' + fromBotId + ' iterationId - ' + iterationId + ']' };
    // }
    // }
    delayBotFunction(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log('Inside delay function');
                let sec = (!util_1.isNullOrUndefined(input.second) && input.second !== '') ? Number(input.second) : 1;
                let waitcountproc = input.processcount;
                if (!util_1.isNullOrUndefined(waitcountproc) && waitcountproc !== '') {
                    if (iterationId > 0 && iterationId % Number(waitcountproc) == 0) {
                        let wait = yield delay(1000 * sec);
                        console.log(wait);
                    }
                }
                else {
                    let wait = yield delay(1000 * sec);
                    console.log(wait);
                }
                outPut['iterationId'] = iterationId;
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                return { message: '', status: 1, data: {} };
            }
        });
    }
    fetchCommentsOnLinkedIn(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                return new Promise((resolve, reject) => {
                    this.linkedInHelper.fetchCommentFromLinkedIn(input, function (err, response) {
                        if (err) {
                            throw err;
                        }
                        else {
                            outPut['result'] = JSON.stringify(response);
                            resolve({ message: '', status: 0, data: outPut });
                        }
                    });
                });
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    addCommentOnLinkedIn(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.linkedInHelper.addCommentOnLinkedIn(input);
                outPut['result'] = data.status === 0 ? JSON.stringify(data.data) : '';
                if (data.status === 0) {
                    return { message: data.info, status: data.status, data: outPut };
                }
                else {
                    throw data.info;
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    commentsMapping(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.fbHelper.createFormatOfComments(input);
                outPut['result'] = data.status === 0 ? data.data : '';
                console.log('commentId: ' + data.data);
                if (data.status === 0) {
                    return { message: data.info, status: data.status, data: outPut };
                }
                else {
                    throw data.info;
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    auditCaProcess(input, outPut, botId, projetId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.auditCaHelper.auditCaProcess(input, botId, projetId);
                if (data.status == 0) {
                    let JsonData = JSON.parse(JSON.stringify(data));
                    outPut['invId'] = !util_1.isNullOrUndefined(JsonData.data.invId) ? JsonData.data.invId : null;
                    outPut['custEid'] = !util_1.isNullOrUndefined(JsonData.data.custEid) ? JsonData.data.custEid : null;
                    let fileData = [];
                    fileData.push(!util_1.isNullOrUndefined(JsonData.data.filePath) ? JsonData.data.filePath : "");
                    outPut['filePath'] = fileData;
                    return { message: data.info, status: data.status, data: outPut };
                }
                else {
                    return { message: data.info, status: data.status, data: outPut };
                }
            }
            catch (e) {
                return { message: 'Mapping failed', status: 1, data: [] };
            }
        });
    }
    findLatestCommnets(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                input['projectId'] = projectId;
                input['botId'] = botId;
                input['iterationId'] = Number(iterationId);
                const data = yield this.fbHelper.findLatestCom(input);
                outPut['result'] = JSON.stringify(data.data.results);
                outPut['count'] = data.data.latest.length;
                outPut['latestComment'] = JSON.stringify(data.data.latest);
                console.log('commentId: ' + data.data);
                if (data.status === 0) {
                    return { message: data.info, status: data.status, data: outPut };
                }
                else {
                    throw data.info;
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    findLatestCommnetsPlayStoreAppstore(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                input['projectId'] = projectId;
                input['botId'] = botId;
                input['iterationId'] = Number(iterationId);
                const data = yield this.fbHelper.findLatestComPlayStoreAppstore(input);
                outPut['result'] = JSON.stringify(data.data.results);
                outPut['count'] = data.data.latest.length;
                outPut['latestComment'] = JSON.stringify(data.data.latest);
                console.log('commentId: ' + data.data);
                if (data.status === 0) {
                    return { message: data.info, status: data.status, data: outPut };
                }
                else {
                    throw data.info;
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    findCommentsData(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.fbHelper.findComments(input);
                outPut['comment'] = data.status === 0 ? JSON.stringify(data.data) : '';
                outPut['index'] = data.status === 0 ? Number(data.index) : 0;
                if (data.status === 0) {
                    return { message: data.info, status: data.status, data: outPut };
                }
                else {
                    throw data.info;
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    reportMetaData(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info('Inside add table metadata-- ' + JSON.stringify(input));
                if (!util_1.isNullOrUndefined(input.json)) {
                    const data = yield this.metaDataService.saveMetaData(JSON.parse(input.json));
                    if (!util_1.isNullOrUndefined(data) && data.status === 0) {
                        outPut['result'] = data;
                        return { message: data.info, status: data.status, data: outPut };
                    }
                    else {
                        throw data.info;
                    }
                }
                else {
                    throw 'Input parameters should not be empty';
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    ExcelToJSON(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info('Inside upload custom table data--' + JSON.stringify(input));
                if (!util_1.isNullOrUndefined(input.filePath) && input.filePath !== '') {
                    input.filePath = input.filePath[0];
                    const data = yield this.metaDataService.saveCustomData(input);
                    //console.log('data---------->', data);
                    outPut['jsonData'] = data.data;
                    return { message: data.info, status: data.status, data: outPut };
                }
                else {
                    return { message: 'Failed..All inputs not provided', status: 1, data: '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
                }
            }
            catch (e) {
                //  return { message: 'Failed for upload data', status: 1, data: [] };
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    uploadCustomData(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info('Inside upload custom table data--' + JSON.stringify(input));
                if (!util_1.isNullOrUndefined(input.filePath) && input.filePath !== '' && !util_1.isNullOrUndefined(input.tableName) && input.tableName !== '' && !util_1.isNullOrUndefined(input.delimiter) && input.delimiter != '' && !util_1.isNullOrUndefined(input.docType) && input.docType != '') {
                    const data = yield this.metaDataService.saveCustomTableData(input);
                    outPut['uploadCount'] = data.status === 0 ? data.data : 0;
                    return { message: data.info, status: data.status, data: outPut };
                }
                else {
                    return { message: 'Failed..All inputs not provided', status: 1, data: '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
                }
            }
            catch (e) {
                //  return { message: 'Failed for upload data', status: 1, data: [] };
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    groupByExcelData(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info('Inside group by excel bot--' + JSON.stringify(input));
                if (!util_1.isNullOrUndefined(input.jsonArray) && input.jsonArray !== '' && !util_1.isNullOrUndefined(input.tableName) && input.tableName !== '') {
                    const data = yield this.metaDataService.getGroupByExcelData(input);
                    console.log("groupby data", data);
                    console.log(data["data"]["length"]);
                    outPut['invoiceCount'] = data.status === 0 ? data["data"]["length"] : null;
                    outPut['groupByJSON'] = data.status === 0 ? data.data : null;
                    return { message: data.info, status: data.status, data: outPut };
                }
                else {
                    return { message: 'Failed to groupby excel data', status: 1, data: '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
                }
            }
            catch (e) {
                //  return { message: 'Failed for upload data', status: 1, data: [] };
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    autoUploadCustomData(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!util_1.isNullOrUndefined(input.directory) && input.directory !== '' && !util_1.isNullOrUndefined(input.delimiter)) {
                    const data = yield this.metaDataService.readDirectory(input.directory, input.delimiter);
                    outPut['status'] = data.status;
                    if (data.status == 0) {
                        return { message: data.info, status: data.status, data: outPut };
                    }
                    else {
                        return { message: data.info, status: 1, data: data.data };
                    }
                }
                else {
                    return { message: 'Input not found', status: 0, data: [] };
                }
            }
            catch (e) {
                return { message: 'Failed for upload data', status: 1, data: [] };
            }
        });
    }
    copyTableData(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!util_1.isNullOrUndefined(input.sourceTable) && input.sourceTable !== '' && !util_1.isNullOrUndefined(input.destinationTable) && input.destinationTable !== '') {
                    const data = yield this.metaDataService.copyTableData(input);
                    if (data.status == 0) {
                        outPut['status'] = "success";
                        return { message: "copy data", status: data.status, data: outPut };
                    }
                    else {
                        return { message: 'Input not found', status: 1, data: "copy failed" };
                    }
                }
                else {
                    return { message: 'Input not found', status: 1, data: "Input not found" };
                }
            }
            catch (e) {
                return { message: 'Failed for copying data', status: 1, data: [] };
            }
        });
    }
    getAccountStExcel(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.reconcile.readFile(input);
                outPut['bank'] = JSON.stringify(data['data']);
                return { message: data['info'], status: data['status'], data: outPut };
            }
            catch (e) {
                return { message: 'Failed for upload data', status: 1, data: [] };
            }
        });
    }
    findAccountData(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.invoiceService.getAccountingData();
                outPut['account'] = JSON.stringify(data['data']);
                return { message: data['info'], status: data['status'], data: outPut };
            }
            catch (e) {
                return { message: 'Failed for upload data', status: 1, data: [] };
            }
        });
    }
    getAccountReconciliData(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let query = { isDelete: false, subscriberId: input.subscriberId, userId: input.userId };
                const mapData = yield this.reconciliationMapperService.getReconciliationMapping(query);
                let parsedMapData = JSON.parse(JSON.stringify(mapData.data[0]));
                input['mapping'] = parsedMapData.mapping;
                const data = yield this.reconcile.getAccountReconciliData(input);
                outPut['result'] = JSON.stringify(data['data']);
                return { message: data['info'], status: data['status'], data: outPut };
            }
            catch (e) {
                return { message: 'Failed for upload data', status: 1, data: [] };
            }
        });
    }
    extendFBAccessToken(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.fbHelper.extendFbAccessToken(input);
                outPut['accessToken'] = data['data'].access_token;
                outPut['expires'] = data['data'].expires_in;
                if (data['status'] === 0) {
                    return { message: data['info'], status: data['status'], data: outPut };
                }
                else {
                    throw data['info'];
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    readBankStatmentFile(input, outputParameters, botId, iterationId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "vars": input,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'readBankStatement',
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                let outPut;
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                console.log('Error in fetching details from bank', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    getUsersForStatement(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info('Inside get users for bank statement--' + JSON.stringify(input));
            const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
            const db = mClient.db(env_2.env.dbConfig.dbname);
            try {
                const tableData = yield db.collection(input.tableName).find({
                    "$or": [
                        { "isDeleted": false },
                        { "isDeleted": { "$exists": false } }
                    ]
                }).toArray();
                if (!util_1.isNullOrUndefined(tableData.length)) {
                    outPut['count'] = tableData.length;
                    outPut['userList'] = tableData;
                }
                else {
                    outPut['count'] = 0;
                }
                return { info: 'Data found Successfully', status: 0, data: outPut };
            }
            catch (e) {
                console.log('Error in fetching details', e);
                //  return { message: '', status: 1, data: e };
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    viewReconcilationMapping(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.reconcilationService.getMappingById(input.mappingId);
                if (!util_1.isNullOrUndefined(data.status) && data.status === 0) {
                    outPut['mappingData'] = data.data;
                    return { info: 'Data found Successfully', status: 0, data: outPut };
                }
                else {
                    outPut['mappingData'] = {};
                    return { info: 'Data found Successfully', status: 1, data: outPut };
                }
            }
            catch (e) {
                console.log('Error in fetching details', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    dataReconcilation(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.reconcilationService.reconcileData(input);
                if (!util_1.isNullOrUndefined(data.status) && data.status === 0) {
                    outPut['result'] = true;
                    return { info: 'Data Reconciled Successfully', status: 0, data: outPut };
                }
                else {
                    outPut['result'] = false;
                    return { info: ' Problem in reconciling data.', status: 1, data: outPut };
                }
            }
            catch (e) {
                console.log('Error in fetching details', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    fetchReconcilationData(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.reconcilationService.getReconcileData(input.mappingId);
                if (!util_1.isNullOrUndefined(data.status) && data.status === 0) {
                    outPut['result'] = data.data;
                    return { info: 'Data found Successfully', status: 0, data: outPut };
                }
                else {
                    outPut['result'] = {};
                    return { info: ' Problem in fetch reconciling data.', status: 1, data: outPut };
                }
            }
            catch (e) {
                console.log('Error in fetching details', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    updateDBbot(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                var obj = {};
                for (let i = 0; i < 10; i++) {
                    let k = i;
                    if (i == 0) {
                        k = '';
                    }
                    ;
                    if (!util_1.isNullOrUndefined(input['findKey' + k]) && !util_1.isNullOrUndefined(input['findValue' + k]) && input['findKey' + k].trim() != '') {
                        obj[input['findKey' + k]] = input['findValue' + k];
                    }
                }
                // const mClient = await MongoClient.connect(env.dbConfig.mongodb_uri);
                // const db = mClient.db(config.dbConfig.dbname);
                let tableData = [];
                if (!(util_1.isNullOrUndefined(obj))) {
                    // tableData = await db.collection(input.tableName).find(obj).toArray();
                    tableData = yield (db.createDynamicModel(input.tableName)).find(obj);
                }
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    if ((input.updateKey != "") && (input.updateValue != "") && (!util_1.isNullOrUndefined(input.updateKey)) && (!util_1.isNullOrUndefined(input.updateValue))) {
                        let bulkOperations = [];
                        const model = db.createDynamicModel(input.tableName);
                        tableData.forEach((element) => {
                            let obj = {};
                            for (let i = 0; i < 10; i++) {
                                let k = i === 0 ? '' : i; // Adjust key accordingly
                                if (!util_1.isNullOrUndefined(input['updateKey' + k]) && !util_1.isNullOrUndefined(input['updateValue' + k]) && input['updateKey' + k].trim() !== '') {
                                    obj[input['updateKey' + k]] = input['updateValue' + k]; // Apply updates to the element
                                }
                            }
                            // Add update operation to bulk array
                            bulkOperations.push({
                                updateOne: {
                                    filter: { _id: element._id },
                                    update: { $set: obj }
                                }
                            });
                        });
                        let data;
                        // Execute bulk operation if there are any operations to perform
                        if (bulkOperations.length > 0) {
                            try {
                                data = yield model.bulkWrite(bulkOperations);
                            }
                            catch (e) {
                                console.log(e);
                            }
                        }
                        output['result'] = data;
                        resolve({ info: 'Data inserted Successfully', status: 0, data: output });
                    }
                    else {
                        if (!util_1.isNullOrUndefined(input.updateObject) && typeof (input.updateObject) == 'object' && (!util_1.isNullOrUndefined(tableData))) {
                            (db.createDynamicModel(input.tableName)).updateOne(obj, { $set: input.updateObject }, function (err, res) {
                                if (err) {
                                    reject({ info: 'failed to insert data into db', status: 0, data: output });
                                }
                                else {
                                    console.log(res);
                                    output['result'] = res;
                                    // db.close();
                                    resolve({ info: 'Data inserted Successfully', status: 0, data: output });
                                }
                            });
                        }
                        else {
                            // db.close();
                            resolve({ info: 'Data inserted Successfully', status: 0, data: output });
                        }
                    }
                })).catch(e => {
                    console.log("exception in unordered bulk", e);
                });
            }
            catch (e) {
                console.log('Error in fetching details', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    appendJSONtoString(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                var result = {
                    "fileId": 1477,
                    "runAsUserIds": [12],
                    "poolIds": [1],
                    "overrideDefaultDevice": false,
                    "callbackInfo": {
                        "url": "https://e897c55c1d4780ac84cf18312ccade82.m.pipedream.net",
                        "headers": {
                            "X-Authorization": "{{token}}"
                        }
                    },
                    "botInput": {
                        "strObjJSON": {
                            "type": "STRING",
                            "string": ""
                        }
                    }
                };
                if (!util_1.isNullOrUndefined(input.data)) {
                    result["botInput"]["strObjJSON"]["string"] = JSON.stringify(input.data[0]);
                    output['result'] = JSON.stringify(result);
                }
                return { info: 'Data appended Successfully', status: 0, data: output };
            }
            catch (e) {
                console.log('Error in appending string', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    get(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            var obj = {};
            if ((input.findquery != "") && (!util_1.isNullOrUndefined(input.findquery))) {
                obj = JSON.parse(input.findquery);
            }
            else {
                if ((!util_1.isNullOrUndefined(input.findKey)) && (input.findKey != "") && (!util_1.isNullOrUndefined(input.findValue)) && (input.findValue != "")) {
                    obj[input.findKey] = input.findValue;
                }
            }
            const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
            const db = mClient.db(config.dbConfig.dbname);
            try {
                var tableData;
                if (!util_1.isNullOrUndefined(obj) && (obj != {})) {
                    tableData = yield db.collection(input.tableName).find(obj).toArray();
                }
                else {
                    tableData = yield db.collection(input.tableName).find().toArray();
                }
                if (!util_1.isNullOrUndefined(tableData.length)) {
                    outPut['count'] = tableData.length;
                    outPut['userList'] = tableData;
                }
                else {
                    outPut['count'] = 0;
                }
                return { info: 'Data found Successfully', status: 0, data: outPut };
            }
            catch (e) {
                console.log('Error in fetching details', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    getAdditionalInfoInput(input, outPut, botId, projetId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                outPut['result'] = JSON.stringify({ "file1": input });
                console.log("ResultData", outPut['result']);
                return { message: 'Data found Successfully', status: 0, data: outPut };
            }
            catch (e) {
                return { message: 'Mapping failed', status: 1, data: [] };
            }
        });
    }
    windowsRecorder(input, outPut, botId, projetId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("input ", input);
                // let data = await eventStatus.findOne({ 'projectId': projectId, 'botId': botId, $or: [{ eventId: input.eventId }, { parentEventId: input.eventId }] });
                if (!util_1.isNullOrUndefined(input)) {
                    console.log("input ", input);
                    // let a = JSON.parse(JSON.stringify(data));
                    let obj = {
                        "exePath": input.exePath,
                        "vars": input,
                        "projectId": projetId,
                        "botId": botId,
                        "iterationId": iterationId,
                        "eventId": input.eventId,
                        "from": 'start_win',
                        "accessControlList": input.accessControlList
                    };
                    this.socket.emit('trigger-event2', JSON.stringify(obj));
                }
                // let outPut;
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                console.log('Error while installing recorder', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    windowsDesktopPlayer(input, outPut, botId, projetId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("execution start");
                if (!util_1.isNullOrUndefined(input)) {
                    console.log("in player");
                    let obj = {
                        "exePath": input.exePath,
                        "xmlPath": input.xmlPath,
                        "appPath": input.appPath,
                        "vars": input,
                        "projectId": projetId,
                        "botId": botId,
                        "iterationId": iterationId,
                        "eventId": input.eventId,
                        "from": 'winPlay',
                        "accessControlList": input.accessControlList
                    };
                    this.socket.emit('trigger-event2', JSON.stringify(obj));
                }
                return { message: '', status: 999, data: outPut };
            }
            catch (e) {
                console.log('Error while installing Player', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    uploadFileViaUtility(input, outputParameters, botId, iterationId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "uploadUrl": input.uploadUrl,
                    "filename": input.filename,
                    "sourcePath": input.sourcePath,
                    "destinationPath": input.destinationPath,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'recorderUpload',
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Socket triggering for uploadFileViaUtility.");
                return { message: 'Socket triggering for uploadFile Via Utility.', status: 0, data: null };
            }
            catch (e) {
                this.log.error("Error in Socket triggering for uploadFileViaUtility." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    arrayToHtmlBot(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info('Inside array to html Bot' + JSON.stringify(input));
                let obj = input.data.slice(-5);
                console.log(obj);
                let htmlString;
                htmlString = "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <title>Bootstrap Example<\/title>\r\n  <meta charset=\"utf-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n  <style>\r\n  table { \r\n  width: 100%; \r\n  border-collapse: collapse; \r\n}\r\n\r\ntd { \r\n  padding: 6px; \r\n  border: 1px solid #ccc; \r\n  text-align: left; \r\n}\r\n\r\n  <\/style>\r\n <p><b>Dear Sir/Madam,<\/b><\/p> \r\n <p>The following shipments have crossed the threshold due to unfavorable weather conditions,Kindly take the appropriate mitigation measures<\/p>\r\n<\/head>\r\n<body>\r\n\r\n<div>           \r\n  <table border=\"1\">\r\n    \r\n        <head>\r\n          \r\n";
                htmlString = htmlString + "<\/head> \r\n    \r\n      \r\n      <tbody>    \r\n      <tr style=\"background:blue;color:white\">\r\n        <td>Shipment_House_Bill<\/td>\r\n        <td>Origin_Town<\/td>\r\n        <td>Destination_Town<\/td>\r\n        <td>Confirmed_Departure<\/td>\r\n        <td>Latest_Status_Location<\/td>\r\n        <td>Latest_Status_Date<\/td>\r\n        <td>Service<\/td>\r\n        <td>Transport_Mode<\/td>\r\n  <td>Reason_of_Catastrophic_Risk<\/td>\r\n <\/tr>\r\n";
                for (let i = 0; i < obj.length; i++) {
                    htmlString = htmlString + "<tr> <td>" + obj[i].Shipment_House_Bill + "</td>";
                    htmlString = htmlString + "<td>\r\n" + obj[i].Origin_Town + "</td>";
                    htmlString = htmlString + "<td>\r\n" + obj[i].Destination_Town + "</td>";
                    htmlString = htmlString + "<td>\r\n" + obj[i].Confirmed_Departure + "</td>";
                    htmlString = htmlString + "<td>\r\n" + obj[i].Latest_Status_Location + "</td>";
                    htmlString = htmlString + "<td>\r\n" + obj[i].Latest_Status_Date + "</td>";
                    //htmlString = htmlString + "<td>\r\n" + obj[i].Service + "</td>";
                    htmlString = htmlString + "<td>\r\n" + obj[i].Transport_Mode + "</td>";
                    htmlString = htmlString + "<td>\r\n" + obj[i].Reason_of_Catastrophic_Risk + "</td>";
                }
                htmlString = htmlString + "<\/tbody>  \r\n  <\/table>\r\n<\/div>\r\n\r\n<\/body>\r\n<\/html>\r\n";
                output['htmlString'] = htmlString;
                return { message: '', status: 0, data: output };
            }
            catch (e) {
                console.log('Error in Reconcilation report', e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    twoFA(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                var authenticator = require('authenticator');
                // const secret = 'ibycewtufprudg3p';
                const secret = input.secret;
                var formattedToken = authenticator.generateToken(secret);
                console.log(formattedToken);
                outPut['result'] = formattedToken;
                console.log("Numbers must be valid integers and greater than 0");
                return { message: 'Numbers must be valid integers and greater than 0', status: 0, data: outPut };
            }
            catch (e) {
                return { message: e, status: 1, data: e };
            }
        });
    }
    mongoDbBot(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info('Inside Mongo Db Bot' + JSON.stringify(input));
            try {
                if (!util_1.isNullOrUndefined(input.userName) && input.userName.trim() !== "") {
                    input.userName = input.userName + ":";
                }
                else {
                    input['userName'] = "";
                }
                if (!util_1.isNullOrUndefined(input.password) && input.password.trim() !== "") {
                    input.password = Buffer.from(input.password, 'base64').toString();
                    input.password = input.password + "@";
                }
                else {
                    input['password'] = "";
                }
                if ((!util_1.isNullOrUndefined(input.data)) && (!util_1.isNullOrUndefined(input.matchedCondition)) && (!util_1.isNullOrUndefined(input.slicedConditionStart))
                    && (!util_1.isNullOrUndefined(input.slicedConditionEnd))) {
                    // url = 'mongodb://username:password@localhost:27017/dbName';
                    const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                    const db = mClient.db(env_2.env.dbConfig.dbname);
                    let match = JSON.parse(input.matchedCondition);
                    let obj = JSON.parse(input.data);
                    let key = Object.keys(obj)[0];
                    console.log(obj, key);
                    let DBdata = yield db.collection(input.collectionName).find(match).toArray();
                    console.log(DBdata);
                    let bulk = yield db.collection(input.collectionName).initializeUnorderedBulkOp();
                    let slicedData = DBdata.slice(input.slicedConditionStart, input.slicedConditionEnd);
                    console.log(slicedData);
                    slicedData.forEach((element, i) => {
                        element[key] = obj[key];
                        console.log(element);
                        bulk.find({ _id: element._id }).update({ $set: element });
                    });
                    /*if (!Array.isArray(input.data) && input.data[0] == '[') {
                        input.data = JSON.parse(input.data);
                    }
                    input.data.forEach(function (item, cb) {
                        if (!isNullOrUndefined(item.publishDate)) {
                            if (item.source === 'https://economictimes.indiatimes.com/industry/cons-products/garments-/-textiles') {
                                // Dec 1, 2018, 05:03 PM IST
                                moment.defaultFormat = 'MMM D, YYYY, hh:mm A z';
                                console.log('item.publishDate 1', item.publishDate);
                                item.publishDate = moment(item.publishDate, moment.defaultFormat).toDate();
                                console.log('item.publishDate 2', item.publishDate);
                            }
                            if (item.source === 'https://economictimes.indiatimes.com/topic/MSME') {
                                //    8 Jan, 2019, 08.06PM IST
                                moment.defaultFormat = 'D MMM, YYYY, hh.mmA z';
                                console.log('item.publishDate 1', item.publishDate);
                                item.publishDate = moment(item.publishDate, moment.defaultFormat).toDate();
                                console.log('item.publishDate 2', item.publishDate);
                            }
                        }
                        bulk.find(item).upsert().updateOne(item);
                    });*/
                    let data = yield this.executeBulk(bulk);
                    output['data'] = data;
                    return { info: 'Data inserted Successfully', status: 0, data: output };
                }
                else {
                    return { message: 'No Data Received to Dump in the Database', status: 1, data: 'No Data Received to be Dump in the Database [ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
                }
            }
            catch (e) {
                console.error('Error: ', e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    executeBulk(bulk) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                return new Promise((resolve, reject) => {
                    bulk.execute(function (err, data) {
                        if (err) {
                            throw err;
                        }
                        else {
                            resolve({ info: 'Data saved successfully', status: 0, data: data.nInserted });
                        }
                    });
                });
            }
            catch (err) {
                console.log("Data not saved" + err);
                return { info: 'Internal Server Error', status: 1, data: [] };
            }
        });
    }
    categorizeBusinessTypeBot(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const self = this;
            self.log.info('Inside Categorize Business Type Bot' + JSON.stringify(input));
            try {
                if (!util_1.isNullOrUndefined(input.category) && !util_1.isNullOrUndefined(input.keywords)) {
                    let category = input.category;
                    let keywords = JSON.parse(input.keywords);
                    let businessData = yield self.businessTypeService.findBusinesses({ businessTypeName: { $in: category }, isDeleted: false }, {});
                    let businessDataParsed;
                    if (!util_1.isNullOrUndefined(businessData) && !util_1.isNullOrUndefined(businessData.data) && businessData.data.length > 0) {
                        businessDataParsed = JSON.parse(JSON.stringify(businessData));
                    }
                    let newsData = yield self.newsServive.findNews({ businessId: { $exists: false } }, {});
                    let tenderData = yield self.webCrawlerService.findTenders({ businessId: { $exists: false } }, {});
                    let newsDataParsed, tenderDataParsed;
                    if (newsData.status === 0) {
                        newsDataParsed = JSON.parse(JSON.stringify(newsData.data));
                    }
                    if (tenderData.status === 0) {
                        tenderDataParsed = JSON.parse(JSON.stringify(tenderData.data));
                    }
                    let arr = [];
                    if (!util_1.isNullOrUndefined(businessDataParsed) && !util_1.isNullOrUndefined(newsDataParsed)) {
                        for (const nData of newsDataParsed) {
                            let match;
                            for (const key of keywords) {
                                let strRegExPattern = '\\b' + key + '\\b';
                                if (!util_1.isNullOrUndefined(nData.news) && !util_1.isNullOrUndefined(nData.news.data)) {
                                    match = nData.news.data.match(new RegExp(strRegExPattern, 'gi'));
                                }
                                if (!util_1.isNullOrUndefined(match)) {
                                    nData['businessId'] = businessDataParsed.data[0]._id;
                                    let qry = { _id: ObjectId(nData._id) };
                                    let set = { $set: { businessId: businessDataParsed.data[0]._id } };
                                    let opt = { upsert: true, new: true };
                                    let updateQuery = yield self.newsServive.findSingleAndUpdate(qry, set, opt);
                                    if (updateQuery.status === 0) {
                                        arr.push(updateQuery.data);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    if (!util_1.isNullOrUndefined(businessDataParsed) && !util_1.isNullOrUndefined(tenderDataParsed)) {
                        for (const tData of tenderDataParsed) {
                            let match;
                            for (const key of keywords) {
                                let strRegExPattern = '\\b' + key + '\\b';
                                if (!util_1.isNullOrUndefined(tData.Summary)) {
                                    match = tData.Summary.match(new RegExp(strRegExPattern, 'gi'));
                                }
                                if (!util_1.isNullOrUndefined(match)) {
                                    tData['businessId'] = businessDataParsed.data[0]._id;
                                    let qry = { _id: ObjectId(tData._id) };
                                    let set = { $set: { businessId: businessDataParsed.data[0]._id } };
                                    let opt = { upsert: true, new: true };
                                    let updateQuery = yield self.webCrawlerService.findSingleAndUpdate(qry, set, opt);
                                    if (updateQuery.status === 0) {
                                        arr.push(updateQuery.data);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    output['data'] = arr;
                    return { info: 'Data Categorized Successfully', status: 0, data: output };
                }
                else {
                    return { info: 'Problem in Categorizing Business Type', status: 1, data: output };
                }
            }
            catch (e) {
                console.error('Error: ', e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    autoFillPDF(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // console.log('input ----> ', input);
                if (!util_1.isNullOrUndefined(input.inputTemplatePath) && !util_1.isNullOrUndefined(input.data) && !util_1.isNullOrUndefined(input.outputPath)) {
                    let isArray = Array.isArray(input.data);
                    let obj = { hourlyRates: "" };
                    if (isArray && !util_1.isNullOrUndefined(input.data[0].productName)) {
                        if (input.data.length > 0) {
                            input.data.forEach((item, index) => {
                                if (item.status == "Yes") {
                                    let i = index + 1;
                                    let key = 'text' + i.toString();
                                    obj[key] = item.productName;
                                    let key2 = 'dosage' + i.toString();
                                    obj[key2] = item.qty.toString();
                                    let key3 = 'rate' + i.toString();
                                    obj[key3] = item.rate.toString();
                                    let key4 = 'it' + i.toString();
                                    obj[key4] = item.itemAmt.toString();
                                }
                            });
                        }
                    }
                    else if (isArray) {
                        let i = 0;
                        input.data.forEach(element => {
                            if (element['category'] === 'medication') {
                                i++;
                                for (let k in element) {
                                    let x = k + i.toString();
                                    obj[x] = element[k];
                                }
                            }
                        });
                    }
                    else {
                        var str = input.data.name, array = str.split('');
                        let name = {};
                        array.forEach((item, index) => {
                            let i = index + 1;
                            let key = 'n' + i.toString();
                            name[key] = item;
                        });
                        if (!util_1.isNullOrUndefined(input.data.mobile) && typeof input.data.mobile !== 'string') {
                            let mobNo = input.data.mobile.toString();
                            input.data.mobile = mobNo;
                        }
                        if (!util_1.isNullOrUndefined(input.data.pinCode) && typeof input.data.pinCode !== 'string') {
                            let pinCode = input.data.pinCode.toString();
                            input.data.pinCode = pinCode;
                        }
                        var str1 = input.data.mobile, array = str1.split('');
                        let mobile = {};
                        array.forEach((item, index) => {
                            let i = index + 1;
                            let key = 'm' + i.toString();
                            mobile[key] = item;
                        });
                        let finalData = Object.assign(name, mobile);
                        var str2 = input.data.panNumber, array = str2.split('');
                        let panNumber = {};
                        array.forEach((item, index) => {
                            let i = index + 1;
                            let key = 'p' + i.toString();
                            panNumber[key] = item;
                        });
                        let finalData1 = Object.assign(panNumber, finalData);
                        let address = input.data.building + " " + input.data.street;
                        let address1 = input.data.area + " " + input.data.city + " " + input.data.state;
                        let address2 = input.data.pinCode;
                        let tempAdd = {
                            "address": address,
                            "address1": address1,
                            "address2": address2
                        };
                        let finalData2 = Object.assign(tempAdd, finalData1);
                        let data = {};
                        if (!util_1.isNullOrUndefined(input.formType) && input.formType !== "") {
                            if (input.formType.toLowerCase() == "nsdl") {
                                data = { "nsdl": "yes" };
                            }
                            else if (input.formType.toLowerCase() == "csdl") {
                                data = { "csdl": "yes" };
                            }
                        }
                        let finalData3 = Object.assign(finalData2, data);
                        obj = Object.assign(finalData3, input.data);
                    }
                    delete obj.hourlyRates;
                    console.log("obj ", obj);
                    pdftk
                        .input(input.inputTemplatePath)
                        .fillForm(obj)
                        .flatten()
                        .output(input.outputPath)
                        .then(buffer => {
                        console.log("PDF Is Written Succesfully");
                    })
                        .catch(err => {
                        console.log("error", err);
                        return { message: 'Error to generate PDF', status: 1, data: err };
                    });
                    let data = input.outputPath;
                    output['data'] = data;
                    return { message: 'PDF created sucessfully', status: 0, data: output };
                }
                else {
                    return { message: 'please give all parameters', status: 1, data: null };
                }
            }
            catch (e) {
                console.log('Internal server error', e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    googleImageOCRBot(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info('Inside Google Image OCR Bot');
            try {
                if (Array.isArray(input.filePath)) {
                    let files = input.filePath;
                    const converted = yield files.reduce((result, el) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                        el = fs.readFileSync(el);
                        console.log("path", el);
                        const baseUrl = "https://vision.googleapis.com/v1/images:annotate", subscriptionKey = "AIzaSyBVttNXNiUjh-ef9rKlRUbUGxDUlFuOlm0", data = {
                            'requests': [
                                {
                                    'image': {
                                        'content': el.toString('base64')
                                    },
                                    'features': [
                                        {
                                            'type': 'DOCUMENT_TEXT_DETECTION'
                                        }
                                    ]
                                }
                            ]
                        };
                        const urloptions = {
                            method: 'POST',
                            url: baseUrl + "?key=" + subscriptionKey,
                            headers: {
                                'Content-Type': 'application/octet-stream',
                                'Ocp-Apim-Subscription-Key': subscriptionKey
                            },
                            body: data,
                            json: true
                        };
                        const res = yield request(urloptions);
                        result += res['responses'][0]['textAnnotations'][0].description;
                        return result;
                    }), "");
                    console.log(converted);
                    output['outputStr'] = converted;
                    return { info: "converted to text", status: 0, data: output };
                }
                else {
                    const file = fs.readFileSync(input.filePath);
                    /*Send file to google vision api*/
                    const baseUrl = "https://vision.googleapis.com/v1/images:annotate", subscriptionKey = "AIzaSyBVttNXNiUjh-ef9rKlRUbUGxDUlFuOlm0", data = {
                        'requests': [
                            {
                                'image': {
                                    'content': file.toString('base64')
                                },
                                'features': [
                                    {
                                        'type': 'DOCUMENT_TEXT_DETECTION'
                                    }
                                ]
                            }
                        ]
                    };
                    const urloptions = {
                        method: 'POST',
                        url: baseUrl + "?key=" + subscriptionKey,
                        headers: {
                            'Content-Type': 'application/octet-stream',
                            'Ocp-Apim-Subscription-Key': subscriptionKey
                        },
                        body: data,
                        json: true
                    };
                    var rest = yield request(urloptions);
                    console.log('restiy ----------> ', rest);
                    output['outputString'] = rest['responses'][0]['fullTextAnnotation']['text'].replace(/\n/g, ",").replace(/[^\w\s]/gi, ' ');
                    output['outputStr'] = rest['responses'][0]['textAnnotations'][0].description;
                    console.log(output['outputStr']);
                    output['outputData'] = rest['responses'][0];
                    let textAnnotations = [];
                    textAnnotations = rest['responses'][0]['textAnnotations'];
                    textAnnotations.forEach((item, index) => {
                        if (!util_1.isNullOrUndefined(item) && !util_1.isNullOrUndefined(item.description) && !util_1.isNullOrUndefined(textAnnotations[index + 1]) && !util_1.isNullOrUndefined(textAnnotations[index + 1].description) && !util_1.isNullOrUndefined(textAnnotations[index + 2]) && !util_1.isNullOrUndefined(textAnnotations[index + 2].description) && !util_1.isNullOrUndefined(textAnnotations[index + 3]) && !util_1.isNullOrUndefined(textAnnotations[index + 3].description)) {
                            if (item.description.toLowerCase() === 'permanent' && textAnnotations[index + 1].description.toLowerCase() == 'account' && textAnnotations[index + 2].description.toLowerCase() == 'number') {
                                output['panNumber'] = textAnnotations[index + 3].description;
                            }
                        }
                    });
                    return { message: 'Image Data Received Successfully', status: 0, data: output };
                }
            }
            catch (err) {
                return { message: 'Error', status: 1, data: err + ' - [ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    jsonToxml_tally_master_template(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let template = !util_1.isNullOrUndefined(input.template) && typeof input.template == 'string' ? JSON.parse(input.template) : input.template;
                //console.log(template)
                let mapping = !util_1.isNullOrUndefined(input.mapping) && typeof input.mapping == 'string' ? JSON.parse(input.mapping) : input.mapping;
                //console.log(mapping)
                let invoiceData = !util_1.isNullOrUndefined(input.invoiceData) && typeof input.invoiceData == 'string' ? JSON.parse(input.invoiceData) : input.invoiceData;
                //console.log(invoiceData)
                if (invoiceData['gstInStatus'] == 'false') {
                    invoiceData['Taxable_Amount'] = invoiceData['InvoiceTotalAmount'];
                }
                if (Number(invoiceData['TDS_Rate']) > 0) {
                    let tdsRate = Number(invoiceData['TDS_Rate']) / 100;
                    let tdsValue = (Number(invoiceData['Taxable_Amount']) * tdsRate).toFixed(2);
                    invoiceData['TDS_Value'] = tdsValue;
                    invoiceData['InvoiceTotalAmount'] = Number(invoiceData['InvoiceTotalAmount']) - tdsValue;
                }
                let masterTemplate = '';
                //console.log(mapping)
                for (let key in template) {
                    let temp = template[key];
                    //console.log(temp)
                    let map = mapping[key];
                    //console.log(map)
                    let arrayFlag = invoiceData[key] && Array.isArray(invoiceData[key]) ? true : false;
                    //console.log(arrayFlag)
                    if (arrayFlag) {
                        let arrayItems = invoiceData[key];
                        let temp2 = temp;
                        temp = '';
                        for (let i = 0; i < arrayItems.length; i++) {
                            let temp3 = temp2;
                            let item = arrayItems[i];
                            for (let mapKey in map) {
                                if (item[map[mapKey]]) {
                                    console.log(mapKey);
                                    let regExp = new RegExp(mapKey, "g");
                                    temp = temp.replace(regExp, invoiceData[map[mapKey]]);
                                }
                            }
                            temp += temp3;
                        }
                    }
                    else {
                        for (let mapKey in map) {
                            if (!util_1.isNullOrUndefined(invoiceData[map[mapKey]])) {
                                //  console.log(invoiceData[map[mapKey]])
                                console.log(mapKey);
                                let regExp = new RegExp(mapKey, "g");
                                temp = temp.replace(regExp, invoiceData[map[mapKey]]);
                            }
                        }
                    }
                    masterTemplate += temp;
                }
                output['XML'] = masterTemplate.replace(/&/g, "&amp;");
                output['tallySetup'] = input.tallySetup;
                output['publicIPAddress'] = input.publicIPAddress;
                output['tallyPort'] = input.tallyPort;
                console.log(output, 'Shyam');
                return { message: 'Json to Xml converted sucessfully', status: 0, data: output };
            }
            catch (e) {
                console.log('JsonToxml_tally Error', e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    readFilesFromFolder(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "directoryPath": input.directoryPath,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'readFilePaths',
                    ///"userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Socket triggering to read files from folder.");
                return { message: 'Socket triggering to read file from folder.', status: 0, data: null };
            }
            catch (e) {
                this.log.error("Error in Socket triggering for read file utility." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    uploadFilesToServer(input, outputParameters, botId, iterationId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "directoryPath": input.directoryPath,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'uploadfilestoserver',
                    ///"userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Socket triggering to read files from folder.");
                return { message: 'Socket triggering to read file from folder.', status: 0, data: null };
            }
            catch (e) {
                this.log.error("Error in Socket triggering for read file utility." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    readExcelFile(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "excelPath": input.excelPath,
                    "startHeader": input.startHeader,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'readExcelFile',
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Socket triggering to read excel files from folder.");
                return { message: 'Socket triggering to read excel file from folder.', status: 0, data: null };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to read excel file utility." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    masterbot(input, outputParameters, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("ENTER THE INPUT", input);
                let compare1 = input.compare1;
                console.log(compare1, 'compare1 ');
                let compare2 = input.compare2;
                let ID = input.ID;
                let count = 0;
                let ID_arry = [];
                let Comp = compare2.split(',');
                if (!util_1.isNullOrUndefined(input.compare1) && !util_1.isNullOrUndefined(input.Comp)) {
                    // let Arry1 = arry1.split(",");
                    // let Arry2 = arry2.split(",");
                    for (let i = 0; i < Comp.length; i++) {
                        if (compare1.includes(Comp[i])) {
                            count++;
                        }
                        else {
                            console.log("input is not matching");
                        }
                    }
                    if (count >= 2) {
                        ID_arry.push(ID);
                        outputParameters['result'] = ID_arry;
                    }
                    else {
                        console.log("matching is less than zero");
                    }
                    return { message: 'Data found Successfully', status: 0, data: outputParameters };
                }
                else {
                    outputParameters['input'] = null;
                    return { status: 1, "message": 'arry is not found', data: outputParameters };
                }
                this.log.info("Socket triggering to read files from folder.");
                return { message: 'Socket triggering to read file from folder.', status: 0, data: null };
            }
            catch (e) {
                this.log.error("Error in Socket triggering for read file utility." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    filterArray(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let path = input.path;
                let json;
                if (typeof (path) == 'string') {
                    json = JSON.parse(path);
                }
                else {
                    json = path;
                }
                //console.log(json);
                let a = [];
                json.tableData.forEach((data) => {
                    data.rows.forEach(row => {
                        row.columns.forEach((column) => {
                            if (Array.isArray(column)) {
                                column.forEach(line => {
                                    if (line.Line == "Must-Have**") {
                                        a.push(row);
                                    }
                                });
                            }
                            else if (column.Line == "Must-Have**") {
                                a.push(row);
                            }
                        });
                    });
                });
                let b = [];
                let c = [];
                let split1, split2;
                let array = a[0]['columns'][1];
                let indx1, indx2, indx3, indx4, indx5, indx6, indx7, indx8, indx9, data1, data2, data3, data4, data5, data6, data7, data8, data9;
                for (let i = 0; i < array.length; i++) {
                    console.log(array[i]['Line'], 'abc');
                    if (array[i]['Line'].includes(' using ') == true) {
                        indx1 = array[i]['Line'].indexOf('using');
                        data1 = array[i]['Line'].slice(indx1 + 7);
                        b.push(data1);
                        // console.log(data1,'okkk')
                        continue;
                    }
                    else if (array[i]['Line'].includes(' of ') == true) {
                        indx2 = array[i]['Line'].indexOf(' of ');
                        data2 = array[i]['Line'].slice(indx2 + 4);
                        b.push(data2);
                        continue;
                    }
                    else if (array[i]['Line'].includes(' on ') == true) {
                        indx3 = array[i]['Line'].indexOf(' on ');
                        data3 = array[i]['Line'].slice(indx3 + 4);
                        b.push(data3);
                        continue;
                    }
                    else if (array[i]['Line'].includes(' in ') == true) {
                        indx4 = array[i]['Line'].indexOf(' in ');
                        data4 = array[i]['Line'].slice(indx4 + 4);
                        b.push(data4);
                        continue;
                    }
                    else if (array[i]['Line'].includes('able to') == true) {
                        indx5 = array[i]['Line'].indexOf('able to');
                        data5 = array[i]['Line'].slice(indx5 + 7);
                        b.push(data5);
                        continue;
                    }
                    else if (array[i]['Line'].includes(' of ') == true) {
                        indx6 = array[i]['Line'].indexOf(' of ');
                        data6 = array[i]['Line'].slice(indx6 + 4);
                        b.push(data6);
                        continue;
                    }
                    else if (array[i]['Line'].includes(' with ') == true) {
                        indx7 = array[i]['Line'].indexOf(' with ');
                        data7 = array[i]['Line'].slice(indx7 + 6);
                        b.push(data7);
                        continue;
                    }
                    else if (array[i]['Line'].includes('ability to') == true) {
                        indx8 = array[i]['Line'].indexOf('ability to');
                        data8 = array[i]['Line'].slice(indx8 + 10);
                        b.push(data8);
                        continue;
                    }
                    else if (array[i]['Line'].includes('should have') == true) {
                        indx9 = array[i]['Line'].indexOf('should have');
                        data9 = array[i]['Line'].slice(indx9 + 2);
                        b.push(data9);
                        continue;
                    }
                    else {
                        b.push(array[i]['Line']);
                        continue;
                    }
                }
                for (let j = 0; j < b.length; j++) {
                    if (b[j].includes('/') == true) {
                        split1 = b[j].split('/');
                        //c.push(split1);
                        split1.forEach(e => c.push(e));
                        continue;
                    }
                    else if (b[j].includes('and')) {
                        split2 = b[j].split('and');
                        //c.push(split2);
                        split2.forEach(e => c.push(e));
                        continue;
                    }
                    else {
                        c.push(b[j]);
                        continue;
                    }
                }
                this.log.info("Sucessful");
                output['result'] = c;
                return { message: 'array splited sucessfully', status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error in spliting in array" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    wordParser2json(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const Parser = require('xml2json');
            try {
                let filePath = input.filePath;
                let finalArray = {
                    lines: [],
                    tableData: []
                };
                if (filePath == undefined || filePath == '' || filePath == null) {
                    //console.log("empty")
                }
                else if (filePath.includes('.xml') || filePath.includes('.rels') || filePath.includes('.bin') || filePath.includes('#') || filePath.includes('.db') || filePath.includes('.lock') || filePath.includes('tqod.RTF') || filePath.includes('.txt') || filePath.includes('~$')) {
                    //console.log("do nothing")
                }
                else {
                    // let pageId = '';
                    console.log("Extracting styles :" + filePath);
                    let filename = filePath.substring(filePath.lastIndexOf('/') + 1);
                    console.log(filename);
                    let doctype = filePath.match(/\/[A-Z]{4}\//) ? filePath.match(/\/[A-Z]{4}\//)[0] : 'Test';
                    doctype = doctype.replace(/\//g, '');
                    // docCount+=1;
                    const zip = yield new AdmZip(filePath);
                    let xml;
                    var zipEntries = yield zip.getEntries(); // an array of ZipEntry records
                    zipEntries.forEach(function (zipEntry) {
                        if (zipEntry.entryName == "word/document.xml") {
                            xml = zipEntry.getData();
                        }
                    });
                    let json = Parser.toJson(xml);
                    json = JSON.parse(json);
                    if (json['w:document'] && json['w:document']['w:body'] && json['w:document']['w:body']['w:p'] && Array.isArray(json['w:document']['w:body']['w:p'])) {
                        let data = JSON.parse(JSON.stringify(json['w:document']['w:body']['w:p']));
                        for (let i = 0; i < data.length; i++) {
                            let D = yield this.getWPText(data[i]);
                            if (D) {
                                finalArray['lines'].push(JSON.parse(JSON.stringify(D)));
                            }
                        }
                    }
                    if (json['w:document'] && json['w:document']['w:body'] && json['w:document']['w:body']['w:tbl']) {
                        let wordTable = JSON.parse(JSON.stringify(json['w:document']['w:body']['w:tbl']));
                        let tableArray = [];
                        if (Array.isArray(wordTable)) {
                            for (let tableNumber = 0; tableNumber < wordTable.length; tableNumber++) {
                                if (wordTable[tableNumber]['w:tr']) {
                                    let rows = yield this.wRowToText(wordTable[tableNumber]['w:tr']);
                                    if (rows.rows.length > 0) {
                                        tableArray.push(JSON.parse(JSON.stringify(rows)));
                                    }
                                }
                            }
                        }
                        else {
                            if (wordTable['w:tr']) {
                                let rows = yield this.wRowToText(wordTable['w:tr']);
                                if (rows.rows.length > 0) {
                                    tableArray.push(JSON.parse(JSON.stringify(rows)));
                                }
                            }
                        }
                        // console.log(JSON.stringify(tableArray));
                        finalArray['tableData'] = JSON.parse(JSON.stringify(tableArray));
                    }
                    console.log("Total WordArray : ", finalArray);
                    //  let fileName = filePath.substring(filePath.lastIndexOf('/') + 1, filePath.lastIndexOf('.doc'))
                    //fs.writeFileSync(`/home/user/Documents/abc/output files/${fileName}.json`, JSON.stringify(finalArray), 'utf8');
                    output['result'] = finalArray;
                }
                return { message: 'word file extracted sucessfully', status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error in extracting word file" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    readFixedWidthFile(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "fwdFilePath": input.fwdFilePath,
                    "configData": input.configData,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'readFwfFile',
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Socket triggering to read excel files from folder.");
                return { message: 'Socket triggering to read excel file from folder.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to read excel file utility." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    remoteJobExecution(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "command": input.command,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'remoteJobExecution',
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                return { message: 'Socket triggering to run commands.', status: 0, data: null };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to read excel file utility." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    drawShapeFiles(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let pro = require('proj4');
                var firstProjection = "+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489 +units=m +no_defs";
                var secondProjection = "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees";
                let address = input.address;
                let plotNo = input.plotNo;
                // let nearbyPoints = [];
                console.log("input.plot", input.plotNo, "pp", plotNo);
                let plotBoundries = {
                    lines: [],
                    plotNoPoints: [],
                    supplyPoints: [],
                };
                let streetData = {
                    line: [],
                    streetPt: []
                };
                let ploatObject = {
                    'plotNumber': plotNo,
                    'street': 'CONNAUGHT STREET'
                };
                const mClient = yield MongoClient.connect(env_1.env.dbConfig.mongodb_uri);
                const db = mClient.db(env_1.env.dbConfig.dbname);
                let cartoData = yield db.collection('cartographictexts').findOne({ "properties.textString": address });
                console.log("JSONcarto", cartoData.loc);
                console.log("cartoData.loc", cartoData.loc[0]);
                let stData = yield db.collection('cartographictexts').aggregate([{
                        $match: {
                            loc: {
                                $geoWithin: { $centerSphere: [cartoData.loc[0], 0.01 / 3963.2] },
                            },
                            "properties.textString": plotNo
                        }
                    }]).toArray();
                console.log("stData", stData);
                let missingPData = yield db.collection('missingpoints').aggregate([
                    {
                        $match: {
                            loc: {
                                $geoWithin: { $centerSphere: [cartoData.loc[0], 0.02 / 3963.2] }
                            },
                            "properties.textString": plotNo
                        }
                    },
                ]).toArray();
                console.log("missingg", missingPData);
                if (!util_1.isNullOrUndefined(missingPData[0])) {
                    console.log(missingPData[0], "st", stData);
                    plotBoundries.plotNoPoints = missingPData[0].loc;
                }
                else {
                    plotBoundries.plotNoPoints = stData[0].loc[0];
                }
                let lineData = yield db.collection('topographiclines').aggregate([
                    {
                        $match: {
                            loc: {
                                $geoWithin: { $centerSphere: [plotBoundries.plotNoPoints, 0.0022 / 3963.2] }
                            },
                        }
                    }, { $project: { loc: "$locBritish", "properties": "$properties", _id: 0 } }
                ]).toArray();
                console.log("lineData", lineData);
                lineData.forEach(element => {
                    if (element.properties.theme.indexOf('Road') < 0) {
                        console.log("ele", element);
                        plotBoundries.lines.push(element.loc);
                    }
                });
                let supData = yield db.collection('supplypoints').aggregate([
                    {
                        $match: {
                            loc: {
                                $geoWithin: { $centerSphere: [plotBoundries.plotNoPoints, 0.0019 / 3963.2] }
                            },
                        }
                    }, { $project: { loc: "$loc", "properties": "$properties", _id: 0 } }
                ]).toArray();
                console.log("sup", supData);
                let topStData = yield db.collection('topographiclines').aggregate([
                    {
                        $match: {
                            loc: { $geoWithin: { $centerSphere: [plotBoundries.plotNoPoints, 0.019 / 3963.2] } },
                        }
                    }, { $project: { loc: "$locBritish", "properties": "$properties", _id: 0 } }
                ]).toArray();
                console.log("topo", topStData);
                topStData.forEach(element => {
                    if (element.properties.descriptiv == "Road Or Track") {
                        streetData.line.push(element.loc);
                    }
                });
                streetData.streetPt = cartoData.loc[0];
                let junctionPoint = yield this.getInterSect(plotBoundries.lines, input);
                ploatObject['junctionPoint'] = junctionPoint.junctionPoint;
                // ploatObject['mainLineSlope'] = junctionPoint.mainLineSlope;
                ploatObject['supplyPointsCo'] = junctionPoint.supplyPoints;
                ploatObject['plotNo'] = pro(secondProjection, firstProjection, plotBoundries.plotNoPoints);
                ploatObject['streetPt'] = pro(secondProjection, firstProjection, streetData.streetPt);
                console.log("ploatObject", ploatObject);
                output['output'] = ploatObject;
                return { message: 'Shapefile Object created', status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error while prepareing shape file" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    getInterSect(lines, input) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let math = require('mathjs');
            //console.log("lines",lines);
            let junctioPointIn = {
                x: 0,
                y: 0
            };
            let supplyPointsCo = {
                x: 0, y: 0
            };
            let mainX2 = 527361.75; //527361.75 ,181109.6
            let mainY2 = 181109.6;
            let mainX1 = 527413.43; //527413.43 181125.03
            let mainY1 = 181125.03;
            let aLen = !util_1.isNullOrUndefined(input.a) ? Number(input.a) * 0.31 : input.a;
            let bLen = !util_1.isNullOrUndefined(input.a) ? Number(input.b) * 0.31 : input.b;
            console.log("a " + aLen + " b" + bLen);
            let cableLength;
            cableLength = !util_1.isNullOrUndefined(input.cableLength) ? Number(input.cableLength) * 0.31 : 15 * 0.31;
            let verX2 = lines[0][0][0];
            let verY2 = lines[0][0][1];
            let verX1 = lines[0][1][0];
            let verY1 = lines[0][1][1];
            if (lines[0][0][0] < lines[1][0][0] && !util_1.isNullOrUndefined(aLen) && aLen > 0) {
                verX2 = lines[0][0][0];
                verY2 = lines[0][0][1];
                verX1 = lines[0][1][0];
                verY1 = lines[0][1][1];
            }
            else {
                verX2 = lines[1][0][0];
                verY2 = lines[1][0][1];
                verX1 = lines[1][1][0];
                verY1 = lines[1][1][1];
            }
            let x, b;
            let x1, b1;
            let y1;
            let m = (mainY2 - mainY1) / (mainX2 - mainX1);
            let m1 = (verY2 - verY1) / (verX2 - verX1);
            let y = mainY2;
            x = mainX2;
            b = y - m * x;
            y1 = verY2, x1 = verX2;
            b1 = y1 - m1 * x1;
            let xInter = (b1 - b) / (m - m1);
            let yInter = m * xInter + b;
            if (m == 0) {
                if (!util_1.isNullOrUndefined(aLen) && aLen > 0) {
                    junctioPointIn.x = xInter + aLen;
                    junctioPointIn.y = yInter;
                }
                else {
                    junctioPointIn.x = xInter - bLen;
                    junctioPointIn.y = yInter;
                }
            }
            // if slope is infinte
            else if (m == -1) {
                if (!util_1.isNullOrUndefined(aLen) && aLen > 0) {
                    junctioPointIn.x = xInter;
                    junctioPointIn.y = yInter + aLen;
                }
                else {
                    junctioPointIn.x = xInter;
                    junctioPointIn.y = yInter - bLen;
                }
            }
            else {
                let dx;
                if (!util_1.isNullOrUndefined(aLen) && aLen > 0) {
                    dx = (aLen / math.sqrt(1 + (m * m)));
                }
                else {
                    dx = (bLen / math.sqrt(1 + (m * m)));
                }
                let dy = m * dx;
                if (!util_1.isNullOrUndefined(aLen) && aLen > 0) {
                    junctioPointIn.x = xInter + dx;
                    junctioPointIn.y = yInter + dy;
                }
                else {
                    junctioPointIn.x = xInter - dx;
                    junctioPointIn.y = yInter - dy;
                }
            }
            if (!util_1.isNullOrUndefined(cableLength)) {
                let m1 = -1 / m;
                console.log("mmm", m1);
                let dx1;
                dx1 = (cableLength / math.sqrt(1 + (m1 * m1)));
                let dy1 = m1 * dx1;
                supplyPointsCo.x = junctioPointIn.x - dx1;
                supplyPointsCo.y = junctioPointIn.y - dy1;
            }
            console.log("xintersect " + xInter);
            console.log("yInter " + yInter);
            return { junctionPoint: junctioPointIn, mainLineSlope: m, supplyPoints: supplyPointsCo };
        });
    }
    // public async scheduleScanJob(input, output, botId, projectId, iterationId) {
    //     this.log.info('Inside fileQ Bot' + JSON.stringify(input));
    //     try {
    //         // const url = 'mongodb://scan-dev.gibots.com:27017/blueocean-dev';
    //         let queryOne = await eventStatus.findOne({"eventId" : ObjectId(input.eventId) , "botId" : botId , "iterationId" : iterationId, "projectId" : ObjectId(projectId)});
    //         let botIdOne = queryOne['successor'][0];
    //         const url = env.dbConfig.mongodb_uri;
    //         const mClient = await MongoClient.connect(url);
    //         // const db = mClient.db('cuda');
    //         const db = mClient.db(env.dbConfig.dbname);
    //         const query = { fileRefNum: input.fileRefNum };
    //         // let update = {}
    //         // let qry = { _id: ObjectId(nData._id) };
    //         const update = { $set: { documentType: input.documentType, status: 'fileQueued', type: input.type} };
    //         const updateFileUploadHistory = { $set: { documentType: input.documentType, eventId : input.eventId ,iterationId : iterationId , botId : botIdOne , projectId : projectId } };
    //         const opt = { upsert: true, new: true };
    //         let fileQueueData = await this.fileQueueService.findOneAndUpdateFileFromQueue(query, update, opt, db);
    //         const fileUploadHistoryData = await db.collection('fileuploadhistories').findOneAndUpdate(query, updateFileUploadHistory, opt);
    //         if (fileQueueData.status === 0 && !isNullOrUndefined(fileUploadHistoryData)) {
    //             output['fileQueueData'] = fileQueueData;
    //             output['fileUploadHistoryData'] = fileUploadHistoryData;
    //             return { info: 'Schedule Scan Job Successfully', status: 0, data: output };
    //         } else {
    //             return { message: fileQueueData.error, status: 1, data: fileQueueData.error + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
    //         }
    //     } catch (e) {
    //         console.error('Error: ', e);
    //         return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
    //     }
    // }
    // public async invoiceException(input, output, botId, projectId, iterationId){
    //     console.log("Entered into dummyBot ====>>> ---->>  ");
    // }
    // public async decisionMakingBot(body, output, botId, projectId, iterationId){
    //         this.log.info("Entered into decisionMakigBot Input----->>>>===>> ");
    //     try{
    //         //const url = env.dbConfig.mongodb_uri;
    //         let queryOne = eventStatus.findOne({"eventId" : body.eventId , "botId" : body.botId , "iterationId" : iterationId, "projectId" : ObjectId(projectId)});
    //         console.log(JSON.stringify(queryOne));
    //        // let botIdOne = queryOne['successor'][0];
    //         const url = "mongodb://server:server@13.126.25.110:27017/cuda-testing";
    //         const mClient = await MongoClient.connect(url);
    //         const db = mClient.db("cuda-testing");
    //         let fields = [];
    //         let avg = 0;
    //         let totalAvg = 0;
    //         if(!isNullOrUndefined(body.documentType) && !isNullOrUndefined(body.fileRefNum)){
    //          let query = {"documentType" : body.documentType};
    //          let queResult = await db.collection('scanningfields').findOne(query);
    //          console.log("queResult ===>--->>", JSON.stringify(queResult));
    //          if(!isNullOrUndefined(queResult)){
    //              queResult.fields.forEach((row,i) => {
    //                  if(row.required == true){
    //                     fields.push(row.fieldName);
    //                  }
    //              });
    //          }
    //          let queryTwo = {"referenceNumber" : body.fileRefNum};
    //          //let queryTwo = {"referenceNumber" : "File539184c2026e8bc59d739acf4b06f6e9"};
    //          let queResTwo = await db.collection(body.documentType).findOne(queryTwo);
    //          console.log(JSON.stringify(queResTwo));
    //          if(!isNullOrUndefined(queResTwo)){
    //             fields =  fields.filter((row,i)=>{
    //                 if(isNullOrUndefined(queResTwo[row]) || queResTwo[row] == ""){
    //                     return row;
    //                 }
    //              });
    //              queResTwo['prediction'].forEach((row,i)=>{
    //                 row['ml'] = row['ml'].replace("%","").trim();
    //                 avg = avg + Number(row.ml);
    //             });
    //             console.log("Avg ===>>-->" , avg);
    //             totalAvg = avg/queResTwo['prediction'].length;
    //             console.log("totalAvg ===>> ",totalAvg)
    //          }
    //     if(fields.length > 0){
    //         if(totalAvg < 80){
    //             let update = {"$set" : { "isException" : true , "avgPrediction" : totalAvg} };
    //             let queRes = await db.collection(body.documentType).findOneAndUpdate(queryTwo,update);
    //             console.log(JSON.stringify(queRes));
    //             return { info: 'Decision Made Successfully', status: 0, data: true };
    //              }else{
    //             let update = {"$set" : { "isException" : false, "avgPrediction" : totalAvg } };
    //             let queRes = await db.collection(body.documentType).findOneAndUpdate(queryTwo,update);
    //             console.log(JSON.stringify(queRes));
    //             return { info: 'Decision Made Successfully', status: 0, data: false };
    //              }
    //          }else{
    //             if(totalAvg < 80){
    //                 let update = {"$set" : { "isException" : true, "avgPrediction" : totalAvg } };
    //                 let queRes = await db.collection(body.documentType).findOneAndUpdate(queryTwo,update);
    //                 console.log(JSON.stringify(queRes));
    //                 return { info: 'Decision Made Successfully', status: 0, data: true };
    //                  }else{
    //                 let update = {"$set" : { "isException" : false, "avgPrediction" : totalAvg } };
    //                 let queRes = await db.collection(body.documentType).findOneAndUpdate(queryTwo,update);
    //                 console.log(JSON.stringify(queRes));
    //                 return { info: 'Decision Made Successfully', status: 0, data: false };
    //                  }
    //          }
    //         }else{
    //             return { info: 'Decision not made due to body is incomplete', status: 1, data: [] };
    //         }
    //     }catch(err){
    //         console.log("err ===>>>---->>>==>> ", err);
    //         return { info: 'Decision not made due to error', status: 1, data: err };
    //     }
    // }
    scheduleScanJob(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info('Inside fileQ Bot' + JSON.stringify(input));
            try {
                // const url = 'mongodb://scan-dev.gibots.com:27017/blueocean-dev';
                let a = yield eventStatus_1.eventStatus.findOne({ "eventId": input.eventId, "botId": botId });
                let queryOne = JSON.parse(JSON.stringify(a));
                console.log(queryOne);
                let botIdOne = queryOne['successor'][0];
                console.log("Bot ID Oneeeeeeee" + botIdOne);
                //const url = "mongodb://server:server@13.126.25.110:27017/cuda-testing";
                const url = env_2.env.dbConfig.mongodb_uri;
                const mClient = yield MongoClient.connect(url);
                //const db = mClient.db("cuda-testing");
                const db = mClient.db(env_2.env.dbConfig.dbname);
                let update;
                let docTypeCol = yield db.collection(input.documentType).findOne({ "referenceNumber": input.fileRefNum });
                docTypeCol = JSON.stringify(docTypeCol);
                console.log("dattaa-khanpp-------", docTypeCol.length);
                if (docTypeCol.length == 4) {
                    console.log("-----------------new RefNum");
                    update = { $set: { documentType: input.documentType, status: 'fileQueued', type: input.type, "isSecPass": false } };
                }
                else {
                    console.log("--------------------old RefNUm");
                    update = { $set: { documentType: input.documentType, status: 'fileQueued', type: input.type, "isSecPass": true } };
                }
                const query = { fileRefNum: input.fileRefNum };
                // let update = {}
                // let qry = { _id: ObjectId(nData._id) };
                //  const update = { $set: { documentType: input.documentType, status: 'fileQueued', type: input.type } };
                const updateFileUploadHistory = { $set: { documentType: input.documentType, eventId: input.eventId, iterationId: iterationId, botId: botIdOne, projectId: projectId } };
                const opt = { upsert: true, new: true };
                let fileQueueData = yield this.fileQueueService.findOneAndUpdateFileFromQueue(query, update, opt, db);
                const fileUploadHistoryData = yield db.collection('fileuploadhistories').findOneAndUpdate(query, updateFileUploadHistory, opt);
                if (fileQueueData.status === 0 && !util_1.isNullOrUndefined(fileUploadHistoryData)) {
                    output['fileQueueData'] = fileQueueData;
                    output['fileUploadHistoryData'] = fileUploadHistoryData;
                    console.log({ info: 'Schedule Scan Job Successfully', status: 0, data: output });
                    yield this.callBackFun(db, input);
                    return { info: 'Schedule Scan Job Successfully', status: 0, data: output };
                }
                else {
                    console.warn({ message: fileQueueData.error, status: 1, data: fileQueueData.error + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' });
                    return { message: fileQueueData.error, status: 1, data: fileQueueData.error + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
                }
            }
            catch (e) {
                console.error('Error: ', e);
                console.error({ message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' });
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    callBackFun(db, input) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("   --->>  ", input['fileRefNum'], " --->>> ", input['documentType'], " ----->>   ");
                let data = yield db.collection('filequeues').findOne({ "fileRefNum": input['fileRefNum'], "documentType": input['documentType'], status: "Success" });
                console.log(data, "filequeues");
                if (!util_1.isNullOrUndefined(data) && data !== "" && !util_1.isNullOrUndefined(data["status"]) && data['status'] == "Success") {
                    return { status: "Success" };
                }
                else {
                    let wait = yield delay(1000 * 5);
                    console.log("delay", wait);
                    yield this.callBackFun(db, input);
                    return { status: "callback" };
                }
            }
            catch (err) {
                console.log(err);
                return { status: "error" };
            }
        });
    }
    invoiceException(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            console.log("Entered into dummyBot ====>>> ---->>  ");
        });
    }
    createBucketInS3(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info('<--------- Entered into createBucketInS3 Bot ----------->');
            try {
                let bucket = new Promise((resolve, reject) => {
                    const s3Config = {
                        'accessKeyId': config.S3_Configuration.accessKeyId,
                        'secretAccessKey': config.S3_Configuration.secretAccessKey,
                        'endpoint': config.S3_Configuration.endpoint,
                        'signatureVersion': config.S3_Configuration.signatureVersion,
                        'region': config.S3_Configuration.region,
                        'ACL': config.S3_Configuration.ACL,
                    };
                    console.log("s3config ---->>>>> ====>>>>  ", JSON.stringify(s3Config));
                    const bucketName = {
                        'Bucket': input.bucketName
                        //'Bucket' : config.S3_Configuration.Bucket
                    };
                    console.log("S3 BucketName ---------->>>>>>   ", JSON.stringify(bucketName));
                    aws.config.update({ accessKeyId: s3Config.accessKeyId, secretAccessKey: s3Config.secretAccessKey });
                    const s3 = new aws.S3({
                        endpoint: s3Config.endpoint,
                        signatureVersion: s3Config.signatureVersion,
                        region: s3Config.region
                    });
                    s3.createBucket(bucketName, function (awsError, awsResp) {
                        if (!awsError) {
                            config.S3_Configuration.Bucket = bucketName.Bucket;
                            console.info("BucketCreates on S3 Server", bucketName.Bucket);
                            resolve({ info: 'BucketCreates on S3 Server', status: 0, data: bucketName.Bucket });
                        }
                        else {
                            throw awsError;
                        }
                    });
                });
                output['Bucket'] = util_1.isNullOrUndefined(bucket) ? [] : bucket;
                console.log("Socket triggering to Upload Scan Document");
                return { message: "Socket triggering to Copy Document from src to dest folder in S3", status: 0, data: output };
            }
            catch (err) {
                console.error("<----- Error in createBucketInS3 BOt ---------->>", err);
                return { message: err, status: 1, data: err };
            }
        });
    }
    passFilePath(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info(" <------------- Entered into passFilePath ----------->>>>>>");
            try {
                let filepath = "";
                let destination = input.destinationPath;
                let files = JSON.parse(input.filePath);
                if (!util_1.isNullOrUndefined(files) && files.length > 0) {
                    filepath = files[iterationId];
                    let imagepath = filepath.split("/");
                    let destinPath = destination + imagepath[imagepath.length - 1];
                    fs.copyFileSync(filepath, destinPath);
                    console.log("Fileee Patheeee ------->>>> ", destinPath);
                    output['filePath'] = destinPath;
                    return { message: "Filepath Fetch successfully", status: 0, data: output };
                }
                else {
                    this.log.info("<<<<<<--- Filepath is Not Matcheable -------->>>");
                    return { message: "Filepath Fetch with failer", status: 1, data: null };
                }
            }
            catch (err) {
                this.log.error("<----- Error In PassFilPath Bot -----> ", err);
                return { message: err, status: 1, data: err };
            }
        });
    }
    getAssginOldBotDetails(input) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!util_1.isNullOrUndefined(input)) {
                    let inputData = JSON.parse(input);
                    let botId = inputData.botId;
                    let eventId = inputData.eventId;
                    let projectId = inputData.projectId;
                    let iterationId = inputData.iterationId;
                    let eventStatusesId = inputData.eventStatusesId;
                    let prevBotId = inputData.prevBotId;
                    let role = inputData.role;
                    console.log(botId + ' ' + eventId + ' ' + projectId + ' ' + iterationId + ' ' + eventStatusesId + ' ' + prevBotId + ' ' + role);
                    let res1 = yield db.collection('eventstatuses').findOne({ "projectId": ObjectId(projectId), "iterationId": iterationId, "botId": prevBotId, "eventId": ObjectId(eventId) });
                    res1 = JSON.parse(JSON.stringify(res1));
                    let res2 = yield db.collection('eventstatuses').findOne({ "projectId": ObjectId(projectId), "iterationId": iterationId, "botId": botId, "eventId": ObjectId(eventId) });
                    res2 = JSON.parse(JSON.stringify(res2));
                    if (!util_1.isNullOrUndefined(res1.assignToList)) {
                        res2.assignToList.push(res1.assignToList[res1.assignToList.length - 1]);
                    }
                    res2.assignToList[res2.assignToList.length - 1]['orchestratorStatus'] = "inProgress";
                    res2.assignToList[res2.assignToList.length - 1]['permissionID'] = "";
                    res2.assignToList[res2.assignToList.length - 1]['date'] = new Date();
                    // let res3 = await db.collection('eventstatuses').updateOne({"projectId":ObjectId(projectId),"iterationId":iterationId,"botId":botId,"eventId":ObjectId(eventId)},{"$set":{res2}});
                    // res3 = JSON.parse(JSON.stringify(res3));
                    // if(res3.nModified!=1){
                    //     throw 'not assign'
                    // }
                    return JSON.stringify(res2.assignToList);
                }
            }
            catch (e) {
                console.log(e);
                return e;
            }
        });
    }
    findReviewerAndAssign(input, filter = '') {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                input = typeof (input) == 'string' ? JSON.parse(input) : input;
                let eventInfo = yield db.collection('events').findOne({ '_id': ObjectId(input.eventId) }).lean();
                let taskCreatorName = eventInfo.username;
                let query = { 'personalInfo.name': taskCreatorName };
                if (!util_1.isNullOrUndefined(filter)) {
                    let filterArr = filter.split(',');
                    filterArr.forEach(key => {
                        if (key == 'orgId') {
                            query['organisation'] = eventInfo['orgId'];
                        }
                        else {
                            query[key] = eventInfo[key];
                        }
                    });
                }
                let taskCreatorInfo = yield db.collection('users').findOne(query).lean();
                let supervisorId = taskCreatorInfo.supervisor;
                let supervisorInfo;
                try {
                    supervisorId = ObjectId(supervisorId);
                    supervisorInfo = yield db.collection('users').findOne({ '_id': supervisorId }).lean();
                }
                catch (e) {
                    supervisorInfo = taskCreatorInfo;
                }
                let assigneeName = eventInfo.additionalInfoVar["Assign To"];
                if (taskCreatorName === assigneeName) {
                    return JSON.stringify([{
                            "assignToName": supervisorInfo.personalInfo.name,
                            "assignToEmail": supervisorInfo.personalInfo.email,
                            "permissionID": "",
                            "date": new Date().toISOString(),
                            "level": 0,
                            "startDate": new Date().toISOString(),
                            "endDate": null,
                            "isBucket": true,
                            "isReleased": false,
                            "isDeleted": false,
                            "isGroup": false,
                            "roleType": "",
                            "assignedToId": ObjectId(supervisorInfo._id),
                            "orchestratorStatus": "inProgress"
                        }]);
                }
                else {
                    return JSON.stringify([{
                            "assignToName": taskCreatorName,
                            "assignToEmail": taskCreatorInfo.personalInfo.email,
                            "permissionID": "",
                            "date": new Date().toISOString(),
                            "level": 0,
                            "startDate": new Date().toISOString(),
                            "endDate": null,
                            "isBucket": true,
                            "isReleased": false,
                            "isDeleted": false,
                            "isGroup": false,
                            "roleType": "",
                            "assignedToId": ObjectId(taskCreatorInfo._id),
                            "orchestratorStatus": "inProgress"
                        }]);
                }
            }
            catch (e) {
                console.log("Err ----", e);
                return e;
            }
        });
    }
    assignBotByUser(userName, botId, eventId, filter = '', input = {}) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let query = { 'personalInfo.name': userName, 'isDeleted': false };
                if (!util_1.isNullOrUndefined(filter)) {
                    let filterArr = filter.split(',');
                    filterArr.forEach((key) => {
                        if (!util_1.isNullOrUndefined(key) && input[key]) {
                            if (key == 'orgId') {
                                query['organisation'] = ObjectId(input[key]);
                            }
                            else {
                                query[key] = ObjectId(input[key]);
                            }
                        }
                    });
                }
                let userData = yield db.collection('users').findOne(query).lean();
                let res2 = yield db.collection('eventstatuses').findOne({ "botId": botId, "eventId": ObjectId(eventId) }).lean();
                let assign = res2['assignToList'] && res2['assignToList'][0] ? res2['assignToList'][0] : {};
                assign['assignedToId'] = ObjectId(userData._id);
                assign['assignToName'] = userData.personalInfo && userData.personalInfo.name ? userData.personalInfo.name : assign['assignToName'];
                console.log('-----------', userData._id, res2['assignToList']);
                let data = yield db.collection('eventstatuses').updateOne({ "botId": botId, "eventId": ObjectId(eventId) }, { $set: { assignToList: res2['assignToList'] } });
                console.log(data);
            }
            catch (e) {
                console.log("Error-----", e);
            }
        });
    }
    setNotifyUser(notifyUsers, botId, eventId, filter = '', input = {}) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let query = { 'personalInfo.name': { $in: notifyUsers }, 'isDeleted': false };
                if (!util_1.isNullOrUndefined(filter)) {
                    let filterArr = filter.split(',');
                    filterArr.forEach((key) => {
                        if (!util_1.isNullOrUndefined(key) && input[key]) {
                            if (key == 'orgId') {
                                query['organisation'] = ObjectId(input[key]);
                            }
                            else {
                                query[key] = ObjectId(input[key]);
                            }
                        }
                    });
                }
                let userData = yield db.collection('users').find(query).lean();
                let notifyUserList = [];
                for (let i = 0; i < userData.length; i++) {
                    notifyUserList.push({ userId: userData[i]._id, name: userData[i].personalInfo && userData[i].personalInfo.name ? userData[i].personalInfo.name : "" });
                }
                let data = yield db.collection('eventstatuses').updateOne({ "botId": botId, "eventId": ObjectId(eventId) }, { $set: { notifyUserList: notifyUserList } });
                console.log(data);
            }
            catch (e) {
                console.log("Error-----", e);
            }
        });
    }
    updateSlaInBot(input) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let inputData = JSON.parse(input);
                let botId = inputData.botId;
                let eventId = inputData.eventId;
                let projectId = inputData.projectId;
                let iterationId = inputData.iterationId;
                let escalationName = inputData.escalationName;
                let escalationId = yield db.collection('escalations').findOne({ "escalationName": escalationName }, { projection: { _id: 1 } }).lean();
                escalationId = escalationId['_id'];
                let res3 = yield db.collection('eventstatuses').updateOne({ "projectId": ObjectId(projectId), "iterationId": iterationId, "botId": botId, "eventId": ObjectId(eventId) }, { "$set": { "escalationId": escalationId } });
                res3 = JSON.parse(JSON.stringify(res3));
                if (res3.nModified != 1) {
                    throw 'not assign';
                }
                return { message: '', status: 0, data: [] };
            }
            catch (e) {
                console.log("error", e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    leastLoadedRole(input) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!util_1.isNullOrUndefined(input)) {
                    let inputData = JSON.parse(input);
                    let botId = inputData.botId;
                    let eventId = inputData.eventId;
                    let projectId = inputData.projectId;
                    let iterationId = inputData.iterationId;
                    //  let eventStatusesId = inputData.eventStatusesId;
                    let prevBotId = inputData.prevBotId;
                    let roleId = inputData.roleId;
                    // let userId =inputData.userId;
                    let supervisorID = '';
                    //    console.log(botId + ' ' + eventId + ' ' + projectId + ' ' + iterationId + ' ' + eventStatusesId + ' ' + prevBotId + ' ' + roleId);
                    let currentBotIdData = yield db.collection('eventstatuses').findOne({ "projectId": ObjectId(projectId), "iterationId": iterationId, "botId": inputData.botId, "eventId": ObjectId(eventId) });
                    currentBotIdData = JSON.parse(JSON.stringify(currentBotIdData));
                    let prevBotIdData = yield db.collection('eventstatuses').findOne({ "projectId": ObjectId(projectId), "iterationId": iterationId, "botId": prevBotId, "eventId": ObjectId(eventId) });
                    prevBotIdData = JSON.parse(JSON.stringify(prevBotIdData));
                    let BotCompletedUser = prevBotIdData.assignToList.find((a) => a.orchestratorStatus == 'Complete');
                    if (!util_1.isNullOrUndefined(BotCompletedUser)) {
                        supervisorID = BotCompletedUser.assignedToId;
                    }
                    // console.log(userId);
                    if (currentBotIdData.orchestratorStatus == "Waiting for execution") {
                        //  console.log("first")
                        let users = yield db.collection('users').aggregate([
                            {
                                "$match": {
                                    "role": ObjectId(roleId),
                                    "supervisor": ObjectId(supervisorID),
                                    "isDeleted": false,
                                    "isActive": true
                                }
                            },
                            {
                                "$project": {
                                    "name": "$personalInfo.name",
                                    "mobile": "$personalInfo.mobile",
                                    "email": "$personalInfo.email",
                                    "role": "$role"
                                }
                            }
                        ]);
                        const userData = JSON.parse(JSON.stringify(users));
                        let userIdList = userData.map((user) => { return (user._id); });
                        let userIdListObject = userData.map((user) => { return ObjectId(user._id); });
                        let eventstatuses = yield db.collection('eventstatuses').aggregate([
                            {
                                "$match": {
                                    "botId": botId,
                                    "projectId": ObjectId(projectId),
                                    "orchestratorStatus": { $in: ['inProgress'] }
                                }
                            },
                            {
                                "$unwind": {
                                    "path": "$assignToList",
                                    "preserveNullAndEmptyArrays": true
                                }
                            },
                            {
                                "$project": {
                                    "assignedToId": "$assignToList.assignedToId",
                                    "assignToName": "$assignToList.assignToName",
                                    "assignToEmail": "$assignToList.assignToEmail",
                                }
                            },
                            {
                                "$match": {
                                    "assignedToId": { $in: userIdListObject }
                                }
                            },
                            {
                                "$group": {
                                    "_id": "$assignedToId",
                                    "data": { $sum: 1 },
                                    "doc": {
                                        "$push": "$$ROOT"
                                    }
                                }
                            },
                            { "$sort": { count: 1 } }
                        ]);
                        const eventStatusData = JSON.parse(JSON.stringify(eventstatuses));
                        if (eventStatusData.length != userIdList.length) {
                            let eventuserIdList = eventStatusData.map((user) => { return (user._id); });
                            let userlist = _.difference(userIdList, eventuserIdList);
                            // console.log("userList:", userlist)
                            // console.log("in eventstatus==========>>>>>>>>", eventuserIdList);
                            if (userlist.length != 0) {
                                const user = userData.find((user1) => user1._id == userlist[0]);
                                //  console.log("userId is.........", user._id);
                                //     console.log("eventstatus is ..........", eventStatus._id);
                                //  console.log("user is", user);
                                if ((user) != null) {
                                    return JSON.stringify([{
                                            "assignToName": user.name,
                                            "assignToEmail": user.email,
                                            "permissionID": "",
                                            "date": new Date().toISOString(),
                                            "level": 0,
                                            "startDate": new Date().toISOString(),
                                            "endDate": null,
                                            "isBucket": true,
                                            "isReleased": false,
                                            "isDeleted": false,
                                            "isGroup": false,
                                            "roleType": "",
                                            "assignedToId": ObjectId(user._id),
                                            "orchestratorStatus": "inProgress"
                                        }]);
                                }
                            }
                            else {
                                // }
                                return JSON.stringify([{
                                        "assignToName": userData[0].name,
                                        "assignToEmail": userData[0].email,
                                        "permissionID": "",
                                        "date": new Date().toISOString(),
                                        "level": 0,
                                        "startDate": new Date().toISOString(),
                                        "endDate": null,
                                        "isBucket": true,
                                        "isReleased": false,
                                        "isDeleted": false,
                                        "isGroup": false,
                                        "roleType": "",
                                        "assignedToId": ObjectId(userData[0]._id),
                                        "orchestratorStatus": "inProgress"
                                    }]);
                            }
                        }
                        else {
                            let assginData = !util_1.isNullOrUndefined(eventStatusData[0].doc[0]) ? eventStatusData[0].doc[0] : [];
                            if (assginData.length != 0) {
                                return JSON.stringify([{
                                        "assignToName": assginData.assignToName,
                                        "assignToEmail": assginData.assignToEmail,
                                        "permissionID": "",
                                        "date": new Date().toISOString(),
                                        "level": 0,
                                        "startDate": new Date().toISOString(),
                                        "endDate": null,
                                        "isBucket": true,
                                        "isReleased": false,
                                        "isDeleted": false,
                                        "isGroup": false,
                                        "roleType": "",
                                        "assignedToId": ObjectId(assginData.assignedToId),
                                        "orchestratorStatus": "inProgress"
                                    }]);
                            }
                        }
                    }
                    else {
                        //  console.log("second")
                        return JSON.stringify([{
                                "assignToName": currentBotIdData.assignToList.assignToName,
                                "assignToEmail": currentBotIdData.assignToList.assignToEmail,
                                "permissionID": "",
                                "date": new Date().toISOString(),
                                "level": 0,
                                "startDate": new Date().toISOString(),
                                "endDate": null,
                                "isBucket": true,
                                "isReleased": false,
                                "isDeleted": false,
                                "isGroup": false,
                                "roleType": "",
                                "assignedToId": ObjectId(currentBotIdData.assignToList.assignedToId),
                                "orchestratorStatus": "inProgress"
                            }]);
                    }
                    throw "eventStatus Not Found";
                }
            }
            catch (e) {
                // console.log(e);
                return e;
            }
        });
    }
    readFileFromDirectoryBulk(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info("<-------------- Entered into readFileFromDirectory ------------->>");
            try {
                let self = this;
                console.log("Input Data For readFileFromDirectory ----------->>>>>> ", JSON.stringify(input));
                if (!util_1.isNullOrUndefined(input.filePath)) { //filePath
                    let filePath;
                    input.filePath = !util_1.isNullOrUndefined(input.filePath) && typeof input.filePath == 'string' ? JSON.parse(input.filePath) : input.filePath;
                    if (input.filePath.length == 1) {
                        filePath = input.filePath[0];
                    }
                    else {
                        filePath = input.filePath[iterationId];
                    }
                    output['ifilePath'] = filePath;
                    output['oldPath'] = filePath;
                    console.log("Type provided" + input.type);
                    let docType = input.documentType;
                    let type = input.type ? input.type : 'train';
                    console.log(" 000000000 ---------        ---------------                 00000000000             >>>>>>> ", docType);
                    let data = yield (db.collection("scanningfields")).findOne({ documentType: docType });
                    if (!util_1.isNullOrUndefined(data)) {
                        let refRes = yield self.getReferenceNumber(input, output, botId, projectId, iterationId);
                        let refNum = refRes['refNo'];
                        let obj = {};
                        let queObj = {};
                        console.log("DocTYPE ---- >>> ", JSON.stringify(docType));
                        obj['subscriberId'] = queObj['subscriberId'] = input.subscriberId;
                        obj['orgId'] = queObj['orgId'] = input.orgId;
                        obj['gstin'] = queObj['gstin'] = input.gstin;
                        obj['userId'] = queObj['userId'] = input.userId;
                        obj['documentType'] = queObj['documentType'] = docType;
                        obj['type'] = queObj['type'] = type;
                        obj['isOcr'] = queObj['isOcr'] = util_1.isNullOrUndefined(input.isOcr) && input.isOcr == "" ? false : input.isOcr;
                        obj['status'] = 'Pending';
                        obj['isProcess'] = false;
                        obj['isScan'] = true;
                        obj['tableName'] = 'Scan';
                        obj['uploadType'] = 'Scan';
                        obj['fileRefNum'] = queObj['fileRefNum'] = refNum;
                        obj['uploadPath'] = config.path + refNum + '_';
                        let uploadPath = config.path + refNum + '_';
                        let fname = path.basename(filePath);
                        fname = fname.replace(/ /g, "_").replace(/[()#,&']/g, "");
                        obj['fileName'] = queObj['fileName'] = fname;
                        obj['filePath'] = queObj['filePath'] = uploadPath + fname;
                        console.log("Copying ", filePath, obj['filePath']);
                        fs.copyFileSync(filePath, obj['filePath']);
                        let fQ = new fileQueue(queObj);
                        yield fQ.save();
                        let fU = new fileUploadHistory(obj);
                        yield fU.save();
                        output['referenceNo'] = refNum;
                        output['documentType'] = docType;
                        output['filePath'] = obj['filePath'];
                        console.log("Sending Data from First Return and output data is" + JSON.stringify(output));
                        return { message: "readFileFromDirectory", status: 0, data: output };
                    }
                    else {
                        console.log("Sending Data from Second Return and output data is" + JSON.stringify(output));
                        return { message: "readFileFromDirectory with SCANFORMFIELD", status: 0, data: [] };
                    }
                }
                else {
                    console.log("Sending Data from Third Return and output data is" + JSON.stringify(output));
                    return { message: "readFileFromDirectory with INPUT", status: 0, data: [] };
                }
            }
            catch (err) {
                console.log("Sending Data from Catch Block and output data is");
                this.log.error("<----- Error In the BOT below is the error " + err);
                console.log(err);
                return { message: err, status: 1, data: err };
            }
        });
    }
    adiswanExtraction(body) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info("<-------------- Entered into adiswanExtraction ------------->>");
            try {
                let referenceNo = body.referenceNo;
                let result = yield db.collection('filequeues').findOne({ "fileRefNum": referenceNo }, { fileRefNum: 1, status: 1, _id: 0 });
                result = JSON.parse(JSON.stringify(result));
                console.log("result from the adiswan extraction  ", result);
                if (!util_1.isNullOrUndefined(result)) {
                    return { info: 'Data fetched successfully', status: 0, data: result };
                }
                else {
                    return { info: 'Data not found', status: 1, data: result };
                }
            }
            catch (err) {
                return { info: 'Data not found', status: 1, data: [] };
            }
        });
    }
    readFileFromDirectory(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info("<-------------- Entered into readFileFromDirectory ********------------->>");
            try {
                let self = this;
                let directCopy = input.directCopy && ["true", true].includes(input.directCopy) ? true : false;
                // input.filePath = ["/home/user/Videos/inputPdfs/DN 1303 - Emp ID 703.pdf"]
                console.log("Input Data For readFileFromDirectory ----------->>>>>> ", JSON.stringify(input));
                if (!util_1.isNullOrUndefined(input.filePath)) { //filePath
                    let filePath;
                    //input.filePath = '["/home/user/Desktop/gibots/gibots-node-api/Attachmentfile/INV002_Invoice.pdf"]'
                    //let files = fs.readdirSync(input.filePath);
                    input.filePath = !util_1.isNullOrUndefined(input.filePath) && typeof input.filePath == 'string' ? JSON.parse(input.filePath) : input.filePath;
                    if (input.filePath.length == 1) {
                        filePath = input.filePath[0];
                    }
                    else {
                        filePath = input.filePath[iterationId];
                    }
                    output['ifilePath'] = filePath;
                    let referenceNo = "";
                    if (!util_1.isNullOrUndefined(input.referenceNo)) {
                        referenceNo = input.referenceNo;
                    }
                    // let filePath = file[iterationId];//home/user/Desktop/Landmark_Train/1.png;
                    let renameFolder = filePath.split("#");
                    let splitString = filePath.split("/");
                    let folderName = splitString[splitString.length - 2];
                    let splitRename = folderName.split("_"); // Tawazun_Doctype_perdict / _train
                    let docType = "";
                    let fileExtSplit = splitString[splitString.length - 1].split(".");
                    let fileType = fileExtSplit[fileExtSplit.length - 1];
                    let renameFile = "";
                    let type = "";
                    console.log("type", input.type, type);
                    if (renameFolder.length > 1) {
                        renameFile = renameFolder[1] + fileType;
                    }
                    else {
                        renameFile = splitRename[0] + iterationId + "_" + splitString[splitString.length - 1];
                    }
                    console.log("rename -------- >> -------- >>>>", renameFile);
                    // let uploderPath = filePath.substring(0, filePath.indexOf(splitString[splitString.length - 2]));
                    let replaceStr = "(^|\\w)train($|\\w)";
                    let expr = new RegExp(replaceStr, "i");
                    if (util_1.isNullOrUndefined(input.type)) {
                        if (!util_1.isNullOrUndefined(splitRename) && splitRename.length > 1 && expr.test(splitString[splitString.length - 2])) {
                            docType = splitRename[0];
                            type = "train";
                        }
                        else {
                            docType = splitRename[0];
                            type = "predict";
                            //type = "gibots"
                        }
                    }
                    else {
                        console.log("Type provided" + input.type);
                        if (!util_1.isNullOrUndefined(input.isDocType) && input.isDocType) {
                            let documentType = filePath.substring(filePath.lastIndexOf('/') + 1, filePath.indexOf('.'));
                            console.log("123123456765423456765423456   ", documentType);
                            docType = documentType;
                            type = input.type;
                        }
                        else {
                            docType = input.documentType;
                            type = input.type;
                        }
                    }
                    console.log(" 000000000 ---------        ---------------                 00000000000             >>>>>>> ", docType);
                    let data = yield (db.collection("scanningfields")).findOne({ documentType: docType });
                    let token = yield self.createToken(input.userId, input.subscriberId, input.orgId);
                    console.log(JSON.stringify(data));
                    if (!util_1.isNullOrUndefined(data)) {
                        let headers = {
                            "Content-Type": "application/json; charset=utf-8",
                            "selectedorgid": input.orgId,
                            "name": renameFile,
                            "Authorization": "Bearer " + token
                        };
                        let scanDocumentPath = filePath;
                        const file = fs.readFileSync(scanDocumentPath);
                        const base64data = Buffer.from(file, "base64");
                        console.log();
                        let MapData = {};
                        console.log("cuda prod url NEW =========>" + env_2.env.routes.adhigam_api);
                        // let Base64FileData = fileData.toString('base64');
                        let options;
                        if (directCopy) {
                            options = {
                                method: 'POST',
                                url: env_2.env.routes.adhigam_api + "adhigam-api/mapper/scan",
                                //url: "http://localhost:3000/adhigam-api/mapper/scan",
                                headers: headers,
                                body: {
                                    directCopy: directCopy,
                                    serverfPath: filePath,
                                    filetype: fileType,
                                    filename: renameFile,
                                    channels: 'sample',
                                    title: 'sampletitle',
                                    documentType: docType,
                                    type: '',
                                },
                                json: true
                            };
                        }
                        else {
                            options = {
                                method: 'POST',
                                url: env_2.env.routes.adhigam_api + "adhigam-api/mapper/scan",
                                //url: "http://localhost:3000/adhigam-api/mapper/scan",
                                headers: headers,
                                formData: {
                                    myfile: base64data,
                                    filetype: fileType,
                                    filename: renameFile,
                                    channels: 'sample',
                                    title: 'sampletitle',
                                    documentType: docType,
                                    type: '',
                                },
                                json: true
                            };
                        }
                        if (referenceNo !== "") {
                            options.formData['referenceNo'] = referenceNo;
                        }
                        console.log("optionss---------", options);
                        process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                        let rest = yield request(options);
                        console.log("Resssssssss---", JSON.stringify(rest));
                        // let rest = await new Promise(async (resolve) => {
                        //     process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                        //     let res = await request(options);
                        //     if (!isNullOrUndefined(res)) {
                        //         resolve(res);
                        //     };
                        // });
                        MapData = JSON.parse(JSON.stringify(rest['data']));
                        // var apiResp = await self.requestApi(options);
                        // var rest = apiResp['output'];
                        // console.log("resprroroor" + JSON.stringify(apiResp));
                        //MapData = rest['body']['data'];
                        // Check if file size is 0 KB
                        let fileSize = fs.statSync(filePath).size;
                        if (fileSize === 0) {
                            output['documentType'] = input.documentType;
                            output['zeroSizeFiles'] = 'zeroSizeFile';
                            if (!util_1.isNullOrUndefined(MapData) && !util_1.isNullOrUndefined(MapData['fileRefNum'])) {
                                output['referenceNo'] = MapData['fileRefNum'];
                                const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                                const db = mClient.db(env_2.env.dbConfig.dbname);
                                yield db.collection('fileuploadhistories').updateOne({ fileRefNum: output['referenceNo'] }, { $set: { status: "Corrupted" } }, { upsert: true });
                            }
                            console.log("File size is 0 KB, skipping file: ", filePath);
                            if (input.successPath) {
                                if (!fs.existsSync(input.successPath)) {
                                    fs.mkdirSync(input.successPath);
                                }
                                let filename = path.basename(filePath);
                                let destinationPath = path.join(input.successPath, filename);
                                console.log("moving------", filePath, destinationPath);
                                fs.renameSync(filePath, destinationPath);
                            }
                            return { message: "Skipped file with 0 KB size", status: 0, data: output };
                        }
                        else {
                            output['zeroSizeFiles'] = 'false';
                        }
                        if (!util_1.isNullOrUndefined(MapData) && !util_1.isNullOrUndefined(MapData['fileRefNum'])) {
                            output['referenceNo'] = MapData['fileRefNum'];
                            referenceNo = output['referenceNo'];
                            //config.cudapath
                            //let outputDirectory = config.cudapath + "successUploadFiles" + "_" + folderName;
                            let outputDirectory = config.cudapath;
                            let oldPath = MapData['filePath'];
                            // oldPath = filePath;
                            let newPath = outputDirectory + MapData['fileRefNum'] + "_" + renameFile;
                            console.log("OLDpath --->", oldPath);
                            console.log("NEWpath---->", newPath);
                            console.log("Scan Document Path New" + scanDocumentPath);
                            console.log("FILE REF NUMBER" + MapData['fileRefNum']);
                            console.log("output file ref number" + output['referenceNo']);
                            if (!fs.existsSync(outputDirectory)) {
                                fs.mkdirSync(outputDirectory);
                            }
                            output['newPath'] = newPath;
                            fs.copyFileSync(oldPath, newPath);
                        }
                        output['renamedFileName'] = renameFile.substring(renameFile.indexOf('_') + 1);
                        console.log("Renamed File Name++++++++++++++++++  ", output['renamedFileName']);
                        output['documentType'] = docType;
                        if (referenceNo !== "") {
                            output['filePath'] = MapData["filePath"];
                        }
                        else {
                            output['filePath'] = scanDocumentPath;
                        }
                        console.log("Sending Data from First Return and output data is" + JSON.stringify(output));
                        return { message: "Socket triggering to readFileFromDirectory", status: 0, data: output };
                    }
                    else {
                        console.log("Sending Data from Second Return and output data is" + JSON.stringify(output));
                        return { message: "Socket triggering to readFileFromDirectory with SCANFORMFIELD", status: 0, data: [] };
                    }
                }
                else {
                    console.log("Sending Data from Third Return and output data is" + JSON.stringify(output));
                    return { message: "Socket triggering to readFileFromDirectory with INPUT", status: 0, data: [] };
                }
            }
            catch (err) {
                console.log("Sending Data from Catch Block and output data is");
                this.log.error("<----- Error In the BOT below is the error " + err);
                console.log(err);
                return { message: err, status: 1, data: err };
            }
        });
    }
    terminalCoomand(cmd) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            return yield new Promise(function (resolve, reject) {
                exec(cmd, (err, stdout, stderr) => {
                    if (err) {
                        resolve({ status: 1, err: err });
                    }
                    if (stderr !== '') {
                        resolve({ status: 1, err: stderr });
                    }
                    else {
                        resolve({ status: 0, output: stdout });
                    }
                });
            });
        });
    }
    requestApi(data) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            return (this, void 0, void 0, function* () {
                return new Promise(function (resolve, reject) {
                    request(data, (err, res) => {
                        if (err) {
                            console.log("Error in the Request API function" + err);
                            resolve({ status: 1, err: err });
                        }
                        else {
                            console.log("Reponse from the request api" + res);
                            resolve({ status: 0, output: res });
                        }
                    });
                });
            });
        });
    }
    copyDocumentInS3Folder(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info('<--------- Entered into copyDocumentInS3Folder Bot ------------->');
            try {
                console.log("Input data Copy Bot--->>>>=======>>>   ", JSON.stringify(input));
                let files = yield dms_1.dms.aggregate([
                    {
                        "$match": {
                            "taskId": ObjectId(input.eventId),
                            "type": "f"
                        }
                    },
                    {
                        "$unwind": {
                            "path": "$versions",
                            "includeArrayIndex": "arrayIndex",
                            "preserveNullAndEmptyArrays": false
                        }
                    },
                    {
                        "$project": {
                            "path": "$versions.path"
                        }
                    }
                ]).allowDiskUse(true);
                let isfileUploaded = "No";
                if (!util_1.isNullOrUndefined(files) && files.length > 0) {
                    isfileUploaded = "Yes";
                    for (let file of files) {
                        if (!util_1.isNullOrUndefined(file['path']) && file['path'] !== '') {
                            file = yield this.s3UploadDoc(file, input, true);
                            if (file.status == 1) {
                                throw JSON.stringify(file['message']);
                            }
                        }
                    }
                }
                output['fileChangePath'] = util_1.isNullOrUndefined(files) ? [] : files;
                output['isfileUploaded'] = isfileUploaded;
                console.log("Socket triggering to Upload Scan Document");
                return { message: "Socket triggering to Copy Document from src to dest folder in S3", status: 0, data: output };
            }
            catch (err) {
                console.error("<----- Error in copyDocumentInS3Folder BOt ---------->>", err);
                return { message: err, status: 1, data: err };
            }
        });
    }
    s3UploadDoc(file, desPath, flag) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try { ///dms/subscriberId_fileName.extension
                let filePath = file['path'];
                let fileName = this.Split(filePath, "_", null);
                let dstKeyName = desPath.folderPath + fileName;
                return new Promise((resolve, reject) => {
                    const s3Config = {
                        'accessKeyId': config.S3_Configuration.accessKeyId,
                        'secretAccessKey': config.S3_Configuration.secretAccessKey,
                        'endpoint': config.S3_Configuration.endpoint,
                        'signatureVersion': config.S3_Configuration.signatureVersion,
                        'region': config.S3_Configuration.region,
                        'Bucket': config.S3_Configuration.Bucket,
                        'ACL': config.S3_Configuration.ACL,
                    };
                    aws.config.update({ accessKeyId: s3Config.accessKeyId, secretAccessKey: s3Config.secretAccessKey });
                    const s3 = new aws.S3({
                        endpoint: s3Config.endpoint,
                        signatureVersion: s3Config.signatureVersion,
                        region: s3Config.region,
                        ACL: s3Config.ACL
                    });
                    if (flag) {
                        let sourceBucket = config.S3_Configuration.srcBucket;
                        let srcKey = filePath;
                        let destBucket = s3Config.Bucket;
                        let destKey = dstKeyName;
                        const copyParams = {
                            CopySource: sourceBucket + '/' + srcKey,
                            Bucket: destBucket,
                            Key: destKey
                        };
                        s3.copyObject(copyParams, function (awsError, awsResp) {
                            if (!awsError) {
                                console.log("<<<---- File Copied from srcKey to DstKey on S3 Server --->>> ", destKey);
                                file["dstPath"] = destKey;
                                resolve({ message: 'File Copied from srcKey to DstKey on S3 Server', status: 0, data: file });
                            }
                            else {
                                resolve({ message: awsError, status: 1, data: null });
                            }
                        });
                    }
                    else {
                        let sourceBucket = config.S3_Configuration.srcBucket;
                        let srcKey = filePath;
                        const deleteParams = {
                            Bucket: sourceBucket,
                            Key: srcKey
                        };
                        s3.deleteObject(deleteParams, function (awsError, awsResp) {
                            if (!awsError) {
                                resolve({ info: 'File delete from srcKey on S3 Server', status: 0, data: srcKey });
                            }
                            else {
                                throw awsError;
                            }
                        });
                    }
                });
            }
            catch (err) {
                return { message: 'File Failed to copy/Delete from srcKey to DstKey on S3 Server', status: 1, data: err };
            }
        });
    }
    deleteDocumentInS3Folder(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info('<--------- Entered into deleteDocumentInS3Folder Bot ------------->');
            try {
                console.log("Input data Delete Bot--->>>>=======>>>   ", JSON.stringify(input));
                let files = yield dms_1.dms.aggregate([
                    {
                        "$match": {
                            "taskId": ObjectId(input.eventId),
                        }
                    },
                    {
                        "$unwind": {
                            "path": "$versions",
                            "includeArrayIndex": "arrayIndex",
                            "preserveNullAndEmptyArrays": false
                        }
                    },
                    {
                        "$project": {
                            "path": "$versions.path"
                        }
                    }
                ]).allowDiskUse(true);
                if (!util_1.isNullOrUndefined(files) && files.length > 0) {
                    for (let file of files) {
                        if (!util_1.isNullOrUndefined(file['path']) && file['path'] !== '') {
                            file = yield this.s3UploadDoc(file, input, false);
                        }
                    }
                }
                output['filePath'] = util_1.isNullOrUndefined(files) ? [] : files;
                console.log("Socket triggering to Delete Document from S3");
                return { message: "Socket triggering to Delete Document from folder in S3", status: 0, data: output };
            }
            catch (err) {
                console.error("<----- Error in deleteDocumentInS3Folder BOt ---------->>", err);
                return { message: err, status: 1, data: err };
            }
        });
    }
    decisionMakingBot(body, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info("Entered into decisionMakigBot Input----->>>>===>> ");
            try {
                //const url = env.dbConfig.mongodb_uri;
                let queryOne = eventStatus_1.eventStatus.findOne({ "eventId": body.eventId, "botId": body.botId, "iterationId": iterationId, "projectId": ObjectId(projectId) });
                console.log(queryOne);
                // let botIdOne = queryOne['successor'][0];
                //const url = "mongodb://server:server@13.126.25.110:27017/cuda-testing";
                const url = env_2.env.dbConfig.mongodb_uri;
                const mClient = yield MongoClient.connect(url);
                //const db = mClient.db("cuda-testing");
                const db = mClient.db(env_2.env.dbConfig.dbname);
                let fields = [];
                let avg = 0;
                let totalAvg = 0;
                if (!util_1.isNullOrUndefined(body.documentType) && !util_1.isNullOrUndefined(body.fileRefNum)) {
                    let query = { "documentType": body.documentType };
                    let queResult = yield db.collection('scanningfields').findOne(query);
                    console.log("queResult ===>--->>", JSON.stringify(queResult));
                    if (!util_1.isNullOrUndefined(queResult)) {
                        queResult.fields.forEach((row, i) => {
                            if (row.required == true) {
                                fields.push(row.fieldName);
                            }
                        });
                    }
                    let queryTwo = { "referenceNumber": body.fileRefNum };
                    //let queryTwo = {"referenceNumber" : "File539184c2026e8bc59d739acf4b06f6e9"};
                    let queResTwo = yield db.collection(body.documentType).findOne(queryTwo);
                    console.log(JSON.stringify(queResTwo));
                    if (!util_1.isNullOrUndefined(queResTwo)) {
                        fields = fields.filter((row, i) => {
                            if (util_1.isNullOrUndefined(queResTwo[row]) || queResTwo[row] == "") {
                                return row;
                            }
                        });
                        queResTwo['prediction'].forEach((row, i) => {
                            row['ml'] = row['ml'].replace("%", "").trim();
                            avg = avg + Number(row.ml);
                        });
                        console.log("Avg ===>>-->", avg);
                        totalAvg = avg / queResTwo['prediction'].length;
                        console.log("totalAvg ===>> ", totalAvg);
                    }
                    if (!util_1.isNullOrUndefined(queResTwo['invoiceItems']) && !util_1.isNullOrUndefined(queResTwo['invoiceItems'].length) && queResTwo['invoiceItems'].length > 0) {
                        if (fields.length > 0) {
                            if (totalAvg < 80) {
                                let update = { "$set": { "isException": true, "avgPrediction": totalAvg } };
                                let queRes = yield db.collection(body.documentType).findOneAndUpdate(queryTwo, update);
                                console.log(JSON.stringify(queRes));
                                return { info: 'Decision Made Successfully', status: 0, data: true };
                            }
                            else {
                                let update = { "$set": { "isException": false, "avgPrediction": totalAvg } };
                                let queRes = yield db.collection(body.documentType).findOneAndUpdate(queryTwo, update);
                                console.log(JSON.stringify(queRes));
                                return { info: 'Decision Made Successfully', status: 0, data: false };
                            }
                        }
                        else {
                            if (totalAvg < 80) {
                                let update = { "$set": { "isException": true, "avgPrediction": totalAvg } };
                                let queRes = yield db.collection(body.documentType).findOneAndUpdate(queryTwo, update);
                                console.log(JSON.stringify(queRes));
                                return { info: 'Decision Made Successfully', status: 0, data: true };
                            }
                            else {
                                let update = { "$set": { "isException": false, "avgPrediction": totalAvg } };
                                let queRes = yield db.collection(body.documentType).findOneAndUpdate(queryTwo, update);
                                console.log(JSON.stringify(queRes));
                                return { info: 'Decision Made Successfully', status: 0, data: false };
                            }
                        }
                    }
                    else {
                        let update = { "$set": { "isException": true, "avgPrediction": totalAvg } };
                        let queRes = yield db.collection(body.documentType).findOneAndUpdate(queryTwo, update);
                        console.log(JSON.stringify(queRes));
                        return { info: 'Decision Made Successfully', status: 0, data: true };
                    }
                }
                else {
                    return { info: 'Decision not made due to body is incomplete', status: 1, data: [] };
                }
            }
            catch (err) {
                console.log("err ===>>>---->>>==>> ", err);
                return { info: 'Decision not made due to error', status: 1, data: err };
            }
        });
    }
    uploadScanDocument(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log('inputinput ------> ', input);
                let filePaths = JSON.parse(input.filePath);
                let obj = {
                    "filePath": filePaths[iterationId],
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "type": input.type,
                    "documentType": !util_1.isNullOrUndefined(input.documentType) ? input.documentType : '',
                    "from": 'uploadScanDocument',
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Socket triggering to Upload Scan Document");
                return { message: 'Socket triggering to Upload Scan Document', status: 0, data: null };
            }
            catch (e) {
                this.log.error("Error in Socket triggering for Uploading Scan Document" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    readCSV(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            // let csvFilePath = input.path;
            const csvFilePath = input.path;
            const csv = require('csvtojson');
            yield csv()
                .fromFile(csvFilePath)
                .then((jsonObj) => {
                console.log(jsonObj);
                output['jsonData'] = jsonObj;
            });
            let jsonPath = input.path.replace('.csv', '.json');
            yield fs.writeFileSync(jsonPath, JSON.stringify(output['jsonData']), function (err) {
                if (err)
                    throw err;
                console.log('Written file');
            });
            output['jsonData'] = jsonPath;
            return { status: 0, "message": 'File read successfull', data: output };
        });
    }
    isEqualDate(d1, d2) {
        console.log('Date Check==>', d1, '---', d2);
        let first_date = new Date(d1);
        let second_date = new Date(d2);
        if (first_date.getTime() == second_date.getTime()) {
            console.log("---Matched Date----");
            return true;
        }
        else if (isNaN(first_date.getTime()) && d1.split('-').length == 3) {
            d1 = d1.split('-0').join('-');
            let ds = d1.split('-');
            let dt2 = d2;
            for (let i = 0; i < ds.length; i++) {
                if (dt2.includes(ds[i]))
                    dt2 = dt2.replace(ds[i], '');
                else
                    return false;
            }
            return true;
        }
        return false;
    }
    uploadDocumentDMSBot(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let self = this;
                let fileName = input.filePath;
                if (Array.isArray(input.filePath)) {
                    input.filePath = input.filePath[iterationId].split("/");
                }
                else {
                    input.filePath = input.filePath.split("/");
                }
                let versions = [];
                var dstFilePath;
                let accCtrl;
                if (!util_1.isNullOrUndefined(input.accessContol) && input.accessContol) {
                    input.accessContol = typeof (input.accessContol) == 'string' ? JSON.parse(input.accessContol) : input.accessContol;
                    accCtrl = input.accessContol[iterationId]['accessContol'];
                }
                else if (!util_1.isNullOrUndefined(input.userId)) {
                    accCtrl = [
                        {
                            "refId": input.userId,
                            "controlName": "",
                            "type": "users",
                            "permissions": {
                                "add": true,
                                "edit": true,
                                "view": true,
                                "execute": true
                            }
                        }
                    ];
                }
                if (!util_1.isNullOrUndefined(input.versionPath)) {
                    if (input.isServer == "false") {
                        const file = fs.readFileSync(fileName);
                        const base64data = Buffer.from(file, "base64");
                        dstFilePath = input.versionPath + input.subscriberId + "/" + input.directoryName + "/" + input.filePath[input.filePath.length - 1];
                        yield this.putObjectInS3(base64data, dstFilePath);
                        fileName = dstFilePath;
                    }
                    else {
                        if (input.check == 'Tawazun') {
                            dstFilePath = input.versionPath + fileName.substring(fileName.indexOf(input.popFrom));
                        }
                        else {
                            dstFilePath = input.versionPath + input.filePath[input.filePath.length - 1];
                        }
                    }
                }
                if (!util_1.isNullOrUndefined(input.vr)) {
                    input.vr = typeof (input.vr) == 'string' ? JSON.parse(input.vr) : input.vr;
                    let vr = input.vr[iterationId]['version'];
                    if (!util_1.isNullOrUndefined(vr) && vr !== '') {
                        let x = "File_" + Math.floor((Math.random() * 1000000) + 9999999) + "_";
                        let fN = input.filePath[input.filePath.length - 1];
                        let newPath = config.cudapath + x + fN;
                        console.log(newPath);
                        fs.copyFileSync(fileName, newPath);
                        let vrArr = yield db.collection('documents').findOne({ name: vr }, { versions: 1 });
                        vrArr = JSON.parse(JSON.stringify(vrArr));
                        if (input.vr[iterationId]['replace']) {
                            let doc = yield db.collection('documents').findOne({ name: vr });
                            doc = JSON.parse(JSON.stringify(doc));
                            let vers = doc['versions'];
                            vers[vers.length - 1] = {
                                createdAt: new Date(),
                                updatedAt: new Date(),
                                path: newPath,
                                isServer: true,
                                versionNumber: vrArr.versions.length - 1,
                                _id: ObjectId()
                            };
                            let newDocs = yield db.collection('documents').updateOne({ name: vr }, {
                                $set: {
                                    versions: vers
                                }
                            });
                            output['outputData'] = newDocs;
                            output['refNo'] = input.fileRefNum;
                            return { message: 'Socket triggering to Upload Scan Document', status: 0, data: output };
                        }
                        let newDocs = yield db.collection('documents').updateOne({ name: vr }, {
                            $push: {
                                versions: {
                                    createdAt: new Date(),
                                    updatedAt: new Date(),
                                    path: newPath,
                                    isServer: true,
                                    versionNumber: vrArr.versions.length,
                                    _id: ObjectId() // MongoDB will generate a unique ObjectId
                                }
                            }
                        });
                        output['outputData'] = newDocs;
                        output['refNo'] = input.fileRefNum;
                        return { message: 'Socket triggering to Upload Scan Document', status: 0, data: output };
                    }
                }
                let x = "File_" + Math.floor((Math.random() * 1000000) + 9999999) + "_";
                let fN = input.filePath[input.filePath.length - 1];
                // fN = fN.length > 15 ? fN.split('_')[fN.split('_').length - 1] : fN;
                let newPath = config.cudapath + x + fN;
                console.log("Users  ", dstFilePath, "   FileName ---   ", input.filePath[input.filePath.length - 1]);
                if (util_1.isNullOrUndefined(dstFilePath)) {
                    fs.copyFileSync(fileName, newPath);
                    versions.push({ "path": newPath, isServer: true, createdAt: new Date(), updatedAt: new Date() });
                }
                else {
                    versions.push({ "path": dstFilePath, createdAt: new Date(), updatedAt: new Date() });
                }
                // fs.rename(fileName, config.cudapath + x + input.filePath[input.filePath.length - 1], (err) => {
                //     if (err) throw err
                //     console.log('Successfully renamed - AKA moved!')
                // })
                if (util_1.isNullOrUndefined(input.fileRefNum) || input.fileRefNum.length === 0) {
                    let refRes = yield self.getReferenceNumber(input, output, botId, projectId, iterationId);
                    let refNum = refRes['refNo'];
                    input.fileRefNum = refNum;
                }
                console.log(JSON.stringify(versions));
                if (!util_1.isNullOrUndefined(fileName) && fileName !== "") {
                    let body = {
                        name: x + fN,
                        directoryName: input.directoryName,
                        isServer: true,
                        projectId: projectId,
                        processId: input.processId,
                        taskId: input.eventId,
                        fileRefNum: input.fileRefNum,
                        versions: versions,
                        documentType: input.documentType ? input.documentType : null,
                        showConfidanceLevel: (!util_1.isNullOrUndefined(input.showConfidanceLevel)) ? input.showConfidanceLevel : false,
                        userPermissions: accCtrl
                    };
                    let headerParams = {
                        userId: input.userId,
                        subscriberId: input.subscriberId,
                        orgId: input.orgId
                    };
                    if (["true", true].includes(input.addParentTaskId)) { // for getting all files under one parentEventId
                        let eventData = yield event_1.event.findOne({ _id: ObjectId(input.eventId) }).lean();
                        eventData = JSON.parse(JSON.stringify(eventData));
                        input.parentEventId = eventData['parentEventId'];
                        body['parentTaskId'] = input.parentEventId;
                    }
                    const newDocs = yield this.dmsServices.uploadDocument(body, headerParams);
                    output['outputData'] = newDocs;
                    output['refNo'] = input.fileRefNum;
                    return { message: 'Socket triggering to Upload Scan Document', status: 0, data: output };
                }
                else {
                    return { message: "Document Couldnot be Copied as Scan Document with name Empty is Store", status: 1, data: output };
                }
            }
            catch (e) {
                this.log.error("Error in Socket triggering for Uploading Scan Document" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    putObjectInS3(base64data, dstKeyName) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const s3Config = {
                    'accessKeyId': config.S3_Configuration.accessKeyId,
                    'secretAccessKey': config.S3_Configuration.secretAccessKey,
                    'endpoint': config.S3_Configuration.endpoint,
                    'signatureVersion': config.S3_Configuration.signatureVersion,
                    "region": config.S3_Configuration.region,
                    "Bucket": config.S3_Configuration.Bucket,
                    'ACL': config.S3_Configuration.ACL,
                };
                aws.config.update({ accessKeyId: s3Config.accessKeyId, secretAccessKey: s3Config.secretAccessKey });
                const s3 = new aws.S3({
                    endpoint: s3Config.endpoint,
                    signatureVersion: s3Config.signatureVersion,
                    region: s3Config.region,
                    ACL: s3Config.ACL
                });
                s3.putObject({
                    Bucket: s3Config.Bucket,
                    Key: dstKeyName,
                    Body: base64data,
                    ACL: s3Config.ACL
                }, function (awsError, awsResp) {
                    if (!awsError) {
                        console.log(awsResp);
                        resolve({ data: dstKeyName });
                    }
                });
            });
        });
    }
    findByPanNo(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!util_1.isNullOrUndefined(input.panNo) && input.panNo !== "") {
                    console.log('inputinput ------> ', input);
                    let panNo = input.panNo;
                    let userData = yield User_1.UserModel.findOne({ 'personalInfo.panNumber': panNo });
                    if (!util_1.isNullOrUndefined(userData)) {
                        let finalData1 = Object.assign(JSON.parse(JSON.stringify(userData.personalInfo)), JSON.parse(JSON.stringify(userData.address)));
                        output['userFound'] = true;
                        output['data'] = JSON.parse(JSON.stringify(finalData1));
                    }
                    else {
                        output['userFound'] = false;
                    }
                    return { message: 'Data Found Sucessfull', status: 0, data: output };
                }
                else {
                    return { message: 'Please Give Pan Number', status: 1, data: output };
                }
            }
            catch (e) {
                this.log.error("Error in Finding User Data" + e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    uploadDMSDocuments(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                input.projectId = projectId;
                const data = yield this.dmsServices.createDMSStucture(input);
                if (data['status'] === 0) {
                    output['outputData'] = JSON.stringify(data.data);
                    this.log.info('Documents Uploaded Successfully');
                    return { message: data['info'], status: data['status'], data: output };
                }
                else {
                    this.log.warn(data['info']);
                    throw data['info'];
                }
            }
            catch (e) {
                this.log.error("Error in Uploading documents" + e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    misJsonFormattedBot(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let d = JSON.parse(input.InputData);
                let temp = [];
                if (!util_1.isNullOrUndefined(d) && d.length > 0) {
                    d.forEach((list) => {
                        let obj = {};
                        let keys = Object.keys(list);
                        keys.forEach((row) => {
                            // let oldKey = row;
                            // let newKey = row.replace(/[`~!@#$%^&*()_|+\-=÷¿?;:'",. <>\{\}\[\]\\\/]/gi, '');
                            // obj[newKey] = list[oldKey];
                            let oldKey = row;
                            let name = row.replace(/[`~!@#$%^&*()_|+\-=÷¿?;:'",. <>\{\}\[\]\\\/]/gi, '');
                            let newKey = name.toLowerCase().replace(/\b[a-z]/g, function (letter) {
                                return letter.toLowerCase();
                            });
                            name = newKey;
                            obj[name] = list[oldKey];
                        });
                        temp.push(obj);
                    });
                }
                output['FormatedData'] = JSON.parse(JSON.stringify(temp));
                return { message: '', status: 0, data: output };
            }
            catch (e) {
                return { message: '', status: 1, data: e };
            }
        });
    }
    smsBot(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let obj = [];
            let authkey = input.authkey;
            let MobNo = input.MobNo;
            obj.push(MobNo);
            this.log.info('Inside send message bot - Mobile no - ' + MobNo);
            let msg = input.msg;
            let senderID = input.senderID;
            let route = input.route;
            let dialCode = input.dialCode;
            try {
                let response = msg91.sendOne(authkey, obj, msg, senderID, route, dialCode, function (response) {
                    return response;
                });
                output['messageId'] = '';
                if (!util_1.isNullOrUndefined(response)) {
                    output['messageId'] = response;
                    this.log.info('Message send successfully');
                }
                return ({ message: "message sent successfully", status: 0, data: output });
            }
            catch (e) {
                this.log.error('Failed in message send bot - ' + e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    twoWayReConciliationOld(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let masterInvdata = [];
                let pOrder = [];
                let invData = [];
                // const url = 'mongodb://scan-dev.gibots.com:27017/blueocean-dev';
                //const url = env_1.env.blueDBConfig.mongodb_uri;
                //const mClient = await MongoClient.connect(url);
                //const db = mClient.db('blueocean-dev');
                const url = env_1.env.dbConfig.mongodb_uri;
                const mClient = yield MongoClient.connect(url);
                const db = mClient.db(env_1.env.dbConfig.dbname);
                if (!util_1.isNullOrUndefined(input.referenceNumber) && input.referenceNumber !== "") {
                    let refNum = input.referenceNumber;
                    let invNumData = yield db.collection('Procuretopay_Recon').findOne({ referenceNumber: refNum });
                    if (!util_1.isNullOrUndefined(invNumData) && !util_1.isNullOrUndefined(invNumData['Original_Ref_Number']) && invNumData['Original_Ref_Number'] !== '') {
                        let poInvNum = invNumData['Original_Ref_Number'];
                        let poInvNumData = yield db.collection('Procuretopay_Recon').findOne({ Invoice_DC_Number: poInvNum });
                        console.log("poInvNumData", poInvNumData);
                        pOrder = JSON.parse(JSON.stringify(poInvNumData['invoiceItems']));
                        invData = JSON.parse(JSON.stringify(invNumData['invoiceItems']));
                        pOrder.forEach((list) => {
                            let data = {};
                            let info = invData.find((res) => {
                                return list.productName.toLowerCase().trim() == res.productName.toLowerCase().trim();
                            });
                            data['poNum'] = poInvNumData.Invoice_DC_Number;
                            data['invNum'] = invNumData.Invoice_DC_Number;
                            if (info) {
                                data['rproductName'] = info.productName;
                                data['productName'] = info.productName;
                                data['poProductName'] = list.productName;
                                data['poProductNameFlag'] = false;
                                invData = _.without(invData, _.findWhere(invData, { productName: info.productName }));
                                if (list.qty == info['qty']) {
                                    data['rqty'] = info['qty'];
                                    data['poQty'] = list.qty;
                                    data['rqtyFlag'] = false;
                                }
                                else {
                                    data['rqty'] = info['qty'];
                                    data['poQty'] = list.qty;
                                    data['rqtyFlag'] = true;
                                }
                                if (list.rate == info['rate']) {
                                    data['rrate'] = info['rate'];
                                    data['poRate'] = list.rate;
                                    data['poRateFlag'] = false;
                                }
                                else {
                                    data['rrate'] = info['rate'];
                                    data['poRate'] = list.rate;
                                    data['poRateFlag'] = true;
                                }
                                if (list.itemAmt == info['itemAmt']) {
                                    data['ritemAmt'] = info['itemAmt'];
                                    data['poItemAmt'] = list.itemAmt;
                                    data['poItemAmtFlag'] = false;
                                }
                                else {
                                    data['ritemAmt'] = info['itemAmt'];
                                    data['poItemAmt'] = list.itemAmt;
                                    data['poItemAmtFlag'] = true;
                                }
                            }
                            else {
                                data['rproductName'] = '';
                                data['productName'] = '';
                                data['poProductName'] = list.productName;
                                data['poProductNameFlag'] = true;
                                data['rqty'] = '';
                                data['poQty'] = list.qty;
                                data['rqtyFlag'] = true;
                                data['rrate'] = '';
                                data['poRate'] = list.rate;
                                data['poRateFlag'] = true;
                                data['ritemAmt'] = '';
                                data['poItemAmt'] = list.itemAmt;
                                data['poItemAmtFlag'] = true;
                            }
                            masterInvdata.push(data);
                        });
                        invData.forEach((list) => {
                            let data = {};
                            data['poNum'] = poInvNumData.Invoice_DC_Number;
                            data['invNum'] = invNumData.Invoice_DC_Number;
                            data['rproductName'] = list.productName;
                            data['productName'] = list.productName;
                            data['poProductName'] = '';
                            data['poProductNameFlag'] = true;
                            data['rqty'] = list.qty;
                            data['poQty'] = '';
                            data['rqtyFlag'] = true;
                            data['rrate'] = list.rate;
                            data['poRate'] = '';
                            data['poRateFlag'] = true;
                            data['ritemAmt'] = list.itemAmt;
                            data['poItemAmt'] = '';
                            data['poItemAmtFlag'] = true;
                            masterInvdata.push(data);
                        });
                        output['outputData'] = JSON.stringify(masterInvdata);
                        db.collection("TwoWayRecon").insertOne(masterInvdata[0]);
                        return { message: 'Data Found Sucessfull', status: 0, data: output };
                    }
                    else {
                        return { message: 'Data Not Found Sucessfull', status: 1, data: output };
                    }
                }
                else {
                    return { message: 'Please Give Pan Number', status: 1, data: output };
                }
            }
            catch (e) {
                this.log.error("Error in Finding User Data" + e);
                return {
                    message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' +
                        projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']'
                };
            }
        });
    }
    invoiceAutomationTwoOrThreeWayChecking(input, output = {}, botid, projectid, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let eventId = input.eventId;
                // let executedEvents =  await (db.collection('events')).find({ parentEventId: ObjectId(eventId) },{additionalInfoVar:1}).lean();
                let originalEventId = yield (db.collection("events")).findOne({ _id: ObjectId(eventId) }, { additionalInfoVar: 1 }).lean();
                let filePathArr = originalEventId.additionalInfoVar.filePathArr;
                // let subProcessFileNames = executedEvents.map(item=>item.additionalInfoVar.orgfilePath) 
                filePathArr = typeof filePathArr == "string" ? JSON.parse(filePathArr) : filePathArr;
                let typeOfFiles = filePathArr.map(item => item.substring(item.lastIndexOf("/") + 1, item.indexOf("_")));
                typeOfFiles = [...new Set(typeOfFiles)];
                if (typeOfFiles.length == 0 || typeOfFiles.length == 1) {
                    output['flow_way'] = 'no';
                    return {
                        message: "Files are not sufficient to process", status: 0, data: output
                    };
                }
                else if (typeOfFiles.length == 2) {
                    output['flow_way'] = 'two_way';
                    return {
                        message: "Two Way Reconciliation", status: 0, data: output
                    };
                }
                else if (typeOfFiles.length == 3) {
                    output['flow_way'] = 'three_way';
                    return {
                        message: "Three Way Reconciliation", status: 0, data: output
                    };
                }
                output['flow_way'] = 'no';
                return {
                    message: "Someyhing Went Wring", status: 0, data: output
                };
            }
            catch (e) {
                this.log.error("Error in Finding User Data" + e);
                return {
                    message: e, status: 1, data: []
                };
            }
        });
    }
    twoWayReConciliation(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let masterInvdata = [];
                let pOrder = [];
                let invData = [];
                let docType = input.docType;
                let invRef = input.inv_ref_no ? input.inv_ref_no : "";
                let poRef = input.po_ref_no ? input.po_ref_no : "";
                let grnRef = input.grn_ref_no ? input.grn_ref_no : "";
                let matchKey = input.matchKey ? input.matchKey : "Description";
                let rateKey = input.rateKey ? input.rateKey : "Rate";
                let qtyKey = input.qtyKey ? input.qtyKey : "Quantity";
                let amtKey = input.amtKey ? input.amtKey : "Amount";
                console.log("Input ---", input, matchKey, rateKey, qtyKey, amtKey);
                // if (!isNullOrUndefined(invRef) && invRef !== "" && !isNullOrUndefined(poRef) && poRef !== "" && !isNullOrUndefined(grnRef) && grnRef !== "") {
                let invNumData;
                let poInvNumData;
                if (invRef != "" && poRef != "" && grnRef == "") {
                    invNumData = yield (db.collection(docType)).findOne({ referenceNumber: invRef }).lean();
                    poInvNumData = yield (db.collection(docType)).findOne({ referenceNumber: poRef }).lean();
                    if (invNumData.PO_Number != poInvNumData.PO_Number) {
                        output['flow'] = "no";
                        return { message: 'Data Found Sucessfull', status: 0, data: output };
                    }
                }
                else if (invRef == "" && poRef != "" && grnRef != "") {
                    invNumData = yield (db.collection(docType)).findOne({ referenceNumber: grnRef }).lean();
                    poInvNumData = yield (db.collection(docType)).findOne({ referenceNumber: poRef }).lean();
                    if (invNumData.PO_Number != poInvNumData.PO_Number) {
                        output['flow'] = "no";
                        return { message: 'Data Found Sucessfull', status: 0, data: output };
                    }
                }
                else if (invRef != "" && poRef == "" && grnRef != "") {
                    invNumData = yield (db.collection(docType)).findOne({ referenceNumber: invRef }).lean();
                    poInvNumData = yield (db.collection(docType)).findOne({ referenceNumber: grnRef }).lean();
                    if (invNumData.PO_Number != poInvNumData.PO_Number) {
                        if (invNumData.Invoice_Number != poInvNumData.Invoice_Number) {
                            output['flow'] = "no";
                            return { message: 'Data Found Sucessfull', status: 0, data: output };
                        }
                    }
                }
                console.log("poInvNumData", poInvNumData);
                pOrder = JSON.parse(JSON.stringify(poInvNumData['multiTable'][0]['Invoice_Items']));
                invData = JSON.parse(JSON.stringify(invNumData['multiTable'][0]['Invoice_Items']));
                let tempTable = JSON.parse(JSON.stringify(invNumData['multiTable'][0]['Invoice_Items']));
                let tempPo = JSON.parse(JSON.stringify(poInvNumData['multiTable'][0]['Invoice_Items']));
                let rObj = {};
                if (pOrder.length == invData.length || pOrder.length < invData.length) {
                    pOrder.forEach((list) => {
                        let data = {};
                        let info = tempTable.find((res) => {
                            return list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase());
                        });
                        if (util_1.isNullOrUndefined(info) && list[matchKey] && tempTable.length) {
                            let mats = tempTable.map(a => a[matchKey].toLowerCase());
                            let match = stringSimilarity.findBestMatch(list[matchKey].toLowerCase(), mats);
                            console.log(`---------match -------`, list[matchKey].toLowerCase(), '------------', match);
                            if (!util_1.isNullOrUndefined(match.bestMatchIndex)) {
                                info = tempTable[match.bestMatchIndex];
                                tempTable.splice(match.bestMatchIndex, 1);
                            }
                        }
                        else {
                            tempTable = tempTable.filter(res => !(list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase())));
                        }
                        data['poNum'] = poInvNumData.PO_Number;
                        data['invNum'] = invNumData.Invoice_Number;
                        rObj['poNum'] = poInvNumData.PO_Number;
                        rObj['invNum'] = invNumData.Invoice_Number;
                        list[qtyKey] = list[qtyKey] ? list[qtyKey].replace(/,/g, '') : '';
                        list[rateKey] = list[rateKey] ? list[rateKey].replace(/,/g, '') : '';
                        list[amtKey] = list[amtKey] ? list[amtKey].replace(/,/g, '') : '';
                        if (info) {
                            data['rproductName'] = info[matchKey];
                            data['productName'] = info[matchKey];
                            data['poProductName'] = list[matchKey];
                            data['poProductNameFlag'] = false;
                            invData = _.without(invData, _.findWhere(invData, { productName: info[matchKey] }));
                            info[qtyKey] = info[qtyKey] ? info[qtyKey].replace(/,/g, '') : '';
                            info[rateKey] = info[rateKey] ? info[rateKey].replace(/,/g, '') : '';
                            info[amtKey] = info[amtKey] ? info[amtKey].replace(/,/g, '') : '';
                            if (list[qtyKey] == info[qtyKey] || (!isNaN(list[qtyKey]) && String(parseFloat(list[qtyKey])) == String(parseFloat(info[qtyKey])))) {
                                data['rqty'] = info[qtyKey];
                                data['poQty'] = list[qtyKey];
                                data['poQtyFlag'] = false;
                            }
                            else {
                                data['rqty'] = info[qtyKey];
                                data['poQty'] = list[qtyKey];
                                data['poQtyFlag'] = true;
                            }
                            if (list[rateKey] == info[rateKey] || (!isNaN(list[rateKey]) && String(parseFloat(list[rateKey])) == String(parseFloat(info[rateKey])))) {
                                data['rrate'] = info[rateKey];
                                data['poRate'] = list[rateKey];
                                data['poRateFlag'] = false;
                            }
                            else {
                                data['rrate'] = info[rateKey];
                                data['poRate'] = list[rateKey];
                                data['poRateFlag'] = true;
                            }
                            if (list[amtKey] == info[amtKey] || (!isNaN(list[amtKey]) && String(parseFloat(list[amtKey])) == String(parseFloat(info[amtKey])))) {
                                data['ritemAmt'] = info[amtKey];
                                data['poItemAmt'] = list[amtKey];
                                data['poItemAmtFlag'] = false;
                            }
                            else {
                                data['ritemAmt'] = info[amtKey];
                                data['poItemAmt'] = list[amtKey];
                                data['poItemAmtFlag'] = true;
                            }
                        }
                        else {
                            data['rproductName'] = list[matchKey];
                            data['productName'] = list[matchKey];
                            data['poProductName'] = list[matchKey];
                            data['poProductNameFlag'] = true;
                            data['rqty'] = '';
                            data['poQty'] = list[qtyKey];
                            data['poQtyFlag'] = true;
                            data['rrate'] = '';
                            data['poRate'] = list[rateKey];
                            data['poRateFlag'] = true;
                            data['ritemAmt'] = '';
                            data['poItemAmt'] = list[amtKey];
                            data['poItemAmtFlag'] = true;
                        }
                        masterInvdata.push(JSON.parse(JSON.stringify(data)));
                    });
                    tempTable.forEach((list) => {
                        let data = rObj;
                        data['rproductName'] = list[matchKey];
                        data['productName'] = list[matchKey];
                        data['poProductName'] = list[matchKey];
                        data['poProductNameFlag'] = true;
                        data['rqty'] = list[qtyKey];
                        data['poQty'] = '';
                        data['poQtyFlag'] = true;
                        data['rrate'] = list[rateKey];
                        data['poRate'] = '';
                        data['poRateFlag'] = true;
                        data['ritemAmt'] = list[amtKey];
                        data['poItemAmt'] = '';
                        data['poItemAmtFlag'] = true;
                        masterInvdata.push(JSON.parse(JSON.stringify(data)));
                    });
                }
                else {
                    invData.forEach((list) => {
                        let data = {};
                        let info = tempPo.find((res) => {
                            return list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase());
                        });
                        if (util_1.isNullOrUndefined(info) && list[matchKey] && tempPo.length) {
                            let mats = tempPo.map(a => a[matchKey].toLowerCase());
                            let match = stringSimilarity.findBestMatch(list[matchKey].toLowerCase(), mats);
                            console.log(`---------match -------`, list[matchKey].toLowerCase(), '------------', match);
                            if (!util_1.isNullOrUndefined(match.bestMatchIndex)) {
                                info = tempPo[match.bestMatchIndex];
                                tempPo.splice(match.bestMatchIndex, 1);
                            }
                        }
                        else {
                            tempPo = tempPo.filter(res => !(list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase())));
                        }
                        data['poNum'] = poInvNumData.PO_Number;
                        data['invNum'] = invNumData.Invoice_Number;
                        rObj['poNum'] = poInvNumData.PO_Number;
                        rObj['invNum'] = invNumData.Invoice_Number;
                        list[qtyKey] = list[qtyKey] ? list[qtyKey].replace(/,/g, '') : '';
                        list[rateKey] = list[rateKey] ? list[rateKey].replace(/,/g, '') : '';
                        list[amtKey] = list[amtKey] ? list[amtKey].replace(/,/g, '') : '';
                        if (info) {
                            let t1 = info ? JSON.parse(JSON.stringify(info)) : info;
                            let t2 = list ? JSON.parse(JSON.stringify(list)) : list;
                            info = t2;
                            list = t1;
                            data['rproductName'] = info[matchKey];
                            data['productName'] = info[matchKey];
                            data['poProductName'] = list[matchKey];
                            data['poProductNameFlag'] = false;
                            invData = _.without(invData, _.findWhere(invData, { productName: info[matchKey] }));
                            info[qtyKey] = info[qtyKey] ? info[qtyKey].replace(/,/g, '') : '';
                            info[rateKey] = info[rateKey] ? info[rateKey].replace(/,/g, '') : '';
                            info[amtKey] = info[amtKey] ? info[amtKey].replace(/,/g, '') : '';
                            list[qtyKey] = list[qtyKey] ? list[qtyKey].replace(/,/g, '') : '';
                            list[rateKey] = list[rateKey] ? list[rateKey].replace(/,/g, '') : '';
                            list[amtKey] = list[amtKey] ? list[amtKey].replace(/,/g, '') : '';
                            if (list[qtyKey] == info[qtyKey] || (!isNaN(list[qtyKey]) && String(parseFloat(list[qtyKey])) == String(parseFloat(info[qtyKey])))) {
                                data['rqty'] = info[qtyKey];
                                data['poQty'] = list[qtyKey];
                                data['poQtyFlag'] = false;
                            }
                            else {
                                data['rqty'] = info[qtyKey];
                                data['poQty'] = list[qtyKey];
                                data['poQtyFlag'] = true;
                            }
                            if (list[rateKey] == info[rateKey] || (!isNaN(list[rateKey]) && String(parseFloat(list[rateKey])) == String(parseFloat(info[rateKey])))) {
                                data['rrate'] = info[rateKey];
                                data['poRate'] = list[rateKey];
                                data['poRateFlag'] = false;
                            }
                            else {
                                data['rrate'] = info[rateKey];
                                data['poRate'] = list[rateKey];
                                data['poRateFlag'] = true;
                            }
                            if (list[amtKey] == info[amtKey] || (!isNaN(list[amtKey]) && String(parseFloat(list[amtKey])) == String(parseFloat(info[amtKey])))) {
                                data['ritemAmt'] = info[amtKey];
                                data['poItemAmt'] = list[amtKey];
                                data['poItemAmtFlag'] = false;
                            }
                            else {
                                data['ritemAmt'] = info[amtKey];
                                data['poItemAmt'] = list[amtKey];
                                data['poItemAmtFlag'] = true;
                            }
                        }
                        else {
                            data['rproductName'] = list[matchKey];
                            data['productName'] = list[matchKey];
                            data['poProductName'] = list[matchKey];
                            data['poProductNameFlag'] = true;
                            data['rqty'] = list[qtyKey];
                            data['poQty'] = '';
                            data['poQtyFlag'] = true;
                            data['rrate'] = list[rateKey];
                            data['poRate'] = '';
                            data['poRateFlag'] = true;
                            data['ritemAmt'] = list[amtKey];
                            data['poItemAmt'] = '';
                            data['poItemAmtFlag'] = true;
                        }
                        masterInvdata.push(JSON.parse(JSON.stringify(data)));
                    });
                    tempPo.forEach((list) => {
                        let data = rObj;
                        data['rproductName'] = list[matchKey];
                        data['productName'] = list[matchKey];
                        data['poProductName'] = list[matchKey];
                        data['poProductNameFlag'] = true;
                        data['rqty'] = '';
                        data['poQty'] = list[qtyKey];
                        data['poQtyFlag'] = true;
                        data['rrate'] = '';
                        data['poRate'] = list[rateKey];
                        data['poRateFlag'] = true;
                        data['ritemAmt'] = '';
                        data['poItemAmt'] = list[amtKey];
                        data['poItemAmtFlag'] = true;
                        masterInvdata.push(JSON.parse(JSON.stringify(data)));
                    });
                }
                // invData.forEach((list) => {
                //     let data = {};
                //     data['poNum'] = poInvNumData.Invoice_Number;
                //     data['invNum'] = invNumData.Invoice_Number;
                //     data['rproductName'] = list[matchKey];
                //     data['productName'] = list[matchKey];
                //     data['poProductName'] = '';
                //     data['poProductNameFlag'] = true;
                //     data['rqty'] = list[qtyKey];
                //     data['poQty'] = '';
                //     data['rqtyFlag'] = true;
                //     data['rrate'] = list[rateKey];
                //     data['poRate'] = '';
                //     data['poRateFlag'] = true;
                //     data['ritemAmt'] = list[amtKey];
                //     data['poItemAmt'] = '';
                //     data['poItemAmtFlag'] = true;
                //     masterInvdata.push(data);
                // });
                output['outputData'] = JSON.stringify(masterInvdata);
                output['flow'] = "yes";
                yield (db.collection("TwoWayRecon")).create(masterInvdata[0]);
                return { message: 'Data Found Sucessfull', status: 0, data: output };
                // }
                // else {
                //     return { message: 'Please Give Pan Number', status: 1, data: output };
                // }
            }
            catch (e) {
                this.log.error("Error in Finding User Data" + e);
                return {
                    message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' +
                        projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']'
                };
            }
        });
    }
    twoWayReConciliation_bkp(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let masterInvdata = [];
                let pOrder = [];
                let invData = [];
                let docType = input.docType;
                let invRef = input.inv_ref_no;
                let poRef = input.po_ref_no;
                let matchKey = input.matchKey ? input.matchKey : "Description";
                let rateKey = input.rateKey ? input.rateKey : "Rate";
                let qtyKey = input.qtyKey ? input.qtyKey : "Quantity";
                let amtKey = input.amtKey ? input.amtKey : "Amount";
                console.log("Input ---", input, matchKey, rateKey, qtyKey, amtKey);
                if (!util_1.isNullOrUndefined(invRef) && invRef !== "" && !util_1.isNullOrUndefined(poRef) && poRef !== "") {
                    let invNumData = yield (db.collection(docType)).findOne({ referenceNumber: invRef }).lean();
                    let poInvNumData = yield (db.collection(docType)).findOne({ referenceNumber: poRef }).lean();
                    console.log("poInvNumData", poInvNumData);
                    pOrder = JSON.parse(JSON.stringify(poInvNumData['multiTable'][0]['Invoice_Items']));
                    invData = JSON.parse(JSON.stringify(invNumData['multiTable'][0]['Invoice_Items']));
                    let tempTable = JSON.parse(JSON.stringify(invNumData['multiTable'][0]['Invoice_Items']));
                    let tempPo = JSON.parse(JSON.stringify(poInvNumData['multiTable'][0]['Invoice_Items']));
                    let rObj = {};
                    if (pOrder.length == invData.length || pOrder.length < invData.length) {
                        pOrder.forEach((list) => {
                            let data = {};
                            let info = tempTable.find((res) => {
                                return list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase());
                            });
                            if (util_1.isNullOrUndefined(info) && list[matchKey] && tempTable.length) {
                                let mats = tempTable.map(a => a[matchKey].toLowerCase());
                                let match = stringSimilarity.findBestMatch(list[matchKey].toLowerCase(), mats);
                                console.log(`---------match -------`, list[matchKey].toLowerCase(), '------------', match);
                                if (!util_1.isNullOrUndefined(match.bestMatchIndex)) {
                                    info = tempTable[match.bestMatchIndex];
                                    tempTable.splice(match.bestMatchIndex, 1);
                                }
                            }
                            else {
                                tempTable = tempTable.filter(res => !(list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase())));
                            }
                            data['poNum'] = poInvNumData.PO_Number;
                            data['invNum'] = invNumData.Invoice_Number;
                            rObj['poNum'] = poInvNumData.PO_Number;
                            rObj['invNum'] = invNumData.Invoice_Number;
                            list[qtyKey] = list[qtyKey] ? list[qtyKey].replace(/,/g, '') : '';
                            list[rateKey] = list[rateKey] ? list[rateKey].replace(/,/g, '') : '';
                            list[amtKey] = list[amtKey] ? list[amtKey].replace(/,/g, '') : '';
                            if (info) {
                                data['rproductName'] = info[matchKey];
                                data['productName'] = info[matchKey];
                                data['poProductName'] = list[matchKey];
                                data['poProductNameFlag'] = false;
                                invData = _.without(invData, _.findWhere(invData, { productName: info[matchKey] }));
                                info[qtyKey] = info[qtyKey] ? info[qtyKey].replace(/,/g, '') : '';
                                info[rateKey] = info[rateKey] ? info[rateKey].replace(/,/g, '') : '';
                                info[amtKey] = info[amtKey] ? info[amtKey].replace(/,/g, '') : '';
                                if (list[qtyKey] == info[qtyKey] || (!isNaN(list[qtyKey]) && String(parseFloat(list[qtyKey])) == String(parseFloat(info[qtyKey])))) {
                                    data['rqty'] = info[qtyKey];
                                    data['poQty'] = list[qtyKey];
                                    data['poQtyFlag'] = false;
                                }
                                else {
                                    data['rqty'] = info[qtyKey];
                                    data['poQty'] = list[qtyKey];
                                    data['poQtyFlag'] = true;
                                }
                                if (list[rateKey] == info[rateKey] || (!isNaN(list[rateKey]) && String(parseFloat(list[rateKey])) == String(parseFloat(info[rateKey])))) {
                                    data['rrate'] = info[rateKey];
                                    data['poRate'] = list[rateKey];
                                    data['poRateFlag'] = false;
                                }
                                else {
                                    data['rrate'] = info[rateKey];
                                    data['poRate'] = list[rateKey];
                                    data['poRateFlag'] = true;
                                }
                                if (list[amtKey] == info[amtKey] || (!isNaN(list[amtKey]) && String(parseFloat(list[amtKey])) == String(parseFloat(info[amtKey])))) {
                                    data['ritemAmt'] = info[amtKey];
                                    data['poItemAmt'] = list[amtKey];
                                    data['poItemAmtFlag'] = false;
                                }
                                else {
                                    data['ritemAmt'] = info[amtKey];
                                    data['poItemAmt'] = list[amtKey];
                                    data['poItemAmtFlag'] = true;
                                }
                            }
                            else {
                                data['rproductName'] = list[matchKey];
                                data['productName'] = list[matchKey];
                                data['poProductName'] = list[matchKey];
                                data['poProductNameFlag'] = true;
                                data['rqty'] = '';
                                data['poQty'] = list[qtyKey];
                                data['poQtyFlag'] = true;
                                data['rrate'] = '';
                                data['poRate'] = list[rateKey];
                                data['poRateFlag'] = true;
                                data['ritemAmt'] = '';
                                data['poItemAmt'] = list[amtKey];
                                data['poItemAmtFlag'] = true;
                            }
                            masterInvdata.push(JSON.parse(JSON.stringify(data)));
                        });
                        tempTable.forEach((list) => {
                            let data = rObj;
                            data['rproductName'] = list[matchKey];
                            data['productName'] = list[matchKey];
                            data['poProductName'] = list[matchKey];
                            data['poProductNameFlag'] = true;
                            data['rqty'] = list[qtyKey];
                            data['poQty'] = '';
                            data['poQtyFlag'] = true;
                            data['rrate'] = list[rateKey];
                            data['poRate'] = '';
                            data['poRateFlag'] = true;
                            data['ritemAmt'] = list[amtKey];
                            data['poItemAmt'] = '';
                            data['poItemAmtFlag'] = true;
                            masterInvdata.push(JSON.parse(JSON.stringify(data)));
                        });
                    }
                    else {
                        invData.forEach((list) => {
                            let data = {};
                            let info = tempPo.find((res) => {
                                return list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase());
                            });
                            if (util_1.isNullOrUndefined(info) && list[matchKey] && tempPo.length) {
                                let mats = tempPo.map(a => a[matchKey].toLowerCase());
                                let match = stringSimilarity.findBestMatch(list[matchKey].toLowerCase(), mats);
                                console.log(`---------match -------`, list[matchKey].toLowerCase(), '------------', match);
                                if (!util_1.isNullOrUndefined(match.bestMatchIndex)) {
                                    info = tempPo[match.bestMatchIndex];
                                    tempPo.splice(match.bestMatchIndex, 1);
                                }
                            }
                            else {
                                tempPo = tempPo.filter(res => !(list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase())));
                            }
                            data['poNum'] = poInvNumData.PO_Number;
                            data['invNum'] = invNumData.Invoice_Number;
                            rObj['poNum'] = poInvNumData.PO_Number;
                            rObj['invNum'] = invNumData.Invoice_Number;
                            list[qtyKey] = list[qtyKey] ? list[qtyKey].replace(/,/g, '') : '';
                            list[rateKey] = list[rateKey] ? list[rateKey].replace(/,/g, '') : '';
                            list[amtKey] = list[amtKey] ? list[amtKey].replace(/,/g, '') : '';
                            if (info) {
                                let t1 = info ? JSON.parse(JSON.stringify(info)) : info;
                                let t2 = list ? JSON.parse(JSON.stringify(list)) : list;
                                info = t2;
                                list = t1;
                                data['rproductName'] = info[matchKey];
                                data['productName'] = info[matchKey];
                                data['poProductName'] = list[matchKey];
                                data['poProductNameFlag'] = false;
                                invData = _.without(invData, _.findWhere(invData, { productName: info[matchKey] }));
                                info[qtyKey] = info[qtyKey] ? info[qtyKey].replace(/,/g, '') : '';
                                info[rateKey] = info[rateKey] ? info[rateKey].replace(/,/g, '') : '';
                                info[amtKey] = info[amtKey] ? info[amtKey].replace(/,/g, '') : '';
                                list[qtyKey] = list[qtyKey] ? list[qtyKey].replace(/,/g, '') : '';
                                list[rateKey] = list[rateKey] ? list[rateKey].replace(/,/g, '') : '';
                                list[amtKey] = list[amtKey] ? list[amtKey].replace(/,/g, '') : '';
                                if (list[qtyKey] == info[qtyKey] || (!isNaN(list[qtyKey]) && String(parseFloat(list[qtyKey])) == String(parseFloat(info[qtyKey])))) {
                                    data['rqty'] = info[qtyKey];
                                    data['poQty'] = list[qtyKey];
                                    data['poQtyFlag'] = false;
                                }
                                else {
                                    data['rqty'] = info[qtyKey];
                                    data['poQty'] = list[qtyKey];
                                    data['poQtyFlag'] = true;
                                }
                                if (list[rateKey] == info[rateKey] || (!isNaN(list[rateKey]) && String(parseFloat(list[rateKey])) == String(parseFloat(info[rateKey])))) {
                                    data['rrate'] = info[rateKey];
                                    data['poRate'] = list[rateKey];
                                    data['poRateFlag'] = false;
                                }
                                else {
                                    data['rrate'] = info[rateKey];
                                    data['poRate'] = list[rateKey];
                                    data['poRateFlag'] = true;
                                }
                                if (list[amtKey] == info[amtKey] || (!isNaN(list[amtKey]) && String(parseFloat(list[amtKey])) == String(parseFloat(info[amtKey])))) {
                                    data['ritemAmt'] = info[amtKey];
                                    data['poItemAmt'] = list[amtKey];
                                    data['poItemAmtFlag'] = false;
                                }
                                else {
                                    data['ritemAmt'] = info[amtKey];
                                    data['poItemAmt'] = list[amtKey];
                                    data['poItemAmtFlag'] = true;
                                }
                            }
                            else {
                                data['rproductName'] = list[matchKey];
                                data['productName'] = list[matchKey];
                                data['poProductName'] = list[matchKey];
                                data['poProductNameFlag'] = true;
                                data['rqty'] = list[qtyKey];
                                data['poQty'] = '';
                                data['poQtyFlag'] = true;
                                data['rrate'] = list[rateKey];
                                data['poRate'] = '';
                                data['poRateFlag'] = true;
                                data['ritemAmt'] = list[amtKey];
                                data['poItemAmt'] = '';
                                data['poItemAmtFlag'] = true;
                            }
                            masterInvdata.push(JSON.parse(JSON.stringify(data)));
                        });
                        tempPo.forEach((list) => {
                            let data = rObj;
                            data['rproductName'] = list[matchKey];
                            data['productName'] = list[matchKey];
                            data['poProductName'] = list[matchKey];
                            data['poProductNameFlag'] = true;
                            data['rqty'] = '';
                            data['poQty'] = list[qtyKey];
                            data['poQtyFlag'] = true;
                            data['rrate'] = '';
                            data['poRate'] = list[rateKey];
                            data['poRateFlag'] = true;
                            data['ritemAmt'] = '';
                            data['poItemAmt'] = list[amtKey];
                            data['poItemAmtFlag'] = true;
                            masterInvdata.push(JSON.parse(JSON.stringify(data)));
                        });
                    }
                    // invData.forEach((list) => {
                    //     let data = {};
                    //     data['poNum'] = poInvNumData.Invoice_Number;
                    //     data['invNum'] = invNumData.Invoice_Number;
                    //     data['rproductName'] = list[matchKey];
                    //     data['productName'] = list[matchKey];
                    //     data['poProductName'] = '';
                    //     data['poProductNameFlag'] = true;
                    //     data['rqty'] = list[qtyKey];
                    //     data['poQty'] = '';
                    //     data['rqtyFlag'] = true;
                    //     data['rrate'] = list[rateKey];
                    //     data['poRate'] = '';
                    //     data['poRateFlag'] = true;
                    //     data['ritemAmt'] = list[amtKey];
                    //     data['poItemAmt'] = '';
                    //     data['poItemAmtFlag'] = true;
                    //     masterInvdata.push(data);
                    // });
                    output['outputData'] = JSON.stringify(masterInvdata);
                    yield (db.collection("TwoWayRecon")).create(masterInvdata[0]);
                    return { message: 'Data Found Sucessfull', status: 0, data: output };
                }
                else {
                    return { message: 'Please Give Pan Number', status: 1, data: output };
                }
            }
            catch (e) {
                this.log.error("Error in Finding User Data" + e);
                return {
                    message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' +
                        projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']'
                };
            }
        });
    }
    twoWayReConciliationNew(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let docType = input.docType;
                let collectionName = input.collectionName;
                let caseNo = input.caseNo;
                let keys = input.keys ? input.keys.split(',') : [];
                let recon = input.recon;
                console.log("Input ---->", input, docType, collectionName, caseNo, recon);
                console.log("Keys ---->", keys);
                function levenshtein(a, b) {
                    const m = a.length;
                    const n = b.length;
                    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
                    for (let i = 0; i <= m; i++) {
                        dp[i][0] = i;
                    }
                    for (let j = 0; j <= n; j++) {
                        dp[0][j] = j;
                    }
                    for (let i = 1; i <= m; i++) {
                        for (let j = 1; j <= n; j++) {
                            if (a[i - 1] === b[j - 1]) {
                                dp[i][j] = dp[i - 1][j - 1];
                            }
                            else {
                                dp[i][j] = Math.min(dp[i - 1][j] + 1, // deletion
                                dp[i][j - 1] + 1, // insertion
                                dp[i - 1][j - 1] + 1 // substitution
                                );
                            }
                        }
                    }
                    return dp[m][n];
                }
                function similarity(a, b) {
                    const distance = levenshtein(a, b);
                    const maxLen = Math.max(a.length, b.length);
                    return ((maxLen - distance) / maxLen) * 100;
                }
                let data = {};
                if (!util_1.isNullOrUndefined(caseNo) && caseNo !== "" && !util_1.isNullOrUndefined(collectionName) && collectionName !== "") {
                    let fromDocs = yield (db.collection(docType)).findOne({ DirName: caseNo }).lean();
                    let toDocs = yield (db.collection(collectionName)).findOne({ DirName: caseNo }).lean();
                    console.log("fromDocs:--->>>", fromDocs);
                    console.log("toDocs:--->>>", toDocs);
                    console.log("fromDocs.length " + !util_1.isNullOrUndefined(fromDocs));
                    console.log("toDocs.length " + !util_1.isNullOrUndefined(toDocs));
                    if (!util_1.isNullOrUndefined(fromDocs) && !util_1.isNullOrUndefined(toDocs)) {
                        console.log("Keys---" + keys);
                        for (let i = 0; i < keys.length; i++) {
                            console.log("key--" + keys[i]);
                            if (!data[collectionName]) {
                                data[collectionName] = {};
                            }
                            if (!data[docType]) {
                                data[docType] = {};
                            }
                            if (!data['Similarity']) {
                                data['Similarity'] = {};
                            }
                            if (!data['Document Type']) {
                                data['Document Type'] = {};
                            }
                            if (toDocs['Document Type'][keys[i]]) {
                                data['Document Type'][keys[i]] = toDocs['Document Type'][keys[i]];
                            }
                            else {
                                data['Document Type'][keys[i]] = "";
                            }
                            data['documentType'] = docType;
                            data['caseNo'] = caseNo;
                            if (toDocs[keys[i]]) {
                                data[collectionName][keys[i]] = toDocs[keys[i]];
                            }
                            else {
                                data[collectionName][keys[i]] = "";
                            }
                            if (fromDocs[keys[i]]) {
                                data[docType][keys[i]] = fromDocs[keys[i]];
                            }
                            else {
                                data[docType][keys[i]] = "";
                            }
                            let info = fromDocs[keys[i]].toString().toLowerCase().trim() == toDocs[keys[i]].toLowerCase().trim() || fromDocs[keys[i]].toLowerCase().includes(toDocs[keys[i]].toLowerCase()) || toDocs[keys[i]].toLowerCase().includes(fromDocs[keys[i]].toLowerCase());
                            console.log(info);
                            if (fromDocs[keys[i]] && toDocs[keys[i]]) {
                                data['Similarity'][keys[i]] = parseFloat(similarity(fromDocs[keys[i]].toString().toLowerCase(), toDocs[keys[i]].toString().toLowerCase()).toFixed(2));
                            }
                            else {
                                data['Similarity'][keys[i]] = 0;
                            }
                            console.log("Similarity: " + similarity(fromDocs[keys[i]], toDocs[keys[i]]));
                        }
                        console.log("Data ---------------");
                        console.log(data);
                    }
                    yield (db.collection(recon)).create(data);
                    output['outputData'] = "Acknowledge";
                    return { message: 'Data Found Sucessfull', status: 0, data: output };
                }
                else {
                    return { message: 'Please Give Pan Number', status: 1, data: output };
                }
            }
            catch (e) {
                this.log.error("Error in Finding User Data" + e);
                return {
                    message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' +
                        projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']'
                };
            }
        });
    }
    twoWayReConParser(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let collectionName = input.ReconCollectionName;
                let fromColl = input.fromColl;
                let toColl = input.toColl;
                let caseNo = input.caseNo;
                let showAccuracy = input.showAccuracy;
                let showFDocument = input.showFDocument;
                let toName = input.toName;
                let fromName = input.fromName;
                // let keys= input.keys?input.keys:[];
                console.log("Input ---->", input, collectionName, caseNo);
                // console.log("Keys ---->", keys);
                // let data = {};
                let isError = 0, err = 0;
                if (!util_1.isNullOrUndefined(caseNo) && caseNo !== "" && !util_1.isNullOrUndefined(collectionName) && collectionName !== "") {
                    // let docs = await (db.collection(docType)).findOne({DirName:caseNo}).lean();
                    let docs = yield (db.collection(collectionName)).find({ caseNo: caseNo }).sort({ updatedAt: -1 }).limit(1).lean();
                    let annualdata = yield (db.collection("Annual_Report")).find({ DirName: caseNo }).sort({ updatedAt: -1 }).limit(1).lean();
                    console.log(docs);
                    let html = '';
                    let errHTML = '';
                    let temp = [];
                    docs.forEach(item => {
                        // let similarityKeys = Object.keys(item.Similarity);
                        let headers;
                        if (showAccuracy == "true" && showFDocument == "true") {
                            headers = ['Keys', toName, fromName, 'Document', 'Similarity', 'Match/Mismatch'];
                        }
                        else if (showAccuracy == "false" && showFDocument == "true") {
                            headers = ['Keys', toName, fromName, 'Document', 'Match/Mismatch'];
                        }
                        else if (showAccuracy == "true" && showFDocument == "false") {
                            headers = ['Keys', toName, fromName, 'Similarity', 'Match/Mismatch'];
                        }
                        else {
                            headers = ['Keys', toName, fromName, 'Match/Mismatch'];
                        }
                        // Add header row
                        html += '<table border="2" style="border-collapse: collapse;" cellspacing="5" cellpadding="5">\n<thead>\n<tr>\n';
                        errHTML += '<table border="2" style="border-collapse: collapse;" cellspacing="6" cellpadding="6">\n<thead>\n<tr>\n';
                        headers.forEach(header => {
                            html += `<th>${header}</th>\n`;
                        });
                        errHTML += `<th>Notification Type</th>\n`;
                        errHTML += `<th>Notification Message</th></tr></thead>\n`;
                        html += '</tr></thead>';
                        function isCurrentOrPreviousYear(dateString) {
                            const [day, month, year] = dateString.split('/').map(Number);
                            const inputDate = new Date(year, month - 1, day);
                            const currentDate = new Date();
                            const currentYear = currentDate.getFullYear();
                            const previousYear = currentYear - 1;
                            const inputYear = inputDate.getFullYear();
                            console.log(dateString + " " + currentYear + " " + previousYear + " " + "INPUT YEAR: " + inputYear);
                            return inputYear === currentYear || inputYear === previousYear;
                        }
                        if (annualdata.length != 0) {
                            console.log(annualdata);
                            let date = annualdata[0]['Balance_sheet_date'];
                            if (!isCurrentOrPreviousYear(date)) {
                                err = 1;
                                errHTML += `<tr><td style='background-color:red'>Older document found</td><td>  Standard document is expired. Please upload the latest one.</td></tr>`;
                            }
                        }
                        // Collect unique keys from documentType and test_nsdl
                        let documentTypeKeys = Object.keys(item[toColl]);
                        let test_nsdlKeys = Object.keys(item[fromColl]);
                        let allKeys = Array.from(new Set([...documentTypeKeys, ...test_nsdlKeys]));
                        // Add rows for keys
                        allKeys.forEach(key => {
                            let htmlObj = '';
                            isError = 0;
                            htmlObj += '<tr>\n';
                            htmlObj += `<td><b>${key}</b></td>\n`;
                            htmlObj += `<td>${item[toColl][key] || ''}</td>\n`;
                            htmlObj += `<td>${item[fromColl][key] || ''}</td>\n`;
                            if (showFDocument == "true") {
                                htmlObj += `<td>${item['Document Type'][key] || ''}</td>\n`;
                            }
                            if (showAccuracy == "true") {
                                if (item.Similarity[key] > 85) {
                                    htmlObj += `<td style='color:green'>${item.Similarity[key] || '0'}%</td>\n`;
                                }
                                else if (item.Similarity[key] < 85 && item.Similarity[key] > 70) {
                                    htmlObj += `<td style='color:orange'>${item.Similarity[key] || '0'}%</td>\n`;
                                }
                                else if (item.Similarity[key] < 70) {
                                    htmlObj += `<td style='color:red'>${item.Similarity[key] || '0'}%</td>\n`;
                                }
                                else {
                                    htmlObj += `<td>${item.Similarity[key] || '0'}%</td>\n`;
                                }
                            }
                            if (item.Similarity[key] == 100 || (item.Similarity[key] > 80 && !(/^[0-9]+$/.test(item[toColl][key])))) {
                                htmlObj += `<td style='background-color:green'>Match</td>\n`;
                            }
                            else {
                                isError = 1;
                                err = 1;
                                if (item[fromColl][key] == "Document not found") {
                                    if (!temp.includes(item['Document Type'][key])) {
                                        temp.push(item['Document Type'][key]);
                                        errHTML += `<tr><td style='background-color:orange'>Standard document not available</td>\n<td><b>${item['Document Type'][key]}</b> is not available. Please check for declaration</td></tr>`;
                                    }
                                }
                                else if (item[fromColl][key] == "Not Available in Document" && item[fromColl][key] != item[toColl][key]) {
                                    errHTML += `<tr><td style='background-color:orange'>Field not available in document</td>\n<td><b>${key}</b> is not available in <b>${item['Document Type'][key]}</b></td></tr>`;
                                }
                                else {
                                    errHTML += `<tr><td style='background-color:orange'>Field level mismatch</td>\n<td><b>${key}</b> in <b>${item['Document Type'][key]}</b> is mismatch</td></tr>`;
                                }
                                htmlObj += `<td style='background-color:red'>Mismatch</td>\n`;
                            }
                            htmlObj += '</tr>\n';
                            html += htmlObj;
                            console.log(isError);
                        });
                    });
                    html += '</table><br>';
                    errHTML += '</table><br>';
                    console.log("Final HTML:----\n" + html);
                    console.log("\nError HTML:----\n" + errHTML);
                    output['htmlString'] = html;
                    output['isError'] = err;
                    output['ErrorHTML'] = errHTML;
                    return { message: 'Data Found Sucessfull', status: 0, data: output };
                }
                else {
                    return { message: 'Please Give Pan Number', status: 1, data: output };
                }
            }
            catch (e) {
                this.log.error("Error in Finding User Data" + e);
                return {
                    message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' +
                        projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']'
                };
            }
        });
    }
    finalReConParser(input, output, botId, projectId, iterationId) {
        try {
            let reconPar = input.reconPar;
            let isError = input.isError;
            let errorPar = input.errorPar;
            let htmlString = input.htmlString;
            let errorHtml = input.errorHtml;
            let caseNo = input.caseNo;
            // let keys= input.keys?input.keys:[];
            console.log("Inside finalReconParser-------------->");
            console.log("Input ---->", reconPar, isError, errorPar);
            // console.log("Keys ---->", keys);
            let finalMailObj = '<p style="font-size:15px">Dear User,</p>\n';
            finalMailObj += `<p style="font-size:15px">${reconPar} ${caseNo}:</p>\n`;
            finalMailObj += '<br><br>' + htmlString;
            if (isError) {
                finalMailObj += '<br><br>' + `<p style="font-size:15px">${errorPar}</p>` + '<br><br>' + errorHtml;
            }
            console.log(finalMailObj);
            // let data = {};
            output['finalHtml'] = finalMailObj;
            return { message: 'HTML created succesfully', status: 0, data: output };
        }
        catch (e) {
            this.log.error("HTML issue" + e);
            return {
                message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' +
                    projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']'
            };
        }
    }
    videoObjectParser(input, output, botId, projectId, iterationId) {
        try {
            let inpObj = input.inpObj;
            if (!util_1.isNullOrUndefined(inpObj)) {
                // console.log(docs);
                const lastSlashIndex = inpObj[0]['loc_name'].lastIndexOf('/');
                let fileName = inpObj[0]['loc_name'].substring(lastSlashIndex + 1);
                const parts = fileName.split('_');
                const finalName = parts.slice(2).join('_');
                let html = '';
                html += "Dear User,<br><br>";
                html += `Following is the analysis report for ${finalName} and have detected anomalies/abnormalities during the following periods:<br><br>`;
                let headers = ["Start Time", "End Time", "Location", "Anomaly Type", "Path"];
                html += '<table border="2" style="border-collapse: collapse;" cellspacing="5" cellpadding="5">\n<thead>\n<tr>\n';
                headers.forEach(header => {
                    html += `<th>${header}</th>\n`;
                });
                html += '</tr></thead>';
                inpObj.forEach(item => {
                    const lastSlashIndex = item['path'].lastIndexOf('/');
                    let fileName = item['path'].substring(lastSlashIndex + 1);
                    let resPath = "https://msme42-fs.gibots.com:643/" + fileName;
                    // console.log(keys);
                    // keys.forEach(key => {
                    let htmlObj = '';
                    // isError = 0;
                    htmlObj += '<tr>\n';
                    htmlObj += `<td>${item['start_time'].toFixed(2)}</td>\n`;
                    htmlObj += `<td>${item['end_time'].toFixed(2)}</td>\n`;
                    htmlObj += `<td>${item['location']}</td>\n`;
                    htmlObj += `<td>${item['type']}</td>\n`;
                    htmlObj += `<td><b><a href="${resPath}">Link</a></b></td>\n`;
                    htmlObj += '</tr>\n';
                    html += htmlObj;
                    // console.log(html);
                    // });
                });
                html += '</table><br>';
                html += `We recommend further investigation to ensure there are no underlying issues that need to be addressed.<br>Please find attached the relevant video segment highlighting the detected anomalies.<br>If you have any questions or require additional information, please do not hesitate to contact us.<br><br>Thank you for your attention to this matter.`;
                // console.log(html);
                output['htmlString'] = html;
                // output['isError'] = err;
                // output['ErrorHTML'] = errHTML;
                return { message: 'Data Found Sucessfull', status: 0, data: output };
            }
            else {
                return { message: 'Please Give Pan Number', status: 1, data: output };
            }
        }
        catch (e) {
            this.log.error("Error in Finding User Data" + e);
            return {
                message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' +
                    projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']'
            };
        }
    }
    threeWayReconciliationOld(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                input.projectId = projectId;
                const data = yield this.reconcilationService.getThreeWayReconcilData(input);
                if (data['status'] === 0) {
                    output['data'] = JSON.stringify(data.data);
                    this.log.info('Invoice Reconciliation Successfully');
                    return { message: data['info'], status: data['status'], data: output };
                }
                else {
                    this.log.warn(data['info']);
                    throw data['info'];
                }
            }
            catch (e) {
                this.log.error("Failed invoice reconciliation " + e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    threeWayReconciliation(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let po = [], inv = [], dc = [];
                let masterReconciliation = [];
                this.log.info('Inside prepare reconciliation');
                let docType = input.docType;
                let invRef = input.inv_ref_no;
                let poRef = input.po_ref_no;
                let grnRef = input.grn_ref_no;
                let matchKey = input.matchKey ? input.matchKey : "Description";
                let rateKey = input.rateKey ? input.rateKey : "Rate";
                let qtyKey = input.qtyKey ? input.qtyKey : "Quantity";
                let amtKey = input.amtKey ? input.amtKey : "Amount";
                console.log("Input ---", input, matchKey, rateKey, qtyKey, amtKey);
                let invoiceData = yield (db.collection(docType)).findOne({ referenceNumber: invRef }).lean();
                let poData = yield (db.collection(docType)).findOne({ referenceNumber: poRef }).lean();
                console.log("poInvNumData", poData);
                let invNo = invoiceData.Invoice_Number;
                let poNo = poData.PO_Number;
                console.log("Invoice No---", invNo, " PO No-----", poNo);
                po = JSON.parse(JSON.stringify(poData['multiTable'][0]['Invoice_Items']));
                inv = JSON.parse(JSON.stringify(invoiceData['multiTable'][0]['Invoice_Items']));
                let tempInv = JSON.parse(JSON.stringify(invoiceData['multiTable'][0]['Invoice_Items']));
                let tempPo = JSON.parse(JSON.stringify(poData['multiTable'][0]['Invoice_Items']));
                let DcData = yield (db.collection(docType)).findOne({ referenceNumber: grnRef }).lean();
                if (!(invoiceData.PO_Number == poData.PO_Number && poData.PO_Number == DcData.PO_Number && invoiceData.PO_Number == DcData.PO_Number)) {
                    output['flow'] = 'no';
                    return { info: 'Po Number Does not match,Failed', status: 0, data: output };
                }
                dc = JSON.parse(JSON.stringify(DcData['multiTable'][0]['Invoice_Items']));
                let rObj = {};
                dc.forEach((element) => {
                    let data = {};
                    let invRec = tempInv.find((invRow) => {
                        return element[matchKey].toLowerCase().trim() == invRow[matchKey].toLowerCase().trim() || element[matchKey].toLowerCase().trim().includes(invRow[matchKey].toLowerCase().trim()) || invRow[matchKey].toLowerCase().trim().includes(element[matchKey].toLowerCase().trim());
                    });
                    if (util_1.isNullOrUndefined(invRec) && element[matchKey] && tempInv.length) {
                        let mats = tempInv.map(a => a[matchKey].toLowerCase());
                        let match = stringSimilarity.findBestMatch(element[matchKey].toLowerCase(), mats);
                        console.log(`---------match -------`, element[matchKey].toLowerCase(), '------------', match);
                        if (!util_1.isNullOrUndefined(match.bestMatchIndex)) {
                            invRec = tempInv[match.bestMatchIndex];
                            tempInv.splice(match.bestMatchIndex, 1);
                        }
                    }
                    else {
                        tempInv = tempInv.filter(invRow => !(element[matchKey].toLowerCase().trim() == invRow[matchKey].toLowerCase().trim() || element[matchKey].toLowerCase().trim().includes(invRow[matchKey].toLowerCase().trim()) || invRow[matchKey].toLowerCase().trim().includes(element[matchKey].toLowerCase().trim())));
                    }
                    data['poNum'] = poData.PO_Number;
                    data['invNum'] = invoiceData.Invoice_Number;
                    data['devNum'] = DcData.Invoice_Number;
                    rObj['poNum'] = poData.PO_Number;
                    rObj['invNum'] = invoiceData.Invoice_Number;
                    rObj['devNum'] = invoiceData.Invoice_Number;
                    element[qtyKey] = element[qtyKey] ? element[qtyKey].replace(/,/g, '') : '';
                    element[rateKey] = element[rateKey] ? element[rateKey].replace(/,/g, '') : '';
                    element[amtKey] = element[amtKey] ? element[amtKey].replace(/,/g, '') : '';
                    if (invRec) {
                        data['productName'] = element[matchKey];
                        data['rproductName'] = invRec[matchKey];
                        data['rproductNameFlag'] = false;
                        inv = _.without(inv, _.findWhere(inv, { productName: invRec[matchKey] }));
                        element[qtyKey] = element[qtyKey] ? element[qtyKey].replace(/,/g, '') : '';
                        invRec[qtyKey] = invRec[qtyKey] ? invRec[qtyKey].replace(/,/g, '') : '';
                        element[rateKey] = element[rateKey] ? element[rateKey].replace(/,/g, '') : '';
                        invRec[rateKey] = invRec[rateKey] ? invRec[rateKey].replace(/,/g, '') : '';
                        element[amtKey] = element[amtKey] ? element[amtKey].replace(/,/g, '') : '';
                        invRec[amtKey] = invRec[amtKey] ? invRec[amtKey].replace(/,/g, '') : '';
                        if (element[qtyKey] == invRec[qtyKey] || (!isNaN(element[qtyKey]) && String(parseFloat(element[qtyKey])) == String(parseFloat(invRec[qtyKey])))) {
                            data['rqty'] = invRec[qtyKey];
                            data['qty'] = element[qtyKey];
                            data['rqtyFlag'] = false;
                        }
                        else {
                            data['rqty'] = invRec[qtyKey];
                            data['qty'] = element[qtyKey];
                            data['rqtyFlag'] = true;
                        }
                        if (element[rateKey] == invRec[rateKey] || (!isNaN(element[rateKey]) && String(parseFloat(element[rateKey])) == String(parseFloat(invRec[rateKey])))) {
                            data['rrate'] = invRec[rateKey];
                            data['rate'] = element[rateKey];
                            data['rrateFlag'] = false;
                        }
                        else {
                            data['rrate'] = invRec[rateKey];
                            data['rate'] = element[rateKey];
                            data['rrateFlag'] = true;
                        }
                        if (element[amtKey] == invRec[amtKey] || (!isNaN(element[amtKey]) && String(parseFloat(element[amtKey])) == String(parseFloat(invRec[amtKey])))) {
                            data['ritemAmt'] = invRec[amtKey];
                            data['itemAmt'] = element[amtKey];
                            data['ritemAmtFlag'] = false;
                        }
                        else {
                            data['ritemAmt'] = invRec[amtKey];
                            data['itemAmt'] = element[amtKey];
                            data['ritemAmtFlag'] = true;
                        }
                    }
                    else {
                        data['productName'] = element[matchKey];
                        data['rproductName'] = element[matchKey];
                        data['rproductNameFlag'] = true;
                        data['qty'] = element[qtyKey];
                        data['rqty'] = '';
                        data['rqtyFlag'] = true;
                        data['rate'] = element[rateKey];
                        data['rrate'] = '';
                        data['rrateFlag'] = true;
                        data['itemAmt'] = element[amtKey];
                        data['ritemAmt'] = '';
                        data['ritemAmtFlag'] = true;
                    }
                    let poRec = tempPo.find((invRow) => {
                        return element[matchKey].toLowerCase().trim() == invRow[matchKey].toLowerCase().trim() || element[matchKey].toLowerCase().trim().includes(invRow[matchKey].toLowerCase().trim()) || invRow[matchKey].toLowerCase().trim().includes(element[matchKey].toLowerCase().trim());
                    });
                    if (util_1.isNullOrUndefined(poRec) && element[matchKey] && tempPo.length) {
                        let mats = tempPo.map(a => a[matchKey].toLowerCase());
                        let match = stringSimilarity.findBestMatch(element[matchKey].toLowerCase(), mats);
                        console.log(`---------match -------`, element[matchKey].toLowerCase(), '------------', match);
                        if (!util_1.isNullOrUndefined(match.bestMatchIndex)) {
                            poRec = tempPo[match.bestMatchIndex];
                            tempPo.splice(match.bestMatchIndex, 1);
                        }
                    }
                    else {
                        tempPo = tempPo.filter((invRow) => !(element[matchKey].toLowerCase().trim() == invRow[matchKey].toLowerCase().trim() || element[matchKey].toLowerCase().trim().includes(invRow[matchKey].toLowerCase().trim()) || invRow[matchKey].toLowerCase().trim().includes(element[matchKey].toLowerCase().trim())));
                    }
                    if (poRec) {
                        data['poProductName'] = poRec[matchKey];
                        data['poProductNameFlag'] = false;
                        po = _.without(po, _.findWhere(po, { productName: poRec[matchKey] }));
                        element[qtyKey] = element[qtyKey] ? element[qtyKey].replace(/,/g, '') : '';
                        poRec[qtyKey] = poRec[qtyKey] ? poRec[qtyKey].replace(/,/g, '') : '';
                        element[rateKey] = element[rateKey] ? element[rateKey].replace(/,/g, '') : '';
                        poRec[rateKey] = poRec[rateKey] ? poRec[rateKey].replace(/,/g, '') : '';
                        element[amtKey] = element[amtKey] ? element[amtKey].replace(/,/g, '') : '';
                        poRec[amtKey] = poRec[amtKey] ? poRec[amtKey].replace(/,/g, '') : '';
                        if (element[qtyKey] == poRec[qtyKey] || (!isNaN(element[qtyKey]) && String(parseFloat(element[qtyKey])) == String(parseFloat(poRec[qtyKey])))) {
                            data['poQty'] = poRec[qtyKey];
                            data['poQtyFlag'] = false;
                        }
                        else {
                            data['poQty'] = poRec[qtyKey];
                            data['poQtyFlag'] = true;
                        }
                        if (element[rateKey] == poRec[rateKey] || (!isNaN(element[rateKey]) && String(parseFloat(element[rateKey])) == String(parseFloat(poRec[rateKey])))) {
                            data['poRate'] = poRec[rateKey];
                            data['poRateFlag'] = false;
                        }
                        else {
                            data['poRate'] = poRec[rateKey];
                            data['poRateFlag'] = true;
                        }
                        if (element[amtKey] == poRec[amtKey] || (!isNaN(element[amtKey]) && String(parseFloat(element[amtKey])) == String(parseFloat(poRec[amtKey])))) {
                            data['poItemAmt'] = poRec[amtKey];
                            data['poItemAmtFlag'] = false;
                        }
                        else {
                            data['poItemAmt'] = poRec[amtKey];
                            data['poItemAmtFlag'] = true;
                        }
                    }
                    else {
                        data['poProductName'] = poRec[matchKey];
                        data['poProductNameFlag'] = true;
                        data['poQty'] = '';
                        data['poQtyFlag'] = true;
                        data['poRate'] = '';
                        data['poRateFlag'] = true;
                        data['poItemAmt'] = '';
                        data['poItemAmtFlag'] = true;
                    }
                    masterReconciliation.push(JSON.parse(JSON.stringify(data)));
                });
                let tempTable = JSON.parse(JSON.stringify(tempInv));
                tempPo.forEach((list) => {
                    let data = rObj;
                    let info = tempTable.find((res) => {
                        return list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase());
                    });
                    if (util_1.isNullOrUndefined(info) && list[matchKey] && tempTable.length) {
                        let mats = tempTable.map(a => a[matchKey].toLowerCase());
                        let match = stringSimilarity.findBestMatch(list[matchKey].toLowerCase(), mats);
                        console.log(`---------match -------`, list[matchKey].toLowerCase(), '------------', match);
                        if (!util_1.isNullOrUndefined(match.bestMatchIndex)) {
                            info = tempTable[match.bestMatchIndex];
                            tempTable.splice(match.bestMatchIndex, 1);
                        }
                    }
                    else {
                        tempTable = tempTable.filter(res => !(list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase())));
                    }
                    list[qtyKey] = list[qtyKey] ? list[qtyKey].replace(/,/g, '') : '';
                    list[rateKey] = list[rateKey] ? list[rateKey].replace(/,/g, '') : '';
                    list[amtKey] = list[amtKey] ? list[amtKey].replace(/,/g, '') : '';
                    if (info) {
                        data['productName'] = list[matchKey];
                        data['rproductName'] = info[matchKey];
                        data['rproductNameFlag'] = false;
                        tempInv = _.without(tempInv, _.findWhere(tempInv, { productName: info[matchKey] }));
                        list[qtyKey] = list[qtyKey] ? list[qtyKey].replace(/,/g, '') : '';
                        info[qtyKey] = info[qtyKey] ? info[qtyKey].replace(/,/g, '') : '';
                        list[rateKey] = list[rateKey] ? list[rateKey].replace(/,/g, '') : '';
                        info[rateKey] = info[rateKey] ? info[rateKey].replace(/,/g, '') : '';
                        list[amtKey] = list[amtKey] ? list[amtKey].replace(/,/g, '') : '';
                        info[amtKey] = info[amtKey] ? info[amtKey].replace(/,/g, '') : '';
                        data['qty'] = '';
                        data['rqty'] = '';
                        data['rqtyFlag'] = true;
                        data['rate'] = '';
                        data['rrate'] = '';
                        data['rrateFlag'] = true;
                        data['itemAmt'] = '';
                        data['ritemAmt'] = '';
                        data['ritemAmtFlag'] = true;
                        if (list[qtyKey] == info[qtyKey] || (!isNaN(list[qtyKey]) && String(parseFloat(list[qtyKey])) == String(parseFloat(info[qtyKey])))) {
                            data['rqty'] = info[qtyKey];
                            data['poQty'] = list[qtyKey];
                            data['rqtyFlag'] = false;
                        }
                        else {
                            data['rqty'] = info[qtyKey];
                            data['poQty'] = list[qtyKey];
                            data['rqtyFlag'] = true;
                        }
                        if (list[rateKey] == info[rateKey] || (!isNaN(list[rateKey]) && String(parseFloat(list[rateKey])) == String(parseFloat(info[rateKey])))) {
                            data['rrate'] = info[rateKey];
                            data['poRate'] = list[rateKey];
                            data['poRateFlag'] = false;
                        }
                        else {
                            data['rrate'] = info[rateKey];
                            data['poRate'] = list[rateKey];
                            data['poRateFlag'] = true;
                        }
                        if (list[amtKey] == info[amtKey] || (!isNaN(list[amtKey]) && String(parseFloat(list[amtKey])) == String(parseFloat(info[amtKey])))) {
                            data['ritemAmt'] = info[amtKey];
                            data['poItemAmt'] = list[amtKey];
                            data['poItemAmtFlag'] = false;
                        }
                        else {
                            data['ritemAmt'] = info[amtKey];
                            data['poItemAmt'] = list[amtKey];
                            data['poItemAmtFlag'] = true;
                        }
                    }
                    else {
                        data['productName'] = list[matchKey];
                        data['rproductName'] = list[matchKey];
                        data['rproductNameFlag'] = true;
                        data['qty'] = '';
                        data['rqty'] = '';
                        data['rqtyFlag'] = true;
                        data['rate'] = '';
                        data['rrate'] = '';
                        data['rrateFlag'] = true;
                        data['itemAmt'] = '';
                        data['ritemAmt'] = '';
                        data['ritemAmtFlag'] = true;
                        data['poProductName'] = list[matchKey];
                        data['poProductNameFlag'] = true;
                        data['poQty'] = list[qtyKey];
                        data['poQtyFlag'] = true;
                        data['poRate'] = list[rateKey];
                        data['poRateFlag'] = true;
                        data['poItemAmt'] = list[amtKey];
                        data['poItemAmtFlag'] = true;
                    }
                    masterReconciliation.push(JSON.parse(JSON.stringify(data)));
                });
                tempTable.forEach((list) => {
                    let data = rObj;
                    data['productName'] = list[matchKey];
                    data['rproductName'] = list[matchKey];
                    data['rproductNameFlag'] = true;
                    data['qty'] = '';
                    data['rqty'] = list[qtyKey];
                    data['rqtyFlag'] = true;
                    data['rate'] = '';
                    data['rrate'] = list[rateKey];
                    data['rrateFlag'] = true;
                    data['itemAmt'] = '';
                    data['ritemAmt'] = list[amtKey];
                    data['ritemAmtFlag'] = true;
                    data['poProductName'] = list[matchKey];
                    data['poProductNameFlag'] = true;
                    data['poQty'] = '';
                    data['poQtyFlag'] = true;
                    data['poRate'] = '';
                    data['poRateFlag'] = true;
                    data['poItemAmt'] = '';
                    data['poItemAmtFlag'] = true;
                    masterReconciliation.push(JSON.parse(JSON.stringify(data)));
                });
                // po.forEach((list) => {
                //     let data = {};
                //     data['poNum'] = poData.Invoice_Number;
                //     data['invNum'] = invoiceData.Invoice_Number;
                //     data['devNum'] = DcData.Invoice_Number;
                //     data['productName'] = '';
                //     data['rproductName'] = '';
                //     data['rproductNameFlag'] = true;
                //     data['qty'] = '';
                //     data['rqty'] = '';
                //     data['rqtyFlag'] = true;
                //     data['rate'] = '';
                //     data['rrate'] = '';
                //     data['rrateFlag'] = true;
                //     data['itemAmt'] = '';
                //     data['ritemAmt'] = '';
                //     data['ritemAmtFlag'] = true;
                //     data['poProductName'] = list[matchKey];
                //     data['poProductNameFlag'] = true;
                //     data['poQty'] = list[qtyKey];
                //     data['poQtyFlag'] = true;
                //     data['poRate'] = list[rateKey];
                //     data['poRateFlag'] = true;
                //     data['poItemAmt'] = list[amtKey];
                //     data['poItemAmtFlag'] = true;
                //     masterReconciliation.push(data);
                // });
                // inv.forEach((list) => {
                //     let data = {};
                //     data['poNum'] = poData.Invoice_Number;
                //     data['invNum'] = invoiceData.Invoice_Number;
                //     data['devNum'] = DcData.Invoice_Number;
                //     data['productName'] = '';
                //     data['rproductName'] = list[matchKey];
                //     data['rproductNameFlag'] = true;
                //     data['qty'] = '';
                //     data['rqty'] = list[qtyKey];
                //     data['rqtyFlag'] = true;
                //     data['rate'] = '';
                //     data['rrate'] = list[rateKey];
                //     data['rrateFlag'] = true;
                //     data['itemAmt'] = '';
                //     data['ritemAmt'] = list[amtKey];
                //     data['ritemAmtFlag'] = true;
                //     data['poProductName'] = '';
                //     data['poProductNameFlag'] = true;
                //     data['poQty'] = '';
                //     data['poQtyFlag'] = true;
                //     data['poRate'] = '';
                //     data['poRateFlag'] = true;
                //     data['poItemAmt'] = '';
                //     data['poItemAmtFlag'] = true;
                //     masterReconciliation.push(data);
                // });
                output['flow'] = 'yes';
                output['outputData'] = JSON.stringify(masterReconciliation);
                return { info: 'Reconciliation Prepare success', status: 0, data: output };
            }
            catch (err) {
                this.log.error('Failed inside prepare reconciliation - ' + err);
                return { info: 'Failed inside prepare reconciliation', status: 1, data: [] };
            }
        });
    }
    threeWayReconciliation_bkp(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let po = [], inv = [], dc = [];
                let masterReconciliation = [];
                this.log.info('Inside prepare reconciliation');
                let docType = input.docType;
                let invRef = input.inv_ref_no;
                let poRef = input.po_ref_no;
                let matchKey = input.matchKey ? input.matchKey : "Description";
                let rateKey = input.rateKey ? input.rateKey : "Rate";
                let qtyKey = input.qtyKey ? input.qtyKey : "Quantity";
                let amtKey = input.amtKey ? input.amtKey : "Amount";
                console.log("Input ---", input, matchKey, rateKey, qtyKey, amtKey);
                let invoiceData = yield (db.collection(docType)).findOne({ referenceNumber: invRef }).lean();
                let poData = yield (db.collection(docType)).findOne({ referenceNumber: poRef }).lean();
                console.log("poInvNumData", poData);
                let invNo = invoiceData.Invoice_Number;
                let poNo = poData.PO_Number;
                console.log("Invoice No---", invNo, " PO No-----", poNo);
                po = JSON.parse(JSON.stringify(poData['multiTable'][0]['Invoice_Items']));
                inv = JSON.parse(JSON.stringify(invoiceData['multiTable'][0]['Invoice_Items']));
                let tempInv = JSON.parse(JSON.stringify(invoiceData['multiTable'][0]['Invoice_Items']));
                let tempPo = JSON.parse(JSON.stringify(poData['multiTable'][0]['Invoice_Items']));
                let DcData = yield (db.collection(docType)).findOne({ isGrn: true, Invoice_Number: invNo }).lean();
                dc = JSON.parse(JSON.stringify(DcData['multiTable'][0]['Invoice_Items']));
                let rObj = {};
                dc.forEach((element) => {
                    let data = {};
                    let invRec = tempInv.find((invRow) => {
                        return element[matchKey].toLowerCase().trim() == invRow[matchKey].toLowerCase().trim() || element[matchKey].toLowerCase().trim().includes(invRow[matchKey].toLowerCase().trim()) || invRow[matchKey].toLowerCase().trim().includes(element[matchKey].toLowerCase().trim());
                    });
                    if (util_1.isNullOrUndefined(invRec) && element[matchKey] && tempInv.length) {
                        let mats = tempInv.map(a => a[matchKey].toLowerCase());
                        let match = stringSimilarity.findBestMatch(element[matchKey].toLowerCase(), mats);
                        console.log(`---------match -------`, element[matchKey].toLowerCase(), '------------', match);
                        if (!util_1.isNullOrUndefined(match.bestMatchIndex)) {
                            invRec = tempInv[match.bestMatchIndex];
                            tempInv.splice(match.bestMatchIndex, 1);
                        }
                    }
                    else {
                        tempInv = tempInv.filter(invRow => !(element[matchKey].toLowerCase().trim() == invRow[matchKey].toLowerCase().trim() || element[matchKey].toLowerCase().trim().includes(invRow[matchKey].toLowerCase().trim()) || invRow[matchKey].toLowerCase().trim().includes(element[matchKey].toLowerCase().trim())));
                    }
                    data['poNum'] = poData.PO_Number;
                    data['invNum'] = invoiceData.Invoice_Number;
                    data['devNum'] = DcData.Invoice_Number;
                    rObj['poNum'] = poData.PO_Number;
                    rObj['invNum'] = invoiceData.Invoice_Number;
                    rObj['devNum'] = invoiceData.Invoice_Number;
                    element[qtyKey] = element[qtyKey] ? element[qtyKey].replace(/,/g, '') : '';
                    element[rateKey] = element[rateKey] ? element[rateKey].replace(/,/g, '') : '';
                    element[amtKey] = element[amtKey] ? element[amtKey].replace(/,/g, '') : '';
                    if (invRec) {
                        data['productName'] = element[matchKey];
                        data['rproductName'] = invRec[matchKey];
                        data['rproductNameFlag'] = false;
                        inv = _.without(inv, _.findWhere(inv, { productName: invRec[matchKey] }));
                        element[qtyKey] = element[qtyKey] ? element[qtyKey].replace(/,/g, '') : '';
                        invRec[qtyKey] = invRec[qtyKey] ? invRec[qtyKey].replace(/,/g, '') : '';
                        element[rateKey] = element[rateKey] ? element[rateKey].replace(/,/g, '') : '';
                        invRec[rateKey] = invRec[rateKey] ? invRec[rateKey].replace(/,/g, '') : '';
                        element[amtKey] = element[amtKey] ? element[amtKey].replace(/,/g, '') : '';
                        invRec[amtKey] = invRec[amtKey] ? invRec[amtKey].replace(/,/g, '') : '';
                        if (element[qtyKey] == invRec[qtyKey] || (!isNaN(element[qtyKey]) && String(parseFloat(element[qtyKey])) == String(parseFloat(invRec[qtyKey])))) {
                            data['rqty'] = invRec[qtyKey];
                            data['qty'] = element[qtyKey];
                            data['rqtyFlag'] = false;
                        }
                        else {
                            data['rqty'] = invRec[qtyKey];
                            data['qty'] = element[qtyKey];
                            data['rqtyFlag'] = true;
                        }
                        if (element[rateKey] == invRec[rateKey] || (!isNaN(element[rateKey]) && String(parseFloat(element[rateKey])) == String(parseFloat(invRec[rateKey])))) {
                            data['rrate'] = invRec[rateKey];
                            data['rate'] = element[rateKey];
                            data['rrateFlag'] = false;
                        }
                        else {
                            data['rrate'] = invRec[rateKey];
                            data['rate'] = element[rateKey];
                            data['rrateFlag'] = true;
                        }
                        if (element[amtKey] == invRec[amtKey] || (!isNaN(element[amtKey]) && String(parseFloat(element[amtKey])) == String(parseFloat(invRec[amtKey])))) {
                            data['ritemAmt'] = invRec[amtKey];
                            data['itemAmt'] = element[amtKey];
                            data['ritemAmtFlag'] = false;
                        }
                        else {
                            data['ritemAmt'] = invRec[amtKey];
                            data['itemAmt'] = element[amtKey];
                            data['ritemAmtFlag'] = true;
                        }
                    }
                    else {
                        data['productName'] = element[matchKey];
                        data['rproductName'] = element[matchKey];
                        data['rproductNameFlag'] = true;
                        data['qty'] = element[qtyKey];
                        data['rqty'] = '';
                        data['rqtyFlag'] = true;
                        data['rate'] = element[rateKey];
                        data['rrate'] = '';
                        data['rrateFlag'] = true;
                        data['itemAmt'] = element[amtKey];
                        data['ritemAmt'] = '';
                        data['ritemAmtFlag'] = true;
                    }
                    let poRec = tempPo.find((invRow) => {
                        return element[matchKey].toLowerCase().trim() == invRow[matchKey].toLowerCase().trim() || element[matchKey].toLowerCase().trim().includes(invRow[matchKey].toLowerCase().trim()) || invRow[matchKey].toLowerCase().trim().includes(element[matchKey].toLowerCase().trim());
                    });
                    if (util_1.isNullOrUndefined(poRec) && element[matchKey] && tempPo.length) {
                        let mats = tempPo.map(a => a[matchKey].toLowerCase());
                        let match = stringSimilarity.findBestMatch(element[matchKey].toLowerCase(), mats);
                        console.log(`---------match -------`, element[matchKey].toLowerCase(), '------------', match);
                        if (!util_1.isNullOrUndefined(match.bestMatchIndex)) {
                            poRec = tempPo[match.bestMatchIndex];
                            tempPo.splice(match.bestMatchIndex, 1);
                        }
                    }
                    else {
                        tempPo = tempPo.filter((invRow) => !(element[matchKey].toLowerCase().trim() == invRow[matchKey].toLowerCase().trim() || element[matchKey].toLowerCase().trim().includes(invRow[matchKey].toLowerCase().trim()) || invRow[matchKey].toLowerCase().trim().includes(element[matchKey].toLowerCase().trim())));
                    }
                    if (poRec) {
                        data['poProductName'] = poRec[matchKey];
                        data['poProductNameFlag'] = false;
                        po = _.without(po, _.findWhere(po, { productName: poRec[matchKey] }));
                        element[qtyKey] = element[qtyKey] ? element[qtyKey].replace(/,/g, '') : '';
                        poRec[qtyKey] = poRec[qtyKey] ? poRec[qtyKey].replace(/,/g, '') : '';
                        element[rateKey] = element[rateKey] ? element[rateKey].replace(/,/g, '') : '';
                        poRec[rateKey] = poRec[rateKey] ? poRec[rateKey].replace(/,/g, '') : '';
                        element[amtKey] = element[amtKey] ? element[amtKey].replace(/,/g, '') : '';
                        poRec[amtKey] = poRec[amtKey] ? poRec[amtKey].replace(/,/g, '') : '';
                        if (element[qtyKey] == poRec[qtyKey] || (!isNaN(element[qtyKey]) && String(parseFloat(element[qtyKey])) == String(parseFloat(poRec[qtyKey])))) {
                            data['poQty'] = poRec[qtyKey];
                            data['poQtyFlag'] = false;
                        }
                        else {
                            data['poQty'] = poRec[qtyKey];
                            data['poQtyFlag'] = true;
                        }
                        if (element[rateKey] == poRec[rateKey] || (!isNaN(element[rateKey]) && String(parseFloat(element[rateKey])) == String(parseFloat(poRec[rateKey])))) {
                            data['poRate'] = poRec[rateKey];
                            data['poRateFlag'] = false;
                        }
                        else {
                            data['poRate'] = poRec[rateKey];
                            data['poRateFlag'] = true;
                        }
                        if (element[amtKey] == poRec[amtKey] || (!isNaN(element[amtKey]) && String(parseFloat(element[amtKey])) == String(parseFloat(poRec[amtKey])))) {
                            data['poItemAmt'] = poRec[amtKey];
                            data['poItemAmtFlag'] = false;
                        }
                        else {
                            data['poItemAmt'] = poRec[amtKey];
                            data['poItemAmtFlag'] = true;
                        }
                    }
                    else {
                        data['poProductName'] = poRec[matchKey];
                        data['poProductNameFlag'] = true;
                        data['poQty'] = '';
                        data['poQtyFlag'] = true;
                        data['poRate'] = '';
                        data['poRateFlag'] = true;
                        data['poItemAmt'] = '';
                        data['poItemAmtFlag'] = true;
                    }
                    masterReconciliation.push(JSON.parse(JSON.stringify(data)));
                });
                let tempTable = JSON.parse(JSON.stringify(tempInv));
                tempPo.forEach((list) => {
                    let data = rObj;
                    let info = tempTable.find((res) => {
                        return list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase());
                    });
                    if (util_1.isNullOrUndefined(info) && list[matchKey] && tempTable.length) {
                        let mats = tempTable.map(a => a[matchKey].toLowerCase());
                        let match = stringSimilarity.findBestMatch(list[matchKey].toLowerCase(), mats);
                        console.log(`---------match -------`, list[matchKey].toLowerCase(), '------------', match);
                        if (!util_1.isNullOrUndefined(match.bestMatchIndex)) {
                            info = tempTable[match.bestMatchIndex];
                            tempTable.splice(match.bestMatchIndex, 1);
                        }
                    }
                    else {
                        tempTable = tempTable.filter(res => !(list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase())));
                    }
                    list[qtyKey] = list[qtyKey] ? list[qtyKey].replace(/,/g, '') : '';
                    list[rateKey] = list[rateKey] ? list[rateKey].replace(/,/g, '') : '';
                    list[amtKey] = list[amtKey] ? list[amtKey].replace(/,/g, '') : '';
                    if (info) {
                        data['productName'] = list[matchKey];
                        data['rproductName'] = info[matchKey];
                        data['rproductNameFlag'] = false;
                        tempInv = _.without(tempInv, _.findWhere(tempInv, { productName: info[matchKey] }));
                        list[qtyKey] = list[qtyKey] ? list[qtyKey].replace(/,/g, '') : '';
                        info[qtyKey] = info[qtyKey] ? info[qtyKey].replace(/,/g, '') : '';
                        list[rateKey] = list[rateKey] ? list[rateKey].replace(/,/g, '') : '';
                        info[rateKey] = info[rateKey] ? info[rateKey].replace(/,/g, '') : '';
                        list[amtKey] = list[amtKey] ? list[amtKey].replace(/,/g, '') : '';
                        info[amtKey] = info[amtKey] ? info[amtKey].replace(/,/g, '') : '';
                        data['qty'] = '';
                        data['rqty'] = '';
                        data['rqtyFlag'] = true;
                        data['rate'] = '';
                        data['rrate'] = '';
                        data['rrateFlag'] = true;
                        data['itemAmt'] = '';
                        data['ritemAmt'] = '';
                        data['ritemAmtFlag'] = true;
                        if (list[qtyKey] == info[qtyKey] || (!isNaN(list[qtyKey]) && String(parseFloat(list[qtyKey])) == String(parseFloat(info[qtyKey])))) {
                            data['rqty'] = info[qtyKey];
                            data['poQty'] = list[qtyKey];
                            data['rqtyFlag'] = false;
                        }
                        else {
                            data['rqty'] = info[qtyKey];
                            data['poQty'] = list[qtyKey];
                            data['rqtyFlag'] = true;
                        }
                        if (list[rateKey] == info[rateKey] || (!isNaN(list[rateKey]) && String(parseFloat(list[rateKey])) == String(parseFloat(info[rateKey])))) {
                            data['rrate'] = info[rateKey];
                            data['poRate'] = list[rateKey];
                            data['poRateFlag'] = false;
                        }
                        else {
                            data['rrate'] = info[rateKey];
                            data['poRate'] = list[rateKey];
                            data['poRateFlag'] = true;
                        }
                        if (list[amtKey] == info[amtKey] || (!isNaN(list[amtKey]) && String(parseFloat(list[amtKey])) == String(parseFloat(info[amtKey])))) {
                            data['ritemAmt'] = info[amtKey];
                            data['poItemAmt'] = list[amtKey];
                            data['poItemAmtFlag'] = false;
                        }
                        else {
                            data['ritemAmt'] = info[amtKey];
                            data['poItemAmt'] = list[amtKey];
                            data['poItemAmtFlag'] = true;
                        }
                    }
                    else {
                        data['productName'] = list[matchKey];
                        data['rproductName'] = list[matchKey];
                        data['rproductNameFlag'] = true;
                        data['qty'] = '';
                        data['rqty'] = '';
                        data['rqtyFlag'] = true;
                        data['rate'] = '';
                        data['rrate'] = '';
                        data['rrateFlag'] = true;
                        data['itemAmt'] = '';
                        data['ritemAmt'] = '';
                        data['ritemAmtFlag'] = true;
                        data['poProductName'] = list[matchKey];
                        data['poProductNameFlag'] = true;
                        data['poQty'] = list[qtyKey];
                        data['poQtyFlag'] = true;
                        data['poRate'] = list[rateKey];
                        data['poRateFlag'] = true;
                        data['poItemAmt'] = list[amtKey];
                        data['poItemAmtFlag'] = true;
                    }
                    masterReconciliation.push(JSON.parse(JSON.stringify(data)));
                });
                tempTable.forEach((list) => {
                    let data = rObj;
                    data['productName'] = list[matchKey];
                    data['rproductName'] = list[matchKey];
                    data['rproductNameFlag'] = true;
                    data['qty'] = '';
                    data['rqty'] = list[qtyKey];
                    data['rqtyFlag'] = true;
                    data['rate'] = '';
                    data['rrate'] = list[rateKey];
                    data['rrateFlag'] = true;
                    data['itemAmt'] = '';
                    data['ritemAmt'] = list[amtKey];
                    data['ritemAmtFlag'] = true;
                    data['poProductName'] = list[matchKey];
                    data['poProductNameFlag'] = true;
                    data['poQty'] = '';
                    data['poQtyFlag'] = true;
                    data['poRate'] = '';
                    data['poRateFlag'] = true;
                    data['poItemAmt'] = '';
                    data['poItemAmtFlag'] = true;
                    masterReconciliation.push(JSON.parse(JSON.stringify(data)));
                });
                // po.forEach((list) => {
                //     let data = {};
                //     data['poNum'] = poData.Invoice_Number;
                //     data['invNum'] = invoiceData.Invoice_Number;
                //     data['devNum'] = DcData.Invoice_Number;
                //     data['productName'] = '';
                //     data['rproductName'] = '';
                //     data['rproductNameFlag'] = true;
                //     data['qty'] = '';
                //     data['rqty'] = '';
                //     data['rqtyFlag'] = true;
                //     data['rate'] = '';
                //     data['rrate'] = '';
                //     data['rrateFlag'] = true;
                //     data['itemAmt'] = '';
                //     data['ritemAmt'] = '';
                //     data['ritemAmtFlag'] = true;
                //     data['poProductName'] = list[matchKey];
                //     data['poProductNameFlag'] = true;
                //     data['poQty'] = list[qtyKey];
                //     data['poQtyFlag'] = true;
                //     data['poRate'] = list[rateKey];
                //     data['poRateFlag'] = true;
                //     data['poItemAmt'] = list[amtKey];
                //     data['poItemAmtFlag'] = true;
                //     masterReconciliation.push(data);
                // });
                // inv.forEach((list) => {
                //     let data = {};
                //     data['poNum'] = poData.Invoice_Number;
                //     data['invNum'] = invoiceData.Invoice_Number;
                //     data['devNum'] = DcData.Invoice_Number;
                //     data['productName'] = '';
                //     data['rproductName'] = list[matchKey];
                //     data['rproductNameFlag'] = true;
                //     data['qty'] = '';
                //     data['rqty'] = list[qtyKey];
                //     data['rqtyFlag'] = true;
                //     data['rate'] = '';
                //     data['rrate'] = list[rateKey];
                //     data['rrateFlag'] = true;
                //     data['itemAmt'] = '';
                //     data['ritemAmt'] = list[amtKey];
                //     data['ritemAmtFlag'] = true;
                //     data['poProductName'] = '';
                //     data['poProductNameFlag'] = true;
                //     data['poQty'] = '';
                //     data['poQtyFlag'] = true;
                //     data['poRate'] = '';
                //     data['poRateFlag'] = true;
                //     data['poItemAmt'] = '';
                //     data['poItemAmtFlag'] = true;
                //     masterReconciliation.push(data);
                // });
                output['outputData'] = JSON.stringify(masterReconciliation);
                return { info: 'Reconciliation Prepare success', status: 0, data: output };
            }
            catch (err) {
                this.log.error('Failed inside prepare reconciliation - ' + err);
                return { info: 'Failed inside prepare reconciliation', status: 1, data: [] };
            }
        });
    }
    POReconcilation(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                return new Promise((resolve, reject) => {
                    if ((!util_1.isNullOrUndefined(input.drivingArray)) && (!util_1.isNullOrUndefined(input.searchArray))) {
                        if ((!util_1.isNullOrUndefined(input.drivingArray_equalMatchKeys)) && (!util_1.isNullOrUndefined(input.searchArray_equalMatchKeys))) {
                            console.log(input.searchArray); //PO table result
                            let invoice_equalmatchkeys = JSON.parse(input.drivingArray_equalMatchKeys);
                            let po_equalmatchkeys = JSON.parse(input.searchArray_equalMatchKeys);
                            let invoice_lessthanequalkeys = JSON.parse(input.drivingArray_lessthanequalMatchKeys);
                            let po_lessthanequalkeys = JSON.parse(input.searchArray_lessthanequalMatchKeys);
                            let invoice_tiebreakerkey = JSON.parse(input.drivingArray_tieBreakerKey);
                            let po_tiebreakerkey = JSON.parse(input.searchArray_tieBreakerKey);
                            input.drivingArray.invoiceItems.forEach(element2 => {
                                console.log("element2-----------************", element2);
                                if (!util_1.isNullOrUndefined(element2)) {
                                    element2['error'] = [];
                                    let exactMatchArray = [];
                                    let partialMatchArray = [];
                                    let POmatched = false;
                                    for (const element1 of input.searchArray) {
                                        let poLineMatch = false;
                                        let unitPriceMatch = false;
                                        let pendingAmountMatch = false;
                                        let pendingQuantityMatch = false;
                                        let pendingAmount = null;
                                        let pendingQuantity = null;
                                        if (!util_1.isNullOrUndefined(element2[invoice_equalmatchkeys[0]]) || (element2[invoice_equalmatchkeys[0]] != "")) {
                                            if (element2[invoice_equalmatchkeys[0]] == element1[po_equalmatchkeys[0]]) { //PO_NUMBER check
                                                console.log("LINE ITEM", element2);
                                                console.log("PO line item", element1);
                                                if (element2[invoice_equalmatchkeys[1]] == element1[po_equalmatchkeys[1]]) { //PO_Line_No check
                                                    poLineMatch = true;
                                                    console.log(invoice_equalmatchkeys[1], po_equalmatchkeys[1]);
                                                    console.log("PO line match");
                                                }
                                                if (element2[invoice_equalmatchkeys[2]] == element1[po_equalmatchkeys[2]]) { //Unit_Price check
                                                    unitPriceMatch = true;
                                                    console.log(invoice_equalmatchkeys[2], po_equalmatchkeys[2]);
                                                    console.log("Unit price match");
                                                }
                                                pendingAmount = element1[po_lessthanequalkeys[0]] - element1[po_lessthanequalkeys[1]];
                                                //PO_LINE_AMOUNT - INVOICE_LINE_AMOUNT
                                                console.log(element1);
                                                console.log(po_lessthanequalkeys[0], po_lessthanequalkeys[1]);
                                                console.log("pendingAmount", pendingAmount);
                                                pendingQuantity = (element1[po_lessthanequalkeys[2]] - element1[po_lessthanequalkeys[3]]) - element1[po_lessthanequalkeys[4]];
                                                //PO_QUANTITY - INVOICED_QUANTITY - QUANTITY_CANCELLED
                                                console.log("POQuantity", element1[po_lessthanequalkeys[2]]);
                                                console.log("pendingQuantity", pendingQuantity);
                                                if (element2[invoice_lessthanequalkeys[0]] <= pendingAmount) { //line_total_amount check
                                                    pendingAmountMatch = true;
                                                    console.log("Pending Amount match");
                                                }
                                                if (element2[invoice_lessthanequalkeys[1]] <= pendingQuantity) { //Quantity check
                                                    pendingQuantityMatch = true;
                                                    console.log("Pending Quantity match");
                                                }
                                                if (poLineMatch && unitPriceMatch && pendingAmountMatch && pendingQuantityMatch) {
                                                    exactMatchArray.push(element1);
                                                    console.log("exact match found");
                                                    POmatched = true;
                                                }
                                                else if (unitPriceMatch && pendingAmountMatch && pendingQuantityMatch) {
                                                    partialMatchArray.push(element1);
                                                    console.log("partial match found");
                                                    POmatched = true;
                                                }
                                                else {
                                                    console.log("no PO match found");
                                                }
                                            }
                                            else {
                                                console.log("PO NUMBER does not match");
                                                //POnotmatched = true;
                                            }
                                        }
                                        else {
                                            console.log("PO NUMBER is undefined or empty", element2[invoice_equalmatchkeys[0]]);
                                            //POnotmatched = true;
                                        }
                                    }
                                    if (POmatched) {
                                        if (exactMatchArray.length == 1) {
                                            input.drivingArray["POcheck"] = "true";
                                            element2["POcheck"] = "true";
                                            element2["Matched_PO_No"] = exactMatchArray[0]["PO_NUMBER"];
                                            element2["Matched_PO_Line_No"] = exactMatchArray[0]["PO_LINE_NO"];
                                            element2["PO_DISTRIBUTION_ID"] = exactMatchArray[0]["PO_DISTRIBUTION_ID"];
                                            element2["LINE_LOCATION_ID"] = exactMatchArray[0]["LINE_LOCATION_ID"];
                                            element2["PO_HEADER_ID"] = exactMatchArray[0]["PO_HEADER_ID"];
                                            element2["INVENTORY_ITEM_ID"] = exactMatchArray[0]["INVENTORY_ITEM_ID"];
                                            element2["PO_LINE_ID"] = exactMatchArray[0]["PO_LINE_ID"];
                                            if (!util_1.isNullOrUndefined(exactMatchArray[0]["PO_RECEIPT_NO"])) {
                                                element2["Receipt_No"] = exactMatchArray[0]["PO_RECEIPT_NO"];
                                                element2["PO_SHIPMENT_NUM"] = exactMatchArray[0]["PO_RECEIPT_NO"];
                                                element2["Receipt_Line_No"] = exactMatchArray[0]["RECEIPT_LINE_NO"];
                                                input.drivingArray["GRNcheck"] = "true";
                                                element2["GRNcheck"] = "true";
                                            }
                                            else {
                                                input.drivingArray["GRNcheck"] = "false";
                                                element2["GRNcheck"] = "false";
                                                if (exactMatchArray[0]["PO_OWNER_EMAIL"] != "") {
                                                    element2["PO_OWNER_EMAIL"] = exactMatchArray[0]["PO_OWNER_EMAIL"];
                                                }
                                                else if (exactMatchArray[0]["PR_OWNER_EMAIL"] != "") {
                                                    element2["PO_OWNER_EMAIL"] = exactMatchArray[0]["PR_OWNER_EMAIL"];
                                                }
                                            }
                                        }
                                        else if (partialMatchArray.length == 1) {
                                            let invoiceDate = this.formatted_date(input.drivingArray[invoice_tiebreakerkey[0]]);
                                            let poDate = partialMatchArray[0][po_tiebreakerkey[0]];
                                            var day1;
                                            day1 = new Date(invoiceDate);
                                            var day2;
                                            day2 = new Date(poDate);
                                            var difference = Math.abs(day1 - day2);
                                            var days = difference / (1000 * 3600 * 24);
                                            console.log(days);
                                            if (days >= 0) {
                                                input.drivingArray["POcheck"] = "true";
                                                element2["POcheck"] = "true";
                                                element2["Matched_PO_No"] = partialMatchArray[0]["PO_NUMBER"];
                                                element2["Matched_PO_Line_No"] = partialMatchArray[0]["PO_LINE_NO"];
                                                element2["PO_DISTRIBUTION_ID"] = partialMatchArray[0]["PO_DISTRIBUTION_ID"];
                                                element2["LINE_LOCATION_ID"] = partialMatchArray[0]["LINE_LOCATION_ID"];
                                                element2["PO_HEADER_ID"] = partialMatchArray[0]["PO_HEADER_ID"];
                                                element2["INVENTORY_ITEM_ID"] = partialMatchArray[0]["INVENTORY_ITEM_ID"];
                                                element2["PO_LINE_ID"] = partialMatchArray[0]["PO_LINE_ID"];
                                                if (!util_1.isNullOrUndefined(partialMatchArray[0]["PO_RECEIPT_NO"])) {
                                                    element2["Receipt_No"] = partialMatchArray[0]["PO_RECEIPT_NO"];
                                                    element2["PO_SHIPMENT_NUM"] = partialMatchArray[0]["PO_RECEIPT_NO"];
                                                    element2["Receipt_Line_No"] = partialMatchArray[0]["RECEIPT_LINE_NO"];
                                                    input.drivingArray["GRNcheck"] = "true";
                                                    element2["GRNcheck"] = "true";
                                                }
                                                else {
                                                    input.drivingArray["GRNcheck"] = "false";
                                                    element2["GRNcheck"] = "false";
                                                    if (partialMatchArray[0]["PO_OWNER_EMAIL"] != "") {
                                                        element2["PO_OWNER_EMAIL"] = partialMatchArray[0]["PO_OWNER_EMAIL"];
                                                    }
                                                    else if (partialMatchArray[0]["PR_OWNER_EMAIL"] != "") {
                                                        element2["PO_OWNER_EMAIL"] = partialMatchArray[0]["PR_OWNER_EMAIL"];
                                                    }
                                                }
                                            }
                                        }
                                        else if (exactMatchArray.length > 1) {
                                            let dates = [];
                                            for (const ele of exactMatchArray) {
                                                console.log("exactMatchArray-->", ele);
                                                dates.push(ele[po_tiebreakerkey[0]]);
                                            }
                                            console.log("dates", dates);
                                            let invoiceDate = this.formatted_date(input.drivingArray[invoice_tiebreakerkey[0]]);
                                            let nearestDaysCount = this.nearest_date(dates, invoiceDate);
                                            var indexMin;
                                            if (!(nearestDaysCount.every(val => val === nearestDaysCount[0]))) {
                                                indexMin = nearestDaysCount.indexOf(Math.min(...nearestDaysCount));
                                                //var indexMin = nearestDaysCount.indexOf(Math.min(...nearestDaysCount));
                                                input.drivingArray["POcheck"] = "true";
                                                element2["POcheck"] = "true";
                                                element2["Matched_PO_No"] = exactMatchArray[indexMin]["PO_NUMBER"];
                                                element2["Matched_PO_Line_No"] = exactMatchArray[indexMin]["PO_LINE_NO"];
                                                element2["PO_DISTRIBUTION_ID"] = exactMatchArray[indexMin]["PO_DISTRIBUTION_ID"];
                                                element2["LINE_LOCATION_ID"] = exactMatchArray[indexMin]["LINE_LOCATION_ID"];
                                                element2["PO_HEADER_ID"] = exactMatchArray[indexMin]["PO_HEADER_ID"];
                                                element2["INVENTORY_ITEM_ID"] = exactMatchArray[indexMin]["INVENTORY_ITEM_ID"];
                                                element2["PO_LINE_ID"] = exactMatchArray[indexMin]["PO_LINE_ID"];
                                                if (!util_1.isNullOrUndefined(exactMatchArray[indexMin]["PO_RECEIPT_NO"])) {
                                                    element2["Receipt_No"] = exactMatchArray[indexMin]["PO_RECEIPT_NO"];
                                                    element2["PO_SHIPMENT_NUM"] = exactMatchArray[indexMin]["PO_RECEIPT_NO"];
                                                    element2["Receipt_Line_No"] = exactMatchArray[indexMin]["RECEIPT_LINE_NO"];
                                                    input.drivingArray["GRNcheck"] = "true";
                                                    element2["GRNcheck"] = "true";
                                                }
                                                else {
                                                    input.drivingArray["GRNcheck"] = "false";
                                                    element2["GRNcheck"] = "false";
                                                    if (exactMatchArray[indexMin]["PO_OWNER_EMAIL"] != "") {
                                                        element2["PO_OWNER_EMAIL"] = exactMatchArray[indexMin]["PO_OWNER_EMAIL"];
                                                    }
                                                    else if (exactMatchArray[indexMin]["PR_OWNER_EMAIL"] != "") {
                                                        element2["PO_OWNER_EMAIL"] = exactMatchArray[indexMin]["PR_OWNER_EMAIL"];
                                                    }
                                                }
                                            }
                                            else {
                                                input.drivingArray["POcheck"] = "false";
                                                element2["POcheck"] = "false";
                                                input.drivingArray["GRNcheck"] = "false";
                                                console.log(" inside same date error", element2['error']);
                                                element2['error'].push({ "PO_LINE_NEED_BY_DATE": "EX163 - POcheck failed due to similar matches found multiple times" });
                                            }
                                        }
                                        else if (partialMatchArray.length > 1) {
                                            let dates = [];
                                            for (const ele of partialMatchArray) {
                                                console.log("partialMatchArray-->", ele);
                                                dates.push(ele[po_tiebreakerkey[0]]);
                                            }
                                            console.log("dates", dates);
                                            let invoiceDate = this.formatted_date(input.drivingArray[invoice_tiebreakerkey[0]]);
                                            let nearestDaysCount = this.nearest_date(dates, invoiceDate);
                                            var indexMin;
                                            if (!(nearestDaysCount.every(val => val === nearestDaysCount[0]))) {
                                                indexMin = nearestDaysCount.indexOf(Math.min(...nearestDaysCount));
                                                console.log("indexmin", indexMin);
                                                input.drivingArray["POcheck"] = "true";
                                                element2["POcheck"] = "true";
                                                console.log("before partial match array", partialMatchArray[indexMin]);
                                                element2["Matched_PO_No"] = partialMatchArray[indexMin]["PO_NUMBER"];
                                                element2["Matched_PO_Line_No"] = partialMatchArray[indexMin]["PO_LINE_NO"];
                                                if (!util_1.isNullOrUndefined(partialMatchArray[indexMin]["PO_RECEIPT_NO"])) {
                                                    element2["Receipt_No"] = partialMatchArray[indexMin]["PO_RECEIPT_NO"];
                                                    element2["PO_SHIPMENT_NUM"] = partialMatchArray[indexMin]["PO_RECEIPT_NO"];
                                                    element2["Receipt_Line_No"] = partialMatchArray[indexMin]["RECEIPT_LINE_NO"];
                                                    element2["PO_DISTRIBUTION_ID"] = partialMatchArray[indexMin]["PO_DISTRIBUTION_ID"];
                                                    element2["LINE_LOCATION_ID"] = partialMatchArray[indexMin]["LINE_LOCATION_ID"];
                                                    element2["PO_HEADER_ID"] = partialMatchArray[indexMin]["PO_HEADER_ID"];
                                                    element2["INVENTORY_ITEM_ID"] = partialMatchArray[indexMin]["INVENTORY_ITEM_ID"];
                                                    element2["PO_LINE_ID"] = partialMatchArray[indexMin]["PO_LINE_ID"];
                                                    input.drivingArray["GRNcheck"] = "true";
                                                    element2["GRNcheck"] = "true";
                                                }
                                                else {
                                                    input.drivingArray["GRNcheck"] = "false";
                                                    element2["GRNcheck"] = "false";
                                                    if (partialMatchArray[indexMin]["PO_OWNER_EMAIL"] != "") {
                                                        element2["PO_OWNER_EMAIL"] = partialMatchArray[indexMin]["PO_OWNER_EMAIL"];
                                                    }
                                                    else if (partialMatchArray[indexMin]["PR_OWNER_EMAIL"] != "") {
                                                        element2["PO_OWNER_EMAIL"] = partialMatchArray[indexMin]["PR_OWNER_EMAIL"];
                                                    }
                                                }
                                                console.log("after partial match array", partialMatchArray[indexMin]);
                                            }
                                            else {
                                                input.drivingArray["POcheck"] = "false";
                                                element2["POcheck"] = "false";
                                                input.drivingArray["GRNcheck"] = "false";
                                                console.log(" inside same date error", element2['error']);
                                                element2['error'].push({ "PO_LINE_NEED_BY_DATE": "EX163 - POcheck failed due to similar matches found multiple times" });
                                            }
                                        }
                                        else {
                                            input.drivingArray["POcheck"] = "false";
                                            element2["POcheck"] = "false";
                                            input.drivingArray["GRNcheck"] = "false";
                                            element2["GRNcheck"] = "false";
                                        }
                                        if (!util_1.isNullOrUndefined(element2["Matched_PO_Line_No"]) && element2["Matched_PO_Line_No"] !== "") {
                                            for (let elem of input.searchArray) {
                                                if (elem["PO_LINE_NO"] == element2["Matched_PO_Line_No"]) {
                                                    elem["INVOICED_QUANITY"] = elem["INVOICED_QUANITY"] + element2["Quantity"];
                                                    elem["INVOICE_LINE_AMOUNT"] = elem["INVOICE_LINE_AMOUNT"] + element2["Line_Total_Amount"];
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        input.drivingArray["POcheck"] = "false";
                                        element2["POcheck"] = "false";
                                        input.drivingArray["GRNcheck"] = "false";
                                        //element2["GRNcheck"] = "false";
                                    }
                                    if (!util_1.isNullOrUndefined(element2["GRNcheck"]) && element2["GRNcheck"] == "false") {
                                        console.log(" inside first if error", element2['error']);
                                        element2['error'].push({ "RECEIPT_LINE_NO": "EX159 - GRNCheck Failed Due To RECEIPT_LINE_NO Not Found" });
                                        input.drivingArray['status'] = "Blocking";
                                        console.log("inside end if error", element2['error']);
                                        if ((util_1.isNullOrUndefined(element2["PO_OWNER_EMAIL"])) || (util_1.isNullOrUndefined(element2["PR_OWNER_EMAIL"]))) {
                                            console.log("inside second if error", element2['error']);
                                            element2['error'].push({ "PO_OWNER_EMAIL": "EX161 - PO/PR_OWNER_EMAIL not found" });
                                            console.log("inside second end if error", element2['error']);
                                        }
                                    }
                                    if (!util_1.isNullOrUndefined(element2["POcheck"]) && element2["POcheck"] == "false") {
                                        console.log("inside second po if error", element2['error']);
                                        element2['error'].push({ "PO_NUMBER": "EX160 - POcheck Failed Due To PO Number is not Matched / Not Found" });
                                        console.log("inside second po if error", element2['error']);
                                        input.drivingArray['status'] = "Blocking";
                                    }
                                    // if (!isNullOrUndefined(input.PO_MandatoryCheck) && (input.PO_MandatoryCheck == true)) {
                                    //     console.log("inside second po if error", element2['error']);
                                    //     input.drivingArray['status'] = "Blocking";
                                    // }
                                    console.log("error", element2['error']);
                                }
                            });
                            console.log(input.drivingArray);
                            let check1 = true;
                            let check2 = true;
                            input.drivingArray.invoiceItems.forEach(elem => {
                                if (elem['POcheck'] == "false") {
                                    check1 = false;
                                }
                                if (elem['GRNcheck'] == "false") {
                                    check2 = false;
                                }
                            });
                            if (!check2) {
                                input.drivingArray["POcheck"] = "false";
                                if (!util_1.isNullOrUndefined(input.drivingArray["Exception_Type"]) && input.drivingArray["Exception_Type"].length > 1) {
                                    input.drivingArray["Exception_Type"] = input.drivingArray["Exception_Type"] + " , " + "GRN No/RECEIPT NO Not Present/Incorrect";
                                }
                                else {
                                    input.drivingArray["Exception_Type"] = "GRN No/RECEIPT NO Not Present/Incorrect";
                                }
                                if (!util_1.isNullOrUndefined(input.drivingArray["Invoice_Status"]) && input.drivingArray["Invoice_Status"].length > 1) {
                                    input.drivingArray["Invoice_Status"] = input.drivingArray["Exception_Type"] + " , " + "Awaiting GRN Check";
                                }
                                else {
                                    input.drivingArray["Invoice_Status"] = "Awaiting GRN Check";
                                }
                            }
                            if (!check1) {
                                input.drivingArray["GRNcheck"] = "false";
                                if (!util_1.isNullOrUndefined(input.drivingArray["Exception_Type"]) && input.drivingArray["Exception_Type"].length > 1) {
                                    input.drivingArray["Exception_Type"] = input.drivingArray["Exception_Type"] + " , " + "PO_Number is Incorect";
                                }
                                else {
                                    input.drivingArray["Exception_Type"] = "PO_Number is Incorect";
                                }
                            }
                            if ((input.drivingArray["POcheck"] == "true") && (input.drivingArray["GRNcheck"] == "true") && (input.drivingArray["error"].length == 0)) {
                                input.drivingArray["status"] = "NonBlocking";
                            }
                            else {
                                input.drivingArray["status"] = "Blocking";
                            }
                            output["POreconresult"] = input.drivingArray;
                            output["status"] = input.drivingArray["status"];
                            resolve({ message: "reconcilation done scuccessfully", status: 0, data: output });
                        }
                    }
                });
            }
            catch (e) {
                this.log.error("Failed invoice reconciliation " + e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    formatted_date(dateInput) {
        const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
        var datestring = dateInput;
        d = datestring.split("-");
        var x = d[1] + "/" + d[0] + "/" + d[2]; //converting into MM/DD/YYYY format
        var d = new Date(x);
        let current_datetime = new Date(x);
        console.log(current_datetime);
        let formatted_date = current_datetime.getDate() + "-" + months[current_datetime.getMonth()] + "-" + current_datetime.getFullYear();
        console.log(formatted_date);
        return formatted_date;
    }
    nearest_date(dateArray, testDate) {
        var day1;
        day1 = new Date(testDate);
        let daysCountArray = [];
        console.log("datearray", dateArray);
        dateArray.forEach(element => {
            var day2;
            day2 = new Date(element);
            var difference = Math.abs(day2 - day1);
            var days = difference / (1000 * 3600 * 24);
            daysCountArray.push(days);
        });
        console.log(daysCountArray);
        return daysCountArray;
    }
    getMapInput(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let self = this;
                let parsedInput = JSON.parse(input.bank);
                // let transactionRemarksArray = _.pluck(parsedInput.transaction, "Transaction Remarks");
                let transactionRemarksArray = parsedInput.transaction;
                let distinctKeyWords = [];
                let words = input.keyWords.split(",");
                for (const item of transactionRemarksArray) {
                    // var words = ['MMT','self', 'on', 'at', 'to', 'a', 'is'];
                    var re = new RegExp('\\b(' + words.join('|') + ')\\b', 'g');
                    let result = (item['Transaction Remarks'] || '').replace(re, '').replace(/[ ]{2,}/, ' ');
                    let questionText = result.replace(/\d+/g, '');
                    let type = Number(item['Withdrawal Amount (INR )']) > 0 ? '(Debit)' : '(Credit)';
                    distinctKeyWords.push(questionText + "  " + type);
                }
                let unique = distinctKeyWords.filter(function (elem, index, self) {
                    return index === self.indexOf(elem);
                });
                let ledgersData = yield self.accountHelper.getLedgers('all', input.subscriberId, input.orgId, input.gstin);
                for (const ledgerItem of ledgersData.data) {
                    if (ledgerItem['ledgerName'] !== '') {
                        ledgerItem['ledgerName'] = ledgerItem['ledgerName'] + "/" + ledgerItem['reportingHead'] + "/" + ledgerItem['accountGroup'];
                    }
                }
                output['Ledgers'] = _.pluck(ledgersData.data, "ledgerName");
                output['distinct Keys'] = unique;
                return { message: '', status: 0, data: output };
            }
            catch (e) {
                this.log.error("Failed getting input " + e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    moveFileViaUtility(input, outputParameters, botId, iterationId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "sourcePath": input.sourcePath,
                    "destinationPath": input.destinationPath,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'moveFile',
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Socket triggering for moveFileViaUtility.");
                return { message: 'Socket triggering for MoveFile Via Utility.', status: 0, data: null };
            }
            catch (e) {
                this.log.error("Error in Socket triggering for MoveFileViaUtility." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    getRowsPerPage(pageHeight, rowHeight) {
        let standardRowHeight = rowHeight;
        if (pageHeight > standardRowHeight) {
            return (pageHeight / standardRowHeight);
        }
        else {
            return 0;
        }
    }
    startNewPage(html, invoiceItems, firstPageHeight, allPageHeight, rowHeight, colWidth) {
        var htmlTable = html[1].match("<tbody>(.*)</tbody>");
        var tableArray = JSON.parse(JSON.stringify(invoiceItems));
        var tempArray = [];
        var rowsPerPage = this.getRowsPerPage(allPageHeight, rowHeight);
        var mainCounter = tableArray.length;
        while (mainCounter > 0) {
            tempArray = JSON.parse(JSON.stringify(tableArray.slice(0, rowsPerPage)));
            let getTableRows = this.replaceTableVariables(htmlTable[1], tempArray, firstPageHeight, allPageHeight, rowHeight, colWidth);
            tableArray = JSON.parse(JSON.stringify(tableArray.slice(getTableRows.counterForRowsAdded)));
            let replacePart = html[1].match("<tbody>(.*)</tbody>");
            html[1] = html[1].replace(replacePart[1], getTableRows.rows);
            let bottomTable = html[1].match("<table style=\"width:100%;margin-top: 10px\">(.*)</tr>");
            if (!util_1.isNullOrUndefined(bottomTable)) {
                html[1] = html[1].replace(bottomTable[0], '');
            }
            mainCounter = 0;
        }
        return { html: html, json: tableArray };
    }
    replaceTableVariables(htmlTable, accTransactions, firstPageHeight, allPageHeight, rowHeight, colWidth) {
        var tempArray = JSON.parse(JSON.stringify(accTransactions));
        var rowValues = [];
        var rows; // function to replace variables inside tables
        var counterForRowsAdded = 0;
        var trArr = '';
        tempArray.every((item, idx) => {
            let tableVariablesPresent = true;
            let testREcopy = htmlTable;
            do {
                let mySubString = testREcopy.substring(testREcopy.lastIndexOf("[") + 1, testREcopy.lastIndexOf("]"));
                if (util_1.isNullOrUndefined(mySubString) || mySubString == '') {
                    tableVariablesPresent = false;
                }
                let mySubString2 = mySubString;
                mySubString = '[' + mySubString + ']';
                let x = accTransactions[idx][mySubString2];
                rowValues.push({ key: mySubString2, value: accTransactions[idx][mySubString2] });
                if (!util_1.isNullOrUndefined(x)) {
                    testREcopy = testREcopy.replace(mySubString, accTransactions[idx][mySubString2]);
                }
                else {
                    testREcopy = testREcopy.replace(mySubString, '');
                }
            } while (tableVariablesPresent);
            let filteredRowValues = rowValues.filter(function (item) {
                return item.value != null;
            });
            rows = this.getWidthHeight(filteredRowValues, colWidth);
            rowValues = [];
            let remainingHeight;
            let getRemainingHeight = this.generateTables(rows, firstPageHeight, allPageHeight, rowHeight);
            if (!util_1.isNullOrUndefined(getRemainingHeight) && !util_1.isNullOrUndefined(getRemainingHeight['firstPageHeight'])) {
                firstPageHeight = getRemainingHeight['firstPageHeight'];
                remainingHeight = firstPageHeight;
            }
            else if (!util_1.isNullOrUndefined(getRemainingHeight) && !util_1.isNullOrUndefined(getRemainingHeight['allPageHeight'])) {
                allPageHeight = getRemainingHeight['allPageHeight'];
                remainingHeight = allPageHeight;
            }
            counterForRowsAdded = counterForRowsAdded + 1;
            if (remainingHeight <= rowHeight) {
                trArr = trArr + testREcopy;
                return false;
            }
            else {
                trArr = trArr + testREcopy;
                return true;
            }
        });
        return {
            rows: trArr, firstPageHeight: firstPageHeight, allPageHeight: allPageHeight, counterForRowsAdded: counterForRowsAdded
        };
    }
    getWidthHeight(data, colWidth) {
        if (data.length > 0) {
            let dataValues = [];
            data.forEach(item => {
                dataValues.push(item.value);
            });
            let reducer = (data) => data.reduce((r, c) => r.length >= c.length ? r : c); // returns longest value from data
            let longestData = reducer(dataValues);
            let keyName = data.filter(item => {
                if (item.value === longestData) {
                    return item.key;
                }
                else {
                    return '';
                }
            });
            let keyWidth = colWidth.filter(item => {
                if (item.columnName === keyName[0].key) {
                    return item.width;
                }
            });
            let dataLen = reducer(dataValues).length;
            let dataWidth = dataLen * 10; // 10 is font size
            let factor;
            if (dataWidth > keyWidth[0].width) {
                factor = dataWidth / keyWidth[0].width;
                return factor;
            }
            else {
                return 0;
            }
        }
        else {
            return 0;
        }
    }
    generateTables(rowFactor, firstPageHeight, allPageHeight, rowHeight) {
        let obj = {};
        rowFactor = Math.ceil(rowFactor);
        let height = (rowFactor > 0) ? rowFactor * rowHeight : rowHeight;
        if (firstPageHeight > rowHeight) {
            firstPageHeight = firstPageHeight - height;
            obj['firstPageHeight'] = firstPageHeight;
        }
        else {
            allPageHeight = allPageHeight - height;
            obj['allPageHeight'] = allPageHeight;
        }
        return obj;
    }
    MailrecieveData(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info('Inside emailrecieve body -- ' + JSON.stringify(input));
                let obj = {
                    user: input.user,
                    password: input.password,
                    host: input.host,
                    port: 993,
                    subject: input.Subject,
                };
                let response = yield this.MaillistnerHelper.MailrecieveData(JSON.stringify(obj));
                let parsedResponse = JSON.parse(JSON.stringify(response));
                let outputParsed = JSON.parse(parsedResponse.output);
                let obj1 = outputParsed[0];
                let obj2 = outputParsed[1];
                outputParameters['Approved_sub'] = obj1.Approved_sub;
                outputParameters['Reject_sub'] = obj1.Reject_sub;
                outputParameters['htmldata'] = obj1.htmldata;
                outputParameters['tomail'] = obj1.tomail;
                outputParameters['responsemail'] = obj2;
                if (util_1.isNullOrUndefined(response)) {
                    return { info: 'error occured', status: 1, data: 'email not read' };
                }
                else {
                    return { info: 'mail recieve successfully', status: 0, data: outputParameters };
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    mailDataCalculater(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            console.log("In mailDataCalculater function");
            input = input.input;
            try {
                let flag = {}, delayCost, to, from, value;
                if (!util_1.isNullOrUndefined(input.to) && !util_1.isNullOrUndefined(input.from)) {
                    to = input.to;
                    from = input.from;
                }
                const tableData = yield travelCost_1.travelCost.find({ "isDeleted": false, to: to, from: from });
                if (!util_1.isNullOrUndefined(tableData) && tableData.length > 0) {
                    delayCost = tableData[0].delayCost * input.days;
                }
                let costCenter = input.costCenter;
                let data = yield costCenterBuget_1.coustCenterBuget.find({ "isDeleted": false, costCenter: costCenter });
                if (!util_1.isNullOrUndefined(data) && data.length > 0) {
                    if (data[0].usedBuget + delayCost <= data[0].allocatedBuget) {
                        value = data[0].usedBuget + delayCost;
                        flag = "Approved";
                        yield costCenterBuget_1.coustCenterBuget.findOneAndUpdate({ "isDeleted": false, costCenter: costCenter }, { $set: { usedBuget: value } }, { upsert: true, new: true });
                    }
                    else {
                        flag = "Reject";
                    }
                }
                output['output'] = flag;
                output['body'] = input.body;
                output['fromMail'] = input.fromMail;
                output['tomail'] = input.tomail;
                output['subject'] = input.subject;
                return { message: "Data Fount sucessfully", status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error in mailDataCalculater" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    mapKeys(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            console.log("in mapKeys-->");
            try {
                let newKeys = [];
                let data, oldKey = [], obj = [];
                if (!util_1.isNullOrUndefined(input.data) && input.data != '') {
                    data = JSON.parse(input.data);
                    obj = JSON.parse(input.input);
                    newKeys = Object.keys(data).map(function (e) {
                        return data[e];
                    });
                    oldKey = Object.keys(data);
                    let i = 0, j = 0;
                    for (i = 0; i < obj.length; i++) {
                        for (j = 0; j < newKeys.length; j++) {
                            obj[i][newKeys[j]] = obj[i][oldKey[j]];
                            delete obj[i][oldKey[j]];
                        }
                    }
                }
                output['output'] = obj;
                return { message: "Process sucessfull completed", status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error in exiseRate" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    insertDBBot(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                var mClient, db, insertData;
                mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                db = mClient.db(env_2.env.dbConfig.dbname);
                return new Promise(function (resolve, reject) {
                    return tslib_2.__awaiter(this, void 0, void 0, function* () {
                        if (!util_1.isNullOrUndefined(input.tableName)) {
                            if (input.key === "Real Estate Insured") {
                                insertData = {
                                    Keynames: "PropertyOwners",
                                    "type": input.key,
                                    "value": input.value,
                                    DocumentType: "Product"
                                };
                            }
                            else {
                                insertData = {
                                    Keynames: "TurnOver",
                                    "type": input.key,
                                    "value": input.value,
                                    DocumentType: "Product"
                                };
                            }
                            if (!util_1.isNullOrUndefined(insertData)) {
                                let result = yield db.collection(input.tableName).insert(insertData);
                                console.log(result);
                                output['result'] = result;
                                if (!util_1.isNullOrUndefined(result)) {
                                    resolve({ message: "Data inserted sucessfully", status: 0, data: output });
                                }
                                else {
                                    resolve({ message: "Error in inserting data into DB", status: 1, data: output });
                                }
                            }
                        }
                        else {
                            reject({ message: "DB details not found", status: 1, data: output });
                        }
                    });
                });
                //return { message: "Data inserted sucessfully", status: 0, data: evalResult };
            }
            catch (e) {
                this.log.error("Error in inserting data into DB" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    exiseRate(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            console.log("In exiseRate function");
            var mClient, db, inputData;
            var startHeader = 1;
            if (!util_1.isNullOrUndefined(input.mongodb_uri) && !util_1.isNullOrUndefined(input.dbName)) {
                mClient = yield MongoClient.connect(input.mongodb_uri);
                db = mClient.db(input.dbName);
            }
            else {
                mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                db = mClient.db(env_2.env.dbConfig.dbname);
            }
            let failData = [];
            let sucessData = [];
            if (!util_1.isNullOrUndefined(input.excelPath) && input.excelPath !== "") {
                console.log("------>>>>>>>", input.excelPath);
                let workbook = XLSX.readFile(input.excelPath);
                var sheet_name_list = workbook.SheetNames;
                sheet_name_list.forEach(function (y) {
                    var worksheet = workbook.Sheets[y];
                    var headers = {};
                    var data = [];
                    for (var z in worksheet) {
                        if (z[0] === '!')
                            continue;
                        //parse out the column, row, and value
                        var tt = 0;
                        var f = JSON.parse(JSON.stringify(z));
                        for (var q = 0; q < f.length; q++) {
                            if (!isNaN(f[q])) {
                                tt = q;
                                break;
                            }
                        }
                        ;
                        var col = z.substring(0, tt);
                        var row = parseInt(z.substring(tt));
                        var value = worksheet[z].v;
                        //store header names
                        if (row == startHeader && value) {
                            headers[col] = value;
                            continue;
                        }
                        if (!data[row])
                            data[row] = {};
                        data[row][headers[col]] = value;
                    }
                    const filtered = data.filter(Boolean);
                    inputData = filtered;
                });
            }
            else {
                inputData = JSON.parse(JSON.stringify(input.input));
            }
            console.log("inputData length-->>", inputData.length);
            try {
                let query = {
                    startDate: { $nin: [null] },
                    endDate: null,
                };
                let evalResult;
                let arrExciseCategory = yield exicesPercentage_1.exicesPercentage.distinct("productDescription");
                let i;
                for (i = 0; i < arrExciseCategory.length; i++) { // for loop start distinct excise category(productDescription)collection
                    let insertExciseRate = [];
                    let filterCategory = _.where(inputData, { "productDescription": arrExciseCategory[i] }); //filter given list categorywaise
                    query["productDescription"] = arrExciseCategory[i];
                    let ftaExciseRate = yield exciseRate.find(query); //get excise rate data for current version
                    for (let j = 0; j < filterCategory.length; j++) { //for loop start filtring catgory data
                        if (util_1.isNullOrUndefined(filterCategory[j])) {
                            console.log("Excise Rate Save: ", "excise rate null or undefined");
                            filterCategory[j]['Date'] = new Date;
                            filterCategory[j]['Fail Reason'] = "filterCategory is null or undefined";
                            failData.push(filterCategory[j]);
                        }
                        else if (util_1.isNullOrUndefined(filterCategory[j].itemCode) || filterCategory[j].itemCode == "") {
                            console.log("Excise Rate Save: ", "itemcode blank or undefined");
                            filterCategory[j]['Date'] = new Date;
                            filterCategory[j]['Fail Reason'] = "item code is null";
                            failData.push(filterCategory[j]);
                        }
                        else if (filterCategory[j].excisePrice == undefined || filterCategory[j].excisePrice == "" && filterCategory[j].excisePrice !== 0) {
                            console.log("Excise Rate Save: ", "excise price blank or undefined");
                            filterCategory[j]['Date'] = new Date;
                            filterCategory[j]['Fail Reason'] = "excise price is null";
                            failData.push(filterCategory[j]);
                        }
                        else {
                            filterCategory[j]['startDate'] = new Date;
                            filterCategory[j]['endDate'] = null;
                            filterCategory[j]['isDeleted'] = false;
                            filterCategory[j]['itemCode'] = JSON.stringify(filterCategory[j]['itemCode']);
                            filterCategory[j]['HSCode'] = JSON.stringify(filterCategory[j]['HSCode']);
                            filterCategory[j]['excisePrice'] = JSON.stringify(filterCategory[j]['excisePrice']);
                            var previousDate = new Date(inputData[0].startDate);
                            previousDate.setDate(previousDate.getDate() - 1);
                            let sameExciseRate = _.where(ftaExciseRate, { "itemCode": filterCategory[j]["itemCode"], "itemDescription": filterCategory[j]["itemDescription"] });
                            if (sameExciseRate.length == 0) {
                                insertExciseRate.push({ insertOne: { "document": filterCategory[j] } });
                            }
                            else {
                                if (sameExciseRate[0].excisePrice != filterCategory[j]["excisePrice"]
                                    || sameExciseRate[0].HSCode != filterCategory[j]["HSCode"]
                                    || sameExciseRate[0].itemDescription != filterCategory[j]["itemDescription"]
                                    || sameExciseRate[0].productDescription != filterCategory[j]["productDescription"]
                                    || sameExciseRate[0].brand != filterCategory[j]["brand"]) {
                                    insertExciseRate.push({ insertOne: { "document": filterCategory[j] } }, {
                                        updateMany: {
                                            "filter": { "_id": sameExciseRate[0]._id },
                                            "update": { $set: { "endDate": previousDate } }
                                        }
                                    });
                                }
                            }
                        }
                    } // end for loop filtering category data
                    //insert and update - bulk data
                    if (!util_1.isNullOrUndefined(insertExciseRate) && insertExciseRate.length > 0) {
                        let col = db.collection('exciserates');
                        let data = yield col.bulkWrite(insertExciseRate, { ordered: false });
                        if (util_1.isNullOrUndefined(data)) {
                            sucessData.push(insertExciseRate);
                            console.log("Excise rate not Save:");
                        }
                        else {
                        }
                    }
                    else {
                        evalResult = {
                            "status": true,
                            "info": "Saved successfully..!!",
                            "value": null
                        };
                    }
                } //end for loop distinct excise category
                if (!util_1.isNullOrUndefined(failData) && failData.length > 0) {
                    yield db.collection('LogExices').insert(failData);
                }
                return { message: "Data Fount sucessfully", status: 0, data: evalResult };
            }
            catch (e) {
                this.log.error("Error in exiseRate" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    getYesyerdaysdate(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let currentDate = new Date();
                currentDate.setDate(currentDate.getDate() - 1);
                let day = currentDate.getDate().toString();
                let month = (currentDate.getMonth() + 1).toString();
                let year = currentDate.getFullYear();
                if (Number(day) <= 9) {
                    day = "0" + day;
                }
                if (Number(month) <= 9) {
                    month = "0" + month;
                }
                let fromDateToDate = day + "" + month + "" + year + " " + day + "" + month + "" + year;
                output["fromDateToDate"] = fromDateToDate;
                return { message: "fromDateToDate calculated sucessfully", status: 0, data: output };
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    readcsv(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                var options = {
                    delimiter: ',',
                    quote: '"' // optional
                };
                let csvpath = input.csvPath;
                let filename = csvpath.split("_")[1];
                let fileref = csvpath.split("_")[0].split("/");
                let fileRefNum = fileref[fileref.length - 1];
                console.log(fileRefNum);
                filename = input.filename;
                //filename = filename + '.pdf';
                console.log("file ----->:>:>:", filename);
                let historicalDataCsv = input.historicalData;
                console.log(historicalDataCsv);
                let fileContent = fs.readFileSync(csvpath, { encoding: 'utf8' });
                var jsoncsv = csvjson.toObject(fileContent, options);
                //console.log(jsoncsv);
                //let historicalContent = fs.readFileSync(historicalData, { encoding: 'utf8' });
                //var historicalDataCsv = csvjson.toObject(historicalContent, options);
                var matchjson = null;
                historicalDataCsv.forEach((data, index) => {
                    if (data["File Name"] == filename) {
                        matchjson = historicalDataCsv[index];
                    }
                });
                let obj = {
                    "Invoice #": matchjson["Invoice #"],
                    "Invoice Date": matchjson["Invoice Date"],
                    "Supplier Name": matchjson["Supplier Name"],
                    "Invoice Total Amount": matchjson["Invoice Total Amount"],
                    "Supplier TRN": matchjson["Supplier TRN"],
                    "Customer PO Number": matchjson["Customer PO Number"],
                    "Invoice Currency": matchjson["Invoice Currency"],
                    "Customer TRN": matchjson["Customer TRN"] //"100270983800003"
                };
                /*
                "Invoice Currency": "AED",         "Supplier TRN": "1003 5766 5700 003",
                "Customer TRN": "100270983800003", "Invoice Total Amount": 3360,
                "Customer PO Number": 8788,        "Invoice Date": "15/02/2021"
                "Invoice Title": "Standard",       "Supplier Site": "DUBAI, UAE",
                "Supplier Address": "1204 Gold Crest Executive Tower, Cluster C, JLT"*/
                var exceptionFlag = false;
                for (const item in obj) { //iterating over object
                    console.log(item, obj[item]);
                    let count = 0;
                    let indices = [];
                    jsoncsv.forEach((val, index) => {
                        if (val["Name"] == obj[item]) { //matching field value without any regex
                            count++;
                            indices.push(index);
                        }
                        else {
                            if ((/[\d,]+/.test(obj[item])) && (count == 0)) { //checking it is number or not
                                //console.log(/[\d~,]+/.test(val["Name"]),"--", val["Name"]);
                                if (/[\d~,]+/.test(val["Name"])) { //checking it is amount with , or ~
                                    var temp = null;
                                    var temp1 = null;
                                    if (val["Name"].search(',') >= 0) { //check for , in amount
                                        temp1 = val["Name"].replace(",", "");
                                        if (obj[item] == temp1) {
                                            count++;
                                            indices.push(index);
                                        }
                                        else {
                                            if (temp1.search('-') >= 0) { //check for - in amount
                                                temp1 = temp1.replace("-", "");
                                                if (Number(obj[item]) == temp1) {
                                                    count++;
                                                    indices.push(index);
                                                }
                                            }
                                        }
                                    }
                                    else if (val["Name"].search('~') >= 0) { //checking for ~
                                        temp = val["Name"].replace("~", "");
                                        if (obj[item] == temp) {
                                            count++;
                                            indices.push(index);
                                        }
                                        else {
                                            console.log("In else", temp);
                                            temp = temp.replace("/", "");
                                            console.log(temp, obj[item]);
                                            //console.log(obj[item], obj[item].length);
                                            if (temp == Number(obj[item])) { //checking for /
                                                console.log(temp, obj[item]);
                                                count++;
                                                indices.push(index);
                                            }
                                        }
                                    }
                                    else if (val["Name"].includes(obj[item])) {
                                        console.log(/[\d~,]+/.test(val["Name"]), "--------", val["Name"]); //check for string included in field value
                                        count++;
                                        indices.push(index);
                                    }
                                    else if (/^(0?[1-9]|[12][0-9]|3[01])[\/\-](0?[1-9]|1[012])[\/\-]\d{4}$/.test(obj[item])) { //check for object is date
                                        console.log("in date check condition", obj[item]);
                                        const months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
                                        var datestring = obj[item];
                                        d = datestring.split("/");
                                        var x = d[1] + "/" + d[0] + "/" + d[2]; //converting into MM/DD/YYYY format
                                        var d = new Date(x);
                                        let current_datetime = new Date(x);
                                        console.log(current_datetime);
                                        let formatted_date = current_datetime.getDate() + " " + months[current_datetime.getMonth()] + " " + current_datetime.getFullYear();
                                        console.log(formatted_date);
                                        if (val["Name"] == formatted_date) { //checking for matching date
                                            count++;
                                            indices.push(index);
                                        }
                                    }
                                    else {
                                        if (obj[item].search(',') >= 0) {
                                            obj[item] = obj[item].replace(" ", "");
                                            let str = obj[item].split(",");
                                            if (val["Name"].includes(str[0])) {
                                                console.log(val["Name"]);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    });
                    if (count == 1) { //single match
                        console.log(".......property match......", count);
                        jsoncsv[indices[0]]["property"] = item;
                        console.log(jsoncsv[indices[0]]["Name"] + "====>>>>" + jsoncsv[indices[0]]["property"]);
                    }
                    else {
                        if ((count > 1) || (count == 0)) { //no match or mutliple matches
                            exceptionFlag = true;
                            if (indices.length > 0) {
                                indices.forEach((i) => {
                                    //jsoncsv[i]["property"] = "exception";
                                    console.log(jsoncsv[i]["Name"] + "====>>>>" + jsoncsv[i]["property"]);
                                });
                            }
                        }
                    }
                    console.log("exception", exceptionFlag);
                }
                outputParameters['jsonCsv'] = jsoncsv;
                outputParameters['fileRefNum'] = fileRefNum;
                outputParameters["pretrainedStatus"] = !exceptionFlag;
                this.log.info("reading csv file");
                return { message: 'CSV read successfully.', status: 0, data: outputParameters };
            }
            catch (e) {
                this.log.error("Error in reading csv file" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    saveDocumentTraining(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            /*Rule for save document level training*/
            try {
                this.log.info('Inside save document training function');
                let obj = {};
                obj['documentType'] = !util_1.isNullOrUndefined(input.documentType) ? input.documentType : '';
                obj['fileRefNum'] = !util_1.isNullOrUndefined(input.fileRefNum) ? input.fileRefNum : '';
                obj['isTrained'] = false;
                obj['preTrainedStatus'] = !util_1.isNullOrUndefined(input.pretrainedStatus) ? input.pretrainedStatus : '';
                if (!util_1.isNullOrUndefined(input.documentCsvData) && input.documentCsvData.length > 0) {
                    input.documentCsvData.forEach((val, index) => {
                        if (val["HasDate"] == '') {
                            val["HasDate"] = 0;
                        }
                        if (val["TOP_HasDate"] == '') {
                            val["TOP_HasDate"] = 0;
                        }
                        if (val["BOTTOM_HasDate"] == '') {
                            val["BOTTOM_HasDate"] = 0;
                        }
                        if (val["RIGHT_HasDate"] == '') {
                            val["RIGHT_HasDate"] = 0;
                        }
                        if (val["LEFT_HasDate"] == '') {
                            val["LEFT_HasDate"] = 0;
                        }
                    });
                    //console.log(input.documentCsvData);
                    obj['documentCsvData'] = input.documentCsvData;
                }
                let trainingData = new docTraining(obj);
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    trainingData.save(function (err, data) {
                        if (err) {
                            output['data'] = err;
                            throw err;
                            reject({ message: 'error in saving data', status: 1, data: err });
                        }
                        else {
                            output['data'] = !util_1.isNullOrUndefined(data) ? true : false;
                            console.log('Document training data saved successfully');
                            resolve({ message: 'data saved successfully.', status: 0, data: output });
                        }
                    });
                }));
            }
            catch (err) {
                console.log('Failed for save document training data - ' + err);
                return { message: 'data saved successfully.', status: 0, data: output };
            }
        });
    }
    readcsvfromserver(input, outputParameters, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "headerstring": input.headerstring,
                    "csvPath": input.csvPath,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": input.iterationId,
                    "eventId": input.eventId,
                };
                let csvpath = obj.csvPath;
                let replaceheader = obj.headerstring;
                let fileContent = fs.readFileSync(csvpath, { encoding: 'utf8' });
                var firstLineRemovedString = fileContent.replace(/.*/, replaceheader);
                fs.writeFileSync(csvpath, firstLineRemovedString);
                outputParameters['csvpath'] = csvpath;
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Socket triggering for readcsvfromserver.");
                return { message: 'Socket triggering for readcsvfromserver.', status: 0, data: outputParameters };
            }
            catch (e) {
                this.log.error("Error in Socket triggering for readcsvfromserver." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    compareData(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("---->>>compareData<<<----");
                let outputData = [];
                let referenceNumberinput = input.referenceNumber;
                let mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                let db = mClient.db(env_2.env.dbConfig.dbname);
                let data2 = yield db.collection('errorinvoices').find({ referenceNumber: referenceNumberinput }).toArray();
                let masterArr = [];
                let masterArr2 = [];
                let medical_condition = [];
                if (!util_1.isNullOrUndefined(input.data) && input.data.length > 0 && input.prescription.length > 0 && !util_1.isNullOrUndefined(input.prescription)) {
                    input.data.forEach(element => {
                        if (element.category.toLocaleLowerCase() == 'medical_condition') {
                            medical_condition.push(element.text.toLowerCase());
                        }
                    });
                    input.prescription.forEach(element => {
                        if (element.category.toLocaleLowerCase() == 'medical_condition') {
                            medical_condition.push(element.text.toLowerCase());
                        }
                    });
                }
                let data = yield pdftk_1.pdfModel.find({ medical_condition: { $in: medical_condition } });
                data.forEach(element => {
                    masterArr.push(element.medication.toLocaleLowerCase());
                    masterArr2.push(element.medication.toLocaleLowerCase());
                });
                if (!util_1.isNullOrUndefined(input.data) && input.data.length > 0) {
                    input.data.forEach(element => {
                        if (element.category.toLocaleLowerCase() == 'medication') {
                            if (masterArr.indexOf(element.text.toLocaleLowerCase()) == -1) {
                                masterArr.push(element.text.toLocaleLowerCase());
                            }
                        }
                    });
                }
                if (!util_1.isNullOrUndefined(input.prescription) && input.prescription.length > 0) {
                    input.prescription.forEach(element => {
                        if (element.category.toLocaleLowerCase() == 'medication') {
                            if (masterArr2.indexOf(element.text.toLocaleLowerCase()) == -1) {
                                masterArr2.push(element.text.toLocaleLowerCase());
                            }
                        }
                    });
                }
                if (!util_1.isNullOrUndefined(data2) && data2.length > 0) {
                    data2.forEach(element => {
                        if (element.invoiceItems.length > 1) {
                            if (element.invoiceItems.length > 1) {
                                element.invoiceItems.forEach(element => {
                                    if (!util_1.isNullOrUndefined(element.productName)) {
                                        if (masterArr.indexOf(element.productName.toLocaleLowerCase()) !== -1 &&
                                            masterArr2.indexOf(element.productName.toLocaleLowerCase()) !== -1) {
                                            element["status"] = "Yes";
                                        }
                                        else {
                                            element["status"] = "No";
                                        }
                                        outputData.push(element);
                                    }
                                });
                            }
                            else {
                                if (masterArr.indexOf(element.invoiceItems[0].productName.toLocaleLowerCase()) !== -1
                                    && masterArr2.indexOf(element.invoiceItems[0].productName.toLocaleLowerCase()) !== -1) {
                                    element.invoiceItems[0]["status"] = "Yes";
                                }
                                else {
                                    element.invoiceItems[0]["status"] = "No";
                                }
                                outputData.push(element.invoiceItems[0]);
                            }
                        }
                    });
                }
                output['output'] = outputData;
                return { message: "Data Fount sucessfully", status: 0, data: output };
            }
            catch (e) {
                console.log("Error in exiseRate" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    strConcate(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info("in strConcate-->");
            try {
                if (!util_1.isNullOrUndefined(input) && input !== "") {
                    let str = '';
                    delete input['eventId'];
                    delete input['orgId'];
                    delete input['subscriberId'];
                    delete input['orgId'];
                    delete input['userId'];
                    let key = Object.keys(input);
                    for (let i = 0; i < key.length; i++) {
                        str += input[key[i]];
                        str += " ";
                    }
                    output['output'] = str;
                    return { message: "Process sucessfull completed", status: 0, data: output };
                }
                else {
                    return { message: "Input data is null", status: 1, data: output };
                }
            }
            catch (e) {
                this.log.error("Error in exiseRate" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    Aggregation(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info("in Aggregate--->>>");
            try {
                if (!util_1.isNullOrUndefined(input) && input !== "") {
                    let collection = input.collectionName;
                    let aggregate = !util_1.isNullOrUndefined(input.aggregate) ? String(input.aggregate) : input.aggregate;
                    let query = !util_1.isNullOrUndefined(input.query) && typeof input.query == 'string' ? JSON.parse(input.query) : input.query;
                    let limit = -1;
                    let resp = [];
                    if (!util_1.isNullOrUndefined(input.limit) && input.limit !== "") {
                        limit = Number(input.limit);
                    }
                    if (!util_1.isNullOrUndefined(query) && !util_1.isNullOrUndefined(aggregate)) {
                        if (!Array.isArray(query) && query[0] == "[") {
                            query = JSON.stringify(query);
                            query = query.replace(/"/g, "");
                        }
                        if (aggregate == "true")
                            resp = yield (db.collection(collection)).aggregate(query);
                        else
                            resp = yield (db.collection(collection)).find(query);
                    }
                    else {
                        resp = yield (db.collection(collection)).find().limit(limit);
                    }
                    let count = resp.length;
                    output['output'] = resp;
                    output['count'] = count;
                    return { message: "Process sucessfull completed", status: 0, data: output };
                }
                else {
                    return { message: "Input data is null", status: 1, data: output };
                }
            }
            catch (e) {
                this.log.error("Error in Aggregation" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    dataCompare(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info("in dataConcate-->");
            try {
                if (!util_1.isNullOrUndefined(input) && input !== "") {
                    let result = input.result;
                    let finalArr = [];
                    let perCount = input.search.split(/[ ,-]+/);
                    let criteria = input.criteria;
                    let csvData;
                    if (result.length > 0 && !util_1.isNullOrUndefined(result)) {
                        if (!Array.isArray(result) && result[0] == '[') {
                            result = JSON.parse(result);
                        }
                        let ioData = [];
                        result.forEach(element => {
                            let total = 0;
                            let userData;
                            let key = Object.keys(element);
                            key.forEach(item => {
                                let count = 0;
                                if (!util_1.isNullOrUndefined(element[item]) && element[item] !== "" && element[item].length > 0) {
                                    csvData = element[item].split(/[ ,-]+/);
                                }
                                if (!util_1.isNullOrUndefined(input[item]) && input[item] !== "") {
                                    userData = input[item].split(/[ ,-]+/);
                                }
                                if (csvData.includes('yrs')) {
                                    csvData.splice(2, 2);
                                }
                                if (Number.isInteger(Number(csvData[0]))) {
                                    if (!util_1.isNullOrUndefined(userData) && userData.length > 0) {
                                        userData.forEach((num, index) => {
                                            if (!Number.isInteger(Number(num))) {
                                                userData.splice(index, 1);
                                            }
                                        });
                                    }
                                }
                                if (!util_1.isNullOrUndefined(input[item] && input[item] !== "")) {
                                    ioData = input[item].split(/[ ,-]+/);
                                }
                                if (csvData.length > 0) {
                                    if (Number.isInteger(Number(csvData[0]))) {
                                        if (csvData[0] <= ioData[0]) {
                                            count++;
                                        }
                                        if (csvData[1] >= ioData[1]) {
                                            count++;
                                        }
                                    }
                                    else {
                                        csvData.forEach(c => {
                                            if (!util_1.isNullOrUndefined(ioData) && ioData.length > 0) {
                                                ioData.forEach(d => {
                                                    if (c.toString().toLowerCase() == d.toString().toLowerCase()) {
                                                        count++;
                                                    }
                                                });
                                            }
                                            ;
                                        });
                                    }
                                }
                                if (!util_1.isNullOrUndefined(userData) && userData.length > 0) {
                                    total += count / userData.length * 100;
                                }
                            });
                            let per = total / perCount.length;
                            if (per >= criteria) {
                                element['Persentage'] = per;
                                finalArr.push(element);
                            }
                        });
                    }
                    output['output'] = finalArr;
                    return { message: "Process sucessfull completed", status: 0, data: output };
                }
                else {
                    return { message: "Input data is null", status: 1, data: output };
                }
            }
            catch (e) {
                this.log.error("Error in Compare data" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    arrayObj(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info("in arrayObj-->", input);
            try {
                if (!util_1.isNullOrUndefined(input) && input !== "") {
                    if (!util_1.isNullOrUndefined(input.array) && input.array.length > 0) {
                        let index;
                        if (!util_1.isNullOrUndefined(input.iterationId) && input.iterationId !== "") {
                            index = Number(input.iterationId);
                        }
                        else {
                            index = iterationId;
                        }
                        let data = input.array;
                        if (!Array.isArray(data) && data[0] == "[") {
                            data = JSON.parse(data);
                        }
                        if (typeof data[index] == "object" && !util_1.isNullOrUndefined(data[index]) && !util_1.isNullOrUndefined(data[index]['path'])) {
                            output['path'] = data[index]['path'];
                        }
                        output["output"] = data[index];
                        output['outputArray'] = [];
                        output['outputArray'].push(data[index]);
                        let len = data.length - 1;
                        if (!util_1.isNullOrUndefined(data) && len == index) {
                            index = -1;
                        }
                        output["index"] = index + 1;
                        return {
                            message: " arrayObj Process sucessfull completed",
                            status: 0,
                            data: output
                        };
                    }
                    return { message: "Input Array is null", status: 1, data: output };
                }
                else {
                    return { message: "Input data is null", status: 1, data: output };
                }
            }
            catch (e) {
                this.log.error("Error in exiseRate" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    arrayLength(inputData, outputParameters, botId, projectId, iterationId) {
        try {
            let arr = inputData.arr;
            // arr = ['a','b','c']
            if (typeof inputData.arr == 'string') {
                arr = JSON.parse(inputData.arr);
                outputParameters["length"] = arr.length;
                return { info: "length found", status: 0, data: outputParameters };
            }
            else if (Array.isArray(arr)) {
                outputParameters["length"] = arr.length;
                return { info: "length found", status: 0, data: outputParameters };
            }
            else {
                return { info: "input type not valid", status: 0, data: outputParameters };
            }
        }
        catch (e) {
            this.log.error("Error in finding length" + e);
            return { message: e, status: 1, data: e };
        }
    }
    EMailrecieveData(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info('Inside emailrecieve body -- ' + JSON.stringify(input));
                let obj = {
                    user: input.user,
                    password: input.password,
                    host: input.host,
                    port: 993,
                    allorseen: input.allorseen,
                    date: input.date,
                    subject: input.subject,
                    from: input.from,
                    to: input.to,
                };
                let response = yield this.EMaillistnerHelper.EMailrecieveData(JSON.stringify(obj));
                let parsedResponse = JSON.parse(JSON.stringify(response));
                let outputParsed = JSON.parse(parsedResponse.output);
                let obj1 = outputParsed[0];
                let obj2 = outputParsed[1];
                outputParameters['subject'] = obj1.subject;
                outputParameters['textbody'] = obj1.textbody;
                outputParameters['htmlbody'] = obj1.htmlbody;
                outputParameters['fromMail'] = obj1.fromMail;
                outputParameters['tomail'] = obj1.tomail;
                outputParameters['attachment_path'] = obj1.attachment_path;
                outputParameters['responsemail'] = obj2;
                if (util_1.isNullOrUndefined(response)) {
                    return { info: 'error occured', status: 1, data: 'email not read' };
                }
                else {
                    return { info: 'mail recieve successfully', status: 0, data: outputParameters };
                }
            }
            catch (e) {
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    chatGenieAPI_Bot(inputData, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const options = {
                    method: inputData.method,
                    headers: {
                        'Origin': inputData.header,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        input: {
                            prompt: inputData.prompt,
                            userId: inputData.userId,
                            orgId: inputData.organisationId,
                            subscriberId: inputData.subsId,
                            mode: inputData.mode,
                            collN: inputData.collN,
                            supervisor: inputData.supervisor,
                            permission: inputData.permission,
                            module: inputData.module
                        }
                    }),
                };
                console.log('options ', options);
                const response = yield fetch(inputData.remoteURL, options);
                const temp = yield response.json();
                temp.response = temp.response.replace(/\n/g, '\\\\n');
                console.log('Response from the Chat genie API ', temp);
                return { message: 'Message Fetched succesfully ', status: 0, data: temp };
            }
            catch (e) {
                console.log('failed to fetch  the Chat Genie API', e);
                return { message: 'ailed to fetch  the Chat Genie API', status: 1, data: [] };
            }
        });
    }
    queryHelper(queue, userList) {
        let queueId = queue._id;
        userList = userList.map((item) => ObjectId(item));
        let query = [{
                $facet: {
                    queueDocuments: [
                        {
                            "$match": {
                                "queueId": ObjectId(queueId),
                                "isFileQueued": true,
                                "orchestratorStatus": {
                                    "$in": [
                                        "inprogress",
                                        "inProgress"
                                    ]
                                },
                            }
                        },
                        {
                            $sort: {
                                _id: 1
                            }
                        },
                        {
                            $lookup: {
                                from: "events",
                                let: { eventId: "$eventId" },
                                as: "customerInfo",
                                pipeline: [
                                    { $match: { $expr: { $eq: ["$_id", "$$eventId"] } } },
                                    { $project: { "additionalInfoVar.sender_email": 1, _id: 0 } } // Include only specific fields
                                ]
                            }
                        },
                        {
                            $lookup: {
                                from: "users",
                                let: { email: { $arrayElemAt: ["$customerInfo.additionalInfoVar.sender_email", 0] } },
                                as: "userInfo",
                                pipeline: [
                                    { $match: { $expr: { $eq: ["$personalInfo.email", "$$email"] } } },
                                    { $match: { $expr: { $eq: ["$orgId", "$$orgId"] } } },
                                    { $project: { _id: 1 } } // Include only specific fields
                                ]
                            }
                        },
                        {
                            $lookup: {
                                from: "livelocation_r",
                                let: { id: { $arrayElemAt: ["$userInfo._id", 0] } },
                                as: "locations",
                                pipeline: [
                                    { $match: { $expr: { $eq: ["$userId", "$$id"] } } },
                                    { $project: { long: 1, lat: 1, _id: 0 } } // Include only specific fields
                                ]
                            }
                        },
                        {
                            $set: {
                                locationCoord: {
                                    $cond: [
                                        { $gt: [{ $size: "$locations" }, 0] },
                                        [
                                            { $arrayElemAt: ["$locations.long", 0] },
                                            { $arrayElemAt: ["$locations.lat", 0] },
                                        ],
                                        null,
                                    ],
                                },
                            },
                        },
                        {
                            $project: {
                                _id: 1,
                                eventId: "$eventId",
                                botId: "$botId",
                                queueId: "$queueId",
                                processId: "$processId",
                                projectId: "$projectId",
                                iterationId: "$iterationId",
                                "email": { $arrayElemAt: ["$customerInfo.additionalInfoVar.sender_email", 0] },
                                userInfoId: { $arrayElemAt: ["$userInfo._id", 0] },
                                locations: { $arrayElemAt: ["$locations", 0] },
                                locationCoord: 1
                            }
                        }
                    ],
                    totalUserTasks: [
                        {
                            $match: {
                                "assignToList.assignedToId": { $in: userList },
                                "queueId": ObjectId(queueId),
                                "orchestratorStatus": {
                                    "$in": [
                                        "inprogress",
                                        "inProgress"
                                    ]
                                },
                            }
                        },
                        {
                            $unwind: "$assignToList"
                        },
                        {
                            $group: {
                                _id: {
                                    id: "$assignToList.assignedToId",
                                },
                                count: { $sum: 1 }
                            }
                        },
                        {
                            $sort: { count: 1 }
                        },
                        // {
                        //   $limit: 1  
                        // },
                        {
                            $project: {
                                id: "$_id.id",
                                count: 1
                            }
                        }
                    ],
                }
            },
            {
                $addFields: {
                    updatedArray: {
                        $map: {
                            input: userList,
                            as: "arrayValue",
                            in: {
                                $cond: {
                                    if: {
                                        $in: [
                                            "$$arrayValue",
                                            { $ifNull: [{ $map: { input: "$totalUserTasks", as: "obj", in: "$$obj.id" } }, []] } // Ensure that the second argument is always an array
                                        ]
                                    },
                                    then: { $arrayElemAt: [{ $filter: { input: "$totalUserTasks", as: "obj", cond: { $eq: ["$$obj.id", "$$arrayValue"] } } }, 0] },
                                    else: { id: "$$arrayValue", count: 0 } // new object with count 0 if not found
                                }
                            }
                        }
                    }
                }
            },
        ];
        return query;
    }
    automatedQueue(inputData, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let queues = yield db.collection('queues').find({ orgId: inputData.orgId, isDeleted: false }).lean();
                if (queues.length == 0) {
                    return { message: 'No queues found', status: 1, data: [] };
                }
                console.log("Queues Fetched, ", queues.length);
                for (let i = 0; i < queues.length; i++) {
                    let queue = queues[i];
                    let adminUserList = queue.queOwner.reduce((acc, item) => {
                        acc.push(item.OwnerId.toString());
                        return acc;
                    }, []);
                    let userList = queue.assignToList.reduce((acc, item) => {
                        if (!adminUserList.includes(item.assignedToId.toString())) {
                            acc.push(item.assignedToId.toString());
                        }
                        return acc;
                    }, []);
                    let query = yield this.queryHelper(queue, userList);
                    let checkInEventStatus = yield db.collection('eventstatuses').aggregate(query).allowDiskUse(true);
                    if (!util_1.isNullOrUndefined(checkInEventStatus) && checkInEventStatus.length == 0) {
                        continue;
                    }
                    console.log("EventStatus task length, ", checkInEventStatus.length);
                    let { queueDocuments, totalUserTasks, updatedArray } = checkInEventStatus[0];
                    console.log("queueDocuments   ", queueDocuments);
                    console.log("totalUserTasks   ", totalUserTasks);
                    console.log("updatedArray   ", updatedArray);
                    if (util_1.isNullOrUndefined(queueDocuments) || queueDocuments.length == 0) {
                        continue;
                    }
                    updatedArray = updatedArray.sort((a, b) => a.count - b.count);
                    updatedArray = updatedArray.filter((item) => item.count < queue.bucketThershold);
                    console.log("queueDocuments.length   ", queueDocuments.length);
                    if (util_1.isNullOrUndefined(updatedArray) || updatedArray.length == 0) {
                        continue;
                    }
                    let lesserTaskUser;
                    let filteredDocuments = queueDocuments.filter(item => item.locationCoord != null);
                    if (filteredDocuments.length == 0) {
                        continue;
                    }
                    let closetUser = yield db.collection("livelocation_r").aggregate([
                        {
                            $geoNear: {
                                near: {
                                    type: "Point",
                                    coordinates: filteredDocuments[0].locationCoord
                                },
                                distanceField: "distance",
                                maxDistance: inputData.maxLength ? inputData.maxLength : 50000,
                                spherical: true
                            }
                        },
                        {
                            $match: {
                                userId: { $in: updatedArray.map(item => ObjectId(item.id)) }
                            }
                        },
                        {
                            $limit: 1
                        },
                        {
                            $project: {
                                userId: 1,
                                distance: 1
                            }
                        }
                    ]);
                    console.log(closetUser);
                    if (!util_1.isNullOrUndefined(closetUser) && closetUser.length != 0) {
                        lesserTaskUser = closetUser[0].userId.toString();
                    }
                    else {
                        continue;
                    }
                    let token = yield this.createToken(inputData.userId, inputData.subscriberId, inputData.orgId);
                    const options = {
                        method: "POST",
                        headers: {
                            Authorization: `Bearer ${token}`,
                            selectedorgid: inputData.orgId,
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            "projectId": filteredDocuments[0].projectId,
                            "processId": filteredDocuments[0].processId,
                            "botId": filteredDocuments[0].botId,
                            "eventId": filteredDocuments[0].eventId,
                            "iterationId": filteredDocuments[0].iterationId,
                            "queueId": filteredDocuments[0].queueId,
                            "assignToUser": true,
                            "userId": lesserTaskUser
                        }),
                    };
                    console.log("options   ", options);
                    let url = process.env.gibots_api + "gibots-api/Queue/taskPull";
                    console.log("url   ", url);
                    let response = yield fetch(url, options);
                    response = yield response.json();
                    console.log('Response from the Automated Queue API ', response);
                    // let userDetails  =  queue.
                }
                return { message: 'Automated Queue  ', status: 0, data: [] };
            }
            catch (e) {
                console.log('Failed in Automated Queue  ', e);
                return { message: 'Failed in Automated Queue  ', status: 1, data: [] };
            }
        });
    }
    emailTicketId(inputData, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let counterName = 'email';
                let counter = yield db.collection("counters").findOneAndUpdate({ id: counterName }, { $inc: { seq: 1 } }, { new: true, upsert: true } // Create counter if it doesn't exist
                );
                counter = JSON.parse(JSON.stringify(counter));
                console.log(counter);
                let tempId = String(counter.seq).padStart(5, '0');
                console.log(tempId);
                let emailTicketId = `EM${tempId}`;
                let obj = {
                    body: inputData.body,
                    subject: inputData.subject,
                    from: inputData.from,
                    to: inputData.to,
                    tickectId: emailTicketId,
                    messageId: inputData.messageId,
                    status: 'open',
                    orgId: inputData.orgId,
                    userId: inputData.userId,
                    subscriberId: inputData.subscriberId,
                };
                let insertedDocs = yield db.collection('emails').insertMany(obj);
                console.log(insertedDocs);
                outputParameters['emailTicketId'] = emailTicketId;
                return { message: 'Ticket id created succesfully ', status: 0, data: outputParameters };
            }
            catch (e) {
                console.log('failed to create the ticket id', e);
                return { message: 'Ticket id created Failed ', status: 1, data: [] };
            }
        });
    }
    TPDOWLTicketId(inputData, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let counterName = inputData.type;
                let prefix = inputData.type === "Service" ? "SR" : "INS";
                inputData.sub_category = inputData.sub_category ? inputData.sub_category : "Default";
                let sub_prefix;
                switch (inputData.sub_category.toLowerCase()) {
                    case "software":
                        sub_prefix = 'SW';
                        break;
                    default:
                        sub_prefix = 'HW';
                        break;
                }
                let counter = yield db.collection("counters").findOneAndUpdate({ id: counterName }, { $inc: { seq: 1 } }, { new: true, upsert: true } // Create counter if it doesn't exist
                );
                counter = JSON.parse(JSON.stringify(counter));
                console.log(counter);
                let tempId = String(counter.seq).padStart(8, '0');
                console.log(tempId);
                let TicketId = `${prefix}/${sub_prefix}/${tempId}`;
                let obj = {
                    title: inputData.title,
                    description: inputData.description,
                    userName: inputData.user,
                    category: inputData.type,
                    sub_category: inputData.sub_category,
                    tickectId: TicketId,
                    status: 'open',
                };
                let insertedDocs = yield db.collection('TPWODL').insertMany(obj);
                console.log(insertedDocs);
                outputParameters['TicketId'] = TicketId;
                return { message: 'Ticket id created succesfully ', status: 0, data: outputParameters };
            }
            catch (e) {
                console.log('failed to create the ticket id', e);
                return { message: 'Ticket id created Failed ', status: 1, data: [] };
            }
        });
    }
    EMailRecieverforUtility(inputData, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let Attachfilename;
                let textbody;
                let htmlbody;
                let allorseen;
                let subject;
                let date;
                let from;
                let to;
                let cc = '';
                let bodydata = [];
                let bodyData = {};
                let self = this;
                if (!util_1.isNullOrUndefined(inputData["password"]) && inputData["password"] !== "" && !util_1.isNullOrUndefined(inputData['decrypt'])) {
                    inputData["password"] = Buffer.from(inputData["password"], 'base64').toString();
                }
                console.log("Input --------->>  ", inputData);
                let config = {
                    imap: {
                        user: inputData.user,
                        password: inputData.password,
                        host: inputData.host,
                        port: 993,
                        tls: true
                    }
                };
                if (!util_1.isNullOrUndefined(inputData.filePath) && inputData.filePath !== '') {
                    let tlsOptions = {
                        ca: [fs.readFileSync(inputData.filePath)],
                        rejectUnauthorized: false
                    };
                    config["imap"]['tlsoptions'] = tlsOptions;
                    config["imap"]["authTimeout"] = 120000;
                    config["imap"]["connTimeout"] = 120000;
                }
                else {
                    config["imap"]["tlsOptions"] = { rejectUnauthorized: false },
                        config["imap"]["authTimeout"] = 120000,
                        config["imap"]["connTimeout"] = 120000;
                }
                console.log("Main Config======>>>>>", config);
                allorseen = inputData.allorseen;
                date = inputData.date;
                subject = inputData.subject;
                from = inputData.fromMail;
                to = inputData.toMail;
                //let currentdate = new Date().toISOString();
                let updateDate = "";
                if (date.length !== 0) {
                    updateDate = new Date(date).toISOString();
                    console.log("date given by user", updateDate);
                }
                let searchCriteria = [];
                let fetchOptions = {};
                console.info(" -- -- --- IN SINCE  BEFORE CONNECTION -------- --- ---- ");
                if (from.length > 0 && to.length > 0 && subject.length > 0) {
                    console.log("<<< <<<< <<<<< <<<<< ---------  Inside InBOX  ------- >>>> >>>> >>>>> >>>>> >>>> ");
                    if (inputData.subjectSearch === "true") {
                        searchCriteria = [allorseen, ['SINCE', updateDate], ['FROM', from], ['TO', to]];
                    }
                    else {
                        searchCriteria = [allorseen, ['SINCE', updateDate], ['FROM', from], ['TO', to], ['SUBJECT', subject]];
                    }
                    fetchOptions = { bodies: ['HEADER.FIELDS (FROM TO SUBJECT DATE)', 'TEXT', ''], markSeen: true, struct: true };
                }
                else if (from.length > 0 && to.length > 0) {
                    console.log("fetch from and to");
                    searchCriteria = [allorseen, ['SINCE', updateDate], ['FROM', from], ['TO', to]];
                    fetchOptions = { bodies: ['HEADER.FIELDS (FROM TO SUBJECT DATE)'], markSeen: true, struct: true };
                }
                else if (from.length > 0 && subject.length > 0) {
                    console.log("this is search only from and subjects");
                    searchCriteria = [allorseen, ['SINCE', updateDate], ['FROM', from], ['SUBJECT', subject]];
                    fetchOptions = { bodies: ['HEADER.FIELDS (FROM TO SUBJECT DATE)'], markSeen: true, struct: true };
                }
                else if (subject.length > 0 && to.length > 0) {
                    console.log("only fetch sub and to");
                    searchCriteria = [allorseen, ['SINCE', updateDate], ['TO', to], ['SUBJECT', subject]];
                    fetchOptions = { bodies: ['HEADER.FIELDS (FROM TO SUBJECT DATE)', 'TEXT', ''], markSeen: true, struct: true };
                }
                else if (from.length > 0 && to.length === 0 && subject.length === 0) {
                    console.log("only access from");
                    searchCriteria = [allorseen, ['SINCE', updateDate], ['FROM', from]];
                    fetchOptions = { bodies: ['HEADER.FIELDS (FROM TO SUBJECT DATE)'], markSeen: true, struct: true };
                }
                else if (subject.length > 0 && from.length === 0 && to.length === 0) {
                    console.log("only fetch subjectss");
                    searchCriteria = [allorseen, ['SINCE', updateDate], ['SUBJECT', subject]];
                    fetchOptions = { bodies: ['HEADER.FIELDS (FROM TO SUBJECT DATE)'], markSeen: true, struct: true };
                }
                else if (to.length > 0 && from.length === 0 && subject.length === 0 && updateDate != '') {
                    console.log("<< <<< ------------ -------- SESRCH USING TO MAIL WITH DATE-------- --------- -------- >>>> ");
                    searchCriteria = [allorseen, ['SINCE', updateDate], ['TO', to]];
                    fetchOptions = { bodies: ['HEADER.FIELDS (FROM TO SUBJECT DATE)', 'TEXT', ''], markSeen: true, struct: true };
                }
                else if (to.length == 0 && from.length === 0 && subject.length === 0) {
                    console.log("<< <<< ------------ -------- SESRCH USING TO MAIL WITHOUT DATE AND TO MAIL -------- --------- -------- >>>> ");
                    searchCriteria = [allorseen];
                    fetchOptions = { bodies: ['HEADER.FIELDS (FROM TO SUBJECT DATE)', 'TEXT', ''], markSeen: true, struct: true };
                }
                else {
                    console.log("-- --- --- --- ----    IN ELSE FOR    --- ---- ----- ----- ----- ----- ---- ----- ");
                }
                return yield new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    let connectionEmail = yield imaps.connect(config);
                    yield connectionEmail.openBox('INBOX');
                    let messages = yield connectionEmail.search(searchCriteria, fetchOptions);
                    if (!util_1.isNullOrUndefined(messages) && messages.length > 0) {
                        let attachments = [];
                        let total_atachments = [];
                        let allMailData = [];
                        let subjectOfAttachment = [];
                        if (inputData.multipleMails && [true, 'true'].includes(inputData.multipleMails)) {
                            from = [];
                            to = [];
                            subject = [];
                            textbody = [];
                            htmlbody = [];
                            for (let i = 0; i < messages.length; i++) {
                                let singleMailAtachments = [];
                                let message = messages[i];
                                var all = _.find(message.parts, { "which": "" });
                                var id = message.attributes.uid;
                                var idHeader = "Imap-Id: " + id + "\r\n";
                                console.log(id);
                                bodyData = yield self.messageExtraction(message, all, idHeader, outputParameters, bodydata, from, to, subject, htmlbody, textbody, inputData, Attachfilename, cc);
                                bodydata = bodyData["bodydata"];
                                let lfrom = !util_1.isNullOrUndefined(bodyData['from']) && bodyData['from'] !== "" ? bodyData['from'] : "";
                                let lto = !util_1.isNullOrUndefined(bodyData['to']) && bodyData['to'] !== "" ? bodyData['to'] : "";
                                let lsubject = !util_1.isNullOrUndefined(bodyData['subject']) && bodyData['subject'] !== "" ? bodyData['subject'] : "";
                                let ltextbody = !util_1.isNullOrUndefined(bodyData['textbody']) && bodyData['textbody'] !== "" ? bodyData['textbody'] : (all.body ? `${all.body.replace(/"/g, "'")}` : "");
                                let lhtmlbody = !util_1.isNullOrUndefined(bodyData['htmlbody']) && bodyData['htmlbody'] !== "" ? bodyData['htmlbody'] : (all.body ? `${all.body.replace(/"/g, "'")}` : "");
                                from.push(lfrom);
                                to.push(lto);
                                subject.push(lsubject);
                                textbody.push(ltextbody);
                                htmlbody.push(lhtmlbody);
                                let parts = yield imaps.getParts(message.attributes.struct);
                                const getSub = message.parts.filter(m => m.which === "HEADER.FIELDS (FROM TO SUBJECT DATE)");
                                if (getSub[0].body.subject[0].startsWith(subject)) {
                                    for (let k = 0; k < parts.length; k++) {
                                        let part = parts[k];
                                        if (!util_1.isNullOrUndefined(part.disposition) && !util_1.isNullOrUndefined(part.disposition.type) && part.disposition.type.toUpperCase() === 'ATTACHMENT') {
                                            let oneatachment = yield self.fetchFileData(part, connectionEmail, message, getSub, inputData);
                                            attachments.push(oneatachment);
                                            singleMailAtachments.push(oneatachment);
                                        }
                                    }
                                }
                                if (singleMailAtachments.length > 0) {
                                    total_atachments.push(singleMailAtachments);
                                    subjectOfAttachment.push(bodydata[i][!util_1.isNullOrUndefined(inputData.folderFrom) ? inputData.folderFrom : 'fromMail']);
                                }
                            }
                        }
                        else {
                            for (let i = 0; i < messages.length; i++) {
                                let singleMailAtachments = [];
                                let message = messages[i];
                                var all = _.find(message.parts, { "which": "" });
                                var id = message.attributes.uid;
                                var idHeader = "Imap-Id: " + id + "\r\n";
                                console.log(id);
                                bodyData = yield self.messageExtraction(message, all, idHeader, outputParameters, bodydata, from, to, subject, htmlbody, textbody, inputData, Attachfilename, cc);
                                bodydata = bodyData["bodydata"];
                                // from = !isNullOrUndefined(bodyData['from']) && bodyData['from'] !== "" ? bodyData['from'] : "";
                                from = !util_1.isNullOrUndefined(bodydata) && !util_1.isNullOrUndefined(bodydata[i]) ? bodydata[i].fromMail : "";
                                to = !util_1.isNullOrUndefined(bodyData['to']) && bodyData['to'] !== "" ? bodyData['to'] : "";
                                subject = !util_1.isNullOrUndefined(bodydata) && !util_1.isNullOrUndefined(bodydata[i]) ? bodydata[i].subject : "";
                                htmlbody = !util_1.isNullOrUndefined(bodydata) && !util_1.isNullOrUndefined(bodydata[i]) ? bodydata[i].htmlbody : "";
                                // subject = !isNullOrUndefined(bodyData['subject']) && bodyData['subject'] !== "" ? bodyData['subject'] : "";
                                textbody = !util_1.isNullOrUndefined(bodyData['textbody']) && bodyData['textbody'] !== "" ? bodyData['textbody'] : (all.body ? `${all.body.replace(/"/g, "'")}` : "");
                                //htmlbody = !isNullOrUndefined(bodyData['htmlbody']) && bodyData['htmlbody'] !== "" ? bodyData['htmlbody'] : (all.body ? `${all.body.replace(/"/g, "'")} ` : "");
                                let parts = yield imaps.getParts(message.attributes.struct);
                                const getSub = message.parts.filter(m => m.which === "HEADER.FIELDS (FROM TO SUBJECT DATE)");
                                if (getSub[0].body.subject[0].startsWith(subject)) {
                                    for (let k = 0; k < parts.length; k++) {
                                        let part = parts[k];
                                        if (!util_1.isNullOrUndefined(part.disposition) && !util_1.isNullOrUndefined(part.disposition.type) && part.disposition.type.toUpperCase() === 'ATTACHMENT') {
                                            let oneatachment = yield self.fetchFileData(part, connectionEmail, message, getSub, inputData);
                                            attachments.push(oneatachment);
                                            singleMailAtachments.push(oneatachment);
                                        }
                                    }
                                }
                                if (inputData.dynamicDir == "Verification") {
                                    let output = this.cheerioExtract(bodydata[i].htmlbody, bodydata[i].subject, inputData.pattern1, inputData.pattern2);
                                    allMailData.push(...output);
                                }
                                if (singleMailAtachments.length > 0) {
                                    total_atachments.push(singleMailAtachments);
                                    subjectOfAttachment.push(bodydata[i][!util_1.isNullOrUndefined(inputData.folderFrom) ? inputData.folderFrom : 'fromMail']);
                                }
                            }
                        }
                        if (!util_1.isNullOrUndefined(attachments) && attachments.length > 0 || inputData.dynamicDir == "Verification") {
                            console.log("<<< <<<< <<<< <<<< --------- ---- EMAIL HAS ATTACHMENTS ----- ----- ----- ----- >>> >>>> ", attachments.length);
                            let count = 0;
                            outputParameters['AttachmentCount'] = attachments.length;
                            let filepath;
                            if (!util_1.isNullOrUndefined(inputData.path) && (inputData.path !== "")) {
                                filepath = inputData.path;
                            }
                            else {
                                filepath = process.cwd();
                            }
                            let outputDirectory;
                            let outputDirectoryList;
                            if (["perCandidate"].includes(inputData.dynamicDir)) {
                                outputDirectoryList = [];
                                for (let i = 0; i < total_atachments.length; i++) {
                                    let key = yield this.getReferenceNumber(inputData, outputParameters, "", "", "");
                                    if (!util_1.isNullOrUndefined(key) && key.data && key.data.hash) {
                                        let candidateKey = 'Cand' + key.data.hash;
                                        let vendor_name = subjectOfAttachment[i];
                                        // vendor_name = this.formatFolderName(vendor_name)
                                        // vendor_name = vendor_name.split('@')[1];
                                        if (util_1.isNullOrUndefined(vendor_name) || vendor_name == "") {
                                            vendor_name = "NA";
                                        }
                                        let outDir = `${filepath}/${vendor_name}_${candidateKey}`;
                                        outputDirectoryList.push(outDir);
                                    }
                                }
                            }
                            else if (["Verification"].includes(inputData.dynamicDir)) {
                                outputDirectoryList = [];
                                let searchKeys = JSON.parse(inputData.searchKeys);
                                for (let i = 0; i < allMailData.length; i++) {
                                    let subject = allMailData[i]['subject'];
                                    let subjectSearchKey = 'Unknown';
                                    const pattern = new RegExp(inputData.pattern1, 'gmi');
                                    const pattern2 = new RegExp(inputData.pattern2, 'gmi');
                                    let arr = subject.match(pattern);
                                    let arr2 = subject.match(pattern2);
                                    let vid = arr2 && arr2.length > 0 ? arr2[0] : "defaultVID";
                                    let caseRefNo = arr && arr.length > 0 ? arr[0] : "defaultCase";
                                    for (let item of Object.keys(searchKeys)) {
                                        if (subject.toLowerCase().includes(item)) {
                                            subjectSearchKey = searchKeys[item];
                                            break;
                                        }
                                    }
                                    let outDir = `${filepath}/${vid}_${subjectSearchKey}_${caseRefNo}`;
                                    outputDirectoryList.push(outDir);
                                }
                            }
                            else if ([true, "true"].includes(inputData.dynamicDir)) {
                                outputDirectory = `${filepath}/Case_${Date.now()}`;
                                console.log("Creating new Directory....", `${filepath}/Case_${Date.now()}`);
                            }
                            else {
                                outputDirectory = filepath;
                            }
                            if (!util_1.isNullOrUndefined(outputDirectoryList)) {
                                for (let outDir of outputDirectoryList) {
                                    if (!fs.existsSync(outDir)) {
                                        yield fs.mkdirSync(outDir);
                                    }
                                }
                            }
                            else if (!fs.existsSync(outputDirectory)) {
                                yield fs.mkdirSync(outputDirectory);
                            }
                            inputData['outputParameters'] = { statusCode: "200", successMessage: 'File read successfull', fromMail: from, tomail: to, subject: subject, attachment_path: [], textbody: textbody, body: textbody, htmlbody: htmlbody, AttachFolder: outputDirectory };
                            //For loop For Attachments
                            console.log("BEFORE ATTACHMENT FOR LOOP");
                            inputData["outputParameters"]["folder_path"] = [];
                            inputData["outputParameters"]["folder_count"] = 0;
                            if (inputData.isSubjectWise === "yes") {
                                for (let element of attachments) {
                                    console.log("INSIDE EMAIL ATTACHEMENT FOR FORLOOP ONEE 1");
                                    let directory = path.dirname(element.filename);
                                    let file = path.basename(element.filename);
                                    directory = directory.replace(/[(#,&*)]/g, "");
                                    let newDirectory = outputDirectory + "/" + directory;
                                    if (!fs.existsSync(newDirectory)) {
                                        console.log("  <<<< <<< << -------- ------ FOLDER PATH ---- ---  -- >> >>  ", outputDirectory + directory);
                                        inputData["outputParameters"]["folder_path"].push(newDirectory);
                                        yield fs.mkdirSync(newDirectory);
                                        count = count + 1;
                                    }
                                    else if (inputData["outputParameters"]["folder_path"].indexOf(newDirectory) == -1) {
                                        console.log("  <<<< <<< << -------- ------ FOLDER PATH ALREADY EXISTS ---- ---  -- >> >>  ", outputDirectory + directory);
                                        inputData["outputParameters"]["folder_path"].push(newDirectory);
                                        count = count + 1;
                                    }
                                    console.log("fileNamee isss-----", element.filename);
                                    Attachfilename = newDirectory + '/' + file;
                                    yield fs.writeFileSync(Attachfilename, element.data);
                                    inputData['outputParameters']['attachment_path'].push(Attachfilename);
                                }
                                inputData["outputParameters"]["folder_count"] = count;
                            }
                            else {
                                let copyattach = (attachmentObj, outputDirectory) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                                    let subject;
                                    let htmlbody;
                                    if (!util_1.isNullOrUndefined(attachmentObj.attachment)) {
                                        subject = attachmentObj.subject;
                                        htmlbody = attachmentObj.htmlbody;
                                        attachmentObj = attachmentObj.attachment;
                                    }
                                    if (attachmentObj.length > 0) {
                                        for (let element of attachmentObj) {
                                            console.log("INSIDE EMAIL ATTACHEMENT FOR FORLOOP TWO 2");
                                            console.log("fileNamee isss-----", element.filename);
                                            Attachfilename = outputDirectory + '/' + element.filename;
                                            yield fs.writeFileSync(Attachfilename, element.data);
                                            inputData['outputParameters']['attachment_path'].push(Attachfilename);
                                        }
                                    }
                                    if (!util_1.isNullOrUndefined(htmlbody)) {
                                        let input = { 'path': `${outputDirectory}`, 'HTMLPage': htmlbody, 'fileName': `TP_Verification ${subject}.png` };
                                        this.htmlToImage(input, {}, "", "", "");
                                    }
                                });
                                if (!util_1.isNullOrUndefined(outputDirectoryList) && ["perCandidate"].includes(inputData.dynamicDir)) {
                                    for (let i = 0; i < outputDirectoryList.length; i++) {
                                        copyattach(total_atachments[i], outputDirectoryList[i]);
                                    }
                                    inputData['outputParameters']['AttachFolder'] = outputDirectoryList;
                                }
                                else if (!util_1.isNullOrUndefined(outputDirectoryList) && ["Verification"].includes(inputData.dynamicDir)) {
                                    for (let i = 0; i < outputDirectoryList.length; i++) {
                                        copyattach(allMailData[i], outputDirectoryList[i]);
                                    }
                                    inputData['outputParameters']['AttachFolder'] = outputDirectoryList;
                                }
                                else {
                                    copyattach(attachments, outputDirectory);
                                }
                                if (!util_1.isNullOrUndefined(outputDirectoryList) && ["perCandidate"].includes(inputData.dynamicDir)) {
                                    for (let i = 0; i < outputDirectoryList.length; i++) {
                                        copyattach(total_atachments[i], outputDirectoryList[i]);
                                    }
                                    inputData['outputParameters']['AttachFolder'] = outputDirectoryList;
                                }
                                else if (!util_1.isNullOrUndefined(outputDirectoryList) && ["Verification"].includes(inputData.dynamicDir)) {
                                    for (let i = 0; i < outputDirectoryList.length; i++) {
                                        copyattach(allMailData[i], outputDirectoryList[i]);
                                    }
                                    inputData['outputParameters']['AttachFolder'] = outputDirectoryList;
                                }
                                else {
                                    copyattach(attachments, outputDirectory);
                                }
                            }
                            console.log("AFTER EMAIL ATTACHEMENT FOR FORLOOP");
                            outputParameters['subject'] = inputData['outputParameters']['subject'];
                            outputParameters['fromMail'] = inputData['outputParameters']['from'];
                            outputParameters['tomail'] = inputData['outputParameters']['to'];
                            //     outputParameters['textbody'] = inputData['outputParameters']['textbody'];
                            //     outputParameters['htmlbody'] = inputData['outputParameters']['htmlbody'];
                            outputParameters['attachment_path'] = inputData['outputParameters']['attachment_path'];
                            //     outputParameters['body'] = inputData['outputParameters']['body'];
                            outputParameters['AttachFolder'] = inputData['outputParameters']['AttachFolder'];
                            outputParameters['emailContent'] = bodydata;
                            outputParameters['createdAt'] = new Date().toJSON().slice(0, 10).replace(/-/g, '/');
                            outputParameters['folder_path'] = inputData["outputParameters"]["folder_path"];
                            outputParameters['folder_count'] = inputData["outputParameters"]["folder_count"];
                            outputParameters['MessageCount'] = Array.isArray(textbody) ? textbody.length : 1;
                            outputParameters['refNo'] = !util_1.isNullOrUndefined(inputData['outputParameters']['refNo']) ? inputData['outputParameters']['refNo'] : null;
                            // console.log("attchfolder --->", inputData['outputParameters']['AttachFolder']);
                            // console.log("attachpath -->", inputData['outputParameters']['attachment_path']);
                            console.log("< < < < < --- ---- ATTACH FOLDERS PATH --- ----- --- > > > > > >  LENGTH   ", outputParameters['folder_count'], "   << < << << <<< < ------ ---------- ATTACH FOLDER PATH ------- --------- > >> >> >> >>    ", outputParameters['folder_path']);
                            console.log("DATA RECIEVED SUCCESSFULLY");
                            // console.info(outputParameters);
                            connectionEmail.end();
                            // connectionEmail.destroy();
                            resolve({ message: "Data recieve SuccessFully", status: 0, data: outputParameters });
                        }
                        else {
                            connectionEmail.end();
                            console.log("attachments not found");
                            outputParameters['subject'] = subject;
                            outputParameters['fromMail'] = from;
                            outputParameters['tomail'] = to;
                            //       outputParameters['textbody'] = textbody;
                            //     outputParameters['htmlbody'] = htmlbody;
                            //    outputParameters['emailContent'] = bodydata;
                            outputParameters['AttachmentCount'] = 0;
                            outputParameters['MessageCount'] = Array.isArray(textbody) ? textbody.length : 1;
                            outputParameters['createdAt'] = new Date().toJSON().slice(0, 10).replace(/-/g, '/');
                            // connectionEmail.destroy();
                            resolve({ message: "NO ATTACHEMENT MAIL TO READ AVAIALBLE", status: 0, data: outputParameters });
                        }
                    }
                    else {
                        connectionEmail.end();
                        // connectionEmail.destroy();
                        resolve({ message: "NO MAIL TO READ AVAIALBLE", status: 0, data: {} });
                    }
                }));
            }
            catch (e) {
                console.log('Error in fetching details from bank', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    cheerioExtract(htmlBody, Subject, textPattern, textPattern2) {
        const $ = cheerio.load(htmlBody);
        const tables = $('table');
        let output = [];
        // Check if tables exist in the HTML
        if (tables.length === 0) {
            let outputObj = { attachment: [], htmlbody: htmlBody, "subject": Subject };
            output.push(outputObj);
            return output;
        }
        const table = tables.eq(0);
        const header = table.find('tr').eq(0).html();
        let tableType = { type: 'vertical', tableCategory: '' };
        // Determine table  header row
        table.find('tr').slice(0, 1).each((index, row) => {
            let headArray = [];
            $(row).find('td').each((colIndex, col) => {
                headArray.push($(col).text().trim().toLowerCase().replace(/[^a-z0-9 ]/g, ''));
            });
            // Determine if table is horizontal based on column count
            if (headArray.length > 4) {
                tableType.type = "horizontal";
            }
        });
        let singleCase;
        let singleVid;
        output = [];
        for (let i = 1; i < table.find('tr').length; i++) {
            let row = table.find('tr').eq(i);
            let rowString = '';
            $(row).find('td').each((colIndex, col) => {
                rowString += ' ' + $(col).text().trim();
            });
            const pattern = new RegExp(textPattern, 'gmi');
            const pattern2 = new RegExp(textPattern2, 'gmi');
            let arr = rowString.match(pattern);
            let arr2 = rowString.match(pattern2);
            let id2 = "defaultvId";
            let caserefno = "defaultCase";
            if (arr2 && arr2.length > 0) {
                id2 = arr2[0];
                singleVid = id2;
            }
            if (arr && arr.length > 0) {
                caserefno = arr[0];
                singleCase = caserefno;
            }
            //condition
            if (tableType.type != "horizontal" && singleCase && singleVid) {
                let outputObj = { attachment: [], htmlbody: rowString, subject: `${Subject} ${singleCase} ${singleVid}` };
                output.push(outputObj);
                return output;
            }
            if (tableType.type === "horizontal") {
                const newTableHtml = `
                        <table>
                            <tr>${header}</tr>
                            ${$(row).html()}
                        </table>`;
                let outputObj = {
                    attachment: [],
                    htmlbody: newTableHtml,
                    subject: `${tableType.tableCategory} ${Subject} ${caserefno}, ${id2}`
                };
                output.push(outputObj);
            }
        }
        if (tableType.type === "horizontal")
            return output;
        else {
            let outputObj = { attachment: [], htmlbody: htmlBody, subject: `${Subject} ${singleCase} ${singleVid}` };
            return [outputObj];
        }
    }
    htmlToImage(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let fileName = input.path + '/' + input.fileName;
                let htmlContent = input.HTMLPage;
                const wkhtmltoimage = spawn('wkhtmltoimage', ['-', fileName]);
                wkhtmltoimage.stdin.write(htmlContent);
                wkhtmltoimage.stdin.end();
                wkhtmltoimage.on('close', (code) => {
                    if (code === 0) {
                        console.log('Image created successfully.');
                    }
                    else {
                        console.error(`wkhtmltoimage process exited with code ${code}`);
                    }
                });
                return { message: 'Image created succesfully ', status: 0, data: [{ 'path': fileName }] };
            }
            catch (e) {
                console.log('failed to create the image', e);
                return { message: 'Failed to create Image', status: 1, data: [] };
            }
        });
    }
    pdfTableExtracter(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info("in strConcate-->");
            try {
                let finalTable3Result = [];
                let firstSpaceIndex;
                if (!util_1.isNullOrUndefined(input) && input !== "") {
                    let dataBuffer = fs.readFileSync(input.path);
                    let data = yield pdf(dataBuffer);
                    // number of pages
                    // console.log(data.numpages);
                    // number of rendered pages
                    // console.log(data.numrender);
                    // PDF info
                    // console.log(data.info);
                    // PDF metadata
                    // console.log(data.metadata);
                    // PDF.js version
                    // check https://mozilla.github.io/pdf.js/getting_started/
                    // console.log(data.version);
                    // PDF text
                    //10175
                    // console.log(data.text.indexOf('REDUCING/PIPING COMPONENTS'));
                    let table1Start = data.text.indexOf('Table of schedules');
                    let table1End = data.text.indexOf('Branch connections 90 degrees ');
                    let table1 = data.text.substring(table1Start, table1End);
                    table1 = table1.replace('Table of schedules', '');
                    console.log("table1****************************************");
                    let spitTable1 = table1.split(' ');
                    let rTable1 = [];
                    let arr = [];
                    //  console.log(spitTable1);
                    for (let i = 0; i < spitTable1.length; i++) {
                        if (spitTable1[i] !== '') {
                            // console.log(spitTable1[i]);
                            if (spitTable1[i].indexOf('\n') > -1) {
                                spitTable1[i] = spitTable1[i].replace('\n', '');
                                if (arr.length > 1) {
                                    rTable1.push(arr);
                                }
                                arr = [];
                                arr.push(spitTable1[i]);
                            }
                            else {
                                arr.push(spitTable1[i]);
                            }
                        }
                    }
                    // console.log(rTable1);
                    let finalTable1Result = [];
                    let headersTable1 = rTable1[0];
                    rTable1.shift();
                    let objTable1;
                    for (let i = 0; i < rTable1.length; i++) {
                        objTable1 = {};
                        let row = rTable1[i];
                        for (let j = 0; j < row.length; j++) {
                            if (!util_1.isNullOrUndefined(headersTable1[j])) {
                                objTable1[headersTable1[j]] = row[j];
                            }
                        } //Object.keys(obj).length   Object.entries(objTable1).length
                        if (Object.keys(objTable1).length === 0 && objTable1.constructor === Object) {
                        }
                        else {
                            finalTable1Result.push(objTable1);
                        }
                    }
                    console.log(finalTable1Result);
                    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    let table2Start = data.text.indexOf('(For full material description see relevant MESC buying description.)');
                    let table2End = data.text.indexOf('Flanges');
                    let table2 = data.text.substring(table2Start, table2End);
                    console.log("table2****************************************");
                    table2 = table2.replace('(For full material description see relevant MESC buying description.)', '');
                    let spitTable2 = table2.split('\n');
                    // console.log(table2);
                    let spitTable2Result = [];
                    for (let i = 0; i < spitTable2.length; i++) {
                        if (spitTable2[i].trim() !== '') {
                            spitTable2Result.push(spitTable2[i]);
                        }
                        // console.log(spitTable2[i]);
                    }
                    // console.log(spitTable2);
                    // console.log(spitTable2Result);
                    let arrTable2 = [];
                    let pArray = [];
                    for (let i = 0; i < spitTable2Result.length; i++) {
                        pArray = [];
                        firstSpaceIndex = spitTable2Result[i].indexOf(' ');
                        let DNIndex = spitTable2Result[i].indexOf('DN');
                        let firstColumn = spitTable2Result[i].substring(0, firstSpaceIndex);
                        let secondColumn = spitTable2Result[i].substring(firstSpaceIndex + 1, DNIndex - 1);
                        let thirdColumnSplit = spitTable2Result[i].split(secondColumn);
                        let thirdColumn = thirdColumnSplit[1];
                        const regex = /\DN \d*\-\d*/gm;
                        const str = thirdColumn;
                        let m;
                        while ((m = regex.exec(str)) !== null) {
                            // This is necessary to avoid infinite loops with zero-width matches
                            if (m.index === regex.lastIndex) {
                                regex.lastIndex++;
                            }
                            // The result can be accessed through the `m`-variable.
                            m.forEach((match, groupIndex) => {
                                if (groupIndex == 0) {
                                    // console.log(`Found match, group ${groupIndex}: ${match}`);
                                    thirdColumn = match;
                                }
                            });
                        }
                        pArray.push(firstColumn);
                        if (DNIndex > -1) {
                            pArray.push(secondColumn);
                            pArray.push(thirdColumn);
                            let fourthColumn = spitTable2Result[i].split(thirdColumn);
                            let fourthColumnFinal = fourthColumn[fourthColumn.length - 1];
                            pArray.push(fourthColumnFinal);
                        }
                        arrTable2.push(pArray);
                    }
                    //console.log(arrTable2);
                    let finalTable2Result = [];
                    let headersTable2 = ['header1', 'header2', 'header3', 'header4'];
                    arrTable2.shift();
                    let objTable2;
                    for (let i = 0; i < arrTable2.length; i++) {
                        objTable2 = {};
                        let row = arrTable2[i];
                        for (let j = 0; j < row.length; j++) {
                            if (!util_1.isNullOrUndefined(headersTable2[j])) {
                                objTable2[headersTable2[j]] = row[j];
                            }
                        } // Object.keys(obj).length   //objTable2
                        if (Object.keys(objTable2).length === 0 && objTable2.constructor === Object) {
                        }
                        else {
                            finalTable2Result.push(objTable2);
                        }
                    }
                    console.log(finalTable2Result);
                    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                    let table3Start = data.text.indexOf('PIPING COMPONENTS');
                    let table3End = data.text.indexOf('REDUCING/PIPING COMPONENTS');
                    let table3 = data.text.substring(table3Start, table3End);
                    table3 = table3.replace(new RegExp('PIPING COMPONENTS', 'g'), '');
                    table3 = table3.replace(new RegExp('Nominal pipe size', 'g'), '');
                    table3 = table3.replace(new RegExp('Item description MESC', 'g'), '');
                    // table3 = table3.replace(new RegExp('Attachment-5-Piping class 31440XPage 5 of 15', 'g'),'')
                    table3 = table3.replace(new RegExp('Class 31440X, Rev. A', 'g'), '');
                    table3 = table3.replace(new RegExp('Metric units', 'g'), '');
                    // table3 = table3.replace(new RegExp('Attachment-5-Piping class 31440XPage 6 of 15', 'g'),'')
                    console.log("table3****************************************");
                    let pipeEnd = table3.indexOf('Flanges');
                    let finalTable3 = table3.substring(0, pipeEnd);
                    // console.log(finalTable3);
                    let spitTable3 = finalTable3.split('\n');
                    //   console.log(spitTable3);
                    let spitTable3Result = [];
                    for (let i = 0; i < spitTable3.length; i++) {
                        if (spitTable3[i].trim() !== '') {
                            spitTable3Result.push(spitTable3[i]);
                        }
                    }
                    // let FinalSpitTable3Result=[];
                    // for (let i =0;i<spitTable3Result.length;i++) {
                    //   let splitRow = spitTable3Result[i].split(' ');
                    //   FinalSpitTable3Result.push(splitRow)
                    // }
                    //  console.log(spitTable3Result);
                    let headers = spitTable3Result[0];
                    let splitHeaders = headers.split(' ');
                    let FinalHeaders = ['Item Description', 'MESC', ' '];
                    for (let i = 0; i < splitHeaders.length; i++) {
                        if (splitHeaders[i].trim() !== '') {
                            FinalHeaders.push(splitHeaders[i]);
                        }
                    }
                    spitTable3Result[0] = FinalHeaders;
                    delete spitTable3Result[1];
                    let pArrayTable3 = [];
                    let arrTable3 = [FinalHeaders];
                    // console.log(spitTable3Result)
                    for (let i = 0; i < spitTable3Result.length; i++) {
                        if (i !== 0 && !util_1.isNullOrUndefined(spitTable3Result[i])) {
                            pArrayTable3 = [];
                            const regex = /(\w*\s\(\w*\s\d*\w*\-\w*\s\w*\))/gm;
                            let str = spitTable3Result[i];
                            let firstColumn;
                            if (/(\w*\s\(\w*\s\d*\w*\-\w*\s\w*\))/gm.test(str)) {
                                let m;
                                while ((m = regex.exec(str)) !== null) {
                                    if (m.index === regex.lastIndex) {
                                        regex.lastIndex++;
                                    }
                                    m.forEach((match, groupIndex) => {
                                        // console.log(`Found match, group ${groupIndex}: ${match}`);
                                        if (groupIndex == 0) {
                                            firstColumn = match;
                                            let secondColumn = spitTable3Result[i].split(firstColumn);
                                            let allColumnsRemaining = secondColumn[1].split(' ');
                                            pArrayTable3.push(match);
                                            //delete allColumnsRemaining[0]
                                            // console.log(allColumnsRemaining)
                                            allColumnsRemaining.shift();
                                            arrTable3.push(pArrayTable3.concat(allColumnsRemaining));
                                        }
                                    });
                                }
                            }
                            else {
                                firstSpaceIndex = spitTable3Result[i].indexOf(' ');
                                firstColumn = spitTable3Result[i].substring(0, firstSpaceIndex);
                                let secondColumn = spitTable3Result[i].split(firstColumn);
                                let allColumnsRemaining = secondColumn[1].split(' ');
                                pArrayTable3.push(firstColumn);
                                //delete allColumnsRemaining[0]
                                //  console.log(allColumnsRemaining)
                                allColumnsRemaining.shift();
                                arrTable3.push(pArrayTable3.concat(allColumnsRemaining));
                            }
                            // let secondColumn = spitTable3Result[i].split(firstColumn)
                            // let allColumnsRemaining = secondColumn[1].split(' ')
                            // console.log('secondColumn-'+allColumnsRemaining)
                            // if (!util_1.isNullOrUndefined(arrTable3[i])) {
                            //   arrTable3[i].push(allColumnsRemaining)
                            // }
                        }
                    }
                    // console.log(arrTable3);
                    let headersTable3 = arrTable3[0];
                    arrTable3.shift();
                    //   console.log(arrTable3);
                    let obj;
                    for (let i = 0; i < arrTable3.length; i++) {
                        obj = {};
                        let row = arrTable3[i];
                        // console.log(row)
                        for (let j = 0; j < row.length; j++) {
                            if (!util_1.isNullOrUndefined(headersTable3[j])) {
                                obj[headersTable3[j]] = row[j];
                            }
                        }
                        if (Object.keys(obj).length === 0 && obj.constructor === Object) {
                        }
                        else {
                            finalTable3Result.push(obj);
                        }
                    }
                    let finalArray = [];
                    console.log("LENGTH OF ARATATATTATATATA" + finalTable1Result.length);
                    let obj1 = {};
                    for (let i = 0; i < finalTable1Result.length; i++) {
                        obj1 = {};
                        obj1["DN"] = finalTable1Result[i]['DN'];
                        obj1["Schedule"] = finalTable1Result[i]['Schedule'];
                        let table2Data = finalTable2Result.filter(function (data) {
                            //  console.log("NO1-------------"+data.no1);
                            //console.log("NO2-------------"+data.no2);
                            //console.log("DN NUMBER--------"+obj1["DN"]);
                            //console.log( ( Number(obj1["DN"]) >= Number(data.no1) )   && ( Number(obj1["DN"]) <= Number(data.no2))   );
                            return (Number(obj1["DN"]) >= Number(data.no1)) && (Number(obj1["DN"]) <= Number(data.no2));
                        });
                        for (let j = 0; j < finalTable3Result.length; j++) {
                            console.log("DNNNNNNNNNNNNN----" + obj1["DN"]);
                            if (!util_1.isNullOrUndefined(finalTable3Result[j][obj1["DN"]])) {
                                if (finalTable3Result[j][obj1["DN"]] != '') {
                                    obj1["MESC"] = finalTable3Result[j]['MESC'] + ' ' + finalTable3Result[j][' '] + ' ' + finalTable3Result[j][obj1["DN"]];
                                    continue;
                                }
                            }
                        }
                        //  console.log("TABLE2 DATTATATTATA"+JSON.stringify(table2Data));
                        obj1["Desc"] = table2Data[0]['header4'];
                        finalArray.push(JSON.parse(JSON.stringify(obj1)));
                        // console.log("FINAL ARAAAAAAYAYAYYAYAYAYAYAYYA"+JSON.stringify(finalArray));
                    }
                    console.log("FINAL ARAAAAAAYAYAYYAYAYAYAYAYYA" + JSON.stringify(finalArray));
                    output['table1'] = finalTable1Result;
                    output['table2'] = finalTable2Result;
                    output['table3'] = finalTable3Result;
                    output['table4'] = finalArray;
                    return { message: "Process sucessfull completed", status: 0, data: output };
                }
                else {
                    return { message: "Input data is null", status: 1, data: output };
                }
            }
            catch (e) {
                this.log.error("Error in exiseRate" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    importTo_tally(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    //"XML": input.XML,
                    "data": input.data,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'importTo_tally',
                    // "userId": input.userId,
                    //"accessControlList": input.accessControlList
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("xmlfile is at given folder path.");
                return { message: 'xmlfile is at given folder path.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to give excel file path." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    evaluateRuleSetBot(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let self = this;
                // input.data = input.data.replace(/['']/g, '');
                console.info("INSIDE eVALUATE RULE SET BOT --------   >>>>>>  ", input);
                if (!util_1.isNullOrUndefined(input) && !util_1.isNullOrUndefined(input.data)) {
                    input['rulesSetValue'] = !util_1.isNullOrUndefined(input.data) && typeof input.data == 'string' ? JSON.parse(input.data) : input.data;
                    let eliminateKeys = ["prediction", "tableEnd", "tableMapping", "tableStart", "Error", "Exception", "tableMapFields", "imageFilePath", "error", "OracleError", "accessControlList"];
                    let elmininateVal = [[], [], [], [], [], [], [], [], [], [], []];
                    if (!util_1.isNullOrUndefined(input['rulesSetValue']) && !util_1.isNullOrUndefined(input['rulesSetValue']) && Object.keys(input['rulesSetValue']).length > 0) {
                        for (let ob in input['rulesSetValue']) {
                            if (eliminateKeys.indexOf(ob) > -1) {
                                elmininateVal[eliminateKeys.indexOf(ob)] = input['rulesSetValue'][ob];
                                delete input['rulesSetValue'][ob];
                            }
                            else {
                                input['rulesSetValue'][ob] = input['rulesSetValue'][ob];
                            }
                        }
                        console.log("<<<<<<-------- OBJ ----------->>>>>>>>", JSON.stringify(input['rulesSetValue']));
                    }
                    let outputEval = yield self.evaluateRuleSet(input);
                    console.log(outputEval);
                    if (!util_1.isNullOrUndefined(outputEval) && !util_1.isNullOrUndefined(outputEval) && Object.keys(outputEval).length > 0) {
                        eliminateKeys.forEach((row, i) => {
                            if (!util_1.isNullOrUndefined(outputEval[row]) && Array.isArray(outputEval[row]) && !util_1.isNullOrUndefined(elmininateVal[i]) && Array.isArray(elmininateVal[i])) {
                                elmininateVal[i].forEach((ro) => {
                                    outputEval[row].push(ro);
                                });
                            }
                            else {
                                outputEval[row] = elmininateVal[i];
                            }
                        });
                    }
                    output['data'] = JSON.parse(JSON.stringify(outputEval));
                    console.log("<<<<<<-------- Output ----------->>>>>>>>", JSON.stringify(output));
                    return { "message": "CustomRules Data is Succefully Extracted", status: 0, data: output };
                }
                else {
                    return { message: "Input data is null", status: 1, data: output };
                }
            }
            catch (e) {
                this.log.error("Error in exiseRate" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    evaluateRuleSetIPP(inputData, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj;
                let resp;
                inputData.preprocess = typeof (inputData.preprocess) == 'string' ? JSON.parse(inputData.preprocess) : inputData.preprocess;
                inputData.preprocessAndEvaluat = typeof (inputData.preprocessAndEvaluat) == 'string' ? JSON.parse(inputData.preprocessAndEvaluat) : inputData.preprocessAndEvaluat;
                if (inputData.preprocess || inputData.preprocessAndEvaluat) { //for preprocess and afetr preprocess bot
                    let id;
                    if ((!util_1.isNullOrUndefined(inputData.preProcessId) && inputData.preProcessId !== "") || (!util_1.isNullOrUndefined(inputData.afterPreprocessId) && inputData.afterPreprocessId !== "")) {
                        if (inputData.preprocess == true || inputData.preprocess == "true") {
                            id = inputData.preProcessId; //preprocess
                        }
                        if (inputData.preprocessAndEvaluat == true || inputData.preprocessAndEvaluat == "true") {
                            id = inputData.afterPreprocessId; //after preprocess
                        }
                    }
                    else {
                        return { status: 1, message: "Rule Id not found", data: "Rule Id not found" + "for File" + inputData.file_path };
                    }
                    obj = {
                        "id": id,
                        "rulesSetValue": {
                            "preprocess": inputData.preprocess,
                            "preprocessAndEvaluate": inputData.preprocessAndEvaluat,
                            "pdfData": inputData.pdfData,
                            "to": parseInt(inputData.to),
                            "from": parseInt(inputData.from),
                            "file_Name": inputData.file_path,
                            "inputputFilePath": inputData.file_path,
                            "outputFilePath": inputData.outputFilePath
                        }
                    };
                }
                if (!inputData.preprocess && !inputData.preprocessAndEvaluat && inputData.IdentifyRuleSetID.length > 1) { //to find out ruleSet to corresponding pdf
                    let output = {};
                    obj = {
                        "id": inputData.IdentifyRuleSetID,
                        "rulesSetValue": {
                            "preprocess": inputData.preprocess,
                            "preprocessAndEvaluate": inputData.preprocessAndEvaluat,
                            "file_Name": inputData.file_Name,
                            "inputputFilePath": inputData.inputputFilePath,
                            "pdfData": inputData.output,
                            "IdentifyRuleSet": true,
                            "to": 5,
                            "from": 5,
                            "preProcessId": "",
                            "afterPreprocessId": ""
                        }
                    };
                    output["output"] = inputData.output;
                    output["file_path"] = inputData.file_path;
                    output["outputFilePath"] = inputData.outputFilePath;
                    output["inputputFilePath"] = inputData.inputputFilePath;
                    output["file_Name"] = inputData.file_Name;
                    //resp = await this.evaluateRuleSet(obj)
                    resp = yield this.evaluateRuleSet(JSON.parse(JSON.stringify(obj)));
                    //    data["preProcessId"]=resp.preProcessId;//replace this by id variable
                    //    data["afterPreprocessId"]=resp.afterPreprocessId;//replace this by id variable
                    if ((!util_1.isNullOrUndefined(resp.preProcessId) && resp.preProcessId !== "") || (!util_1.isNullOrUndefined(resp.afterPreprocessId) && resp.afterPreprocessId !== "")) {
                        output["preProcessId"] = !util_1.isNullOrUndefined(resp.preProcessId) && resp.preProcessId !== "" ? resp.preProcessId : ""; //replace this by id variable
                        output["afterPreprocessId"] = !util_1.isNullOrUndefined(resp.afterPreprocessId) && resp.afterPreprocessId !== "" ? resp.afterPreprocessId : ""; //replace this by id variable
                        // output["preProcessId"] = "5f577e9338fba2177a8f0058";//replace this by id variable
                        // output["afterPreprocessId"] = "5f5b140f07c1dd416a726cdf";//replace this by id variable
                    }
                    else {
                        resp = null;
                        return { status: 1, message: "Can not Identify PDF", data: "Can not Identify PDF" + " " + "for File" + " " + inputData.file_path };
                    }
                    //    data["id"]=resp.preProcessId;//replace this by id variable
                    //    data["file_Name"]=resp.afterPreprocessId
                    return { status: 0, message: "Successfully executed command", data: output };
                }
                resp = yield this.evaluateRuleSet(obj);
                if (!util_1.isNullOrUndefined(resp) && resp.status == 1) {
                    return { status: 1, message: resp.message, data: resp.data + " " + "for File" + " " + inputData.file_path };
                }
                let ipK = Object.keys(inputData);
                let blank = [];
                // let fill = [];
                for (let i = 0; i < ipK.length; i++) {
                    if (inputData[ipK[i]] == "" || util_1.isNullOrUndefined(inputData[ipK[i]]) || !inputData[ipK[i]]) {
                        blank.push(ipK[i]);
                    }
                    else {
                        output[ipK[i]] = JSON.parse(JSON.stringify(inputData[ipK[i]]));
                        // fill.push(ipK[i]);
                    }
                }
                // ipK.forEach(b => {
                //     if (inputData[b] == "" || isNullOrUndefined(inputData[b]) || !inputData[b]) {
                //         blank.push(b);
                //     }
                //     else {
                //         fill.push(b);
                //     }
                // });
                // for (let i = 0; i < fill.length; i++) {
                //     output[fill[i]] = inputData[fill[i]];
                // }
                // if (fill.length > 0) {
                //     fill.forEach(t => {
                //         output[t] = inputData[t];
                //     });
                // }
                if (!util_1.isNullOrUndefined(resp) && Array.isArray(resp) && resp.length > 0) {
                    if (!inputData.preprocessAndEvaluat) {
                        // blank.forEach(p => {
                        //     resp.forEach(element => {
                        //         if (!isNullOrUndefined(element[p]) && element[p] !== "" && element[p] && element[p] !== "false") {
                        //             output[p] = element[p];
                        //         }
                        //     });
                        // });
                        for (let i = 0; i < blank.length; i++) {
                            for (let j = 0; j < resp.length; j++) {
                                if (!util_1.isNullOrUndefined(resp[j][blank[i]]) && resp[j][blank[i]] !== "" && resp[j][blank[i]] && resp[j][blank[i]] !== "false") {
                                    output[blank[i]] = resp[j][blank[i]];
                                }
                            }
                        }
                    }
                }
                output['preProcessId'] = !util_1.isNullOrUndefined(inputData['preProcessId']) ? inputData['preProcessId'] : '';
                output['afterPreprocessId'] = !util_1.isNullOrUndefined(inputData['afterPreprocessId']) ? inputData['afterPreprocessId'] : '';
                output['pdfData'] = null;
                delete output['from'];
                delete output['to'];
                if (!util_1.isNullOrUndefined(resp) && resp.length > 0 && util_1.isNullOrUndefined(resp.data)) {
                    // Exclusion_String = this.getExclusionString(resp);
                    output['pdfData'] = [];
                    output['pdfData'] = JSON.parse(JSON.stringify(resp));
                }
                else {
                    // Exclusion_String = this.getExclusionString(resp.data);
                    output['pdfData'] = [];
                    output['pdfData'] = JSON.parse(JSON.stringify(resp.data));
                }
                resp = null;
                let OutPut = JSON.parse(JSON.stringify(output));
                output = null;
                obj = null;
                return { status: 0, message: "Successfully executed command", data: OutPut };
            }
            catch (e) {
                this.log.error("Error in exiseRate" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    evaluateRulesAndSplitPDF(inputData) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let tempcustomRulesIds = inputData.rulesSet;
            let obj = {};
            let dataArray = [];
            let finelObj = {};
            let lastObj = {};
            console.log(lastObj); //as giving error while build, so added this log
            // let isSamePage = false;
            // let islastPage = false;
            // let isFalse=false;
            try {
                let tempInput = {};
                let currentIndex = -1;
                let newPageid = 0;
                let lineCount = 0;
                for (let i = 0; i < inputData.pdfData.length; i++) {
                    let obj = inputData.pdfData[i];
                    if (obj["pageId"] == newPageid) {
                        obj["lineNumber"] = lineCount;
                    }
                    else {
                        lineCount = 0;
                        newPageid = obj["pageId"];
                        obj["lineNumber"] = lineCount;
                    }
                    lineCount++;
                    if (i > 0) {
                        let preObj = inputData.pdfData[i - 1];
                        obj['preline'] = preObj['line'];
                        obj['preTop'] = preObj['top'];
                    }
                    if (i < inputData.pdfData.length - 1) {
                        let nextObj = inputData.pdfData[i + 1];
                        if (i < inputData.pdfData.length - 2) {
                            let nextOfnextobj = inputData.pdfData[i + 2];
                            obj['nextOfnextline'] = nextOfnextobj['line'];
                        }
                        obj['nextline'] = nextObj['line'];
                        obj['nextText'] = nextObj['text'];
                        obj['nextTop'] = nextObj['top'];
                        dataArray.push(obj);
                    }
                    else {
                        dataArray.push(obj);
                        lastObj = obj;
                    }
                }
                inputData.pdfData[inputData.pdfData.length - 1]['lastPage'] = true;
                let pushFlag = false;
                for (const input of dataArray) {
                    currentIndex++;
                    if (pushFlag) {
                        pushFlag = false;
                        continue;
                    }
                    for (const i of Object.keys(finelObj)) {
                        input[i] = finelObj[i];
                    }
                    // let found = false;
                    for (const element of tempcustomRulesIds) {
                        for (var i = 0; i < element.rules.length; i++) {
                            let count = 0;
                            let criteriaMatchCount = 0;
                            for (const dInnerInner of element.rules[i].rule.criteria) {
                                criteriaMatchCount = count;
                                obj[dInnerInner.field] = input[dInnerInner.field];
                                if (dInnerInner.value === '') {
                                    count++;
                                }
                                else {
                                    evalObjField = {
                                        "Expression": dInnerInner.field,
                                        "value": input
                                    };
                                    evalObjValue = {
                                        "Expression": dInnerInner.value,
                                        "value": input
                                    };
                                    let val = yield this.evaluateExpression(evalObjField);
                                    let compareVal = yield this.evaluateExpression(evalObjValue);
                                    if (val == true) {
                                        val = "true";
                                    }
                                    if (val == false) {
                                        val = "false";
                                    }
                                    if (compareVal == true) {
                                        compareVal = "true";
                                    }
                                    if (compareVal == false) {
                                        compareVal = "false";
                                    }
                                    if (!util_1.isNullOrUndefined(val) && !util_1.isNullOrUndefined(compareVal)) {
                                        switch (dInnerInner.operator) {
                                            case '===':
                                                if ((compareVal == "empty" && dInnerInner.field == val) || (compareVal == "empty" && val.trim() == "")) {
                                                    count++;
                                                }
                                                else {
                                                    if (isNaN(val) && isNaN(compareVal)) {
                                                        try {
                                                            if (val.replace(/\s/g, '') === compareVal.replace(/\s/g, '')) {
                                                                count++;
                                                            }
                                                        }
                                                        catch (e) {
                                                            console.log(e);
                                                        }
                                                    }
                                                    else {
                                                        if (Number(val) === Number(compareVal)) {
                                                            count++;
                                                        }
                                                    }
                                                }
                                                break;
                                            case '!==':
                                                if ((compareVal == "empty" && dInnerInner.field == val) || (compareVal == "empty" && val.trim() == "")) {
                                                    count++;
                                                }
                                                else {
                                                    if (isNaN(val) && isNaN(compareVal)) {
                                                        if (val !== compareVal) {
                                                            count++;
                                                        }
                                                    }
                                                    else {
                                                        if (Number(val) !== Number(compareVal)) {
                                                            count++;
                                                        }
                                                    }
                                                }
                                                break;
                                            case '>':
                                                if (isNaN(val) && isNaN(compareVal)) {
                                                    if (val > compareVal) {
                                                        count++;
                                                    }
                                                }
                                                else {
                                                    if (Number(val) > Number(compareVal)) {
                                                        count++;
                                                    }
                                                }
                                                break;
                                            case '<':
                                                if (isNaN(val) && isNaN(compareVal)) {
                                                    if (val < compareVal) {
                                                        count++;
                                                    }
                                                }
                                                else {
                                                    if (Number(val) < Number(compareVal)) {
                                                        count++;
                                                    }
                                                }
                                                break;
                                            case '>=':
                                                if (isNaN(val) && isNaN(compareVal)) {
                                                    if (val >= compareVal) {
                                                        count++;
                                                    }
                                                }
                                                else {
                                                    if (Number(val) >= Number(compareVal)) {
                                                        count++;
                                                    }
                                                }
                                                break;
                                            case '<=':
                                                if (isNaN(val) && isNaN(compareVal)) {
                                                    if (val <= compareVal) {
                                                        count++;
                                                    }
                                                }
                                                else {
                                                    if (Number(val) <= Number(compareVal)) {
                                                        count++;
                                                    }
                                                }
                                                break;
                                        }
                                    }
                                    if (dInnerInner.value === '') {
                                        count++;
                                    }
                                }
                                if (criteriaMatchCount == count) {
                                    break;
                                }
                            }
                            if (count === element.rules[i].rule.criteria.length) {
                                for (const dResult of element.rules[i].rule.result) {
                                    let result;
                                    let tempObj = {};
                                    if (dResult.operator == "push") {
                                        tempInput = Object.assign({}, input);
                                        evalObjValue = {
                                            "Expression": dResult.value,
                                            "value": input
                                        };
                                        let val = yield this.evaluateExpression(evalObjValue);
                                        evalObjValue = {
                                            "Expression": dResult.value.replace(/line/g, 'tagline'),
                                            "value": input
                                        };
                                        let tagval = yield this.evaluateExpression(evalObjValue);
                                        tempInput["line"] = val;
                                        tempInput["tagline"] = tagval;
                                        dataArray.splice(currentIndex, 0, tempInput);
                                        pushFlag = true;
                                        continue;
                                    }
                                    if (dResult.operator == "table") {
                                        let evalObjValuenewtable1 = {
                                            "Expression": dResult.value,
                                            "value": input,
                                        };
                                        evalObjValuenewtable1['value']['isObject'] = true;
                                        let keyResult = yield this.evaluateExpression(evalObjValuenewtable1);
                                        tempObj = JSON.parse(keyResult);
                                        if (tempObj[0] != undefined) {
                                            tempObj[0].col = tempObj[0].col.replace(/newline/g, '\n');
                                        }
                                        if (tempObj[1] != undefined) {
                                            tempObj[1].col = tempObj[1].col.replace(/newline/g, '\n');
                                        }
                                        if (util_1.isNullOrUndefined(finelObj[dResult.field])) {
                                            // input[dResult.field] = []
                                            finelObj[dResult.field] = [];
                                        }
                                        // input[dResult.field].push(tempObj);
                                        finelObj[dResult.field].push(tempObj);
                                        continue;
                                    }
                                    if (dResult.field == "delete") {
                                        delete input[dResult.value];
                                        delete finelObj[dResult.value];
                                    }
                                    else {
                                        var re = {};
                                        if (dResult.value.indexOf('push') > -1) {
                                            result = '';
                                            let splitR = dResult.value.split('.');
                                            const regex = /^\s*(\w+)\s*\((.*)\)/gm;
                                            const str = splitR[1];
                                            let m;
                                            let key;
                                            while ((m = regex.exec(str)) !== null) {
                                                if (m.index === regex.lastIndex) {
                                                    regex.lastIndex++;
                                                }
                                                m.forEach((match, groupIndex) => {
                                                    console.log(`Found match, group ${groupIndex}: ${match}`);
                                                    if (groupIndex == 1) {
                                                    }
                                                    else if (groupIndex == 2) {
                                                        key = match;
                                                    }
                                                });
                                            }
                                            if (util_1.isNullOrUndefined(finelObj[splitR[0]])) {
                                                finelObj[splitR[0]] = input[key];
                                            }
                                            else {
                                                finelObj[splitR[0]] = finelObj[splitR[0]] + '-' + input[key];
                                            }
                                        }
                                        else {
                                            evalObjValue = {
                                                "Expression": dResult.value,
                                                "value": input,
                                            };
                                            if (dResult.field == "file_Name") {
                                                // console.log('abc');
                                            }
                                            if (dResult.field == "exitNow") {
                                                return { status: 0, message: "Successfully executed command", data: dataArray };
                                            }
                                            result = yield this.evaluateExpression(evalObjValue);
                                            input[dResult.field] = result;
                                            var tage = '';
                                            if (!util_1.isNullOrUndefined(input['tagline']) && dResult.field == 'line' && dResult.value.includes('~') && input['tagline'].trim().substring(0, 3).includes('#') && input['tagline'].trim().substring(0, 8).includes('$')) {
                                                tage = input['tagline'].substring(input['tagline'].indexOf('#') + 1, input['tagline'].indexOf('$'));
                                                input['tagline'] = input['tagline'].trim().replace(/#.*?\$/, '').trim();
                                            }
                                            if (dResult.field == 'line') {
                                                let evalObjValuetag = {
                                                    "Expression": dResult.value.replace(/line/g, 'tagline'),
                                                    "value": input,
                                                };
                                                let resulttag = yield this.evaluateExpression(evalObjValuetag);
                                                if (tage != '') {
                                                    input['tagline'] = '#' + tage + '$' + ' ' + resulttag;
                                                }
                                                else {
                                                    input['tagline'] = resulttag;
                                                }
                                            }
                                            if (typeof dResult.value == "string" && dResult.value.includes('fuzzylookUp') && (Number(result) == -1 || result.includes("is not defined"))) {
                                                if (input['FreeState_Province'] == true) {
                                                    result = "PN";
                                                }
                                                else {
                                                    return { status: 1, message: dResult.field + " " + "  Not found in collection", data: dResult.field + " " + "  Not found in collection" };
                                                }
                                            }
                                            if (dResult.field != "line") {
                                                obj[dResult.field] = result;
                                                finelObj[dResult.field] = result;
                                                re[dResult.field] = result;
                                            }
                                            // if(dResult.field=="content_page"&&(result=="false"||result==false)){
                                            //     isFalse=true;
                                            // }
                                        }
                                        ;
                                    }
                                }
                                i = element.rules.length;
                            }
                        }
                    }
                    ;
                    // if(isFalse){
                    //     break;
                    // }
                }
                let ipK = Object.keys(inputData);
                let blank = [];
                let fill = [];
                ipK.forEach(b => {
                    if (inputData[b] == "" || util_1.isNullOrUndefined(inputData[b]) || !inputData[b]) {
                        blank.push(b);
                    }
                    else {
                        fill.push(b);
                    }
                });
                if (fill.length > 0) {
                    fill.forEach(t => {
                        // output[t] = inputData[t];
                    });
                }
                blank.forEach(p => {
                    dataArray.forEach(element => {
                        if (!util_1.isNullOrUndefined(element[p]) && element[p] !== "" && element[p] && element[p] !== "false") {
                            // output[p] = element[p];
                        }
                    });
                });
                // output['pdfData'] = dataArray;
                return { status: 0, message: "Successfully executed command", data: dataArray };
            }
            catch (e) {
                console.log('errrr------->', e);
                return { info: 'Internal Server Error', status: 1, data: e };
            }
        });
    }
    EvaluateRulePDF(ruleSet, fields, input) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let c = true;
                // let pOutout;
                // let strO;
                let keyList1 = Object.keys(fields);
                let isArrayFound = false;
                let pdfData;
                let kk = "";
                let isDataOperation = false;
                let ruleSetCount = 0;
                let expression = {};
                for (const k of keyList1) {
                    kk = k;
                    if (Array.isArray(fields[kk])) {
                        isArrayFound = true;
                        pdfData = fields[k];
                        // if(pdfData.length>4000){
                        // pdfData=pdfData.slice(0,500)
                        // }
                    }
                }
                if (!isArrayFound) {
                    return "Invalid input Data";
                }
                if (fields.preprocessAndEvaluate) {
                    let inputData = {
                        pdfData: pdfData,
                        rulesSet: ruleSet,
                        file_path: fields.file_Name,
                        outputFilePath: fields.outputFilePath
                    };
                    // let pdfDataResult = [];
                    // for (let increment = 0; increment <= pdfData.length - 1; increment++) {
                    //     let resp = await this.EvaluateRule(ruleSet, pdfData[increment]);
                    //     pdfDataResult.push(JSON.parse(JSON.stringify(resp)));
                    // }
                    // return pdfDataResult;
                    return this.evaluateRulesAndSplitPDF(inputData);
                }
                else {
                    let index = -1;
                    let compVal;
                    let Val;
                    let finelObj = {};
                    let Expresult;
                    pdfData[pdfData.length - 1]['lastPage'] = true;
                    let k = Object.keys(pdfData[0]);
                    let lastObj = pdfData[pdfData.length - 1];
                    lastObj['pageIds'] = lastObj['pageId'];
                    // console.log("----------Total PDF lines------------------------------"+pdfData.length);
                    for (let increment = 0; increment <= pdfData.length - 1; increment++) {
                        pdfData[increment]["inputputFilePath"] = input.rulesSetValue.inputputFilePath;
                        // console.log("Executing for line------------------>"+increment+"--"+pdfData[increment].line);
                        for (const i of Object.keys(finelObj)) {
                            pdfData[increment][i] = finelObj[i];
                        }
                        if (increment == pdfData.length - 1) {
                            // console.log("near to lastobj")
                            pdfData[increment]['lastPage'] = true;
                        }
                        index = index + 1;
                        isDataOperation = false;
                        ruleSetCount = 0;
                        let keyList = Object.keys(pdfData[increment]);
                        for (const myrules of ruleSet) {
                            ruleSetCount = ruleSetCount + 1;
                            for (let i = 0; i < myrules.rules.length; i++) {
                                let matchCriteriaCount = 0;
                                let totalCriteria = 0;
                                totalCriteria = myrules.rules[i].rule.criteria.length;
                                let criteriaIncrementCount = 0;
                                for (const criteria of myrules.rules[i].rule.criteria) {
                                    criteriaIncrementCount = criteriaIncrementCount + 1;
                                    if (criteria.value !== "") {
                                        if (index >= fields.from && index < pdfData.length - fields.to) {
                                            if (criteria.value.includes("isNullOrUndefined")) {
                                                let newobj = {};
                                                for (const newfield of Object.keys(pdfData[increment])) {
                                                    newobj[newfield] = pdfData[increment][newfield];
                                                }
                                                newobj['pdfData'] = JSON.stringify(pdfData.slice(index - fields.from, index + fields.to));
                                                newobj['index'] = index;
                                                newobj['currentIndex'] = fields.from;
                                                expression = {
                                                    Expression: criteria.value,
                                                    value: newobj
                                                };
                                            }
                                            else {
                                                expression = {
                                                    Expression: criteria.value,
                                                    value: { pdfData: JSON.stringify(pdfData.slice(index - fields.from, index + fields.to)), index: index, currentIndex: fields.from }
                                                };
                                            }
                                        }
                                        else {
                                            if (criteria.value.includes("isNullOrUndefined")) {
                                                let newobj = {};
                                                for (const newfield of Object.keys(pdfData[increment])) {
                                                    newobj[newfield] = pdfData[increment][newfield];
                                                }
                                                newobj['pdfData'] = JSON.stringify(pdfData.slice(0, index + fields.to));
                                                newobj['index'] = index;
                                                newobj['currentIndex'] = index;
                                                expression = {
                                                    Expression: criteria.value,
                                                    value: newobj
                                                };
                                            }
                                            else {
                                                expression = {
                                                    Expression: criteria.value,
                                                    value: { pdfData: JSON.stringify(pdfData.slice(0, index + fields.to)), index: index, currentIndex: index }
                                                };
                                            }
                                        }
                                        Val = yield this.evaluateExpression(expression);
                                        let self = this;
                                        let isOutOfField = false;
                                        if (keyList.indexOf(criteria.field) == -1) {
                                            if (index >= 10 && index < pdfData.length - 10) {
                                                if (criteria.field.includes("isNullOrUndefined")) {
                                                    let newobj = {};
                                                    for (const newfield of Object.keys(pdfData[increment])) {
                                                        newobj[newfield] = pdfData[increment][newfield];
                                                    }
                                                    newobj['pdfData'] = JSON.stringify(pdfData.slice(index - fields.from, index + fields.to));
                                                    newobj['index'] = index;
                                                    newobj['currentIndex'] = fields.from;
                                                    expression = {
                                                        Expression: criteria.field,
                                                        value: newobj
                                                    };
                                                }
                                                else {
                                                    expression = {
                                                        Expression: criteria.field,
                                                        value: { pdfData: JSON.stringify(pdfData.slice(index - fields.from, index + fields.to)), index: index, currentIndex: fields.from }
                                                    };
                                                }
                                            }
                                            else {
                                                if (criteria.field.includes("isNullOrUndefined")) {
                                                    let newobj = {};
                                                    for (const newfield of Object.keys(pdfData[increment])) {
                                                        newobj[newfield] = pdfData[increment][newfield];
                                                    }
                                                    newobj['pdfData'] = JSON.stringify(pdfData.slice(index - fields.from, index + fields.to));
                                                    newobj['index'] = index;
                                                    newobj['currentIndex'] = index;
                                                    expression = {
                                                        Expression: criteria.field,
                                                        value: newobj
                                                    };
                                                }
                                                else {
                                                    expression = {
                                                        Expression: criteria.field,
                                                        value: { pdfData: JSON.stringify(pdfData.slice(0, index + fields.to)), index: index, currentIndex: index }
                                                    };
                                                }
                                            }
                                            compVal = yield this.evaluateExpression(expression);
                                            isOutOfField = true;
                                        }
                                        if (Val == "true") {
                                            Val = true;
                                        }
                                        if (Val == "false") {
                                            Val = false;
                                        }
                                        if (compVal == "true") {
                                            compVal = true;
                                        }
                                        if (compVal == "false") {
                                            compVal = false;
                                        }
                                        if (!isNaN(compVal)) {
                                            compVal = Number(compVal);
                                        }
                                        if (!isNaN(Val)) {
                                            Val = Number(Val);
                                        }
                                        if (self.operators[criteria.operator](compVal, Val)) {
                                            matchCriteriaCount++;
                                        }
                                        if (isOutOfField) {
                                            delete pdfData[increment][criteria.field];
                                        }
                                        if (matchCriteriaCount != criteriaIncrementCount) {
                                            break;
                                        }
                                    }
                                    else {
                                        totalCriteria = totalCriteria - 1;
                                    }
                                }
                                if (matchCriteriaCount == totalCriteria) {
                                    for (const result of myrules.rules[i].rule.result) {
                                        // let result
                                        // let re = {}
                                        if (!util_1.isNullOrUndefined(result) && result !== "") {
                                            if (result.value.indexOf('push') > -1) {
                                                // result = '';
                                                let splitR = result.value.split('.');
                                                const regex = /^\s*(\w+)\s*\((.*)\)/gm;
                                                const str = splitR[1];
                                                let m;
                                                let key;
                                                while ((m = regex.exec(str)) !== null) {
                                                    if (m.index === regex.lastIndex) {
                                                        regex.lastIndex++;
                                                    }
                                                    m.forEach((match, groupIndex) => {
                                                        console.log(`Found match, group ${groupIndex}: ${match}`);
                                                        if (groupIndex == 1) {
                                                        }
                                                        else if (groupIndex == 2) {
                                                            key = match;
                                                        }
                                                    });
                                                }
                                                if (util_1.isNullOrUndefined(finelObj[splitR[0]])) {
                                                    finelObj[splitR[0]] = pdfData[increment][key];
                                                }
                                                else {
                                                    finelObj[splitR[0]] = finelObj[splitR[0]] + '-' + pdfData[increment][key];
                                                }
                                            }
                                            if (result.field == "exit") {
                                                return pdfData;
                                            }
                                            let tagexpression;
                                            let tagExpresult;
                                            if (result.value !== "") {
                                                if (index >= 10 && index < pdfData.length - 10) {
                                                    let data123 = pdfData.slice(index - fields.from, index + fields.to);
                                                    data123;
                                                    expression = {
                                                        Expression: result.value,
                                                        // value: {pdfData:JSON.stringify(pdfData.slice(index-10, index+10)),index:index,currentIndex:0}
                                                        value: { pdfData: JSON.stringify(pdfData.slice(index - fields.from, index + fields.to)), index: index, currentIndex: fields.from }
                                                    };
                                                    if (result.field == 'line') {
                                                        tagexpression = {
                                                            Expression: result.value.replace(/line/g, 'tagline'),
                                                            // value: {pdfData:JSON.stringify(pdfData.slice(index-10, index+10)),index:index,currentIndex:0}
                                                            value: { pdfData: JSON.stringify(pdfData.slice(index - fields.from, index + fields.to)), index: index, currentIndex: fields.from }
                                                        };
                                                    }
                                                }
                                                else {
                                                    let data123 = pdfData.slice(0, index + fields.to);
                                                    data123;
                                                    expression = {
                                                        Expression: result.value,
                                                        value: { pdfData: JSON.stringify(pdfData.slice(0, index + fields.to)), index: index, currentIndex: index }
                                                    };
                                                    if (result.field == 'line') {
                                                        tagexpression = {
                                                            Expression: result.value.replace(/line/g, 'tagline'),
                                                            value: { pdfData: JSON.stringify(pdfData.slice(0, index + fields.to)), index: index, currentIndex: index }
                                                        };
                                                    }
                                                }
                                                if (result.field === "dataOperation") {
                                                    yield pdfData.splice(index + 1, 1);
                                                    // pdfData = await this.evaluateExpression(expression)
                                                    // pdfData=pdfData.slice(0,index+1).concat(pdfData.slice(index+2,pdfData.length))
                                                    isDataOperation = true;
                                                }
                                                else if (result.field === "sort" && c == true) {
                                                    let a = [];
                                                    let val = result.value;
                                                    for (let t = 0; t < pdfData.length; t++) {
                                                        if (!util_1.isNullOrUndefined(pdfData[t].content_page) && (pdfData[t].content_page == true || pdfData[t].content_page == "true")) {
                                                            a.push(pdfData[t]);
                                                            pdfData[t] = ({ p: "r" });
                                                            if (!util_1.isNullOrUndefined(pdfData[t].content_page) && (pdfData[t].content_page == false || pdfData[t].content_page == "false")) {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    a.sort((a, b) => a.line.substring(a.line.indexOf(val) + val.length + 1, a.line.lastIndexOf('(') - 1) - b.line.substring(b.line.indexOf(val) + val.length + 1, b.line.lastIndexOf('(') - 1));
                                                    for (let o = 0; o < a.length; o++) {
                                                        if (!util_1.isNullOrUndefined(a[o].line) && a[o].line !== "" && !util_1.isNullOrUndefined(a[o + 1]) && !util_1.isNullOrUndefined(a[o + 1].line) && a[o + 1].line !== "") {
                                                            let g = a[o].line.substring(a[o].line.indexOf(val) + val.length + 1, a[o].line.lastIndexOf('(') - 1);
                                                            let h = a[o + 1].line.substring(a[o + 1].line.indexOf(val) + val.length + 1, a[o + 1].line.lastIndexOf('(') - 1);
                                                            if (!util_1.isNullOrUndefined(a[o + 1]) && g[g.length - 1] == h[h.length - 1]) {
                                                                let c = (a[o].line.match(/,/g) || []).length;
                                                                let m = (a[o + 1].line.match(/,/g) || []).length;
                                                                if (c > m) {
                                                                    a.splice(o, 1);
                                                                }
                                                                else {
                                                                    a.splice(o + 1, 1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                    let index = 0;
                                                    for (let q = 0; q < pdfData.length; q++) {
                                                        if (!util_1.isNullOrUndefined(pdfData[q].p) && pdfData[q].p == 'r') {
                                                            // index = p;
                                                            // break;
                                                            if (!util_1.isNullOrUndefined(a[index]) && a[index] !== "") {
                                                                pdfData[q] = a[index];
                                                                index++;
                                                            }
                                                        }
                                                        // if(isNullOrUndefined(pdfData[q]) || pdfData[q] == "undefined" || (!isNullOrUndefined(pdfData[q].p) && pdfData[q].p =='r')){
                                                        //     pdfData.splice(q, 1);
                                                        // }
                                                    }
                                                    c = false;
                                                }
                                                else if (result.field === "sortNR" && c == true) {
                                                    let a = [];
                                                    let val = result.value;
                                                    let startOfContent = -1;
                                                    let endOfContent = 0;
                                                    for (let t = 0; t < pdfData.length; t++) {
                                                        if (!util_1.isNullOrUndefined(pdfData[t].content_page) && (pdfData[t].content_page == true || pdfData[t].content_page == "true")) {
                                                            if (startOfContent == -1) {
                                                                startOfContent = t;
                                                            }
                                                            else {
                                                                endOfContent++;
                                                            }
                                                            if (pdfData[t].line.substring(pdfData[t].line.indexOf(val)).includes('(') == true) {
                                                                if (pdfData[t].line.substring(pdfData[t].line.indexOf(val)).split(' ').length <= 2) {
                                                                    pdfData[t].line = pdfData[t].line.substring(0, pdfData[t].line.lastIndexOf('(')) + ' ' + pdfData[t].line.substring(pdfData[t].line.lastIndexOf('('));
                                                                }
                                                                pdfData[t]['pageStart'] = pdfData[t].line.substring(pdfData[t].line.indexOf(val) + val.length + 1, pdfData[t].line.lastIndexOf('(') - 1);
                                                                a.push(pdfData[t]);
                                                                pdfData[t] = ({ p: "r" });
                                                            }
                                                            else {
                                                                pdfData[t].line = pdfData[t].line + " (";
                                                                pdfData[t]['pageStart'] = pdfData[t].line.substring(pdfData[t].line.indexOf(val) + val.length + 1, pdfData[t].line.lastIndexOf('(') - 1);
                                                                a.push(pdfData[t]);
                                                                pdfData[t] = ({ p: "r" });
                                                            }
                                                            if (!util_1.isNullOrUndefined(pdfData[t].content_page) && (pdfData[t].content_page == false || pdfData[t].content_page == "false")) {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    a.sort((a, b) => a.line.substring(a.line.indexOf(val) + val.length + 1, a.line.lastIndexOf('(') - 1) - b.line.substring(b.line.indexOf(val) + val.length + 1, b.line.lastIndexOf('(') - 1));
                                                    let l = a.length;
                                                    for (let o = 0; o < l; o++) {
                                                        if (!util_1.isNullOrUndefined(a[o]) && a[o] !== "" && !util_1.isNullOrUndefined(a[o].line) && a[o].line !== "" && !util_1.isNullOrUndefined(a[o + 1]) && a[o + 1] !== "" && !util_1.isNullOrUndefined(a[o + 1].line) && a[o + 1].line !== "") {
                                                            // let g = a[o].line.substring(a[o].line.indexOf(val) + val.length+1, a[o].line.lastIndexOf('(') - 1);
                                                            // let h = a[o + 1].line.substring(a[o + 1].line.indexOf(val) + val.length+1, a[o + 1].line.lastIndexOf('(') - 1)
                                                            let g = a[o].pageStart;
                                                            let h = a[o + 1].pageStart;
                                                            if (isNaN(g)) {
                                                                a.splice(o, 1);
                                                                o--;
                                                                continue;
                                                            }
                                                            if (!util_1.isNullOrUndefined(a[o + 1]) && !util_1.isNullOrUndefined(a[o + 1].line) && g == h) {
                                                                let c = (a[o].line.match(/,/g) || []).length;
                                                                let m = (a[o + 1].line.match(/,/g) || []).length;
                                                                if (c > m) {
                                                                    a.splice(o, 1);
                                                                }
                                                                else {
                                                                    a.splice(o + 1, 1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                    pdfData.splice(startOfContent, endOfContent);
                                                    // let index = 0
                                                    for (let q = 0; q < a.length; q++) {
                                                        pdfData.splice(startOfContent, 0, a[q]);
                                                        startOfContent++;
                                                    }
                                                    c = false;
                                                }
                                                else if (result.field === "Cases_Reported" && c == true) {
                                                    // checkTo(pdfData, matchKey) {
                                                    // let pageid = 'none';
                                                    // if(!matchKey.includes("No.")){matchKey="No. "+matchKey}
                                                    // if (!isNaN(matchKey)) { matchKey = "No. " + matchKey }
                                                    // pdfData.filter((re) => {
                                                    //     if (re.content_page == "false" && re.line.includes(result.value)) {
                                                    //         if (re.lineNumber <= 3) {
                                                    //             pageid = re.pageId;
                                                    //         } else {
                                                    //             pageid = re.pageId + 1;
                                                    //         }
                                                    //     }
                                                    // })
                                                    // return pageid;
                                                    let a = [];
                                                    for (let r = 0; r < pdfData.length; r++) {
                                                        // let k = "p" + r;
                                                        if (!util_1.isNullOrUndefined(pdfData[r].content_page) && (pdfData[r].content_page == "true" || pdfData[r].content_page == true) && pdfData[r].content_page !== "false") {
                                                            if (!pdfData[r].line.toUpperCase().includes('CASES REPORTED') && !pdfData[r].line.toUpperCase().includes("BOTSWANA LAW REPORTS")) {
                                                                a.push(pdfData[r]);
                                                                pdfData[r] = ({ p: "r" });
                                                            }
                                                            //  else {
                                                            //     pdfData[r] = ({ p: "r" })
                                                            // }
                                                        }
                                                    }
                                                    a.sort((a, b) => a.line.split(' ')[a.line.split(' ').length - 1] - b.line.split(' ')[b.line.split(' ').length - 1]);
                                                    let index = 0;
                                                    for (let o = 0; o < a.length; o++) {
                                                        if (!util_1.isNullOrUndefined(a[o].line) && a[o].line !== "" && !util_1.isNullOrUndefined(a[o + 1]) && !util_1.isNullOrUndefined(a[o + 1].line) && a[o + 1].line !== "") {
                                                            let g = a[o].line.split(' ');
                                                            let h = a[o + 1].line.split(' ');
                                                            if (!util_1.isNullOrUndefined(a[o + 1]) && g[g.length - 1] == h[h.length - 1]) {
                                                                let c = (a[o].line.match(/,/g) || []).length;
                                                                let m = (a[o + 1].line.match(/,/g) || []).length;
                                                                if (c > m) {
                                                                    a.splice(o, 1);
                                                                }
                                                                else {
                                                                    a.splice(o + 1, 1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                    // let d = [];
                                                    let court = ['CIRCUIT COURT', 'COURT OF APPEAL', 'INDUSTRIAL COURT', 'HIGH COURT'];
                                                    let occurrence = 0;
                                                    for (let d = 0; d < a.length; d++) {
                                                        if (!util_1.isNullOrUndefined(a[d].content_page) && a[d].content_page) {
                                                            // if (!a[d].line.toUpperCase().includes('CASES REPORTED') && !a[d].line.toUpperCase().includes("BOTSWANA LAW REPORTS")) {
                                                            let j = a[d].line.split(' ')[a[d].line.split(' ').length - 1];
                                                            if (!isNaN(j)) {
                                                                let i = a[d].line.indexOf(". .");
                                                                if (i !== -1 || i !== '-1') {
                                                                    let s = a[d].line.substring(0, i);
                                                                    if (!util_1.isNullOrUndefined(s) && s !== '') {
                                                                        s = s.replace(', (IC)', '');
                                                                        s = s.replace(', (CC)', '');
                                                                        s = s.replace(', (CA)', '');
                                                                        s = s.replace(', (HC)', '');
                                                                        s = s.trim();
                                                                        let id = 0;
                                                                        for (let f = 0; f < pdfData.length; f++) {
                                                                            if (id !== pdfData[f].pageId) {
                                                                                occurrence = 0;
                                                                                id = pdfData[f].pageId;
                                                                            }
                                                                            if (!util_1.isNullOrUndefined(pdfData[f].line) && pdfData[f].line[0].toUpperCase() == pdfData[f].line[0] && pdfData[f].line[1] == ' ') {
                                                                                pdfData[f].line = pdfData[f].line.substring(2, pdfData[f].line.length);
                                                                            }
                                                                            else if (!util_1.isNullOrUndefined(pdfData[f].line) && pdfData[f].line[pdfData[f].line.length - 1].toUpperCase() == pdfData[f].line[pdfData[f].line.length - 1] && pdfData[f].line[pdfData[f].line.length - 1] == ' ') {
                                                                                pdfData[f].line = pdfData[f].line.substring(0, pdfData[f].line.length - 2);
                                                                            }
                                                                            // pdfData[f]['occurrence'] = 1
                                                                            if (!util_1.isNullOrUndefined(pdfData[f].line) && pdfData[f].line.length > 6 && s.toUpperCase().trim() == pdfData[f].line.toUpperCase().trim()) { // && pdfData[f].bold == true   s.toUpperCase().includes(pdfData[f].line.toUpperCase().trim())
                                                                                occurrence += 1;
                                                                                for (let c = 0; c < court.length; c++) {
                                                                                    if ((!util_1.isNullOrUndefined(pdfData[f + 1].line) && pdfData[f + 1].line.includes(court[c])) || (!util_1.isNullOrUndefined(pdfData[f + 2].line) && pdfData[f + 2].line.includes(court[c])) || (!util_1.isNullOrUndefined(pdfData[f + 3].line) && pdfData[f + 3].line.includes(court[c])) || (!util_1.isNullOrUndefined(pdfData[f + 4].line) && pdfData[f + 4].line.includes(court[c])) || (!util_1.isNullOrUndefined(pdfData[f + 5].line) && pdfData[f + 5].line.includes(court[c])) || (!util_1.isNullOrUndefined(pdfData[f + 6].line) && pdfData[f + 6].line.includes(court[c]))) {
                                                                                        a[d]['splitId'] = pdfData[f].pageId;
                                                                                        a[d]['occurrence'] = occurrence;
                                                                                        a[d]['splitText'] = s;
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            // }
                                                        }
                                                    }
                                                    for (let q = 0; q < pdfData.length; q++) {
                                                        if (!util_1.isNullOrUndefined(pdfData[q].p) && pdfData[q].p == 'r') {
                                                            // index = p;
                                                            // break;
                                                            if (!util_1.isNullOrUndefined(a[index]) && a[index] !== "") {
                                                                pdfData[q] = a[index];
                                                                index++;
                                                            }
                                                        }
                                                        // if(isNullOrUndefined(pdfData[q]) || pdfData[q] == "undefined" || (!isNullOrUndefined(pdfData[q].p) && pdfData[q].p =='r')){
                                                        //     pdfData.splice(q, 1);
                                                        // }
                                                    }
                                                    // for(let w=index;w<pdfData.length;w++){
                                                    // }
                                                    result.value = "SortDone";
                                                    c = false;
                                                    // }
                                                }
                                                else if (result.field === "CILSA" && c == true) {
                                                    for (let d = 0; d < pdfData.length; d++) {
                                                        if (!util_1.isNullOrUndefined(pdfData[d].content_page) && (pdfData[d].content_page == "true" || pdfData[d].content_page == true) && !util_1.isNullOrUndefined(pdfData[d].line)) {
                                                            let no = pdfData[d].line.replace(/[^0-9]/g, '');
                                                            if (!util_1.isNullOrUndefined(no) && no !== "") {
                                                                let index = pdfData[d].line.indexOf(no);
                                                                if (pdfData[d].line[index - 1] == " " && pdfData[d].line[index + no.toString().length] == " ") {
                                                                    pdfData[d]['splitId'] = no;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    c = false;
                                                }
                                                else if (result.field.includes('+') || result.field.includes('-')) {
                                                    // result.field = result.field.split("[").join("");
                                                    // result.field = result.field.split("]").join("");
                                                    let expressionIndexing = {
                                                        Expression: result.field,
                                                        value: pdfData[increment]
                                                    };
                                                    //expressionIndexing["value"]["pdfData"] = JSON.stringify(pdfData)
                                                    expressionIndexing["value"]["index"] = increment;
                                                    let indexIn = yield this.evaluateExpression(expressionIndexing);
                                                    let expression = {
                                                        Expression: result.value,
                                                        value: { pdfData: JSON.stringify(pdfData), index: index }
                                                    };
                                                    let tagexpression = {
                                                        Expression: result.value.replace(/line/g, 'tagline'),
                                                        value: { pdfData: JSON.stringify(pdfData), index: index }
                                                    };
                                                    for (const newfield of Object.keys(pdfData[increment])) {
                                                        if (newfield !== 'line') {
                                                            expression.value[newfield] = pdfData[increment][newfield];
                                                        }
                                                    }
                                                    if (!isNaN(indexIn) && indexIn < pdfData.length) {
                                                        let evalExpr = yield this.evaluateExpression(expression);
                                                        let tagevalExpr = yield this.evaluateExpression(tagexpression);
                                                        pdfData[indexIn][result.operator] = evalExpr;
                                                        pdfData[indexIn]['tagline'] = tagevalExpr;
                                                    }
                                                }
                                                else {
                                                    Expresult = yield this.evaluateExpression(expression);
                                                    if (result.field == 'line') {
                                                        tagExpresult = yield this.evaluateExpression(tagexpression);
                                                    }
                                                    // obj[result.field] = Expresult;
                                                    if (!k.includes(result.field)) {
                                                        finelObj[result.field] = Expresult;
                                                    }
                                                    if (result.field.trim() == "idFound") {
                                                        //---- Krishna ----
                                                        let splitId = Expresult.split(',');
                                                        let idObj = {};
                                                        if (!(!(splitId.length % 2))) {
                                                            idObj = {
                                                                "preProcessId": util_1.isNullOrUndefined(splitId[0]) ? "" : splitId[0],
                                                                "afterPreprocessId": util_1.isNullOrUndefined(splitId[1]) ? "" : splitId[1],
                                                                "preFotPreProcessId": util_1.isNullOrUndefined(splitId[2]) ? "" : splitId[2],
                                                                "afterFotPreProcessId": util_1.isNullOrUndefined(splitId[3]) ? "" : splitId[3],
                                                                "concatId": util_1.isNullOrUndefined(splitId[splitId.length - 1]) ? "" : splitId[splitId.length - 1]
                                                            };
                                                        }
                                                        else {
                                                            idObj = {
                                                                "preProcessId": util_1.isNullOrUndefined(splitId[0]) ? "" : splitId[0],
                                                                "afterPreprocessId": util_1.isNullOrUndefined(splitId[1]) ? "" : splitId[1],
                                                                "preFotPreProcessId": util_1.isNullOrUndefined(splitId[2]) ? "" : splitId[2],
                                                                "afterFotPreProcessId": util_1.isNullOrUndefined(splitId[3]) ? "" : splitId[3],
                                                            };
                                                        }
                                                        return idObj;
                                                    }
                                                    if (result.field == "exitnow" && (Expresult == 'true' || Expresult == true)) {
                                                        return pdfData;
                                                    }
                                                    if (pdfData[index][result.field] === undefined) {
                                                        finelObj[result.field] = Expresult;
                                                        // re[result.field] = Expresult;
                                                    }
                                                    pdfData[index][result.field] = Expresult;
                                                    if (result.field == 'line') {
                                                        pdfData[index]['tagline'] = tagExpresult;
                                                    }
                                                    //   pdfData[index][result.field] = Expresult
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (ruleSetCount == ruleSet.length && isDataOperation == true) {
                                increment = increment - 1;
                                index = index - 1;
                            }
                        }
                    }
                    return pdfData;
                }
            }
            catch (error) {
                return error;
            }
        });
    }
    applyCustomRules(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let self = this;
                let keys = Object.keys(input);
                let values = Object.values(input);
                let eliminateKeys = ["prediction", "tableEnd", "tableMapping", "tableStart", "Error", "Exception"];
                let elmininateVal = [[], [], [], [], [], []];
                // keys.forEach((element,i) => {
                let obj = {};
                for (let index = 0; index < values.length; index++) {
                    if (typeof (values[index]) == 'string') {
                        values[index] = values[index].toString().replace(/\"/g, `'`);
                    }
                }
                keys.forEach((ele, i) => {
                    if (ele.toLowerCase() !== 'rulesset') {
                        if (Array.isArray(values[i]) && typeof values[i] == 'object') {
                            obj[ele] = JSON.stringify(values[i]);
                        }
                        else {
                            obj[ele] = values[i];
                        }
                    }
                });
                // });
                if (!util_1.isNullOrUndefined(obj) && !util_1.isNullOrUndefined(obj["obj"]) && Object.keys(obj["obj"]).length > 0) {
                    input['rulesSetValue'] = {};
                    for (let ob in obj["obj"]) {
                        if (eliminateKeys.indexOf(ob) > -1) {
                            elmininateVal[eliminateKeys.indexOf(ob)] = obj["obj"][ob];
                        }
                        else {
                            input['rulesSetValue'][ob] = obj["obj"][ob];
                        }
                    }
                    // console.log("<<<<<<-------- OBJ ----------->>>>>>>>", JSON.stringify(input['rulesSetValue']));
                }
                else {
                    input['rulesSetValue'] = JSON.parse(JSON.stringify(obj));
                }
                if (input['rulesSetValue'] && typeof input['rulesSetValue'] == 'object' && !Array.isArray(input['rulesSetValue'])) {
                    input['rulesSetValue']['inputId'] = {
                        'orgId': input.orgId,
                        'userId': input.userId,
                        'subscriberId': input.subscriberId,
                        'roleId': input.role,
                        'deptId': input.deptId
                    };
                }
                // input['rulesSetValue'] = JSON.parse(JSON.stringify(obj));
                let outputEval = yield self.evaluateRuleSet(input);
                console.log(outputEval);
                let outputKeys = Object.keys(outputEval);
                let outputValues = Object.values(outputEval);
                outputKeys.forEach((ele, i) => {
                    output[ele] = outputValues[i];
                });
                if (!util_1.isNullOrUndefined(obj) && !util_1.isNullOrUndefined(obj["obj"]) && Object.keys(obj["obj"]).length > 0) {
                    eliminateKeys.forEach((row, i) => {
                        if (!util_1.isNullOrUndefined(output[row]) && Array.isArray(output[row]) && !util_1.isNullOrUndefined(elmininateVal[i]) && Array.isArray(elmininateVal[i])) {
                            elmininateVal[i].forEach((ro) => {
                                output[row].push(ro);
                            });
                        }
                        else {
                            output[row] = elmininateVal[i];
                        }
                    });
                }
                // console.log("<<<<<<-------- Output ----------->>>>>>>>", JSON.stringify(output));
                elmininateVal = null;
                return { "message": "CustomRules Data is Succefully Extracted", status: 0, data: output };
            }
            catch (err) {
                console.log("<<<<<--------- ERROR in CustomRulesSet bot -------------->>>>>>", err);
                return { "message": "CustomRules Data is Null", status: 1, data: err };
            }
        });
    }
    applyCustomReport(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const self = this;
                let reportId = input.reportId;
                if (!reportId)
                    throw "ReportId is not present";
                let reportData = yield (db.collection('dynamicreportsqueries')).findById(reportId).lean();
                if (!reportData)
                    throw "Report is not present in DB.";
                let collection = reportData.table;
                let queryString = JSON.parse(reportData.queryString);
                let fields = reportData.tableReceivedData && reportData['tableReceivedData'][0] ? reportData['tableReceivedData'][0]['fields'] : [];
                let matchObj = {};
                for (let item of fields) {
                    if (input[item['dbName']] && item['dbName'] != 'orgId') {
                        matchObj[item['dbName']] = input[item['dbName']];
                    }
                }
                let match = {
                    $match: matchObj
                };
                queryString.unshift(match);
                console.log('<<<-------------Collection------------>>>', collection);
                console.log('<<<-------------Query----------------->>>\n', JSON.stringify(queryString));
                let finalData = yield (db.collection(collection)).aggregate(queryString).allowDiskUse(true);
                let displayMapping = fields.reduce((acc, obj) => {
                    acc[obj['dbName']] = obj['uiName'];
                    return acc;
                }, {});
                finalData.map(obj => self.renameKeys(obj, displayMapping));
                console.log(displayMapping, finalData.length);
                output['reportData'] = finalData;
                if ([true, "true"].includes(input.generateExcel)) {
                    finalData = finalData.length ? finalData : [Object.values(displayMapping).map(a => String(a)).reduce((acc, obj) => {
                            acc[obj] = null;
                            return acc;
                        }, {})];
                    let filePath = input.filePath ? input.filePath : `${config.path.replace(/\/$/, '')}/${collection}_${Date.now()}.xlsx`;
                    let sheetName = input.sheetName ? input.sheetName : collection;
                    let resPath = yield self.exportExcelPath(filePath, finalData, sheetName, Object.keys(finalData[0]));
                    console.log("File Generated------------->", resPath);
                    output['resPath'] = resPath;
                }
                return { "message": "CustomRules Data is Succefully Extracted", status: 0, data: output };
            }
            catch (err) {
                console.log("<<<<<--------- ERROR in CustomRulesSet bot -------------->>>>>>", err);
                return { "message": "CustomRules Data is Null", status: 1, data: err };
            }
        });
    }
    renameKeys(obj, newKeys) {
        return Object.keys(obj).reduce((acc, key) => {
            acc[newKeys[key] || key] = obj[key];
            return acc;
        }, {});
    }
    exportExcelPath(filePath, data, sheetName, headers) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log(sheetName, filePath, headers);
                if (!fs.existsSync(filePath)) {
                    console.log("Creating new Xlsx..");
                    let wb = XLSX.utils.book_new();
                    let ws = this.generateWorkSheet(data, headers);
                    XLSX.utils.book_append_sheet(wb, ws, sheetName);
                    yield XLSX.writeFile(wb, filePath);
                    return filePath;
                }
                else {
                    console.log("Updating current Xlsx..");
                    const existingWorkbook = XLSX.readFile(filePath);
                    const newWorkbook = XLSX.utils.book_new();
                    existingWorkbook.SheetNames.forEach(sheetName => {
                        const sheet = existingWorkbook.Sheets[sheetName];
                        XLSX.utils.book_append_sheet(newWorkbook, sheet, sheetName);
                    });
                    if (existingWorkbook.SheetNames.includes(sheetName)) {
                        sheetName = sheetName + '_' + Date.now();
                        console.log('Duplicate SheetName found------', sheetName);
                    }
                    let ws = this.generateWorkSheet(data, headers);
                    XLSX.utils.book_append_sheet(newWorkbook, ws, sheetName);
                    yield XLSX.writeFile(newWorkbook, filePath);
                    return filePath;
                }
            }
            catch (e) {
                console.log("Error---", e);
                return null;
            }
        });
    }
    generateWorkSheet(data, header) {
        try {
            let data_len;
            let my_data;
            let data_count;
            let wscols;
            my_data = Object.keys(data[0]);
            if (!util_1.isNullOrUndefined(my_data)) {
                my_data = [];
                header.forEach(element => {
                    if (element) {
                        my_data.push(element);
                    }
                });
            }
            data_count = my_data.length;
            data_len = data.length + 1;
            let ws = XLSX.utils.json_to_sheet(data, { header: my_data, skipHeader: false });
            let final_count_string;
            let j = 0;
            let k = 0;
            my_data.forEach((element, i) => {
                if (element) {
                    let val = 'A'.charCodeAt(0) + i;
                    if (val < 91) {
                        ws[(String.fromCharCode(val) + '1')].v = element;
                        final_count_string = String.fromCharCode(val);
                    }
                    else {
                        let val1 = 'A'.charCodeAt(0) + k;
                        let val2 = 'A'.charCodeAt(0) + j;
                        ws[(String.fromCharCode(val1, val2) + '1')].v = element;
                        final_count_string = String.fromCharCode(val1, val2);
                        if (j == 25) {
                            j = 0;
                            k++;
                        }
                        else {
                            j++;
                        }
                    }
                }
            });
            wscols = [];
            for (let i = 0; i <= data_count; i++) {
                wscols.push({ wch: 30 });
            }
            ws['!cols'] = wscols;
            ws['!ref'] = 'A1:' + final_count_string + data_len + '';
            ws['!margins'] = { left: 1.0, right: 1.0, top: 1.0, bottom: 1.0, header: 0.5, footer: 0.5 };
            ws['!merges'] = [XLSX.utils.decode_range('A1')];
            return ws;
        }
        catch (e) {
            let ws = XLSX.utils.json_to_sheet(data, { skipHeader: false });
            console.log("XLSX err -", e);
            return ws;
        }
    }
    EvaluateRuleOld(ruleSet, fields) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                fields = JSON.parse(JSON.stringify(fields));
                let forCriteria = JSON.parse(JSON.stringify(fields));
                let keyList = Object.keys(fields);
                console.log(" --- KEYLIST ---- ---   ", keyList);
                let finalResult = {};
                var Result = "";
                var Error = [];
                var Exception = [];
                var Success = [];
                // ruleSet.forEach(myrules => {
                for (const myrules of ruleSet) {
                    for (let i = 0; i < myrules.rules.length; i++) {
                        let matchCriteriaCount = 0;
                        let totalCriteria = 0;
                        totalCriteria = myrules.rules[i].rule.criteria.length;
                        // myrules.rules[i].rule.criteria.forEach( criteria => {
                        for (const op of keyList) {
                            if (forCriteria[op] == '' || util_1.isNullOrUndefined(forCriteria[op])) {
                                forCriteria[op] = '';
                            }
                        }
                        for (const criteria of myrules.rules[i].rule.criteria) {
                            if (criteria.value !== "") {
                                let expression = {
                                    Expression: criteria.value,
                                    value: forCriteria
                                };
                                let val = yield this.evaluateExpression(expression);
                                let self = this;
                                let isOutOfField = false;
                                if (keyList.indexOf(criteria.field) == -1) {
                                    expression = {
                                        Expression: criteria.field,
                                        value: forCriteria
                                    };
                                    forCriteria[criteria.field] = yield this.evaluateExpression(expression);
                                    isOutOfField = true;
                                }
                                if (val == "true") {
                                    val = true;
                                }
                                if (val == "false") {
                                    val = false;
                                }
                                if (forCriteria[criteria.field] == "true") {
                                    forCriteria[criteria.field] = true;
                                }
                                if (forCriteria[criteria.field] == "false") {
                                    forCriteria[criteria.field] = false;
                                }
                                if (self.operators[criteria.operator](forCriteria[criteria.field], val)) {
                                    matchCriteriaCount++;
                                }
                                if (isOutOfField) {
                                    delete forCriteria[criteria.field];
                                }
                            }
                            else {
                                totalCriteria = totalCriteria - 1;
                            }
                        }
                        if (matchCriteriaCount == totalCriteria) {
                            console.warn("<<<-------- Codition Matches -------->>>> ");
                            //     myrules.rules[i].rule.result.forEach( result=>{
                            //     if(result.value!==""){
                            //             let expression={
                            //             Expression:result.value,
                            //             value:fields
                            //              }
                            //              finalResult[result.field]= await this.evaluateExpression(expression)
                            //     }
                            // })
                            for (const result of myrules.rules[i].rule.result) {
                                if (result.value !== "") {
                                    let expression = {
                                        Expression: result.value,
                                        value: fields
                                    };
                                    let perviousResult = Result;
                                    finalResult[result.field] = yield this.evaluateExpression(expression);
                                    Result = finalResult[result.field];
                                    if (result.field == 'isError') {
                                        fields['error'] = [];
                                        Error.push(perviousResult);
                                        // Error.push("ONe");
                                        finalResult["error"] = Error;
                                    }
                                    else if (result.field == 'isException') {
                                        fields['Exception'] = [];
                                        Exception.push(perviousResult);
                                        finalResult['Exception'] = Exception;
                                    }
                                    else if (result.field == 'isSuccess') {
                                        fields['Success'] = [];
                                        Success.push(perviousResult);
                                        finalResult['Success'] = Success;
                                    }
                                }
                                if (!util_1.isNullOrUndefined(finalResult) && !util_1.isNullOrUndefined(Object.keys(finalResult)) && Object.keys(finalResult).length > 0) {
                                    for (let key in finalResult) {
                                        if (fields.hasOwnProperty(key)) {
                                            if (Array.isArray(finalResult[key]) || key == 'error' || key == 'Exception') {
                                                fields[key] = finalResult[key];
                                            }
                                            else {
                                                fields[key] = finalResult[key].toString();
                                            }
                                        }
                                    }
                                }
                            }
                            i = myrules.rules.length;
                            for (let key in finalResult) {
                                if (fields.hasOwnProperty(key)) {
                                    if (Array.isArray(finalResult[key]) || key == 'error' || key == 'Exception') {
                                        fields[key] = finalResult[key];
                                    }
                                    else if (util_1.isNullOrUndefined(finalResult[key])) {
                                        finalResult[key] = '';
                                    }
                                    else {
                                        fields[key] = finalResult[key].toString();
                                    }
                                }
                            }
                        }
                        for (const op of keyList) {
                            if (util_1.isNullOrUndefined(fields[op]) || fields[op] == '') {
                                forCriteria[op] = '';
                            }
                            else {
                                forCriteria[op] = fields[op];
                            }
                        }
                    }
                    for (const op of keyList) {
                        if (util_1.isNullOrUndefined(fields[op]) || fields[op] == '') {
                            forCriteria[op] = '';
                        }
                        else {
                            forCriteria[op] = fields[op];
                        }
                    }
                }
                console.log;
                return fields;
            }
            catch (error) {
                return error;
            }
        });
    }
    EvaluateRule(ruleSet, fields) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // fields = JSON.parse(JSON.stringify(fields));
                let forCriteria = JSON.parse(JSON.stringify(fields));
                let keyList = Object.keys(fields);
                // console.log(" --- KEYLIST ---- ---   ", keyList);
                let finalResult = {};
                let Result = "";
                let Error = [];
                let Exception = [];
                let Success = [];
                let fixedValues = ["true", "false"];
                let DocumentLevelError = [];
                let ErrorReview = [];
                // ruleSet.forEach(myrules => {
                for (const myrules of ruleSet) {
                    for (let i = 0; i < myrules.rules.length; i++) {
                        let matchCriteriaCount = 0;
                        let totalCriteria = 0;
                        totalCriteria = myrules.rules[i].rule.criteria.length;
                        // myrules.rules[i].rule.criteria.forEach( criteria => {
                        for (const op of keyList) {
                            if (util_1.isNullOrUndefined(forCriteria[op])) {
                                forCriteria[op] = '';
                            }
                        }
                        for (const criteria of myrules.rules[i].rule.criteria) {
                            if (criteria.value !== "") {
                                let expression = {
                                    Expression: criteria.value,
                                    value: forCriteria
                                };
                                let val;
                                if (fixedValues.includes(expression.Expression)) {
                                    val = expression.Expression;
                                }
                                else {
                                    val = yield this.evaluateExpression(expression);
                                }
                                let self = this;
                                let isOutOfField = false;
                                if (keyList.indexOf(criteria.field) == -1) {
                                    expression = {
                                        Expression: criteria.field,
                                        value: forCriteria
                                    };
                                    forCriteria[criteria.field] = yield this.evaluateExpression(expression);
                                    isOutOfField = true;
                                }
                                if (val == "true") {
                                    val = true;
                                }
                                if (val == "false") {
                                    val = false;
                                }
                                if (forCriteria[criteria.field] == "true") {
                                    forCriteria[criteria.field] = true;
                                }
                                if (forCriteria[criteria.field] == "false") {
                                    forCriteria[criteria.field] = false;
                                }
                                if (self.operators[criteria.operator](forCriteria[criteria.field], val)) {
                                    matchCriteriaCount++;
                                }
                                if (isOutOfField) {
                                    delete forCriteria[criteria.field];
                                }
                            }
                            else {
                                totalCriteria = totalCriteria - 1;
                            }
                        }
                        if (matchCriteriaCount == totalCriteria) {
                            console.warn("<<<-------- Codition Matches -------->>>> ");
                            //     myrules.rules[i].rule.result.forEach( result=>{
                            //     if(result.value!==""){
                            //             let expression={
                            //             Expression:result.value,
                            //             value:fields
                            //              }
                            //              finalResult[result.field]= await this.evaluateExpression(expression)
                            //     }
                            // })
                            for (const result of myrules.rules[i].rule.result) {
                                if (result.value !== "") {
                                    let expression = {
                                        Expression: result.value,
                                        value: fields
                                    };
                                    let perviousResult = Result;
                                    finalResult[result.field] = yield this.evaluateExpression(expression);
                                    if (result.field.includes('.')) {
                                        const keys = result.field.split('.');
                                        const results = finalResult[result.field];
                                        let current = fields;
                                        keys.forEach((key, index) => {
                                            if (index === keys.length - 1) {
                                                current[key] = results;
                                            }
                                            else {
                                                current[key] = current[key] || {};
                                                if (typeof (current[key]) == 'string') {
                                                    if (current[key].startsWith('[')) {
                                                        current[key] = JSON.parse(current[key]);
                                                    }
                                                }
                                                current = current[key];
                                            }
                                        });
                                    }
                                    Result = finalResult[result.field];
                                    if (result.field == 'isError') {
                                        fields['error'] = [];
                                        Error.push(perviousResult);
                                        // Error.push("ONe");
                                        finalResult["error"] = Error;
                                    }
                                    else if (result.field == 'isException') {
                                        fields['Exception'] = [];
                                        Exception.push(perviousResult);
                                        finalResult['Exception'] = Exception;
                                    }
                                    else if (result.field == 'isSuccess') {
                                        fields['Success'] = [];
                                        Success.push(perviousResult);
                                        finalResult['Success'] = Success;
                                    }
                                    else if (result.field == 'isDocumentLevel') {
                                        fields['DocumentLevelError'] = [];
                                        DocumentLevelError.push(perviousResult);
                                        finalResult['DocumentLevelError'] = DocumentLevelError;
                                    }
                                    else if (result.field == 'isErrorReview') {
                                        fields['ErrorReview'] = [];
                                        ErrorReview.push(perviousResult);
                                        finalResult['ErrorReview'] = ErrorReview;
                                    }
                                }
                                if (!util_1.isNullOrUndefined(finalResult) && !util_1.isNullOrUndefined(Object.keys(finalResult)) && Object.keys(finalResult).length > 0) {
                                    for (let key in finalResult) {
                                        if (fields.hasOwnProperty(key)) {
                                            if (Array.isArray(finalResult[key]) || typeof finalResult[key] == 'object' || key == 'error' || key == 'Exception' || key == 'DocumentLevelError' || key == 'ErrorReview') {
                                                fields[key] = finalResult[key];
                                            }
                                            else {
                                                fields[key] = finalResult[key].toString();
                                            }
                                        }
                                    }
                                }
                            }
                            i = myrules.rules.length;
                            for (let key in finalResult) {
                                if (fields.hasOwnProperty(key)) {
                                    if (Array.isArray(finalResult[key]) || typeof finalResult[key] == 'object' || key == 'error' || key == 'Exception' || key == 'DocumentLevelError' || key == 'ErrorReview') {
                                        fields[key] = finalResult[key];
                                    }
                                    else if (util_1.isNullOrUndefined(finalResult[key])) {
                                        finalResult[key] = '';
                                    }
                                    else {
                                        fields[key] = finalResult[key].toString();
                                    }
                                }
                            }
                        }
                        for (const op of keyList) {
                            if (util_1.isNullOrUndefined(fields[op]) || fields[op] == '') {
                                forCriteria[op] = '';
                            }
                            else {
                                forCriteria[op] = fields[op];
                            }
                        }
                    }
                    for (const op of keyList) {
                        if (util_1.isNullOrUndefined(fields[op]) || fields[op] == '') {
                            forCriteria[op] = '';
                        }
                        else {
                            forCriteria[op] = fields[op];
                        }
                    }
                }
                return fields;
            }
            catch (error) {
                return error;
            }
        });
    }
    evaluateRuleSetOld(input) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log(input.id, input.name);
                let resp = {};
                let ruleSetObject = {};
                if (!util_1.isNullOrUndefined(input) && !util_1.isNullOrUndefined(input.rulesSet)) {
                    ruleSetObject['data'] = [];
                    ruleSetObject['data'].push({ "rulesSet": input.rulesSet });
                }
                else {
                    ruleSetObject = yield this.RuleEngineService.getRuleSetObject(input.id, input.name);
                }
                if ((!util_1.isNullOrUndefined(input.rulesSetValue.preprocess) && input.rulesSetValue.preprocess) || (!util_1.isNullOrUndefined(input.rulesSetValue.preprocessAndEvaluate) && input.rulesSetValue.preprocessAndEvaluate) || input.rulesSetValue.IdentifyRuleSet) {
                    resp = yield this.EvaluateRulePDF(ruleSetObject['data'][0].rulesSet, input.rulesSetValue, input);
                    return resp;
                }
                if (!util_1.isNullOrUndefined(input.rulesSetValue)) {
                    let isArray = false;
                    let ObjKey = Object.keys(input.rulesSetValue);
                    for (let row of ObjKey) {
                        // ObjKey.forEach((row, i) => {
                        if (Array.isArray(input.rulesSetValue[row]) && typeof input.rulesSetValue[row] == 'object') {
                            isArray = true;
                            console.info("Inside Invoice Array");
                            let invoiceItems = JSON.parse(JSON.stringify(input.rulesSetValue[row]));
                            delete input.rulesSetValue[row];
                            for (let i = 0; i < invoiceItems.length; i++) {
                                let element = invoiceItems[i];
                                //if (!isNullOrUndefined(element) && typeof element != 'object') {
                                let tabFields = Object.keys(element);
                                tabFields.forEach((ele, j) => {
                                    if (!util_1.isNullOrUndefined(element[ele]) && !Array.isArray(element[ele]) && typeof element[ele] != 'object') {
                                        input.rulesSetValue[ele] = element[ele];
                                    }
                                });
                                input.rulesSetValue['count'] = i;
                                resp = yield this.EvaluateRule(ruleSetObject['data'][0].rulesSet, input.rulesSetValue);
                                console.info(" ---- RESP1 ------- ", JSON.parse(JSON.stringify(resp)));
                                let keys = Object.keys(resp);
                                for (const op of keys) {
                                    if (util_1.isNullOrUndefined(resp[op])) {
                                        resp[op] = "";
                                    }
                                }
                                resp = yield this.isErroFlag(resp);
                                tabFields.forEach((ele, j) => {
                                    if (!util_1.isNullOrUndefined(resp[ele]) && resp[ele] !== '' && !Array.isArray(resp[ele]) && typeof resp[ele] != 'object') {
                                        element[ele] = resp[ele];
                                    }
                                    ;
                                    let errObj = resp["error"];
                                    if (!util_1.isNullOrUndefined(resp["error"]) && errObj.length != 0) {
                                        errObj.forEach(item => {
                                            let key = Object.keys(item)[0];
                                            if (key === ele) {
                                                console.log(item);
                                                if (util_1.isNullOrUndefined(element["error"])) {
                                                    element["error"] = [].concat(item);
                                                }
                                                else {
                                                    let err = element["error"];
                                                    err = err.concat(item);
                                                    element["error"] = err;
                                                }
                                                console.log(element);
                                            }
                                        });
                                    }
                                });
                                invoiceItems[i] = JSON.parse(JSON.stringify(element));
                                //}
                                // console.info("invoiceItems[i]", invoiceItems[i])
                                // console.info("resp for resp", resp)
                            }
                            resp = yield this.EvaluateRule(ruleSetObject['data'][0].rulesSet, input.rulesSetValue);
                            let keys = Object.keys(resp);
                            for (const op of keys) {
                                if (util_1.isNullOrUndefined(resp[op])) {
                                    resp[op] = "";
                                }
                            }
                            resp = yield this.isErroFlag(resp);
                            resp[row] = invoiceItems;
                            console.info(" ---- RESP ------- ", JSON.parse(JSON.stringify(resp)));
                        }
                    }
                    ;
                    if (!isArray) {
                        console.info("OutSide Invoice Array");
                        let invoiceItems = !util_1.isNullOrUndefined(input.rulesSetValue["invoiceItems"]) ? input.rulesSetValue["invoiceItems"] : [];
                        delete input.rulesSetValue["invoiceItems"];
                        resp = yield this.EvaluateRule(ruleSetObject['data'][0].rulesSet, input.rulesSetValue);
                        if (!util_1.isNullOrUndefined(resp) && !util_1.isNullOrUndefined(resp["message"])) {
                            resp = input.rulesSetValue;
                        }
                        let keys = Object.keys(resp);
                        for (const op of keys) {
                            if (util_1.isNullOrUndefined(resp[op])) {
                                resp[op] = "";
                            }
                        }
                        resp = yield this.isErroFlag(resp);
                        resp["invoiceItems"] = !util_1.isNullOrUndefined(invoiceItems) && invoiceItems.length > 0 ? JSON.parse(JSON.stringify(invoiceItems)) : [];
                        console.info(" ---- RESP2 ------- ", JSON.parse(JSON.stringify(resp)));
                    }
                    return resp;
                }
                else {
                    let rulesSetValue = {};
                    input.variableList.forEach(element => {
                        rulesSetValue[element.label] = element.value;
                    });
                    console.log("Default Outside");
                    let resp = yield this.EvaluateRule(ruleSetObject['data'][0], rulesSetValue);
                    let keys = Object.keys(resp);
                    for (const op of keys) {
                        if (util_1.isNullOrUndefined(resp[op])) {
                            resp[op] = "";
                        }
                    }
                    resp = yield this.isErroFlag(resp);
                    return resp;
                }
            }
            catch (err) {
                return err;
            }
        });
    }
    evaluateRuleSet(input) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log(input.id);
                let resp = {};
                let ruleSetObject = {};
                if (!util_1.isNullOrUndefined(input) && !util_1.isNullOrUndefined(input.rulesSet)) {
                    ruleSetObject['data'] = [];
                    ruleSetObject['data'].push({ "rulesSet": input.rulesSet });
                }
                else {
                    ruleSetObject = yield this.RuleEngineService.getRuleSetObject(input.id, input.name);
                }
                if ((!util_1.isNullOrUndefined(input.rulesSetValue.preprocess) && input.rulesSetValue.preprocess) || (!util_1.isNullOrUndefined(input.rulesSetValue.preprocessAndEvaluate) && input.rulesSetValue.preprocessAndEvaluate) || input.rulesSetValue.IdentifyRuleSet) {
                    resp = yield this.EvaluateRulePDF(ruleSetObject['data'][0].rulesSet, input.rulesSetValue, input);
                    return resp;
                }
                if (!util_1.isNullOrUndefined(input.rulesSetValue)) {
                    let isArray = false;
                    let ObjKey = Object.keys(input.rulesSetValue);
                    if (!util_1.isNullOrUndefined(input.rulesSetValue['invoiceItems'])) {
                        input.rulesSetValue['invoiceItemsNew'] = JSON.stringify(input.rulesSetValue['invoiceItems']);
                        delete input.rulesSetValue['invoiceItems'];
                    }
                    for (let row of ObjKey) {
                        // ObjKey.forEach((row, i) => {
                        if (row == 'resArray') {
                            let temp = input.rulesSetValue[row];
                            try {
                                input.rulesSetValue[row] = JSON.parse(temp);
                            }
                            catch (e) {
                                input.rulesSetValue[row] = temp;
                            }
                        }
                        if (Array.isArray(input.rulesSetValue[row]) && row != 'resArray') {
                            // added this resArray key , bcoz for some cases have to iterate the array and apply rules on that
                            input.rulesSetValue[row] = JSON.stringify(input.rulesSetValue[row]);
                        }
                        if (Array.isArray(input.rulesSetValue[row]) && typeof input.rulesSetValue[row] == 'object') {
                            isArray = true;
                            console.info("Inside Invoice Array");
                            let invoiceItems = JSON.parse(JSON.stringify(input.rulesSetValue[row]));
                            delete input.rulesSetValue[row];
                            let invoiceObject = {};
                            invoiceObject = JSON.parse(JSON.stringify(input.rulesSetValue));
                            for (let i = 0; i < invoiceItems.length; i++) {
                                let element = invoiceItems[i];
                                //if (!isNullOrUndefined(element) && typeof element != 'object') {
                                let tabFields = Object.keys(element);
                                tabFields.forEach((ele, j) => {
                                    if (!util_1.isNullOrUndefined(element[ele]) && !Array.isArray(element[ele]) && typeof element[ele] != 'object') {
                                        input.rulesSetValue[ele] = element[ele];
                                    }
                                });
                                input.rulesSetValue['count'] = i;
                                resp = yield this.EvaluateRule(ruleSetObject['data'][0].rulesSet, input.rulesSetValue);
                                console.info(" ---- RESP1 ------- ", JSON.parse(JSON.stringify(resp)));
                                let keys = Object.keys(resp);
                                for (const op of keys) {
                                    if (util_1.isNullOrUndefined(resp[op])) {
                                        resp[op] = "";
                                    }
                                }
                                resp = yield this.isErroFlag(resp);
                                tabFields.forEach((ele, j) => {
                                    if (!util_1.isNullOrUndefined(resp[ele]) && resp[ele] !== '' && !Array.isArray(resp[ele]) && typeof resp[ele] != 'object') {
                                        element[ele] = resp[ele];
                                    }
                                    ;
                                });
                                invoiceItems[i] = JSON.parse(JSON.stringify(element));
                                //}
                                // console.info("invoiceItems[i]", invoiceItems[i])
                                // console.info("resp for resp", resp)
                            }
                            input.rulesSetValue = JSON.parse(JSON.stringify(invoiceObject));
                            resp = yield this.EvaluateRule(ruleSetObject['data'][0].rulesSet, input.rulesSetValue);
                            let keys = Object.keys(resp);
                            for (const op of keys) {
                                if (util_1.isNullOrUndefined(resp[op])) {
                                    resp[op] = "";
                                }
                            }
                            resp = yield this.isErroFlag(resp);
                            resp[row] = invoiceItems;
                            console.info(" ---- RESP ------- ", JSON.parse(JSON.stringify(resp)));
                        }
                    }
                    ;
                    if (!isArray) {
                        console.info("OutSide Invoice Array");
                        let invoiceItems = !util_1.isNullOrUndefined(input.rulesSetValue["invoiceItems"]) ? input.rulesSetValue["invoiceItems"] : [];
                        delete input.rulesSetValue["invoiceItems"];
                        resp = yield this.EvaluateRule(ruleSetObject['data'][0].rulesSet, input.rulesSetValue);
                        if (!util_1.isNullOrUndefined(resp) && !util_1.isNullOrUndefined(resp["message"])) {
                            resp = input.rulesSetValue;
                        }
                        let keys = Object.keys(resp);
                        for (const op of keys) {
                            if (util_1.isNullOrUndefined(resp[op])) {
                                resp[op] = "";
                            }
                        }
                        for (let row of keys) {
                            try {
                                resp[row] = JSON.parse(resp[row]);
                            }
                            catch (e) {
                            }
                        }
                        resp = yield this.isErroFlag(resp);
                        resp["invoiceItems"] = !util_1.isNullOrUndefined(invoiceItems) && invoiceItems.length > 0 ? JSON.parse(JSON.stringify(invoiceItems)) : [];
                        resp["invoiceItems"] = !util_1.isNullOrUndefined(resp['invoiceItemsNew']) && Array.isArray(resp['invoiceItemsNew']) && resp['invoiceItemsNew'].length > 0 ? JSON.parse(JSON.stringify(resp['invoiceItemsNew'])) : [];
                        // console.info(" ---- RESP2 ------- ", JSON.parse(JSON.stringify(resp)));
                    }
                    return resp;
                }
                else {
                    let rulesSetValue = {};
                    input.variableList.forEach(element => {
                        rulesSetValue[element.label] = element.value;
                    });
                    console.log("Default Outside");
                    let resp = yield this.EvaluateRule(ruleSetObject['data'][0], rulesSetValue);
                    let keys = Object.keys(resp);
                    for (const op of keys) {
                        if (util_1.isNullOrUndefined(resp[op])) {
                            resp[op] = "";
                        }
                    }
                    resp = yield this.isErroFlag(resp);
                    return resp;
                }
            }
            catch (err) {
                return err;
            }
        });
    }
    TapPOReconcilation(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    let mClient, db;
                    if (!util_1.isNullOrUndefined(input.mongodb_uri) && !util_1.isNullOrUndefined(input.dbname)) {
                        mClient = yield MongoClient.connect(input.mongodb_uri);
                        db = mClient.db(input.dbname);
                    }
                    //finding data using fileRefNum
                    let drivingArray, searchArray;
                    if (!util_1.isNullOrUndefined(input.doc_Type) && !util_1.isNullOrUndefined(input.referenceNumber)) {
                        drivingArray = yield db.collection(input.doc_Type).find({ referenceNumber: input.referenceNumber }).toArray();
                    }
                    drivingArray = drivingArray && drivingArray.length == 1 ? drivingArray[0] : {};
                    if (!util_1.isNullOrUndefined(input.masterCollection)) {
                        searchArray = yield db.collection(input.masterCollection).find().toArray();
                    }
                    console.log("-------Inside TapPOReconcilation---------");
                    console.log("Total Master Data :", searchArray.length);
                    if ((!util_1.isNullOrUndefined(drivingArray)) && (!util_1.isNullOrUndefined(searchArray))) {
                        if ((!util_1.isNullOrUndefined(input.drivingArray_equalMatchKeys)) && (!util_1.isNullOrUndefined(input.searchArray_equalMatchKeys)) && Array.isArray(drivingArray.invoiceItems)) {
                            // console.log(searchArray);  //PO table result
                            let invoice_equalmatchkeys = JSON.parse(input.drivingArray_equalMatchKeys);
                            let po_equalmatchkeys = JSON.parse(input.searchArray_equalMatchKeys);
                            let invoice_lessthanequalkeys = JSON.parse(input.drivingArray_lessthanequalMatchKeys);
                            let po_lessthanequalkeys = JSON.parse(input.searchArray_lessthanequalMatchKeys);
                            if (!util_1.isNullOrUndefined(drivingArray.PO_Number) && drivingArray.PO_Number !== '') {
                                for (let i = 0; i < drivingArray.invoiceItems.length; i++) {
                                    if (util_1.isNullOrUndefined(drivingArray.invoiceItems[i].Item_PO_Number)) {
                                        drivingArray.invoiceItems[i].Item_PO_Number = drivingArray.PO_Number;
                                    }
                                }
                            }
                            drivingArray.invoiceItems.forEach(element2 => {
                                console.log("element2-----------************", element2);
                                if (!util_1.isNullOrUndefined(element2)) {
                                    element2['error'] = [];
                                    let exactMatchArray = [];
                                    let partialMatchArray = [];
                                    let POmatched = false;
                                    for (const element1 of searchArray) {
                                        // let poLineMatch = false;
                                        let unitPriceMatch = false;
                                        let pendingAmountMatch = false;
                                        let pendingQuantityMatch = false;
                                        let pendingAmount = null;
                                        let pendingQuantity = null;
                                        if (!util_1.isNullOrUndefined(element2[invoice_equalmatchkeys[0]]) && (element2[invoice_equalmatchkeys[0]] != "")) {
                                            if (element2[invoice_equalmatchkeys[0]] == element1[po_equalmatchkeys[0]]) { //PO_NUMBER check
                                                console.log("LINE ITEM", element2);
                                                console.log("PO line item", element1);
                                                // if (!isNullOrUndefined(element2[invoice_equalmatchkeys[1]]) && (element2[invoice_equalmatchkeys[1]] != "") && element2[invoice_equalmatchkeys[1]] == element1[po_equalmatchkeys[1]]) { //PO_Line_No check
                                                //     poLineMatch = true;
                                                //     console.log(invoice_equalmatchkeys[1], po_equalmatchkeys[1]);
                                                //     console.log("PO line match");
                                                // }
                                                if (!util_1.isNullOrUndefined(element2[invoice_equalmatchkeys[1]]) && (element2[invoice_equalmatchkeys[1]] != "") && element2[invoice_equalmatchkeys[1]] == element1[po_equalmatchkeys[1]]) { //Unit_Price check
                                                    unitPriceMatch = true;
                                                    console.log(invoice_equalmatchkeys[1], po_equalmatchkeys[1]);
                                                    console.log("Unit price match");
                                                }
                                                pendingAmount = !isNaN(Number(element1[po_lessthanequalkeys[0]]) - Number(element1[po_lessthanequalkeys[1]])) ? Number(element1[po_lessthanequalkeys[0]]) - Number(element1[po_lessthanequalkeys[1]]) : -1;
                                                //PO_LINE_AMOUNT - INVOICE_LINE_AMOUNT
                                                console.log(element1);
                                                console.log(element1[po_lessthanequalkeys[0]] + " - " + element1[po_lessthanequalkeys[1]] + " = " + (Number(element1[po_lessthanequalkeys[0]]) - Number(element1[po_lessthanequalkeys[1]])));
                                                // console.log(po_lessthanequalkeys[0], po_lessthanequalkeys[1]);
                                                console.log("PendingAmount :", pendingAmount);
                                                console.log(element1[po_lessthanequalkeys[2]] + " - " + element1[po_lessthanequalkeys[3]] + " = " + (Number(element1[po_lessthanequalkeys[2]]) - Number(element1[po_lessthanequalkeys[3]])));
                                                pendingQuantity = !isNaN(Number(element1[po_lessthanequalkeys[2]]) - Number(element1[po_lessthanequalkeys[3]])) ? Number(element1[po_lessthanequalkeys[2]]) - Number(element1[po_lessthanequalkeys[3]]) : -1;
                                                //PO_QUANTITY - INVOICED_QUANTITY - QUANTITY_CANCELLED
                                                console.log("pendingQuantity", pendingQuantity);
                                                console.log(invoice_lessthanequalkeys[0] + " " + element2[invoice_lessthanequalkeys[0]]);
                                                console.log(invoice_lessthanequalkeys[1] + " " + element2[invoice_lessthanequalkeys[1]]);
                                                if (!util_1.isNullOrUndefined(element2[invoice_lessthanequalkeys[0]]) && ((Number(element2[invoice_lessthanequalkeys[0]]) <= pendingAmount) || (pendingAmount == 0 && Number(element2[invoice_lessthanequalkeys[0]]) == Number(element1[po_lessthanequalkeys[1]])))) { //line_total_amount check
                                                    pendingAmountMatch = true;
                                                    console.log("Pending Amount match");
                                                }
                                                if (!util_1.isNullOrUndefined(element2[invoice_lessthanequalkeys[1]]) && ((Number(element2[invoice_lessthanequalkeys[1]]) <= pendingQuantity) || (pendingQuantity == 0 && Number(element2[invoice_lessthanequalkeys[1]]) == Number(element1[po_lessthanequalkeys[3]])))) { //Quantity check
                                                    pendingQuantityMatch = true;
                                                    console.log("Pending Quantity match");
                                                }
                                                if (unitPriceMatch && pendingAmountMatch && pendingQuantityMatch) {
                                                    exactMatchArray.push(element1);
                                                    console.log("exact match found");
                                                }
                                                else if (unitPriceMatch || pendingAmountMatch || pendingQuantityMatch) {
                                                    partialMatchArray.push(element1);
                                                    console.log("partial match found");
                                                }
                                                else {
                                                    console.log("no PO match found");
                                                }
                                                POmatched = true;
                                            }
                                            else {
                                                console.log("PO NUMBER does not match");
                                            }
                                        }
                                        else {
                                            console.log("PO NUMBER is undefined or empty", element2[invoice_equalmatchkeys[0]]);
                                        }
                                    }
                                    if (POmatched) {
                                        if (exactMatchArray.length == 1) {
                                            drivingArray["POcheck"] = "true";
                                            element2["POcheck"] = "true";
                                            element2["Matched_PO_No"] = exactMatchArray[0]["PO_Number"] ? exactMatchArray[0]["PO_Number"] : '';
                                            // element2["PO_Line_No"] = exactMatchArray[0]["PO_Line_No"] ? exactMatchArray[0]["PO_Line_No"] : '';
                                            element2["PO Line Ref"] = exactMatchArray[0]["Item_Number"] ? exactMatchArray[0]["Item_Number"] : '';
                                            // element2["Matched_PO_Line_No"] = exactMatchArray[0]["Matched_PO_Line_No"] ? exactMatchArray[0]["Matched_PO_Line_No"] : '';
                                        }
                                        else if (partialMatchArray.length == 1) {
                                            console.log("inside second po if error", element2['error']);
                                            element2['error'].push({ "PO_NUMBER": "EX160 - POcheck Failed Due To PO Number is not Matched / Not Found" });
                                            console.log("inside second po if error", element2['error']);
                                            drivingArray['status'] = "Blocking";
                                        }
                                        else {
                                            element2["POcheck"] = "false";
                                            drivingArray["POcheck"] = "false";
                                            drivingArray['status'] = "Blocking";
                                        }
                                    }
                                    else {
                                        element2["POcheck"] = "false";
                                    }
                                    if (!util_1.isNullOrUndefined(element2["POcheck"]) && element2["POcheck"] == "false") {
                                        console.log("inside second po if error", element2['error']);
                                        element2['error'].push({ "PO_NUMBER": "EX160 - POcheck Failed Due To PO Number is not Matched / Not Found" });
                                        console.log("inside second po if error", element2['error']);
                                        drivingArray['status'] = "Blocking";
                                    }
                                    if (!util_1.isNullOrUndefined(input.PO_MandatoryCheck) && (input.PO_MandatoryCheck == true)) {
                                        console.log("inside second po if error", element2['error']);
                                        drivingArray['status'] = "Blocking";
                                    }
                                    console.log("error", element2['error']);
                                }
                            });
                            console.log(drivingArray);
                            output["POreconresult"] = drivingArray;
                            if (!util_1.isNullOrUndefined(input.doc_Type) && !util_1.isNullOrUndefined(input.referenceNumber) && !util_1.isNullOrUndefined(drivingArray.invoiceItems)) {
                                yield db.collection(input.doc_Type).update({ referenceNumber: input.referenceNumber }, { $set: { "invoiceItems": drivingArray.invoiceItems } });
                            }
                            resolve({ message: "reconcilation done scuccessfully", status: 0, data: output });
                        }
                    }
                }));
            }
            catch (e) {
                this.log.error("Failed invoice reconciliation " + e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    extractMaster(field, value, collectionName, fieldName, existingValue, type) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            //find parameters : field & value => collectionName => key to search for => exiting value of the key => type to find
            const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
            const db = yield mClient.db(env_2.env.dbConfig.dbname);
            let result;
            if (!util_1.isNullOrUndefined(collectionName)) {
                result = yield db.collection(collectionName).find({}).toArray();
            }
            else {
                result = [];
            }
            console.log(fieldName);
            console.log(existingValue);
            try {
                if (type == 'normal') {
                    if (!util_1.isNullOrUndefined(field) && !util_1.isNullOrUndefined(value)) {
                        let Data = result.filter(a => a[field] == value);
                        console.log(Data);
                        let unique = fieldName ? [...new Set(Data.map(item => item[fieldName]))] : [];
                        if (Data.length == 1 || unique.length == 1) {
                            Data = Data[0];
                            if (!util_1.isNullOrUndefined(fieldName) && !util_1.isNullOrUndefined(Data[fieldName])) {
                                return Data[fieldName];
                            }
                        }
                    }
                }
                else if (type == 'fuzzy') {
                    let stringSimilarity = require("string-similarity");
                    let datatoMatch = [];
                    let index = 0;
                    for (let i = 0; i < result.length; i++) {
                        if (!util_1.isNullOrUndefined(result[i][field[0]])) {
                            datatoMatch.push(result[i][field[0]]);
                            result[i]['index'] = index;
                            index++;
                        }
                    }
                    if (result.length >= 1 && !util_1.isNullOrUndefined(value[0]) && datatoMatch.length) {
                        let match = stringSimilarity.findBestMatch(value[0], datatoMatch);
                        console.log(`---------match ${field[0]}+':'+${value[0]}-------`);
                        console.log(match);
                        if (!util_1.isNullOrUndefined(match) && !util_1.isNullOrUndefined(match.ratings) && Array.isArray(match.ratings) && !util_1.isNullOrUndefined(match.bestMatch.rating) && match.bestMatch.rating > 0.6 && !util_1.isNullOrUndefined(match.bestMatchIndex)) {
                            let foundData = result.filter(a => a.index == match.bestMatchIndex);
                            foundData = foundData.length == 1 ? foundData[0] : {};
                            let rateIndex = 0;
                            match.ratings = match.ratings.filter(a => a.index = rateIndex++);
                            let similar = match.ratings.filter(a => a.rating > 0.6);
                            if (similar.length > 1) {
                                let recon = [];
                                for (let i = 0; i < similar.length; i++) {
                                    let res = result.filter(a => a.index == similar[i].index);
                                    res.length == 1 ? recon.push(res[0]) : '';
                                }
                                !util_1.isNullOrUndefined(value[1]);
                                {
                                    let foundData = recon.filter(a => a[field[1]] == value[1]);
                                    let unique = fieldName ? [...new Set(foundData.map(item => item[fieldName]))] : [];
                                    if (foundData.length == 1 || unique.length == 1) {
                                        foundData = foundData[0];
                                        if (!util_1.isNullOrUndefined(foundData[fieldName])) {
                                            return foundData[fieldName];
                                        }
                                    }
                                }
                                // let recontoMatch = []
                                // index=0;
                                // for(let i=0;i<recon.length;i++)
                                // {
                                //     if (!isNullOrUndefined(recon[i][field[1]])) {
                                //         recontoMatch.push(recon[i][field[1]])
                                //         recon[i]['index'] = index;
                                //         index++;
                                //      }
                                // }
                            }
                            else if (!util_1.isNullOrUndefined(foundData[fieldName])) {
                                return foundData[fieldName];
                            }
                        }
                    }
                }
                return existingValue ? existingValue : '';
            }
            catch (error) {
                console.log("extractMaster exception :", error);
                return '';
            }
        });
    }
    isErroFlag(resp) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!util_1.isNullOrUndefined(resp) && (!util_1.isNullOrUndefined(resp['error']) || !util_1.isNullOrUndefined(resp['Exception']) || !util_1.isNullOrUndefined(resp['Success']) || !util_1.isNullOrUndefined(resp['ErrorReview']))) {
                    let errorType = !util_1.isNullOrUndefined(resp['error']) && !util_1.isNullOrUndefined(resp['error'][0]) ? resp['error'][0] : false;
                    console.log("1 --- ------       ", typeof errorType);
                    if (!util_1.isNullOrUndefined(resp['error']) && resp['error'].length > 0 && Array.isArray(resp['error']) && typeof errorType == "string") {
                        console.log("2");
                        let errorList = yield errWarn_1.errWarn.find({ "category": "Error", "code": { $in: resp['error'] } }, { "code": 1.0, "field": 1.0, "description": 1.0 });
                        console.log("3");
                        let errWar = [];
                        errorList.forEach(warn => {
                            let err = {};
                            if (!util_1.isNullOrUndefined(warn['description'])) {
                                err[warn['field']] = warn['code'] + " - " + warn['description'];
                                errWar.push(err);
                            }
                        });
                        errorList = null;
                        console.log("3", errWar);
                        resp['error'] = errWar;
                    }
                    let ExceptionType = !util_1.isNullOrUndefined(resp['Exception']) && !util_1.isNullOrUndefined(resp['Exception'][0]) ? resp['Exception'][0] : false;
                    if (!util_1.isNullOrUndefined(resp['Exception']) && resp['Exception'].length > 0 && Array.isArray(resp['Exception']) && typeof ExceptionType == "string") {
                        let WarningList = yield errWarn_1.errWarn.find({ "category": "Warning", "code": { $in: resp['Exception'] } }, { "code": 1.0, "field": 1.0, "description": 1.0 });
                        let warnErr = [];
                        WarningList.forEach(warn => {
                            let err = {};
                            if (!util_1.isNullOrUndefined(warn['description'])) {
                                err[warn['field']] = warn['code'] + " - " + warn['description'];
                                warnErr.push(err);
                            }
                        });
                        WarningList = null;
                        resp['Exception'] = warnErr;
                    }
                    let SuccessType = !util_1.isNullOrUndefined(resp['Success']) && !util_1.isNullOrUndefined(resp['Success'][0]) ? resp['Success'][0] : false;
                    if (!util_1.isNullOrUndefined(resp['Success']) && resp['Success'].length > 0 && Array.isArray(resp['Success']) && typeof SuccessType == "string") {
                        let SuccessList = yield errWarn_1.errWarn.find({ "category": "Success", "code": { $in: resp['Success'] } }, { "code": 1.0, "field": 1.0, "description": 1.0 });
                        let SuccErr = [];
                        SuccessList.forEach(warn => {
                            let err = {};
                            if (!util_1.isNullOrUndefined(warn['description'])) {
                                err[warn['field']] = warn['code'] + " - " + warn['description'];
                                SuccErr.push(err);
                            }
                        });
                        SuccessList = null;
                        resp['Success'] = SuccErr;
                    }
                    let ErrorReviewType = !util_1.isNullOrUndefined(resp['ErrorReview']) && !util_1.isNullOrUndefined(resp['ErrorReview'][0]) ? resp['ErrorReview'][0] : false;
                    if (!util_1.isNullOrUndefined(resp['ErrorReview']) && resp['ErrorReview'].length > 0 && Array.isArray(resp['ErrorReview']) && typeof ErrorReviewType == "string") {
                        let ErrorReviewList = yield errWarn_1.errWarn.find({ "category": "ErrorReview", "code": { $in: resp['ErrorReview'] } }, { "code": 1.0, "field": 1.0, "description": 1.0 });
                        let SuccErr = [];
                        ErrorReviewList.forEach(warn => {
                            let err = {};
                            if (!util_1.isNullOrUndefined(warn['description'])) {
                                err[warn['field']] = warn['code'] + " - " + warn['description'];
                                SuccErr.push(err);
                            }
                        });
                        ErrorReviewList = null;
                        resp['ErrorReview'] = SuccErr;
                    }
                    let DocumentLevelErrorType = !util_1.isNullOrUndefined(resp['DocumentLevelError']) && !util_1.isNullOrUndefined(resp['DocumentLevelError'][0]) ? resp['DocumentLevelError'][0] : false;
                    if (!util_1.isNullOrUndefined(resp['DocumentLevelError']) && resp['DocumentLevelError'].length > 0 && Array.isArray(resp['DocumentLevelError']) && typeof DocumentLevelErrorType == "string") {
                        let DocumentLevelErrorList = yield errWarn_1.errWarn.find({ "category": "DocumentLevelError", "code": { $in: resp['DocumentLevelError'] } }, { "code": 1.0, "field": 1.0, "description": 1.0 });
                        let DocErr = [];
                        DocumentLevelErrorList.forEach(warn => {
                            let err = {};
                            if (!util_1.isNullOrUndefined(warn['description'])) {
                                err[warn['field']] = warn['code'] + " - " + warn['description'];
                                DocErr.push(err);
                            }
                        });
                        DocumentLevelErrorList = null;
                        resp['DocumentLevelError'] = DocErr;
                    }
                    else {
                        resp['DocumentLevelError'] = [];
                    }
                }
                console.log("4");
                return resp;
            }
            catch (err) {
                console.log(err);
                return err;
            }
        });
    }
    dateFormat(data, pattern) {
        try {
            let result = data.replace(pattern);
            return result;
        }
        catch (error) {
            return error["message"];
        }
    }
    //     try {
    //         let result = data.replace(pattern);
    //         return result
    //     } catch (error) {
    //         return error.message
    //     }
    // }
    innerLookUP(data, tableName, match, value, project, field) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let val = [];
                let temp;
                let finalMatch = [];
                let finalValue = [];
                let finalProject = [];
                let matchNew = match.replace("[", "").replace("]", "").split(",");
                let valueNew = value.replace("[", "").replace("]", "").split(",");
                let newProject = project.replace("[", " ").replace("]", " ").trim().split(",");
                let finalData = [];
                // let tempObj={};
                // let count=0;
                for (const z of matchNew) {
                    if (z.length != z.replace("'", "").length) {
                        temp = z.replace("'", "").replace("'", "").substring(0, z.replace("'", "").replace("'", "").length);
                        finalMatch.push(temp);
                    }
                    else {
                        finalMatch.push(z);
                    }
                }
                for (const z of valueNew) {
                    if (z.length != z.replace("'", "").length) {
                        temp = z.replace("'", "").replace("'", "").substring(0, z.replace("'", "").replace("'", "").length);
                        finalValue.push(temp);
                    }
                    else {
                        finalValue.push(z);
                    }
                }
                for (const z of newProject) {
                    temp = z.replace("'", "").replace("'", "");
                    finalProject.push(temp);
                }
                for (const i of data) {
                    val = [];
                    for (const x of finalValue) {
                        if (i[x] != undefined) {
                            val.push(i[x]);
                        }
                        else if (field[x] != undefined) {
                            val.push(field[x]);
                        }
                        else {
                            console.log("match ignored");
                        }
                    }
                    let mydata = yield this.fuzzylookUp(tableName, finalMatch, val, finalProject, 0, 1, 0, 0, 90); //considering only first match 0 to avoid project match
                    if (mydata != -1) {
                        // mydata=mydata.split(",")
                        // count=0;
                        // tempObj=[];
                        // for(const y of finalProject){
                        //     tempObj[y]=mydata[count]
                        //     count++;
                        // }
                        //   finalData.push(tempObj)
                        //*********************************UnComment this if lookup is used********************************** */
                        // //  await delete mydata[0]._id;
                        //    for(const t of Object.keys(mydata[0])){
                        //       i[t]=mydata[0][t]
                        //   }
                        //****************************************betweeen this all*********************************************** */
                        //   ********************is for the this.fuzzylookUp******************************?
                        for (const t of Object.keys(mydata)) {
                            i[t] = mydata[t];
                        }
                        finalData.push(i);
                    }
                    else {
                        finalData.push(i);
                    }
                }
                return finalData;
            }
            catch (error) {
                return error["message"];
            }
        });
    }
    convertDate(date, format) {
        let data = moment(date).format(format);
        return data;
    }
    convertDateForNextMonth(date) {
        let nextMonthDate = moment(date, "DD-MMM-YYYY")
            .add(1, 'months')
            .format('ll');
        let final = moment(nextMonthDate, 'll').set('date', 1).format('ll');
        return final;
    }
    removeCharater(str) {
        if (typeof str !== 'string') {
            str = str.toString();
        }
        let extra = ["/", "-", "?", "$"];
        let removeCharacter = [">", ">=", "[", "{", ")"];
        let secondaryCharater = ["<", "<=", "]", "}", "("];
        removeCharacter.forEach((r, i) => {
            if (str.includes(r) && str.includes(secondaryCharater[i])) {
                return str;
            }
            else {
                let one = new RegExp('[\\' + r + ']', 'g');
                let two = new RegExp('[\\' + secondaryCharater[i] + ']', 'g');
                str = str.replace(one, '').replace(two, '');
                return str;
            }
        });
        extra.forEach((r, i) => {
            if (str.includes(r)) {
                let one = new RegExp('[\\' + r + ']', 'g');
                str = str.replace(one, '');
                return str;
            }
            else {
                return str;
            }
        });
        return str;
    }
    myFunDemo(a, b) {
        console.log(a, " --- ", b);
        return a + b;
    }
    getFileNameWithoutExt(filePath) {
        let fileNameWithExtension = filePath.split('/').pop();
        let fileNameWithoutExtension = fileNameWithExtension.replace(/\.[^/.]+$/, "");
        console.log(">>>>>>>>>>>>>>>>>>>>>>>>>>>>");
        console.log("File Name extracted:" + fileNameWithoutExtension);
        console.log(">>>>>>>>>>>>>>>>>>>>>>>>>>>>");
        let parts = fileNameWithoutExtension.split('_');
        console.log(parts);
        let result = parts.slice(2).join('_');
        console.log(result);
        return result;
    }
    dateFormatter(line, option, dateadd, dateunit) {
        console.log("inside date formatter");
        let month;
        let year;
        let day;
        let date;
        let months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        let shortcutmonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        if (option == 1) {
            line = line.toUpperCase();
            for (let m = 0; m < months.length; m++) {
                if (line.toUpperCase().includes(months[m].toUpperCase())) {
                    line = line.replace(months[m], '');
                    month = m;
                    break;
                }
                if (line.toUpperCase().includes(shortcutmonths[m].toUpperCase())) {
                    line = line.replace(shortcutmonths[m], '');
                    month = m;
                    break;
                }
            }
            year = line.match(/[0-9]{4}/)[0];
            line = line.replace(year, '');
            day = line.match(/[0-9]{1,2}/)[0];
            date = day + '-' + months[month] + '-' + year;
            return date;
        }
        else if (option == 2) {
            date = new Date(line);
            if (dateunit.toUpperCase() == 'YEAR' || dateunit.toUpperCase() == 'YEARS') {
                date.setFullYear(date.getFullYear() + Number(dateadd));
            }
            else if (dateunit.toUpperCase() == 'MONTH' || dateunit.toUpperCase() == 'MONTHS') {
                date.setMonth(date.getMonth() + Number(dateadd));
            }
            else if (dateunit.toUpperCase() == 'DAY' || dateunit.toUpperCase() == 'DAYS') {
                date.setDate(date.getDate() + Number(dateadd));
            }
            let finaldate = date.getDate() + '-' + months[date.getMonth()] + '-' + date.getFullYear();
            return finaldate;
        }
    }
    evaluateExpressionOld(expression) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let result;
                let MyExpression = expression.Expression;
                MyExpression = expression.Expression.replace("this.", "");
                //Register Newly Created function here
                // let j = 0;
                let myNewFunction = ["isNullOrUndefined", "!isNullOrUndefined", "tostring", "findQueryRegex", "findAndUpdateManyQuery", "findAndUpdateQuery", "split", "evaluateOrganization", 'evaluateBranch', 'lookUp', 'lookUpCount', 'fuzzylookUp', "avg", "median", "mean", "sum", "count", "range", "isDate", "date", "digitLengthNew", "digitLength", "includeAnyOf", "alternateData", "noticeExclusion", "getData", "getContentEnd", "createCustomTable", "replaceAll", "convertToTitleCase", "NthWord", "roman_to_Int", "isRoman", "firstCharUpperCase", "evaluateDiscrepency", "evaluateParentOrg", "NthWord", "oracleLookUp", "oracleLookUpLength", "checkLoadBalance", "regexMatch", "PONumberExtraction", "removeCharater", "convertDate", "convertDoubleToSingle", "isEmptyCheck", "!isEmptyCheck", "testingfuzzy", "fuzzyMatch", "convertDateForNextMonth", "myFunDemo", "extractMaster", "PUSH", "dateFormatter", "getStartDate", "getEndDate", "getAssginOldBotDetails", "leastLoadedRole", "toStringForGroupBy", "IfNull", "toInt", "arrayElemAt", "push", "SumForGroupBy", "slice", "add", "sumForProject", "firstForgroupBy", "SumForGroupByWithVariable", "count", "ErrorHandlingSTC"];
                let splitrCharacter = ["(", ")", ",", "+", "-", "/", "*", "%", ".", "[", "]", "{", "}", "^", "?", ":", "=", "|", "||", "&", ">", "<"];
                let operator = [":", "?", "+", "-", "/", "*", ">", "<", "!", ">=", "<=", "%", "==", "===", "^", "|", "&", "(", ")", ".length"];
                let firstString = "";
                let i = 0;
                let addColumn = 0;
                let currentString = "";
                let secondString = "";
                let tempFirstString = "";
                let isCotesFound = false;
                let executebleStatement = false;
                while (i < MyExpression.length) {
                    currentString = "";
                    while (splitrCharacter.indexOf(MyExpression.charAt(i)) == -1 && i < MyExpression.length) {
                        currentString = currentString + MyExpression.charAt(i);
                        i++;
                    }
                    // if (currentString == "dateFormat") {
                    //     let date = MyExpression.substring(i + 2, MyExpression.indexOf(",") - 1)
                    //     let dataValue = expression.value[date]
                    //     let outPut = await this.dateFormat(dataValue, MyExpression.substring(MyExpression.indexOf(",") + 2, MyExpression.length))
                    //     return outPut;
                    // }
                    if (currentString == "isNullOrUndefined") {
                        let data = MyExpression.substring(MyExpression.indexOf("(") + 1, MyExpression.indexOf(")"));
                        return this.isNullOrUndefined(data, expression.value);
                    }
                    if (currentString == "isEmptyCheck") {
                        let data = MyExpression.substring(MyExpression.indexOf("isEmptyCheck") + 13, MyExpression.indexOf(")"));
                        return this.isEmptyCheck(data, expression["value"]);
                    }
                    if (currentString == "PUSH") {
                        let arr = MyExpression.substring(MyExpression.indexOf('PUSH') + 5, MyExpression.indexOf(','));
                        if (!util_1.isNullOrUndefined(expression.value[arr])) {
                            arr = expression.value[arr];
                        }
                        let value = MyExpression.substring(MyExpression.indexOf(',') + 1, MyExpression.length - 1);
                        let obj = JSON.parse(JSON.stringify(expression.value));
                        let s1 = '';
                        for (let key in obj) {
                            // if (typeof obj[key] !== 'object' && value.includes(key)) {
                            //     if (typeof obj[key] == 'string') {
                            //         s1 = (s1 == '') ? key + '=' + `'${obj[key]}'` : s1 + ',' + key + '=' + `'${obj[key]}'`;
                            //     } else {
                            //         s1 = (s1 == '') ? key + '=' + obj[key] : s1 + ',' + key + '=' + obj[key];
                            //     }
                            // }
                            if (value.includes(':' + key) && (value.includes(key + ',') || value.includes(key + '}'))) {
                                value = value.split(':' + key).join(':' + JSON.stringify(obj[key]));
                            }
                        }
                        value = (s1 == '') ? value : s1 + ',' + value;
                        let value1;
                        try {
                            value1 = yield new Promise((resolve, reject) => {
                                resolve(eval(value));
                            });
                            console.log("value of =========" + JSON.stringify(value1));
                        }
                        catch (err) {
                            console.log("eval error ==========" + err);
                            value1 = null;
                        }
                        return this.PUSH(arr, value1);
                    }
                    if (currentString == "innerLookUP") { //innerLookUP(invoiceItems,tappoline,['PO_Quantity','PO_Number'],['PO_UOM','PO_Quantity'])",
                        let ind1 = MyExpression.indexOf(",") + 1;
                        let ind2 = MyExpression.indexOf("]") + 1;
                        let tableName = MyExpression.substring(ind1, MyExpression.indexOf("[") - 1);
                        let data = MyExpression.substring(i + 1, ind1 - 1);
                        let match = MyExpression.substring(MyExpression.indexOf("["), MyExpression.indexOf("]") + 1);
                        // let x=MyExpression.indexOf(MyExpression.indexOf("]")+1,"]");
                        // x
                        let val = MyExpression.substring(ind2 + 1, MyExpression.split("]", 2).join("]").length + 1);
                        // let project = MyExpression.substring(ind2+1,MyExpression.indexOf(")"))
                        // let projectArry = MyExpression.split(",")
                        // let project= projectArry[projectArry.length-1]
                        let project = MyExpression.substring(MyExpression.split("]", 2).join("]").length + 2, MyExpression.indexOf(")"));
                        let dataValue = expression.value[data];
                        let outPut = yield this.innerLookUP(dataValue, tableName, match, val, project, expression.value);
                        return outPut;
                    }
                    if (currentString == "") {
                        i++;
                    }
                    if (!this.findMe(currentString, myNewFunction) && currentString !== "") { //if expression and inbuild function
                        addColumn = 0;
                        i = i - currentString.length;
                        if (util_1.isNullOrUndefined(expression.value[currentString]) || expression.value[currentString].toString().includes("[native code]")) { //if value of the current string undefined or is not a native function
                            let myStr = currentString;
                            let cotes = "\'";
                            let temp = myStr.split(cotes).join("");
                            cotes = "\"";
                            temp = myStr.split(cotes).join("");
                            if (!util_1.isNullOrUndefined(temp) && isNaN(Number(temp)) === false) {
                                if (currentString.trim().length > 0) {
                                    firstString = MyExpression.substring(0, i) + currentString;
                                    isCotesFound = true;
                                }
                                else {
                                    firstString = MyExpression.substring(0, i) + "";
                                }
                            }
                            else {
                                firstString = MyExpression.substring(0, i) + currentString;
                            }
                        }
                        else {
                            if (!util_1.isNullOrUndefined(expression.value[currentString]) && isNaN(expression.value[currentString]) === false) { //if variable name is numeric
                                firstString = MyExpression.substring(0, i) + expression.value[currentString];
                            }
                            else {
                                if (!util_1.isNullOrUndefined(expression.value[currentString]) && isNaN(Number(expression.value[currentString])) === false) { //if variable value is numeric
                                    tempFirstString = firstString;
                                    firstString = MyExpression.substring(0, i) + expression.value[currentString];
                                    addColumn = 0;
                                    if (MyExpression[tempFirstString.length + 2] === "." || MyExpression[i + currentString.length]) {
                                        firstString = MyExpression.substring(0, i) + '"' + expression.value[currentString] + '"';
                                        addColumn = 2;
                                    }
                                    else {
                                        if (MyExpression[currentString.length] === ".") {
                                            firstString = '"' + firstString + '"';
                                            addColumn = 2;
                                        }
                                    }
                                }
                                else {
                                    if (!util_1.isNullOrUndefined(expression.value[currentString]) && !Array.isArray(expression.value[currentString]) && expression.value[currentString].charAt(expression.value[currentString].length - 1) !== ']') {
                                        firstString = MyExpression.substring(0, i) + '"' + expression.value[currentString] + '"'; //if variable value is string
                                        addColumn = 2;
                                    }
                                    else {
                                        firstString = MyExpression.substring(0, i) + expression.value[currentString]; //if variable value is string
                                        addColumn = 0;
                                    }
                                }
                            }
                        }
                        if (isCotesFound) { //remove this if else if successfully tested
                            i = i + currentString.length;
                            //i = i + temp.length;
                        }
                        else {
                            i = i + currentString.length;
                        }
                        secondString = MyExpression.substring(i);
                        i++;
                        // if(secondString[0]==="."){
                        //     firstString='"'+firstString+'"'
                        //     i=i+2;
                        //     }
                        MyExpression = firstString + secondString;
                        if (!util_1.isNullOrUndefined(expression.value[currentString]) && expression.value[currentString].toString().includes("[native code]") == false) {
                            if (!isNaN(expression.value[currentString])) {
                                let numberLength = expression.value[currentString].toString().length;
                                i = i + numberLength - currentString.length + addColumn;
                            }
                            else {
                                i = i + expression.value[currentString].length - currentString.length + addColumn;
                            }
                        }
                    }
                    else {
                        if (currentString !== "") {
                            i = i - currentString.length - 1;
                            if (MyExpression.charAt(i + 1) === '!') { //to handle not operator for the custome function
                                firstString = MyExpression.substring(0, i + 1) + "!this.";
                                secondString = MyExpression.substring(i + 2);
                                i = i + 6 + currentString.length + 1;
                            }
                            else {
                                firstString = MyExpression.substring(0, i + 1) + "this.";
                                secondString = MyExpression.substring(i + 1);
                                i = i + 5 + currentString.length + 1;
                            }
                            MyExpression = firstString + secondString;
                        }
                    }
                }
                operator.forEach(op => {
                    if (!executebleStatement) {
                        if (MyExpression.includes(op)) {
                            executebleStatement = true;
                        }
                    }
                });
                if (executebleStatement) {
                    MyExpression = firstString + secondString;
                    // MyExpression=MyExpression.replace("this.","")
                    // result = new Function("return " + MyExpression)()
                    if (!MyExpression.includes("this.")) {
                        result = yield new Function("return " + MyExpression)();
                        return result;
                    }
                    else {
                        console.log(" -- BEFORE PROMIS FUNC. ---");
                        return result = yield new Promise((resolve, reject) => {
                            console.log(" -- BEFORE EVAL FUNC. ---      ------        ", MyExpression);
                            try {
                                // Safely execute eval
                                resolve(eval(MyExpression));
                            }
                            catch (error) {
                                // Reject the promise with the error
                                reject(error);
                            }
                        });
                    }
                }
                else {
                    MyExpression = MyExpression.replace('"', '');
                    MyExpression = MyExpression.replace(/"([^"]*)$/, '$1');
                    console.log("myExpression ELSE =======>>>>  ", MyExpression);
                    result = MyExpression;
                    return result;
                }
                if (typeof result === "object" && !util_1.isNullOrUndefined(expression.value['isObject'])) {
                    return JSON.stringify(result);
                }
                console.log("FinalREsult =====>>>>>>----111111------>>>>>>>> ", result);
                return result;
            }
            catch (err) {
                console.log("error", err);
                return err["message"];
            }
        });
    }
    deleteDataBeforeUpdatedAt(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!util_1.isNullOrUndefined(input) && input !== "") {
                    let collectionNames = typeof (input.collectionNames) == 'string' ? JSON.parse(input.collectionNames) : input.collectionNames;
                    const targetDate = new Date(input.targetDate);
                    // Set the time of targetDate to the start of the day (00:00:00)
                    targetDate.setHours(0, 0, 0, 0);
                    for (const collectionName of collectionNames) {
                        const result = yield db.collection(collectionName).deleteMany({
                            updatedAt: {
                                $exists: true,
                                $lt: targetDate
                            }
                        });
                        console.log(`Deleted ${result.deletedCount} documents from ${collectionName}`);
                    }
                    return { message: "Process successfully completed", status: 0, data: output };
                }
                else {
                    return { message: "Input data is null", status: 1, data: output };
                }
            }
            catch (e) {
                this.log.error("Error in deleteDataBeforeUpdatedAt" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    evaluateExpression(expression) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let result;
                let MyExpression = expression.Expression;
                MyExpression = expression.Expression.replace("this.", "");
                //Register Newly Created function here
                // let j = 0;
                let myNewFunction = ["isNullOrUndefined", "!isNullOrUndefined", "tostring", "findQueryRegex", "Split", "getUserDetails", "reverseString", "evaluateOrganization", 'evaluateBranch', 'lookUp', 'lookUpCount', 'gstInFormatter', 'checkFinancialYear', 'getOrgData', 'getOrgAddress', 'fuzzyMatchStr', 'getStateinIndiabyAddr', 'getStateinIndia', 'orderStringMatch', 'stringCompare', 'fuzzylookUp', 'sortItems', 'identifyGroup', "avg", "median", "mean", "sum", "count", "range", "isDate", "date", "digitLengthNew", "digitLength", "includeAnyOf", "alternateData", "noticeExclusion", "getData", "getContentEnd", "createCustomTable", "replaceAll", "convertToTitleCase", "NthWord", "roman_to_Int", "isRoman", "firstCharUpperCase", "evaluateDiscrepency", "evaluateParentOrg", "NthWord", "oracleLookUp", "oracleLookUpLength", "checkLoadBalance", "regexMatch", "PONumberExtraction", "removeCharater", "convertDate", "convertDateNew", "convertDoubleToSingle", "isEmptyCheck", "!isEmptyCheck", "testingfuzzy", "fuzzyMatch", "convertDateForNextMonth", "myFunDemo", "extractMaster", "getAssginOldBotDetails", "leastLoadedRole", "updateSlaInBot", "ErrorHandlingSTC", "typeIdentificationPharma", "checkIfHasBlankPage", "lookupHeaderFeildDataInJson", "sendExcelDatatoInvoiceViewFeild", "ramcoMatchData", "DateBeforeWordRemove", "sumofGSTamt", "Generate15DigitNumber", "findQuery", "findQuerywithObj", "insertQuery", "merge_array", "findAndUpdateManyQuery", "findAndUpdateQuery", "formatDateHrs", "assignBotByUser", "removePatternsFromString", "findReviewerAndAssign", "sh", "arrFilter", "generateStorylines", "generateVideoScript", "replacePlaceholders", "convertToSafeSnakeCase", "setNotifyUser", "generateTargetAudience", "callopenAI", "callgenAI", "fetchWeatherData", "toObjectId", "importToTallyRemote", "syncLedgerTallyRemote"];
                let splitrCharacter = ["(", ")", ",", "+", "-", "/", "*", "%", ".", "[", "]", "{", "}", "^", "?", ":", "=", "|", "||", "&", ">", "<"];
                let operator = [":", "?", "+", "-", "/", "*", ">", "<", "!", ">=", "<=", "%", "==", "===", "^", "|", "&", "(", ")", ".length", "`"];
                let firstString = "";
                let i = 0;
                let addColumn = 0;
                let currentString = "";
                let secondString = "";
                let tempFirstString = "";
                let isCotesFound = false;
                let executebleStatement = false;
                while (i < MyExpression.length) {
                    currentString = "";
                    while (splitrCharacter.indexOf(MyExpression.charAt(i)) == -1 && i < MyExpression.length) {
                        currentString = currentString + MyExpression.charAt(i);
                        i++;
                    }
                    // if (currentString == "dateFormat") {
                    //     let date = MyExpression.substring(i + 2, MyExpression.indexOf(",") - 1)
                    //     let dataValue = expression.value[date]
                    //     let outPut = await this.dateFormat(dataValue, MyExpression.substring(MyExpression.indexOf(",") + 2, MyExpression.length))
                    //     return outPut;
                    // }
                    if (currentString == "isEmptyCheck") {
                        let data = MyExpression.substring(MyExpression.indexOf("isEmptyCheck") + 13, MyExpression.indexOf(")"));
                        return this.isEmptyCheck(data, expression["value"]);
                    }
                    if (currentString == "innerLookUP") { //innerLookUP(invoiceItems,tappoline,['PO_Quantity','PO_Number'],['PO_UOM','PO_Quantity'])",
                        let ind1 = MyExpression.indexOf(",") + 1;
                        let ind2 = MyExpression.indexOf("]") + 1;
                        let tableName = MyExpression.substring(ind1, MyExpression.indexOf("[") - 1);
                        let data = MyExpression.substring(i + 1, ind1 - 1);
                        let match = MyExpression.substring(MyExpression.indexOf("["), MyExpression.indexOf("]") + 1);
                        // let x=MyExpression.indexOf(MyExpression.indexOf("]")+1,"]");
                        // x
                        let val = MyExpression.substring(ind2 + 1, MyExpression.split("]", 2).join("]").length + 1);
                        // let project = MyExpression.substring(ind2+1,MyExpression.indexOf(")"))
                        // let projectArry = MyExpression.split(",")
                        // let project= projectArry[projectArry.length-1]
                        let project = MyExpression.substring(MyExpression.split("]", 2).join("]").length + 2, MyExpression.indexOf(")"));
                        let dataValue = expression.value[data];
                        let outPut = yield this.innerLookUP(dataValue, tableName, match, val, project, expression.value);
                        return outPut;
                    }
                    if (currentString == "") {
                        i++;
                    }
                    if (!this.findMe(currentString, myNewFunction) && currentString !== "") { //if expression and inbuild function
                        addColumn = 0;
                        i = i - currentString.length;
                        if (util_1.isNullOrUndefined(expression.value[currentString]) || expression.value[currentString].toString().includes("[native code]")) { //if value of the current string undefined or is not a native function
                            let myStr = currentString;
                            let cotes = "\'";
                            let temp = myStr.split(cotes).join("");
                            cotes = "\"";
                            temp = myStr.split(cotes).join("");
                            if (!util_1.isNullOrUndefined(temp) && isNaN(Number(temp)) === false) {
                                if (currentString.trim().length > 0) {
                                    firstString = MyExpression.substring(0, i) + currentString;
                                    isCotesFound = true;
                                }
                                else {
                                    firstString = MyExpression.substring(0, i) + "";
                                }
                            }
                            else {
                                firstString = MyExpression.substring(0, i) + currentString;
                            }
                        }
                        else {
                            if (!util_1.isNullOrUndefined(expression.value[currentString]) && expression.value[currentString] === '') {
                                expression.value[currentString] = "''";
                            }
                            if (!util_1.isNullOrUndefined(expression.value[currentString]) && isNaN(expression.value[currentString]) === false) { //if variable name is numeric
                                firstString = MyExpression.substring(0, i) + expression.value[currentString];
                            }
                            else {
                                if (!util_1.isNullOrUndefined(expression.value[currentString]) && isNaN(Number(expression.value[currentString])) === false) { //if variable value is numeric
                                    tempFirstString = firstString;
                                    firstString = MyExpression.substring(0, i) + expression.value[currentString];
                                    addColumn = 0;
                                    if (MyExpression[tempFirstString.length + 2] === "." || MyExpression[i + currentString.length]) {
                                        firstString = MyExpression.substring(0, i) + '"' + expression.value[currentString] + '"';
                                        addColumn = 2;
                                    }
                                    else {
                                        if (MyExpression[currentString.length] === ".") {
                                            firstString = '"' + firstString + '"';
                                            addColumn = 2;
                                        }
                                    }
                                }
                                else {
                                    let isArr = false;
                                    try {
                                        if (Array.isArray(JSON.parse(expression.value[currentString]))) {
                                            isArr = true;
                                        }
                                    }
                                    catch (e) { }
                                    if (!util_1.isNullOrUndefined(expression.value[currentString]) && Array.isArray(expression.value[currentString])) {
                                        firstString = MyExpression.substring(0, i) + JSON.stringify(expression.value[currentString]); //if variable value is string
                                        addColumn = 2;
                                    }
                                    else if (!util_1.isNullOrUndefined(expression.value[currentString]) && typeof expression.value[currentString] == 'object') {
                                        firstString = MyExpression.substring(0, i) + JSON.stringify(expression.value[currentString]);
                                        addColumn = 2;
                                    }
                                    // else if (!isNullOrUndefined(expression.value[currentString]) && expression.value[currentString].charAt(expression.value[currentString].length - 1) !== ']') {
                                    else if (!util_1.isNullOrUndefined(expression.value[currentString]) && typeof expression.value[currentString] == 'string' && !isArr) {
                                        firstString = MyExpression.substring(0, i) + '"' + expression.value[currentString] + '"'; //if variable value is string
                                        addColumn = 2;
                                    }
                                    else {
                                        firstString = MyExpression.substring(0, i) + expression.value[currentString]; //if variable value is string
                                        addColumn = 0;
                                    }
                                }
                            }
                        }
                        if (isCotesFound) { //remove this if else if successfully tested
                            i = i + currentString.length;
                            //i = i + temp.length;
                        }
                        else {
                            i = i + currentString.length;
                        }
                        secondString = MyExpression.substring(i);
                        i++;
                        // if(secondString[0]==="."){
                        //     firstString='"'+firstString+'"'
                        //     i=i+2;
                        //     }
                        MyExpression = firstString + secondString;
                        if (!util_1.isNullOrUndefined(expression.value[currentString]) && expression.value[currentString].toString().includes("[native code]") == false) {
                            if (!isNaN(expression.value[currentString])) {
                                let numberLength = expression.value[currentString].toString().length;
                                i = i + numberLength - currentString.length + addColumn;
                            }
                            else if (typeof expression.value[currentString] === 'object') {
                                i = i + JSON.stringify(expression.value[currentString]).length - currentString.length;
                            }
                            else {
                                i = i + expression.value[currentString].length - currentString.length + addColumn;
                            }
                        }
                    }
                    else {
                        if (currentString !== "") {
                            i = i - currentString.length - 1;
                            if (MyExpression.charAt(i + 1) === '!') { //to handle not operator for the custome function
                                firstString = MyExpression.substring(0, i + 1) + "!this.";
                                secondString = MyExpression.substring(i + 2);
                                i = i + 6 + currentString.length + 1;
                            }
                            else {
                                firstString = MyExpression.substring(0, i + 1) + "this.";
                                secondString = MyExpression.substring(i + 1);
                                i = i + 5 + currentString.length + 1;
                            }
                            MyExpression = firstString + secondString;
                        }
                    }
                }
                operator.forEach(op => {
                    if (!executebleStatement) {
                        if (MyExpression.includes(op)) {
                            executebleStatement = true;
                        }
                    }
                });
                if (executebleStatement) {
                    MyExpression = firstString + secondString;
                    // MyExpression=MyExpression.replace("this.","")
                    // result = new Function("return " + MyExpression)()
                    if (!MyExpression.includes("this.")) {
                        //console.log("Expr", MyExpression)
                        MyExpression = MyExpression.replace(/\${"([^}]*)"}/g, (m, g) => {
                            const escapedContent = g.replace(/"/g, '\\"');
                            return `\${"${escapedContent}"}`;
                        });
                        result = yield new Function("return " + MyExpression)();
                        return result;
                    }
                    else {
                        // console.log(" -- BEFORE PROMIS FUNC. ---");
                        result = yield new Promise((resolve, reject) => {
                            // console.log(" -- BEFORE EVAL FUNC. ---      ------        ", MyExpression);
                            try {
                                // Safely execute eval
                                resolve(eval(MyExpression));
                            }
                            catch (error) {
                                // Reject the promise with the error
                                reject(error);
                            }
                        });
                        return result;
                    }
                }
                else {
                    MyExpression = MyExpression.replace('"', '');
                    MyExpression = MyExpression.replace(/"([^"]*)$/, '$1');
                    // console.log("myExpression ELSE =======>>>>  ", MyExpression);
                    result = MyExpression;
                    return result;
                }
                if (typeof result === "object" && !util_1.isNullOrUndefined(expression.value['isObject'])) {
                    return JSON.stringify(result);
                }
                // console.log("FinalREsult =====>>>>>>----111111------>>>>>>>> ", result);
                return result;
            }
            catch (err) {
                console.log("error", err);
                return err["message"];
            }
        });
    }
    // find regex match of document
    findQueryRegex(collectionName, field, value, options) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let match = {};
                try {
                    if (!util_1.isNullOrUndefined(options)) {
                        match[field] = new RegExp(value, options);
                    }
                    else {
                        match[field] = new RegExp(value);
                    }
                }
                catch (err) {
                    match[field] = value;
                }
                let res = yield db.collection(collectionName).find(match);
                res = JSON.parse(JSON.stringify(res));
                return JSON.stringify(res);
            }
            catch (err) {
                console.log("findQuery error: ", err);
                return err;
            }
        });
    }
    ErrorHandlingSTC(providers, systemComm) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log(providers, systemComm);
                let data = yield (db.collection('ErrorHandling')).findOne().lean();
                data = data.data;
                let pro = providers.tableData.map(a => a['Provider']).filter(a => a != '');
                let sys = systemComm.tableData.reduce((final, acc) => {
                    if (pro.includes(acc['System Name'])) {
                        final[acc['System Name']] = acc['System Communication Protocol'];
                    }
                    return final;
                }, {});
                console.log(pro, sys);
                let finalArr = [];
                for (let obj of data) {
                    let dObj = {};
                    dObj['Name'] = obj['Name'];
                    dObj['Code'] = obj['Code'];
                    dObj['HTTP Code'] = 'NA';
                    dObj['Description'] = obj['Description'];
                    dObj['System'] = obj['System'];
                    dObj['Type'] = obj['Type'];
                    dObj['Handling'] = obj['Handling'];
                    if (obj['System'].includes('Replace with Target')) {
                        for (let pr of pro) {
                            if (obj['Scenario'].includes(sys[pr]) || obj['Scenario'].includes('Always')) {
                                dObj['System'] = pr;
                                finalArr.push(JSON.parse(JSON.stringify(dObj)));
                            }
                        }
                    }
                    else if (obj['Scenario'].includes('Always')) {
                        finalArr.push(JSON.parse(JSON.stringify(dObj)));
                    }
                }
                console.log(finalArr);
                return finalArr;
            }
            catch (e) {
                console.log("Error in the ErrorHandlingSTC------", e);
                return e;
            }
        });
    }
    typeIdentificationPharma(pdfData, filePath, type) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let data = yield (db.collection('TMFIndex')).find({}).lean();
                let artifacts = data.map(a => a['ARTIFACT (CLASSIFICATION)']);
                let currAf = filePath.substr(filePath.lastIndexOf('/') + 1).replace(/(.pdf)$/, '').replace(/\d/g, '').replace(/_/g, ' ').trim();
                console.log(currAf);
                let match = stringSimilarity.findBestMatch(currAf, artifacts);
                let perfectmatch = match.ratings.filter((a, index) => {
                    a.index = index;
                    return a.rating == match.bestMatch.rating;
                });
                let rowData;
                if (perfectmatch.length == 1) {
                    rowData = data[match.bestMatch.index];
                }
                else if (perfectmatch.length > 1) {
                    let multipleData = perfectmatch.map(a => data[a.index]);
                    if (pdfData.filter(a => /(site)/.test(a.Name.toLowerCase())).length) {
                        rowData = multipleData.filter(a => a['Filing Level'].toLowerCase().includes('site'))[0];
                    }
                    else {
                        rowData = multipleData.filter(a => a['Filing Level'].toLowerCase().includes('country'))[0];
                    }
                }
                else {
                    throw "Errrrrrrrrrrrrrrrrrrrr";
                }
                console.log(perfectmatch);
                if (type == 'type') {
                    let type = rowData['ARTIFACT (CLASSIFICATION)'].replace(/\s/g, '_');
                    console.log(type);
                    return type;
                }
                else {
                    rowData['zone'] = rowData['Zone #'];
                    rowData['artifactID'] = rowData['Artifact ID'];
                    rowData['fillinglevel'] = rowData['Filing Level'];
                    rowData['zoneType'] = rowData['Zone (Document type)'];
                    rowData['artifact'] = rowData['ARTIFACT (CLASSIFICATION)'];
                    console.log(rowData);
                    return JSON.stringify(rowData);
                }
            }
            catch (e) {
                console.log("Error in the typeIdentificationPharma------", e);
                return '';
            }
        });
    }
    // ------------------------------------------------------------------------------------------------------
    //THIS FUNCTION FOR FIND OUT GIVEN CHARACTER IS OPERATOR, SPLITE CHARACTER OR NEWLY ADDED FUNCTION .
    digitLengthNew(data, length) {
        data = data.trim();
        let i = data.length;
        while (i < length) {
            data = "0" + data;
            i++;
        }
        if (data.length > 0) {
            return data;
        }
        else {
            return "";
        }
    }
    // --------------______________REGEX MATCH _______________----------//
    regexMatch(reg, str) {
        let matchreg = new RegExp(reg, 'g');
        if (matchreg.test(str)) {
            return true;
        }
        else {
            return false;
        }
    }
    PONumberExtraction(str) {
        let value = '';
        if (typeof str !== 'string') {
            str = str.toString();
        }
        let splitStr = str.split('');
        let once = true;
        splitStr.forEach((e, i) => {
            if (/\d/g.test(e) && once == true) {
                value = value != '' ? value + e : e;
            }
            else if (/[a-zA-Z-]/g.test(e) && value != '') {
                once = false;
            }
        });
        return value;
    }
    digitLength(data, length) {
        if (!util_1.isNullOrUndefined(data)) {
            if (!isNaN(data)) {
                data = data.toString().trim();
            }
            data = data.replace(/[a-zA-Z”]/g, '').trim();
            if (data.includes(' ')) {
                data = data.substring(data.lastIndexOf(' ')).trim();
            }
            if (data.includes('	')) {
                data = data.substring(data.lastIndexOf('	')).trim();
            }
            let i = data.length;
            if (data.substring(0, 2) == '9#') {
                length = length + 2;
            }
            while (i < length) {
                data = "0" + data;
                i++;
            }
            if (data.length > 0) {
                return data + "9#";
            }
            else {
                return "";
            }
        }
        else {
            let zero = '0';
            return zero;
        }
    }
    month(line) {
        let month = ['JANUARY', 'FEBRUARY', 'MARCH', 'APRIL', 'MAY', 'JUNE', 'JULY', 'AUGUST', 'SEPTEMBER', 'OCTOBER', 'NOVEMBER', 'DECEMBER'];
        line = line.toUpperCase();
        // words.forEach(e => {
        // month.forEach(r => {
        for (let m = 0; m < month.length; m++) {
            if (line.includes(month[m])) {
                let n;
                if (m < 9) {
                    n = "0" + ++m;
                }
                else {
                    return ++m;
                }
                return n;
                break;
            }
        }
        // })
        // })
        return "";
    }
    isNullOrUndefined(data, fields) {
        if (fields[data] != undefined) // || fields[data] == ""
            return false;
        return true;
    }
    reverseString(str, split, join) {
        return str.split(split).reverse().join(join);
    }
    // REPLACE ALL ___ FUNCTION ------------------------//
    replaceAll(string, search, replace) {
        if (typeof string == 'string') {
            return string.split(search).join(replace);
        }
        else {
            return string.toString().split(search).join(replace);
        }
    }
    // First Charater Upper CASE -----___________--------------//
    firstCharUpperCase(line) {
        const words = line.split(" ");
        for (let i = 0; i < words.length; i++) {
            words[i] = words[i][0].toUpperCase() + words[i].substr(1);
        }
        line = words.join(" ");
        return line;
    }
    // INCLUDE ANYY OOFFF -------------------------------_______________ ---------- //
    includeAnyOf(line, array) {
        for (let i = 0; i < array.length - 1; i++) {
            if (line.includes(array[i])) {
                return line.indexOf(array[i]);
            }
            else {
                return -1;
            }
        }
    }
    // FORMAT OBJ ---------------------___________________ ---------- ..//
    formatObj(inputArr, key1, key2) {
        let res;
        if (!util_1.isNullOrUndefined(inputArr) && Array.isArray(inputArr)) {
            res = inputArr.reduce((final, obj) => {
                let newObject = {};
                newObject[key1] = Object.keys(obj).toString();
                newObject[key2] = Object.values(obj).toString();
                final.push(newObject);
                return final;
            }, []);
        }
        return {
            "result": res
        };
    }
    // ----------------------- ------------------- _ ------___________  isDate ----- //
    isDate(date) {
        // const words = date.split(' ');
        // let isDate = false;
        let month = ['JANUARY', 'FEBRUARY', 'MARCH', 'APRIL', 'MAY', 'JUNE', 'JULY', 'AUGUST', 'SEPTEMBER', 'OCTOBER', 'NOVEMBER', 'DECEMBER'];
        date = date.toUpperCase();
        // words.forEach(e => {
        // month.forEach(r => {
        for (let m = 0; m < month.length; m++) {
            if (date.includes(month[m])) {
                return true;
                break;
            }
        }
        // })
        // })
        return false;
    }
    // IS ROMAN ------------- ____________ ------------- //
    isRoman(str) {
        let expr = new RegExp("^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$", "i");
        return expr.test(str);
    }
    // ------------------------ FUZZY LOOK UP _____________________________-----------------//
    testingfuzzy(table_Name, parameter, vendor_name, supplier_address, supplier_trn, fileRefNum, outputfieldValue, thersold) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("Inside testingfuzzy Done");
                let self = this;
                return yield new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    let oracleinput = {};
                    let oracleoutput = {};
                    console.info(" --- VENDOR_NAME  ----- ", vendor_name);
                    console.info(" --- supplier_address  ----- ", supplier_address);
                    console.info(" --- supplier_trn  ----- ", supplier_trn);
                    console.info(" --- fileRefNum  ----- ", fileRefNum);
                    console.info(" --- outputfieldValue  ----- ", outputfieldValue);
                    console.info(" ----- Parameters --------- >> ", parameter);
                    console.info(" ----- table_Name --------- >> ", table_Name);
                    console.info(" ----- thersold --------- >> ", thersold);
                    oracleinput['username'] = env_2.env.fileConfig.OracleUser;
                    oracleinput['password'] = env_2.env.fileConfig.OraclePassword;
                    oracleinput['connectString'] = env_2.env.fileConfig.connectionString;
                    oracleinput['isRuleEngine'] = true;
                    if (parameter == 'sql1') {
                        oracleinput['parameter'] = 'sql1';
                        oracleinput['tableName'] = table_Name;
                    }
                    else {
                        oracleinput['parameter'] = parameter;
                        oracleinput['query'] = table_Name;
                    }
                    let result = yield self.oracleDBConnector(oracleinput, oracleoutput, null, null, null);
                    if (!util_1.isNullOrUndefined(result) && !util_1.isNullOrUndefined(result['data']) && !util_1.isNullOrUndefined(result['data']['result'])) {
                        result['converted'] = JSON.parse(JSON.stringify(result['data']['result']['converted']));
                    }
                    // let result = {};
                    let endResult = {};
                    let email_address = '';
                    endResult[outputfieldValue] = '';
                    let input = {
                        "VENDOR_NAME": vendor_name,
                        "Supplier_Address": supplier_address,
                        "Supplier_TRN": supplier_trn,
                        "outputfieldValue": outputfieldValue
                    };
                    try {
                        const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                        const db = yield mClient.db(env_2.env.dbConfig.dbname);
                        if (!util_1.isNullOrUndefined(fileRefNum)) {
                            let collection = "fileuploadhistories";
                            let query = { "fileRefNum": fileRefNum };
                            let data = yield db.collection(collection).find(query).toArray();
                            data = data.length > 0 ? data[0] : {};
                            if (!util_1.isNullOrUndefined(data["mailContent"]) && !util_1.isNullOrUndefined(data["mailContent"][0]["fromMail"])) {
                                email_address = data["mailContent"][0]["fromMail"];
                            }
                            console.log("Email Address :" + email_address);
                        }
                    }
                    catch (err) {
                        console.log("Inside fileUpload for email :" + err);
                    }
                    if (!util_1.isNullOrUndefined(result["converted"]) && Array.isArray(result["converted"])) {
                        console.log("Total rows fetched  :" + result["converted"].length);
                        let DBdata = JSON.parse(JSON.stringify(result["converted"]));
                        DBdata = Array.isArray(DBdata) ? DBdata : result["converted"];
                        let vendor_names = [];
                        let vendor_name_add = [];
                        let vendor_address = [];
                        let vendor_index = 0;
                        for (let i = 0; i < DBdata.length; i++) {
                            vendor_names.push(DBdata[i]["VENDOR_NAME"].toString().toLowerCase());
                            DBdata[i]["myindex"] = vendor_index;
                            DBdata[i]["Supplier_Address"] = DBdata[i]["ADDRESS_LINE1"] + ' ' + DBdata[i]["ADDRESS_LINE2"] + ' ' + DBdata[i]["ADDRESS_LINE3"] + ' ' + DBdata[i]["CITY"];
                            DBdata[i]["Supplier_Address"] = DBdata[i]["Supplier_Address"].replace(/(null)|(undefined)|(vat no: \d+)|(VAT No: \d+)/g, '').trim().toLowerCase();
                            DBdata[i]["Vendor_Name_Address"] = DBdata[i]["VENDOR_NAME"] + ' ' + DBdata[i]["Supplier_Address"];
                            vendor_address.push(DBdata[i]["Supplier_Address"].toString().toLowerCase());
                            vendor_name_add.push(DBdata[i]["Vendor_Name_Address"].toString().toLowerCase());
                            vendor_index++;
                        }
                        // Matching the vendor_name results
                        let match;
                        let multiplematch;
                        let newDBdata = [];
                        let valuetoSearch;
                        if (endResult[outputfieldValue] == '' && !util_1.isNullOrUndefined(input["VENDOR_NAME"]) && input["VENDOR_NAME"] != '' && Array.isArray(vendor_names) && vendor_names.length > 0) {
                            valuetoSearch = input["VENDOR_NAME"].toString().toLowerCase();
                            match = stringSimilarity.findBestMatch(valuetoSearch, vendor_names);
                            console.log("Inside vendor_name");
                            //console.log(match)
                            if (!util_1.isNullOrUndefined(match) && !util_1.isNullOrUndefined(match.ratings) && Array.isArray(match.ratings) && !util_1.isNullOrUndefined(match.bestMatch.rating) && match.bestMatch.rating > 0.5 && !util_1.isNullOrUndefined(match.bestMatchIndex)) {
                                for (let i = 0; i < match.ratings.length; i++) {
                                    match.ratings[i]["myindex"] = i;
                                    match.ratings[i]["Rating"] = Math.floor(match.ratings[i].rating * 10);
                                }
                                if (!util_1.isNullOrUndefined(match.bestMatch.target) && valuetoSearch.length < (match.bestMatch.target.length / 1.5)) {
                                    multiplematch = match.ratings.filter(a => a.Rating <= (Math.floor(match.bestMatch.rating * 10) + 1) && a.Rating >= (Math.floor(match.bestMatch.rating * 10) - 1));
                                }
                                else {
                                    multiplematch = match.ratings.filter(a => a.rating <= match.bestMatch.rating + 0.06 && a.rating >= match.bestMatch.rating - 0.06);
                                }
                                console.log(" --- MULTIPLEMATCH ---- ", multiplematch.length);
                                let perfectmatch = match.ratings.filter(a => a.rating == match.bestMatch.rating);
                                if (multiplematch.length > 0) {
                                    console.log("Matched single records-------");
                                    let matchedData = DBdata.filter(a => a.myindex == match.bestMatchIndex);
                                    matchedData = matchedData.length > 0 ? matchedData[0] : {};
                                    if (!util_1.isNullOrUndefined(matchedData[input["outputfieldValue"]])) {
                                        endResult[outputfieldValue] = matchedData[input["outputfieldValue"]];
                                    }
                                }
                                else if ((perfectmatch.length == multiplematch.length) && multiplematch.length > 1 && !util_1.isNullOrUndefined(input["Supplier_Address"]) && input["Supplier_Address"] != '') {
                                    console.log("Matched multiple records-------");
                                    let Address = [];
                                    for (let i = 0; i < multiplematch.length; i++) {
                                        let dbData = DBdata.filter(a => a.myindex == multiplematch[i].myindex);
                                        if (dbData.length > 0) {
                                            dbData[0] = JSON.parse(JSON.stringify(dbData[0]));
                                            dbData[0]["myindex"] = i;
                                            newDBdata.push(dbData[0]);
                                            if (!util_1.isNullOrUndefined(dbData[0]["Supplier_Address"])) {
                                                Address.push(dbData[0]["Supplier_Address"]);
                                            }
                                            else {
                                                Address.push('');
                                            }
                                        }
                                    }
                                    let match1 = stringSimilarity.findBestMatch(input["Supplier_Address"], Address);
                                    console.log("Inside Supplier_Address");
                                    //console.log(match1.bestMatch)
                                    if (!util_1.isNullOrUndefined(match1.bestMatchIndex) && !util_1.isNullOrUndefined(match1.bestMatch.rating) && match1.bestMatch.rating > 0.1) {
                                        console.warn("match1.ratings.length === .... >>  ", match1);
                                        let matchedData = newDBdata.filter(a => a.myindex == match1.bestMatchIndex);
                                        matchedData = matchedData.length > 0 ? matchedData[0] : {};
                                        if (!util_1.isNullOrUndefined(matchedData[input["outputfieldValue"]])) {
                                            endResult[outputfieldValue] = matchedData[input["outputfieldValue"]];
                                        }
                                    }
                                }
                                // //Multiple match have same vendor_name
                                // if (perfectmatch.length == multiplematch.length && (isNullOrUndefined(endResult[outputfieldValue]) || endResult[outputfieldValue] == '')) {
                                //     console.log("Inside Perfect matches-----------")
                                //     if (!isNullOrUndefined(input["outputfieldValue"]) && input["outputfieldValue"] == 'VENDOR_NAME') {
                                //         let matchedData = DBdata.filter(a => a.myindex == match.bestMatchIndex)
                                //         console.warn("DBdata.ratings.length === .... >>  ", DBdata);
                                //         matchedData = matchedData.length == 1 ? matchedData[0] : {};
                                //         if (!isNullOrUndefined(matchedData[input["outputfieldValue"]])) {
                                //             endResult[outputfieldValue] = matchedData[input["outputfieldValue"]];
                                //         }
                                //     }
                                // }
                            }
                        }
                        // else if (endResult[outputfieldValue] == '' && !isNullOrUndefined(input["Supplier_Address"]) && input["Supplier_Address"] != '' && Array.isArray(vendor_address) && vendor_address.length > 0) {
                        //     valuetoSearch = input["Supplier_Address"].toString().toLowerCase();
                        //     match = stringSimilarity.findBestMatch(valuetoSearch, vendor_address);
                        //     console.log("Inside Supplier_Address");
                        //     console.log(match)
                        //     if (!isNullOrUndefined(match) && !isNullOrUndefined(match.ratings) && Array.isArray(match.ratings) && !isNullOrUndefined(match.bestMatch.rating) && match.bestMatch.rating > 0.5 && !isNullOrUndefined(match.bestMatchIndex)) {
                        //         let matchedData = DBdata.filter(a => a.myindex == match.bestMatchIndex);
                        //         console.warn("DBdata.ratings.length === .... >>  ", DBdata);
                        //         matchedData = matchedData.length == 1 ? matchedData[0] : {};
                        //         if (!isNullOrUndefined(matchedData[input["outputfieldValue"]])) {
                        //             endResult[outputfieldValue] = matchedData[input["outputfieldValue"]];
                        //         }
                        //     }
                        // }
                        //Matching supplier TRN
                        if ((util_1.isNullOrUndefined(endResult[outputfieldValue]) || endResult[outputfieldValue] == '') && !util_1.isNullOrUndefined(input["Supplier_TRN"]) && input["Supplier_TRN"] != '') {
                            let TRNmatch = DBdata.filter(a => a["SUPPLIER_TRN"] == input["Supplier_TRN"]);
                            let sameVendorMatch = [];
                            let Address4 = [];
                            if (TRNmatch.length > 1) {
                                for (let i = 0; i < TRNmatch.length; i++) {
                                    for (let j = 0; j < TRNmatch.length; j++) {
                                        if (i !== j) { // do not compare same elements
                                            if (TRNmatch[i]["VENDOR_NAME"] === TRNmatch[j]["VENDOR_NAME"]) {
                                                sameVendorMatch.push(TRNmatch[i]);
                                            }
                                        }
                                    }
                                }
                                for (let i = 0; i < sameVendorMatch.length; i++) {
                                    if (!util_1.isNullOrUndefined(sameVendorMatch[i]["Supplier_Address"])) {
                                        Address4.push(sameVendorMatch[i]["Supplier_Address"]);
                                    }
                                    else {
                                        Address4.push('');
                                    }
                                }
                                let match3 = stringSimilarity.findBestMatch(input["Supplier_Address"], Address4);
                                console.log("Inside Supplier_Address", match3);
                                if (!util_1.isNullOrUndefined(match3.bestMatchIndex) && !util_1.isNullOrUndefined(match3.bestMatch.rating) && match3.bestMatch.rating > 0.1) {
                                    console.warn("match1.ratings.length === .... >>  ", match3);
                                    let matchedData = sameVendorMatch.filter(a => a.myindex == match3.bestMatchIndex);
                                    matchedData = matchedData.length > 0 ? matchedData[0] : {};
                                    if (!util_1.isNullOrUndefined(matchedData[input["outputfieldValue"]])) {
                                        endResult[outputfieldValue] = matchedData[input["outputfieldValue"]];
                                    }
                                }
                            }
                            else {
                                TRNmatch = TRNmatch.length > 0 ? TRNmatch[0] : {};
                            }
                            if (!util_1.isNullOrUndefined(TRNmatch[input["outputfieldValue"]])) {
                                endResult[outputfieldValue] = TRNmatch[input["outputfieldValue"]];
                            }
                        }
                        //Matching email address
                        if ((util_1.isNullOrUndefined(endResult[outputfieldValue]) || endResult[outputfieldValue] == '') && !util_1.isNullOrUndefined(email_address) && /\w{1,}@\w{1,}/.test(email_address)) {
                            console.log("Inside Email match...");
                            let sameVendorMatch = [];
                            let Address5;
                            let domainName = email_address.replace(/\w{1,}@/g, '');
                            let matchEmail = DBdata.filter(a => !util_1.isNullOrUndefined(a["EMAIL_ADDRESS"]) && a["EMAIL_ADDRESS"].includes(domainName));
                            let singleEmail = matchEmail.length > 0 ? matchEmail[0] : {};
                            if (matchEmail.length > 1) {
                                for (let i = 0; i < matchEmail.length; i++) {
                                    for (let j = 0; j < matchEmail.length; j++) {
                                        if (i !== j) { // do not compare same elements
                                            if (matchEmail[i]["VENDOR_NAME"] === matchEmail[j]["VENDOR_NAME"]) {
                                                sameVendorMatch.push(matchEmail[i]);
                                            }
                                        }
                                    }
                                }
                                for (let i = 0; i < sameVendorMatch.length; i++) {
                                    if (!util_1.isNullOrUndefined(sameVendorMatch[i]["Supplier_Address"])) {
                                        Address5.push(sameVendorMatch[i]["Supplier_Address"]);
                                    }
                                    else {
                                        Address5.push('');
                                    }
                                }
                                let match4 = stringSimilarity.findBestMatch(input["Supplier_Address"], Address5);
                                console.log("Inside Supplier_Address");
                                //console.log(match4.bestMatch)
                                if (!util_1.isNullOrUndefined(match4.bestMatchIndex) && !util_1.isNullOrUndefined(match4.bestMatch.rating) && match4.bestMatch.rating > 0.1) {
                                    console.warn("match1.ratings.length === .... >>  ", match4);
                                    let matchedData = sameVendorMatch.filter(a => a.myindex == match4.bestMatchIndex);
                                    matchedData = matchedData.length > 0 ? matchedData[0] : {};
                                    if (!util_1.isNullOrUndefined(matchedData[input["outputfieldValue"]])) {
                                        endResult[outputfieldValue] = matchedData[input["outputfieldValue"]];
                                    }
                                }
                            }
                            //let multiEmail = matchEmail.length > 1 ? matchEmail[0] : {};
                            if (!util_1.isNullOrUndefined(singleEmail[input["outputfieldValue"]])) {
                                endResult[outputfieldValue] = singleEmail[input["outputfieldValue"]];
                            }
                            // if (!isNullOrUndefined(multiEmail[input["outputfieldValue"]]) && input["outputfieldValue"] == "VENDOR_NAME") {
                            //     endResult[outputfieldValue] = multiEmail[input["outputfieldValue"]];
                            // }
                        }
                        //Matching Vendor_Name_Address results
                        // if (endResult[outputfieldValue] == '' && vendor_name_add.length > 0 && !isNullOrUndefined(input["VENDOR_NAME"]) && !isNullOrUndefined(input["Supplier_Address"]) && input["VENDOR_NAME"] != '' && input["Supplier_Address"] != '') {
                        //     let value = input["VENDOR_NAME"] + ' ' + input["Supplier_Address"];
                        //     value = value.toLocaleLowerCase();
                        //     let matchVA = stringSimilarity.findBestMatch(value, vendor_name_add)
                        //     console.log("Inside Vendor_Name_Address");
                        //     if (!isNullOrUndefined(matchVA) && !isNullOrUndefined(matchVA.ratings) && Array.isArray(matchVA.ratings) && !isNullOrUndefined(matchVA.bestMatch.rating) && matchVA.bestMatch.rating > 0.6 && !isNullOrUndefined(matchVA.bestMatchIndex)) {
                        //         console.warn("matchVA.ratings.length === .... >>  ", matchVA);
                        //         let multiplematchVA = matchVA.ratings.filter(a => a.rating === matchVA.bestMatch.rating)
                        //         if (multiplematchVA.length == 1) {
                        //             let matchedData = DBdata.filter(a => a.myindex == matchVA.bestMatchIndex)
                        //             matchedData = matchedData.length == 1 ? matchedData[0] : {};
                        //             if (!isNullOrUndefined(matchedData[input["outputfieldValue"]])) {
                        //                 endResult[outputfieldValue] = matchedData[input["outputfieldValue"]];
                        //             }
                        //         }
                        //     }
                        // }
                    }
                    console.warn(" ------ OUTPUT FOR TESTING FUZZY LOGIC ------ ---------  >>>> >> ", endResult[outputfieldValue]);
                    resolve(endResult[outputfieldValue]);
                }));
            }
            catch (error) {
                console.log("testingfuzzy " + error);
                return '';
            }
        });
    }
    // public async fuzzylookUp(collectionName, fieldsOnSearch, valuesToSearch, project, from, to, singleValue, spaceflag, percentage, excludeCount) {
    //     try {
    //         if (isNullOrUndefined(from)) {
    //             from = 0
    //         }
    //         if (isNullOrUndefined(to)) {
    //             to = 10000;
    //         }
    //         if (isNullOrUndefined(percentage)) {
    //             percentage = 1;
    //         }
    //         let query = {}
    //         let count = 0;
    //         // let resultValue=[];
    //         let finalResult = [];
    //         let metchResult = [];
    //         let sum = 0;
    //         let innerLookUPData = {}
    //         if (!isNullOrUndefined(valuesToSearch) && !isNullOrUndefined(fieldsOnSearch) && Array.isArray(valuesToSearch) && Array.isArray(fieldsOnSearch) && valuesToSearch.length == fieldsOnSearch.length) {
    //             if (isNullOrUndefined(spaceflag) || spaceflag == 0) {
    //                 fieldsOnSearch.forEach(element => {
    //                     query[element] = valuesToSearch[count]
    //                     count++;
    //                 })
    //             }
    //             if (!isNullOrUndefined(spaceflag) && spaceflag == 1) {
    //                 fieldsOnSearch.forEach(element => {
    //                     query[element] = valuesToSearch[count].replace(/ /g, '')
    //                     count++;
    //                 })
    //             }
    //             let projectObj = {}
    //             if (Array.isArray(project) && project.length > 0) {
    //                 project.forEach(col => {
    //                     projectObj[col] = 1
    //                 })
    //             }
    //             if (Array.isArray(fieldsOnSearch) && fieldsOnSearch.length > 0) {
    //                 fieldsOnSearch.forEach(col => {
    //                     projectObj[col] = 1
    //                 })
    //             }
    //             // const mClient = await MongoClient.connect(env.dbConfig.mongodb_uri);
    //             // const db = await mClient.db(env.dbConfig.dbname);
    //             let countDocs = await db.collection(collectionName).find({}, { _id: -1 }).count();
    //             let result = [];
    //             if (countDocs > 0) {
    //                 result = await db.collection(collectionName).find({}, projectObj).limit(countDocs - excludeCount).sort({ _id: -1 }).lean();
    //             }
    //             if (result.length === 0) {
    //                 return -1
    //             }
    //             for (const myresult of result) {
    //                 sum = 0;
    //                 for (let i = 0; i < fieldsOnSearch.length; i++) {
    //                     if (!isNullOrUndefined(myresult[fieldsOnSearch[i]])) {
    //                         sum = sum + this.approxMatch(myresult[fieldsOnSearch[i]], valuesToSearch[i])
    //                     } else {
    //                         if (valuesToSearch[i] == "null") {
    //                             sum = sum + 1
    //                         }
    //                     }
    //                 }
    //                 metchResult.push(sum / fieldsOnSearch.length)
    //             }
    //             let maxindex = Math.max(...metchResult)
    //             if (maxindex > percentage / 100) {
    //                 maxindex = metchResult.indexOf(maxindex)
    //                 for (let i = 0; i < project.length; i++) {
    //                     if (!isNullOrUndefined(singleValue) && singleValue == 0) {
    //                         // innerLookUPData[project[i]] = result[maxindex][project[i]]
    //                     }
    //                     innerLookUPData[project[i]] = result[maxindex][project[i]];
    //                     // finalResult.push(result[maxindex][project[i]]);
    //                 }
    //                 finalResult.push(innerLookUPData);
    //                 if (!isNullOrUndefined(singleValue) && singleValue == 0) {
    //                     return innerLookUPData
    //                 }
    //                 return JSON.stringify(finalResult)
    //             } else {
    //                 return -1
    //             }
    //         } else {
    //             return "value is undefined or value != field"
    //         }
    //     } catch (error) {
    //         return error["message"];
    //     }
    // }
    fuzzylookUp(collectionName, fieldsOnSearch, valuesToSearch, project, from, to, singleValue, spaceflag, percentage, mainSearch = '', resultData = undefined) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                if (util_1.isNullOrUndefined(from)) {
                    from = 0;
                }
                if (util_1.isNullOrUndefined(to)) {
                    to = 10000;
                }
                if (util_1.isNullOrUndefined(percentage)) {
                    percentage = 1;
                }
                let query = {};
                let count = 0;
                // let resultValue=[];
                let finalResult = [];
                let metchResult = [];
                let sum = 0;
                //let innerLookUPData = {}
                if (!util_1.isNullOrUndefined(valuesToSearch) && !util_1.isNullOrUndefined(fieldsOnSearch) && Array.isArray(valuesToSearch) && Array.isArray(fieldsOnSearch) && valuesToSearch.length == fieldsOnSearch.length) {
                    if (util_1.isNullOrUndefined(spaceflag) || spaceflag == 0) {
                        fieldsOnSearch.forEach(element => {
                            query[element] = valuesToSearch[count];
                            count++;
                        });
                    }
                    if (!util_1.isNullOrUndefined(spaceflag) && spaceflag == 1) {
                        fieldsOnSearch.forEach(element => {
                            query[element] = valuesToSearch[count].replace(/ /g, '');
                            count++;
                        });
                    }
                    let projectObj = {};
                    if (Array.isArray(project) && project.length > 0) {
                        project.forEach(col => {
                            projectObj[col] = 1;
                        });
                    }
                    if (Array.isArray(fieldsOnSearch) && fieldsOnSearch.length > 0) {
                        fieldsOnSearch.forEach(col => {
                            projectObj[col] = 1;
                        });
                    }
                    const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                    const db = yield mClient.db(env_2.env.dbConfig.dbname);
                    let result;
                    if (util_1.isNullOrUndefined(resultData)) {
                        if (!util_1.isNullOrUndefined(mainSearch)) {
                            let query = JSON.parse(mainSearch);
                            if (typeof query == "object") {
                                //  result = await db.collection(collectionName).find(query, projectObj).toArray()
                                result = yield yield db.collection(collectionName).find(query, projectObj);
                                result = JSON.parse(JSON.stringify(result));
                            }
                            else {
                                result = yield yield db.collection(collectionName).find({}, projectObj);
                                result = JSON.parse(JSON.stringify(result));
                            }
                        }
                        else {
                            result = yield yield db.collection(collectionName).find({}, projectObj);
                            result = JSON.parse(JSON.stringify(result));
                        }
                        if (result.length === 0) {
                            return -1;
                        }
                    }
                    else {
                        result = resultData;
                        if (/null/.test(result)) {
                            return -1;
                        }
                        if (typeof result == 'string') {
                            result = JSON.parse(result);
                        }
                    }
                    for (const myresult of result) {
                        sum = 0;
                        for (let i = 0; i < fieldsOnSearch.length; i++) {
                            if (!util_1.isNullOrUndefined(myresult[fieldsOnSearch[i]])) {
                                sum = sum + this.approxMatch(myresult[fieldsOnSearch[i]], valuesToSearch[i]);
                            }
                            else {
                                if (valuesToSearch[i] == "null") {
                                    sum = sum + 1;
                                }
                            }
                        }
                        metchResult.push(sum / fieldsOnSearch.length);
                    }
                    let maxindex = Math.max(...metchResult);
                    if (maxindex > percentage / 100) {
                        metchResult.forEach((el, ind) => {
                            if (el > percentage / 100) {
                                finalResult.push(result[ind]);
                            }
                        });
                        return JSON.stringify(finalResult);
                    }
                    else {
                        return -1;
                    }
                    // let maxindex = Math.max(...metchResult)
                    // if (maxindex > percentage / 100) {
                    //     maxindex = metchResult.indexOf(maxindex)
                    //     for (let i = 0; i < project.length; i++) {
                    //         if (!isNullOrUndefined(singleValue) && singleValue == 0) {
                    //             innerLookUPData[project[i]] = result[maxindex][project[i]]
                    //         }
                    //         finalResult.push(result[maxindex][project[i]]);
                    //     }
                    //     if (!isNullOrUndefined(singleValue) && singleValue == 0) {
                    //         const matchResult = [].concat(innerLookUPData)
                    //         return JSON.stringify(matchResult)
                    //     }
                    //     return finalResult.toString()
                    // } else {
                    //     return -1
                    // }
                }
                else {
                    return "value is undefined or value != field";
                }
            }
            catch (error) {
                return error["message"];
            }
        });
    }
    approxMatch(s1, s2) {
        if (typeof s1 !== 'string') {
            s1 = s1.toString();
        }
        if (typeof s2 !== 'string') {
            s2 = s2.toString();
        }
        let longer = s1;
        let shorter = s2;
        if (s1.length < s2.length) {
            longer = s2;
            shorter = s1;
        }
        let longerLength = longer.length;
        if (longerLength == 0) {
            return 1.0;
        }
        return (longerLength - this.editDistance(longer, shorter)) / parseFloat(longerLength);
    }
    PUSH(arr, value) {
        // try {
        //     arr = JSON.parse(arr);
        // }
        // catch (e) {
        //     console.log("In PUSH ========" + arr);
        // }
        if (!util_1.isNullOrUndefined(arr) && !util_1.isNullOrUndefined(value)) {
            if (Array.isArray(arr)) {
                arr.push(value);
            }
            else {
                arr = [];
                arr.push(value);
            }
        }
        return arr;
    }
    editDistance(s1, s2) {
        s1 = s1.toLowerCase();
        s2 = s2.toLowerCase();
        let costs = new Array();
        for (let i = 0; i <= s1.length; i++) {
            let lastValue = i;
            for (let j = 0; j <= s2.length; j++) {
                if (i == 0)
                    costs[j] = j;
                else {
                    if (j > 0) {
                        let newValue = costs[j - 1];
                        if (s1.charAt(i - 1) != s2.charAt(j - 1))
                            newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
            }
            if (i > 0)
                costs[s2.length] = lastValue;
        }
        return costs[s2.length];
    }
    RULEPUSH(arr, value) {
        // try {
        //     arr = JSON.parse(arr);
        // }
        // catch (e) {
        //     console.log("In PUSH ========" + arr);
        // }
        if (!util_1.isNullOrUndefined(arr) && !util_1.isNullOrUndefined(value)) {
            if (Array.isArray(arr)) {
                //arr.push(value)
                var flg = false;
                for (var i = 0; i < arr.length; i++) {
                    if (value.result == arr[i]["result"]) {
                        flg = true;
                        if (value.line !== "") {
                            arr[i].line = value.line;
                        }
                    }
                }
                if (flg == false) {
                    arr.push(value);
                }
            }
            else {
                arr = [];
                arr.push(value);
            }
        }
        return arr;
    }
    formatForOracleQuery(jsonObj, keySequence, tableName) {
        let result;
        console.log(keySequence);
        if (!util_1.isNullOrUndefined(jsonObj) && !util_1.isNullOrUndefined(keySequence)) {
            let keySequenceArr = keySequence.split(",");
            if (util_1.isNullOrUndefined(tableName) || tableName == "") {
                keySequenceArr.forEach((key, i) => {
                    if (jsonObj[key]) {
                        // if (typeof jsonObj[key] === "string") {
                        result = i > 0 && !util_1.isNullOrUndefined(result) ? result + `'${jsonObj[key]}',` : `'${jsonObj[key]}',`;
                        // }
                        //  else {
                        //     result = i > 0 && !isNullOrUndefined(result) ? result + jsonObj[key] + "," : jsonObj[key] + ",";
                        // }
                    }
                    else if (!jsonObj[key] || jsonObj[key] == "") {
                        result += "'',";
                    }
                });
                result = result.slice(0, -1);
            }
            else {
                let resultArr = [];
                if (Array.isArray(jsonObj[tableName])) {
                    jsonObj[tableName].forEach(el => {
                        let res = '';
                        keySequenceArr.forEach(key => {
                            if (el[key]) {
                                // if (typeof el[key] === "string") {
                                res += `'${el[key]}',`;
                                // }
                                //  else {
                                // res += el[key] + ","
                                // }
                            }
                            else if (jsonObj[key] == 0 || jsonObj[key] == "0") {
                                // if (typeof jsonObj[key] === "string") {
                                res += `'${jsonObj[key]}',`;
                                // } else {
                                //     res += jsonObj[key] + ","
                                // }
                            }
                            else if (jsonObj[key]) {
                                // if (typeof jsonObj[key] === "string") {
                                res += `'${jsonObj[key]}',`;
                                // } else {
                                //     res += jsonObj[key] + ","
                                // }
                            }
                            else if (!jsonObj[key]) {
                                res += "'',";
                            }
                        });
                        res = res.slice(0, -1);
                        resultArr.push(res);
                    });
                }
                result = resultArr;
            }
        }
        return {
            "result": result
        };
    }
    executeFunction(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let fnParams = ``;
                for (let i = 1; i <= input.paramCount; i++) {
                    let paramName = `param${i}`;
                    fnParams += `${JSON.stringify(input[paramName])},`;
                }
                fnParams = fnParams.slice(0, -1); // params for function
                let functionCall = `this.${input.fnName}(${fnParams})`; //template for function call
                //console.log(functionCall)
                let functionReturn = yield eval(functionCall);
                if (functionReturn) {
                    console.log(functionReturn);
                    output['result'] = functionReturn.result;
                    output['status'] = functionReturn.status;
                    return { message: 'fn working.', status: 0, data: output };
                }
                else {
                    return { message: 'fn did not return', status: 0, data: output };
                }
            }
            catch (err) {
                return { "message": "Function not found", status: 1, data: err };
            }
        });
    }
    jsonToCsv(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const { Parser } = require('json2csv');
            try {
                if (!util_1.isNullOrUndefined(input.jsonObj)) {
                    const jsonObj = input.jsonObj;
                    const json2csvParser = new Parser();
                    const csv = yield json2csvParser.parse(jsonObj);
                    const filepath = input.filepath;
                    const filename = input.fileName;
                    let fileStored = filepath + "/" + filename;
                    console.log("-------->,", csv);
                    if (!util_1.isNullOrUndefined(filepath) && !util_1.isNullOrUndefined(csv)) {
                        fs.writeFileSync(fileStored, csv);
                        output['path'] = fileStored;
                        output['csvData'] = csv;
                    }
                    console.log("-------->,", output);
                }
                return { message: "Process sucessfull completed", status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    matchKey(input, output, botId, projectId, iterationId) {
        try {
            if (!util_1.isNullOrUndefined(input.obj) || !util_1.isNullOrUndefined(input.key)) {
                let jsonObj = input.obj;
                if (typeof input.obj === "string") {
                    jsonObj = JSON.parse(input.obj);
                }
                let keysToSearch = input.key.split(",");
                let unmatchedKey = "";
                if (keysToSearch.length > 0) {
                    keysToSearch.forEach(k => {
                        if (jsonObj[k] === undefined || jsonObj[k] === "") {
                            unmatchedKey += `${k},`;
                        }
                    });
                }
                output['missing'] = "false";
                if (unmatchedKey.length > 0) {
                    output['missing'] = "true";
                }
                output['unmatched'] = unmatchedKey.slice(0, -1);
            }
            return { message: "Process sucessfull completed", status: 0, data: output };
        }
        catch (e) {
            this.log.error("Error in finding length" + e);
            return { message: e, status: 1, data: e };
        }
    }
    arrayCombine(input, output, botId, projectId, iterationId) {
        try {
            let finalArr = [];
            let arr0 = [];
            let arr1 = [];
            if (!util_1.isNullOrUndefined(input.arr0) && Array.isArray(input.arr0) && input.arr0.length > 0) {
                arr0 = input.arr0;
            }
            if (!util_1.isNullOrUndefined(input.arr1)) {
                arr1 = [].concat(input.arr1);
            }
            if (arr1.length > 0 && arr0.length > 0) {
                finalArr = finalArr.concat(arr0, arr1);
            }
            else if (arr1.length > 0) {
                finalArr = arr1;
            }
            else if (arr0.length > 0) {
                finalArr = arr0;
            }
            output['final'] = finalArr;
            return { message: "Process sucessfull completed", status: 0, data: output };
        }
        catch (e) {
            this.log.error("Error" + e);
            return { message: e, status: 1, data: e };
        }
    }
    arrayFilter(input, output, botId, projectId, iterationId) {
        try {
            if (!util_1.isNullOrUndefined(input.arr) && !util_1.isNullOrUndefined(input.key) && (input.arr != "") && (input.key != "")) {
                let arr = input.arr;
                if (typeof arr === "string") {
                    arr = JSON.parse(arr);
                }
                let key = input.key;
                let matchedValue = [];
                let unmatchedValue = [];
                let objField = "";
                if (!util_1.isNullOrUndefined(input.field)) {
                    objField = input.field;
                }
                if (Array.isArray(arr)) {
                    arr.forEach(element => {
                        let reg = new RegExp(key, "ig");
                        if (reg.test(element)) {
                            matchedValue.push(element);
                        }
                        else if (reg.test(element[objField])) {
                            matchedValue.push(element);
                        }
                        else {
                            unmatchedValue.push(element);
                        }
                    });
                    output['matched'] = matchedValue;
                    output['matchedlength'] = matchedValue.length > 0 ? "true" : "false";
                    output['unmatched'] = unmatchedValue;
                    output['unmatchedlength'] = unmatchedValue.length > 0 ? "true" : "false";
                }
            }
            else {
                output['matched'] = [];
                output['unmatched'] = [];
                output['matchedlength'] = output.matched.length > 0 ? "true" : "false";
                output['unmatchedlength'] = output.unmatched.length > 0 ? "true" : "false";
            }
            console.log("=====>out", output);
            return { message: "Process sucessfully completed", status: 0, data: output };
        }
        catch (e) {
            this.log.error("Error in finding length" + e);
            return { message: e, status: 1, data: e };
        }
    }
    detachKeyFromObject(input, output, botId, projectId, iterationId) {
        try {
            let primaryObject = input.objValue; //Main object which contains multiple key
            let searchKey = input.key.split(","); //Key to search from main object
            console.log("searchkeys", searchKey);
            if (searchKey.length > 0) {
                // console.log(primaryObject[searchKey])
                searchKey.forEach((key, i) => {
                    let value = primaryObject[key];
                    console.log(`keyValue${i}` + key + primaryObject[key]);
                    output[`keyValue${i}`] = value;
                    console.log("//////////////+++++**********", value, "*********+++++\\\\\\\\\\\\\\\\");
                    if (util_1.isNullOrUndefined(value)) {
                        console.log("inside", value);
                        output[`keyValue${i}`] = "";
                    }
                });
                console.log(JSON.stringify(output));
                return { message: 'search key value found.', status: 0, data: output };
            }
            else {
                return { message: 'search key is empty or key not found in object', status: 0, data: output };
            }
        }
        catch (err) {
            return { "message": "key not found", status: 1, data: err };
        }
    }
    filterArrayData(arrayData, keyToSearch, keyValue) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let searchkey = keyToSearch.split(","); //keys that needs to be searched
                let matchValue = keyValue.split(","); //values of search key
                const filteredResult = arrayData.reduce((final, item) => {
                    let matchedKeys = searchkey.filter((key, i) => item[key] === matchValue[i]); //check if the item matches the all thesearch key
                    if (matchedKeys.length === searchkey.length) {
                        final['result'] = item;
                        final['status'] = 1;
                    }
                    return final;
                }, {});
                //console.log(filteredResult)
                if (filteredResult.status === 1) {
                    return filteredResult;
                }
                else {
                    return {
                        "result": "",
                        "status": 0
                    };
                }
            }
            catch (error) {
                return { "error": error };
            }
        });
    }
    // ------------------------------------------------------------------------------------------------------
    //THIS FUNCTION FOR FIND OUT GIVEN CHARACTER IS OPERATOR, SPLITE CHARACTER OR NEWLY ADDED FUNCTION .
    findMe(data, findMeIn) {
        try {
            for (let i = 0; i < findMeIn.length; i++) {
                if (data === findMeIn[i]) {
                    return true;
                }
            }
            return false;
        }
        catch (e) {
            return e["message"];
        }
    }
    isEmptyCheck(data, fields) {
        try {
            if (!util_1.isNullOrUndefined(fields) && !util_1.isNullOrUndefined(fields[data]) && fields[data] != "" && fields[data] != '') {
                return false;
            }
            else {
                return true;
            }
        }
        catch (e) {
            return e["message"];
        }
    }
    tostring(data) {
        try {
            return data.toString();
        }
        catch (e) {
            return e["message"];
        }
    }
    SumForGroupBy() {
        try {
            return { "$sum": 1 };
        }
        catch (e) {
            return e["message"];
        }
    }
    firstForgroupBy() {
        try {
            return { "$first": "$$ROOT" };
        }
        catch (e) {
            return e["message"];
        }
    }
    SumForGroupByWithVariable(data) {
        try {
            if (lodash_1.isString(data)) {
                data = data.split('.');
                return { "$sum": "$" + data[data.length - 1] };
            }
            else {
                return { "$sum": data };
            }
        }
        catch (e) {
            return e["message"];
        }
    }
    sumForProject(d1, d2) {
        try {
            return { "$sum": ["$" + d1, "$" + d2] };
        }
        catch (e) {
            return e["message"];
        }
    }
    slice(d1, d2) {
        try {
            // if (isNumber(d1)) {
            //     d1 = parseInt(d1)
            // }
            if (lodash_1.isString(d1)) {
                d1 = "$" + d1;
            }
            // if (isNumber(d2)) {
            //     d2 = parseInt(d2)
            // }
            if (lodash_1.isString(d2)) {
                d2 = "$" + d2;
            }
            return { "$slice": [d1, d2] };
        }
        catch (e) {
            return e["message"];
        }
    }
    add(d1, d2) {
        try {
            return { "$add": ["$" + d1, util_1.isNumber(d2) ? d2 : "$" + d2] };
        }
        catch (e) {
            return e["message"];
        }
    }
    toStringForGroupBy(data) {
        try {
            let newData = data.split('.');
            if (newData.length > 1) {
                newData.shift();
            }
            return { "$toString": "$" + newData };
        }
        catch (e) {
            return e["message"];
        }
    }
    push(key) {
        try {
            let data;
            if (key.includes('.')) {
                data = key.split('.');
                data.shift();
            }
            else {
                data = key;
            }
            return { "$push": "$" + data };
        }
        catch (e) {
            return e["message"];
        }
    }
    IfNull(data1, data2) {
        try {
            if (lodash_1.isString(data1)) {
                data1 = data1.split('.');
                if (data1.length > 1) {
                    data1.shift();
                }
                return { "$ifNull": ["$" + data1, (!util_1.isNullOrUndefined(data2) && data2 != '') ? "$" + data2 : ""] };
            }
            else {
                return { "$ifNull": [data1, data2] };
            }
        }
        catch (e) {
            return e["message"];
        }
    }
    arrayElemAt(array, pos) {
        try {
            let newD;
            if (array.includes('.')) {
                newD = array.split('.');
                newD.shift();
            }
            else {
                newD = array;
            }
            return { "$arrayElemAt": ["$" + newD, "$" + pos] };
        }
        catch (e) {
            return e["message"];
        }
    }
    toInt(data) {
        try {
            let newData;
            if (data.includes('.')) {
                newData = data.split('.');
                newData.shift();
            }
            else {
                newData = data;
            }
            return { "$toInt": "$" + newData };
        }
        catch (e) {
            return e["message"];
        }
    }
    Substring(mystr, f, l) {
        try {
            return mystr.substring(f, l);
        }
        catch (e) {
            return e["message"];
        }
    }
    Split(str, splitBy, index) {
        try {
            let arr = str.split(splitBy);
            if (index == "l") {
                return arr.length;
            }
            else if (util_1.isNullOrUndefined(index)) {
                return arr[arr.length - 1];
            }
            else {
                return arr[index];
            }
        }
        catch (e) {
            return e["message"];
        }
    }
    convertDoubleToSingle(string) {
        try {
            return string.replace(/["]/g, "'");
        }
        catch (e) {
            return e["message"];
        }
    }
    restartFailedExcel(input, output) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let query1 = [{ "$match": { "eventStatus": /failed/i } }, { "$sort": { "orgId": 1 } }, { "$project": { "orgId": { "$toString": "$orgId" }, "eventId": { "$toString": "$_id" }, "botName": "$currentEventStatus.statusName", "createdAt": 1, "updatedAt": 1 } }];
                let finalData = yield db.collection("events").aggregate(query1);
                let filePath = input.filePath ? input.filePath : `${config.path.replace(/\/$/, '')}/${Date.now()}.xlsx`;
                let sheetName = input.sheetName ? input.sheetName : "FailedBot";
                let resPath = yield this.exportExcelPath(filePath, finalData, sheetName, Object.keys(finalData[0]));
                console.log("File Generated------------->", resPath);
                console.log("Result----", finalData);
                output["filepath"] = resPath;
                return { message: '', status: 0, data: output };
            }
            catch (e) {
                console.log('bot1 Error', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    findQuery(collectionName, matchKey, matchValue, resultKey, distinct = false, one = false, filter = '', input = {}, orKey = null) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let match = {};
                if (Array.isArray(matchValue)) {
                    match[matchKey] = { "$in": matchValue };
                }
                else {
                    match[matchKey] = matchValue;
                }
                if (!util_1.isNullOrUndefined(filter)) {
                    let filterArr = filter.split(',');
                    filterArr.forEach((key) => {
                        if (!util_1.isNullOrUndefined(key) && input[key]) {
                            if (key === 'organisation') {
                                match[key] = ObjectId(input['orgId']);
                            }
                            else {
                                match[key] = ObjectId(input[key]);
                            }
                        }
                    });
                }
                if (!util_1.isNullOrUndefined(orKey)) {
                    match = { $or: [match, orKey] };
                }
                console.log("Match------", match);
                let data = yield (db.collection(collectionName)).find(match).lean();
                data = JSON.parse(JSON.stringify(data));
                data = JSON.parse((JSON.stringify(data)).replace(/\\n/g, ' '));
                console.log("Data-------", data.length);
                if (resultKey == 'self') {
                    return data;
                }
                else if (resultKey.includes('+')) {
                    let keys = resultKey.split('+').map(a => a.trim());
                    data = data.map(a => keys.map(k => a[k]).join(" "));
                }
                else if (resultKey.includes('.')) {
                    let nestedKeys = resultKey.split('.');
                    data = data.map(a => {
                        let nestedValue = a;
                        for (const key of nestedKeys) {
                            nestedValue = nestedValue[key];
                        }
                        return nestedValue;
                    });
                }
                else {
                    data = data.map(a => a[resultKey]);
                }
                if (distinct) {
                    data = [...new Set(data)];
                }
                return one ? data[0] : data;
            }
            catch (e) {
                console.log("Errr-----", e);
                return [];
            }
        });
    }
    findAndUpdateManyQuery(collectionName, matchObj, updateObj, type = 'set') {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("Match------", matchObj, updateObj);
                let data;
                if (type == 'push') {
                    data = yield (db.collection(collectionName)).updateMany(matchObj, { $push: updateObj });
                    console.log("Result----", data);
                }
                else {
                    data = yield (db.collection(collectionName)).updateMany(matchObj, { $set: updateObj });
                    console.log("Result----", data);
                }
                return data;
            }
            catch (e) {
                console.log("Errr-----", e);
                return [];
            }
        });
    }
    findAndUpdateQuery(collectionName, matchObj, updateObj, type = 'set') {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("Match------", matchObj, updateObj);
                let data;
                if (type == 'push') {
                    data = yield (db.collection(collectionName)).findOneAndUpdate(matchObj, { $push: updateObj });
                    console.log("Result----", data);
                }
                else {
                    data = yield (db.collection(collectionName)).findOneAndUpdate(matchObj, { $set: updateObj });
                    console.log("Result----", data);
                }
                return data;
            }
            catch (e) {
                console.log("Errr-----", e);
                return [];
            }
        });
    }
    findQuerywithObj(collectionName, matchObj, resultKey, distinct = false, one = false) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("Match------", matchObj, resultKey);
                let data = yield (db.collection(collectionName)).find(matchObj).lean();
                data = JSON.parse(JSON.stringify(data));
                console.log("Data-------", data.length);
                if (resultKey == 'self') {
                    return one ? data[0] : data;
                }
                else if (resultKey == 'length') {
                    return data.length;
                }
                else if (resultKey.includes('+')) {
                    let keys = resultKey.split('+').map(a => a.trim());
                    data = data.map(a => keys.map(k => a[k]).join(" "));
                }
                else if (resultKey.includes('.')) {
                    let nestedKeys = resultKey.split('.');
                    data = data.map(a => {
                        let nestedValue = a;
                        for (const key of nestedKeys) {
                            nestedValue = nestedValue[key];
                        }
                        return nestedValue;
                    });
                }
                else {
                    data = data.map(a => a[resultKey]);
                }
                if (distinct) {
                    data = [...new Set(data)];
                }
                return one ? data[0] : data;
            }
            catch (e) {
                console.log("Errr-----", e);
                return [];
            }
        });
    }
    insertQuery(collectionName, insertObj) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!Array.isArray(insertObj)) {
                    insertObj = [insertObj];
                }
                console.log("Match------", insertObj);
                let data = yield (db.collection(collectionName)).insertMany(insertObj);
                console.log("Result----", data);
                return data;
            }
            catch (e) {
                console.log("Errr-----", e);
                return [];
            }
        });
    }
    merge_array(inputArr, mergeArr, inputField, mergeField, fieldsRequired, defaultValue = {}) {
        try {
            let result = inputArr.reduce((final, el) => {
                let filterMergeArr = mergeArr.find(it => {
                    return inputField.every((inp, i) => it[inp] == el[mergeField[i]]);
                });
                if (filterMergeArr) {
                    let output = Object.assign({}, el, filterMergeArr);
                    let outputObj = {};
                    if (fieldsRequired.length > 0) {
                        for (let key in output) {
                            if (fieldsRequired.includes(key)) {
                                outputObj[key] = output[key];
                            }
                        }
                        final.push(outputObj);
                    }
                    else {
                        final.push(output);
                    }
                }
                else {
                    for (let key in defaultValue) {
                        if (defaultValue[key]) {
                            el[key] = el[defaultValue[key]];
                        }
                        else {
                            el[key] = defaultValue[key];
                        }
                    }
                    final.push(el);
                }
                return final;
            }, []);
            return result;
        }
        catch (e) {
            console.log("Errr-----", e);
            return [];
        }
    }
    lookUpCount(collectionName, fieldsOnSearch, valuesToSearch) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let query = {};
                let count = 0;
                if (!util_1.isNullOrUndefined(valuesToSearch) && !util_1.isNullOrUndefined(fieldsOnSearch) && Array.isArray(valuesToSearch) && Array.isArray(fieldsOnSearch) && valuesToSearch.length == fieldsOnSearch.length) {
                    fieldsOnSearch.forEach(element => {
                        query[element] = valuesToSearch[count];
                        count++;
                    });
                    const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                    const db = yield mClient.db(env_2.env.dbConfig.dbname);
                    let result = yield db.collection(collectionName).find(query).count();
                    return result;
                }
                else {
                    return "please send currect input";
                }
            }
            catch (err) {
                return err["message"];
            }
        });
    }
    handleNewLine(input, outputParams) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const theText = input.theText;
                let output;
                output = theText.replace(/\n/g, '\\n');
                //output = output.replace(/'/g, '’').replace(/"/g, '“').replace(/“/g, '”');
                output = output.replace(/'/g, '’');
                outputParams['output'] = output;
                console.log("shivam---------------------------------------------------------");
                console.log(outputParams);
                console.log("shivam---------------------------------------------------------");
                return { message: '', status: 0, data: outputParams };
            }
            catch (e) {
                return { message: '', status: 1, data: e };
            }
        });
    }
    convertToSafeSnakeCase(inputStr, outputStr) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                return inputStr
                    .toLowerCase()
                    .replace(/[^a-z0-9\s]/g, '')
                    .trim()
                    .replace(/\s+/g, '_');
            }
            catch (e) {
                console.log("error while converting to safe snake case");
                return "";
            }
        });
    }
    replacePlaceholders(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const emailsArray = input.emailsArray; // Array of email objects
                const collectionName = input.collectionName; // Dynamic collection name
                const queryContents = input.query; // Dynamic query contents
                const emailKey = input.emailKey; // Dynamic key name for email address
                // Validate emailsArray
                if (!emailsArray || !Array.isArray(emailsArray)) {
                    throw new Error("Invalid input: emailsArray must be an array");
                }
                // Validate collectionName
                if (!collectionName || typeof collectionName !== 'string') {
                    throw new Error("Invalid input: collectionName must be provided as a string");
                }
                // Validate emailKey
                if (!emailKey || typeof emailKey !== 'string') {
                    throw new Error("Invalid input: emailKey must be provided as a string");
                }
                // Validate queryContents
                if (!queryContents || typeof queryContents !== 'string') {
                    throw new Error("Invalid input: query must be provided as a string");
                }
                // Convert query string to object
                let queryObject;
                try {
                    // Clean up the string and convert it to a valid JSON format
                    const cleanedQuery = queryContents.replace(/'/g, '"'); // Replace single quotes with double quotes
                    queryObject = JSON.parse(`{${cleanedQuery}}`); // Wrap it in curly braces to make it a valid JSON object
                }
                catch (error) {
                    throw new Error("Invalid query format. Make sure it's a valid string.");
                }
                // Extract all unique email addresses from the emailsArray
                const emailAddresses = [...new Set(emailsArray.map(email => email.to))]; // Assuming the "to" field is the email address
                // Dynamically set the email key in the query object
                queryObject[emailKey] = { $in: emailAddresses }; // Use the dynamic key for email address
                // Retrieve all lead documents with the matching criteria in a single DB query
                const leads = yield this.findQuerywithObj(collectionName, queryObject, 'self', false, false);
                const leadsMap = {};
                // Convert the leads array into a dictionary for faster lookups
                leads.forEach(lead => {
                    leadsMap[lead[emailKey]] = lead; // Use the dynamic emailKey for the lead lookup
                });
                const placeholderRegex = /{{(.*?)}}/g; // Regex to capture placeholders like {{variable_name}}
                // Filter out emails that do not have a corresponding lead
                const processedEmails = emailsArray.filter(email => {
                    const toEmail = email.to; // Assuming 'to' field contains the email address
                    const lead = leadsMap[toEmail];
                    // Find all placeholders in the body text
                    const placeholders = email.body.match(placeholderRegex);
                    if (placeholders === null) {
                        return true;
                    }
                    if (!lead) {
                        console.warn(`No lead found for email: ${toEmail}`);
                        return false; // Exclude this email if no corresponding lead data is found
                    }
                    if (placeholders) {
                        for (let placeholder of placeholders) {
                            // Extract the variable name between the curly braces
                            const variableName = placeholder.slice(2, -2).trim();
                            // Get the value from the lead document or use an empty string if not found
                            const value = lead[variableName] || '';
                            // Replace the placeholder with the fetched value
                            email.body = email.body.replace(new RegExp(`{{${variableName}}}`, 'g'), value);
                        }
                    }
                    return true; // Keep the email if matching lead data was found and processed
                });
                console.log("Processed emails count ===>", processedEmails.length);
                // Add the processed emailsArray to the output parameters
                outputParameters['processedEmails'] = processedEmails;
                outputParameters['emailsCount'] = processedEmails.length;
                // Return success status with processed email data
                return { message: '', status: 0, data: outputParameters };
            }
            catch (ex) {
                console.log("Error in replacePlaceholders--", ex);
                return { message: '', status: 1, data: ex };
            }
        });
    }
    logSentEmails(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const { campaignId, senderEmailId, receiverEmailId, messageId, userId, subscriberId, orgId } = input;
                const docData = {
                    userId: ObjectId(userId),
                    subscriberId: ObjectId(subscriberId),
                    orgId: ObjectId(orgId),
                    campaignId: ObjectId(campaignId),
                    senderEmailId: senderEmailId,
                    receiverEmailId: receiverEmailId,
                    messageId: messageId,
                    isDeleted: false,
                    createdAt: new Date()
                };
                yield db.collection('emails_sent_logs').create(docData);
                output['message'] = "Success";
                return { message: '', status: 0, data: output };
            }
            catch (e) {
                console.log('bot2 Error', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    toObjectId(input) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const output = ObjectId(input);
                return output;
            }
            catch (e) {
                console.log("Error occurred while converting to Object Id", e);
                return -1;
            }
        });
    }
    extractField(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const { theArray, fieldName } = input;
                let arrayData;
                if (typeof theArray === 'string') {
                    const fileContent = fs.readFileSync(theArray, { encoding: 'utf8' });
                    arrayData = JSON.parse(fileContent);
                }
                else if (Array.isArray(theArray)) {
                    arrayData = theArray;
                }
                else {
                    throw new Error('Invalid input: theArray should be an array or a JSON file path.');
                }
                output['outputArray'] = arrayData.map(item => item[fieldName]);
                return { message: '', status: 0, data: output };
            }
            catch (e) {
                console.error('Error while extracting field:', e);
                return { message: 'Error while extracting field', status: 1, data: e };
            }
        });
    }
    isEligible(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const { emailsArray, campaignId, maxPerDay, maxPerWeek, subscriberId, orgId } = input;
                const eligibleEmails = [];
                for (const emailObj of emailsArray) {
                    const { to } = emailObj;
                    // Convert receiverEmailId and campaignId to ObjectId for the query
                    const receiverEmailIdObj = to;
                    const campaignIdObj = ObjectId(campaignId);
                    const subscriberIdObj = ObjectId(subscriberId);
                    const orgIdObj = ObjectId(orgId);
                    console.log(campaignIdObj);
                    console.log(subscriberIdObj);
                    // Get the current date and calculate the time bounds for the checks
                    const todayStart = moment().startOf('day').toDate();
                    const oneWeekAgo = moment().subtract(7, 'days').toDate();
                    // Initialize the condition for checking if the email can be sent
                    let canSendEmail = true;
                    // If maxPerDay is defined, check daily limit
                    if (maxPerDay) {
                        const emailsSentToday = yield db.collection('emails_sent_logs').countDocuments({
                            receiverEmailId: receiverEmailIdObj,
                            //campaignId: campaignIdObj,
                            subscriberId: subscriberIdObj,
                            orgId: orgIdObj,
                            isDeleted: false,
                            createdAt: { $gte: todayStart }
                        });
                        // Check daily limit
                        if (emailsSentToday >= maxPerDay) {
                            canSendEmail = false;
                        }
                    }
                    // If maxPerWeek is defined, check weekly limit
                    if (maxPerWeek) {
                        const emailsSentThisWeek = yield db.collection('emails_sent_logs').countDocuments({
                            receiverEmailId: receiverEmailIdObj,
                            //campaignId: campaignIdObj,
                            subscriberId: subscriberIdObj,
                            orgId: orgIdObj,
                            isDeleted: false,
                            createdAt: { $gte: oneWeekAgo }
                        });
                        // Check weekly limit
                        if (emailsSentThisWeek >= maxPerWeek) {
                            canSendEmail = false;
                        }
                    }
                    // If the email is eligible, push it to the eligibleEmails array
                    if (canSendEmail) {
                        eligibleEmails.push(emailObj);
                    }
                }
                output['eligibleEmails'] = eligibleEmails;
                return { message: '', status: 0, data: output };
            }
            catch (e) {
                console.log('Error in isEligible function:', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    distributeEmails(input, output) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const { toEmails, fromEmails, subject, body, subscriberId, orgId } = input; // Include orgId in input
                const emailsToSend = [];
                // Get the start of the day for today's date
                const todayStart = new Date();
                todayStart.setHours(0, 0, 0, 0);
                // Step 1: Fetch the maximum emails per day for each sender
                const maxEmailsConfig = yield db.collection('email_details').find({
                    email_address: { $in: fromEmails },
                    subscriberId: ObjectId(subscriberId),
                    orgId: ObjectId(orgId),
                    isDeleted: false // Check for isDeleted if necessary
                }).lean();
                // Create a mapping of from emails to their max email limits
                const maxEmailsMap = {};
                const replyToMap = {};
                maxEmailsConfig.forEach(user => {
                    maxEmailsMap[user.email_address] = parseInt(user.max_emails, 10);
                    replyToMap[user.email_address] = user.reply_to || '';
                });
                // Step 2: Prepare emails to send
                const senderUsage = {}; // Track how many emails have been sent from each sender
                for (let toEmail of toEmails) {
                    if (toEmail && toEmail.includes(':')) {
                        toEmail = toEmail.split(':')[1];
                    }
                    // Step to fetch past senders for the current recipient
                    const pastSenders = yield db.collection('emails_sent_logs').distinct("senderEmailId", {
                        receiverEmailId: toEmail,
                        subscriberId: ObjectId(subscriberId),
                        orgId: ObjectId(orgId),
                        isDeleted: false
                    });
                    // Track valid senders for this recipient
                    const validSenders = [];
                    // Track if a match is found between past senders and current fromEmails
                    let pastSenderMatchFound = false;
                    for (const fromEmail of fromEmails) {
                        // Count how many emails have been sent today from this sender
                        const sentFromCount = yield db.collection('emails_sent_logs').countDocuments({
                            senderEmailId: fromEmail,
                            subscriberId: ObjectId(subscriberId),
                            orgId: ObjectId(orgId),
                            createdAt: { $gte: todayStart },
                            isDeleted: false
                        });
                        // Total emails sent for this fromEmail including today's
                        const totalSent = (senderUsage[fromEmail] || 0) + sentFromCount;
                        // Check if the current sender can still send emails today
                        if (totalSent < maxEmailsMap[fromEmail]) {
                            if (pastSenders && pastSenders.length > 0) {
                                // Only consider senders that have sent to this recipient in the past
                                if (pastSenders && pastSenders.includes(fromEmail)) {
                                    validSenders.push(fromEmail); // Add past sender if found
                                    pastSenderMatchFound = true;
                                }
                            }
                            else {
                                // If there are no past senders, add the sender to validSenders
                                validSenders.push(fromEmail);
                            }
                        }
                    }
                    // Fallback: If no past sender matches but there are still valid senders
                    if (!pastSenderMatchFound && validSenders.length === 0 && pastSenders.length > 0) {
                        // Add any valid current sender if none of the past senders match
                        for (const fromEmail of fromEmails) {
                            const sentFromCount = yield db.collection('emails_sent_logs').countDocuments({
                                senderEmailId: fromEmail,
                                subscriberId: ObjectId(subscriberId),
                                orgId: ObjectId(orgId),
                                createdAt: { $gte: todayStart },
                                isDeleted: false
                            });
                            const totalSent = (senderUsage[fromEmail] || 0) + sentFromCount;
                            if (totalSent < maxEmailsMap[fromEmail]) {
                                validSenders.push(fromEmail); // Add any available sender from current fromEmails
                            }
                        }
                    }
                    // Randomize valid senders and assign one to the recipient
                    const shuffledSenders = validSenders.sort(() => Math.random() - 0.5);
                    // If we have valid senders, send an email
                    if (shuffledSenders.length > 0) {
                        const fromEmail = shuffledSenders[0]; // Pick the first sender from shuffled valid senders
                        const replyTo = replyToMap[fromEmail];
                        if (replyTo !== '') {
                            emailsToSend.push({ from: fromEmail, to: toEmail, subject, body, replyTo });
                        }
                        else {
                            emailsToSend.push({ from: fromEmail, to: toEmail, subject, body });
                        }
                        senderUsage[fromEmail] = (senderUsage[fromEmail] || 0) + 1; // Increment usage
                    }
                }
                // Shuffle the final output array to randomize the order of emails
                const shuffledEmailsToSend = emailsToSend.sort(() => Math.random() - 0.5);
                // Add shuffled emails to the output
                output['emailsToSend'] = shuffledEmailsToSend;
                return { message: 'Emails prepared successfully', status: 0, data: output };
            }
            catch (e) {
                console.log('Error in distributeEmails function:', e);
                return { message: 'Failed to prepare emails', status: 1, data: e };
            }
        });
    }
    createTemplate(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let { access_token, whatsapp_business_account_id, temp_name, content } = input;
                const url = `https://graph.facebook.com/v20.0/${whatsapp_business_account_id}/message_templates`;
                const header = `-H "Content-Type: Application/json" -H "Authorization: Bearer ${access_token}"`;
                const data = {
                    "name": temp_name,
                    "category": "marketing",
                    "allow_category_change": true,
                    "language": "en_US",
                    "components": [
                        {
                            "type": "BODY",
                            "text": content
                        }
                    ]
                };
                const curlCommand = `curl -s -X POST "${url}" ${header} -d '${JSON.stringify(data)}'`;
                const execAsync = util_2.promisify(exec);
                // Execute the curl command
                const { stdout, stderr } = yield execAsync(curlCommand);
                if (stderr) {
                    console.error(`stderr: ${stderr}`);
                    return { message: stderr, status: 1 };
                }
                if (stdout) {
                    const jsonResponse = JSON.parse(stdout);
                    output['status'] = jsonResponse;
                }
                return { message: '', status: 0, data: output };
            }
            catch (e) {
                console.log('bot2 Error', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    retrieveTemplates(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let { access_token, whatsapp_business_account_id, fields } = input;
                if (util_1.isNullOrUndefined(fields)) {
                    fields = "";
                }
                const url = `https://graph.facebook.com/v20.0/${whatsapp_business_account_id}/message_templates?fields=${fields}&access_token=${access_token}`;
                const curlCommand = `curl -s -X GET "${url}"`;
                const execAsync = util_2.promisify(exec);
                // Execute the curl command
                const { stdout, stderr } = yield execAsync(curlCommand);
                if (stderr) {
                    console.error(`stderr: ${stderr}`);
                    return { message: stderr, status: 1 };
                }
                try {
                    // Attempt to parse the JSON response
                    const jsonResponse = JSON.parse(stdout);
                    const templates = [];
                    const templatesObj = [];
                    for (let template of jsonResponse.data) {
                        if (template.status === 'APPROVED') {
                            templates.push(template.name);
                            const name = template.name;
                            const text = template.components[0].text;
                            const obj = {
                                'name': name,
                                'text': text
                            };
                            templatesObj.push(obj);
                        }
                    }
                    if (!output) {
                        output = {};
                    }
                    output['templates'] = templates;
                    output['templatesObj'] = templatesObj;
                    console.log(`Parsed Response:`, jsonResponse);
                }
                catch (e) {
                    console.error(`Error parsing JSON response: ${e.message}`);
                    console.log(`Raw Response: ${stdout}`);
                }
                return { message: '', status: 0, data: output };
            }
            catch (e) {
                console.log('bot2 Error', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    sendWhatsAppMsg(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const { access_token, phone_num_id, business_account_id, message_type, message, temp_name, template_header_data, template_body_data } = input;
                let { recipient } = input;
                if (!Array.isArray(recipient)) {
                    recipient = [String(recipient)];
                }
                let data;
                if (message_type.toLowerCase() === "text") {
                    data = {
                        messaging_product: "whatsapp",
                        to: recipient,
                        type: "text",
                        text: {
                            body: message,
                        },
                    };
                }
                else if (message_type.toLowerCase() === "template") {
                    let headerParameters = [];
                    let new_template_header_data = [];
                    if (template_header_data.length > 0) {
                        new_template_header_data = template_header_data.split(",");
                    }
                    if (new_template_header_data.length > 0) {
                        let theJson;
                        if (new_template_header_data[0] == 'text') {
                            theJson = {
                                type: new_template_header_data[0],
                                text: new_template_header_data[1]
                            };
                        }
                        else if (new_template_header_data[0] == 'image') {
                            theJson = {
                                type: new_template_header_data[0],
                                image: {
                                    link: new_template_header_data[1]
                                }
                            };
                        }
                        else if (new_template_header_data[0] == 'video') {
                            theJson = {
                                type: new_template_header_data[0],
                                video: {
                                    link: new_template_header_data[1]
                                }
                            };
                        }
                        else if (new_template_header_data[0] == 'document') {
                            theJson = {
                                type: new_template_header_data[0],
                                document: {
                                    link: new_template_header_data[1]
                                }
                            };
                        }
                        headerParameters.push(theJson);
                    }
                    let bodyParameters = [];
                    let new_template_body_data = [];
                    if (template_body_data.length > 0) {
                        new_template_body_data = template_body_data.split(",");
                    }
                    for (let i = 0; i < new_template_body_data.length; i++) {
                        bodyParameters[i] = {
                            type: "text",
                            text: new_template_body_data[i],
                        };
                    }
                    data = {
                        messaging_product: "whatsapp",
                        to: recipient,
                        type: "template",
                        template: {
                            name: temp_name,
                            language: {
                                code: "en_US",
                            },
                            components: [
                                {
                                    type: "HEADER",
                                    parameters: headerParameters
                                },
                                {
                                    type: "BODY",
                                    parameters: bodyParameters,
                                }
                            ],
                        },
                    };
                }
                let content = "";
                if (data.type === 'template') {
                    const temp_name = data.template.name;
                    const url = `https://graph.facebook.com/v20.0/${business_account_id}/message_templates?name=${temp_name}&access_token=${access_token}`;
                    const curlCommand = `curl -s -X GET "${url}"`;
                    const execAsync = util_2.promisify(exec);
                    // Execute the curl command
                    const { stdout, stderr } = yield execAsync(curlCommand);
                    if (stderr) {
                        console.error(`stderr: ${stderr}`);
                        return { message: stderr, status: 1 };
                    }
                    try {
                        // Attempt to parse the JSON response
                        const jsonResponse = JSON.parse(stdout);
                        const template = jsonResponse.data;
                        const message = template[0].components[1].text;
                        content = message;
                    }
                    catch (e) {
                        console.error(`Error parsing JSON response: ${e.message}`);
                        console.log(`Raw Response: ${stdout}`);
                    }
                }
                for (let i = 0; i < recipient.length; i++) {
                    try {
                        // Adding this because first time it is json but from second time it becomes string and we can't edit the recipient on string
                        try {
                            data = JSON.parse(data);
                        }
                        catch (e) {
                            data = data;
                        }
                        if (recipient[i] == null) {
                            continue;
                        }
                        recipient[i] = String(recipient[i]);
                        const num = recipient[i].trim().replace(/^\+/, ''); // Remove '+' if present
                        const isValid = /^\d+$/.test(num);
                        if (isValid && num.length == 10) {
                            data.to = "91" + num;
                        }
                        else if (isValid) {
                            data.to = num;
                        }
                        else {
                            continue;
                        }
                        data = JSON.stringify(data);
                        const url = `https://graph.facebook.com/v19.0/${phone_num_id}/messages`;
                        const curlCommand = `curl -s -X POST ${url} -H "Content-Type: application/json" -H "Authorization: Bearer ${access_token}" -d '${data}' --connect-timeout 10 --retry 3 --retry-delay 2`;
                        const execAsync = util_2.promisify(exec);
                        // Execute the curl command
                        try {
                            const { stdout, stderr } = yield execAsync(curlCommand);
                            if (stderr) {
                                console.error(`stderr: ${stderr}`);
                                return { message: stderr, status: 1 };
                            }
                            if (stdout) {
                                const jsonResponse = JSON.parse(stdout);
                                const obj = {
                                    'message_id': jsonResponse.messages[0].id,
                                    'message': content,
                                    'wa_id': jsonResponse.contacts[0].wa_id,
                                    'phone_number_id': `${phone_num_id}`,
                                    'template_name': temp_name,
                                    'source': 'sent',
                                    'campaignId': ObjectId(input.campaignId),
                                    'userId': ObjectId(input.userId),
                                    'subscriberId': ObjectId(input.subscriberId),
                                    'orgId': ObjectId(input.orgId)
                                };
                                yield (db.collection('whatsapp_sent_logs', { timestamps: true })).create(obj);
                            }
                        }
                        catch (e) {
                            console.log('Error sending whatsapp message', e);
                        }
                    }
                    catch (e) {
                        console.error("Something went wrong while sending whatsapp message:", e);
                        continue;
                    }
                }
                //outPut['response'] = jsonResponse;
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                console.log('bot2 Error', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    uploadSheet(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            var e_1, _a, e_2, _b;
            try {
                function generateFormOutput(metadata, fieldValues) {
                    let result = [];
                    metadata.forEach((metaObject) => {
                        let nameOutput = {};
                        metaObject.childTable.forEach((field) => {
                            const groupPrototypeField = metaObject.groupPrototype.find(group => group.label === field.parameterName);
                            if (groupPrototypeField) {
                                if (fieldValues.hasOwnProperty(field.parameterName)) {
                                    const fieldValue = fieldValues[field.parameterName];
                                    nameOutput[groupPrototypeField.id] = fieldValue;
                                }
                            }
                        });
                        if (Object.keys(nameOutput).length > 0) {
                            result.push({
                                name: metaObject.name,
                                data: nameOutput,
                                required: metaObject.mandatoryField,
                                id: metaObject.realId
                            });
                        }
                    });
                    return result;
                }
                function getRowCount(filepath) {
                    return tslib_2.__awaiter(this, void 0, void 0, function* () {
                        return new Promise((resolve, reject) => {
                            yauzl.open(filepath, { lazyEntries: true }, (err, zipfile) => {
                                if (err)
                                    return reject(err);
                                const sheetMap = {};
                                const rowCounts = {};
                                let workbookProcessed = false;
                                zipfile.on('entry', (entry) => {
                                    if (!workbookProcessed && entry.fileName === 'xl/workbook.xml') {
                                        // Process workbook.xml to map sheet IDs to names
                                        workbookProcessed = true;
                                        zipfile.openReadStream(entry, (err, stream) => {
                                            if (err)
                                                return reject(err);
                                            const parser = sax.createStream(true);
                                            parser.on('opentag', (node) => {
                                                if (node.name === 'sheet' && node.attributes.name && node.attributes.sheetId) {
                                                    sheetMap[node.attributes.sheetId] = node.attributes.name;
                                                }
                                            });
                                            parser.on('end', () => {
                                                stream.destroy();
                                                zipfile.readEntry(); // Continue processing other entries
                                            });
                                            stream.pipe(parser);
                                        });
                                    }
                                    else if (entry.fileName.match(/^xl\/worksheets\/sheet\d+\.xml$/)) {
                                        // Process sheet files
                                        const sheetIdMatch = entry.fileName.match(/^xl\/worksheets\/sheet(\d+)\.xml$/);
                                        const sheetId = sheetIdMatch && sheetIdMatch[1];
                                        const sheetName = sheetMap[sheetId];
                                        if (sheetName === 'DropdownValues') {
                                            zipfile.readEntry(); // Skip this sheet
                                            return;
                                        }
                                        zipfile.openReadStream(entry, (err, stream) => {
                                            if (err)
                                                return reject(err);
                                            const parser = sax.createStream(true);
                                            parser.on('opentag', (node) => {
                                                if (node.name === 'dimension' && node.attributes.ref) {
                                                    const range = node.attributes.ref.split(':').pop(); // e.g., "A1:Z1000" → "Z1000"
                                                    const rowCount = parseInt(range.replace(/[A-Z]/g, ''), 10);
                                                    rowCounts[sheetName || `Unknown Sheet ${sheetId}`] = rowCount;
                                                }
                                            });
                                            parser.on('end', () => {
                                                stream.destroy();
                                                zipfile.readEntry(); // Continue processing other entries
                                            });
                                            stream.pipe(parser);
                                        });
                                    }
                                    else {
                                        zipfile.readEntry(); // Skip other files
                                    }
                                });
                                zipfile.on('end', () => resolve(rowCounts)); // Resolve with row counts
                                zipfile.on('error', reject);
                                zipfile.readEntry(); // Start processing entries
                            });
                        });
                    });
                }
                function doRealWork(referenceObj, columnsToDelete, structure, jsonData, mergedResults) {
                    return tslib_2.__awaiter(this, void 0, void 0, function* () {
                        const tasks = [];
                        for (const task of jsonData) {
                            const valuesToSave = [];
                            const newStructure = [];
                            const addInfos = [];
                            for (const theItem in referenceObj) {
                                const new_headers = {
                                    'authorization': 'Bearer ' + token,
                                    'content-type': "application/json",
                                    "orgId": orgId,
                                    "selectedorgid": orgId
                                };
                                const objToInsert = Object.assign({}, referenceObj[theItem]);
                                const a = objToInsert.keys;
                                const b = objToInsert.values;
                                for (let j = 0; j < a.length; j++) {
                                    objToInsert[a[j]] = task[b[j]];
                                }
                                delete objToInsert['keys'];
                                delete objToInsert['values'];
                                const options = {
                                    method: 'POST',
                                    url: process.env.Application_URL + "gibots-api/crud/save",
                                    headers: new_headers,
                                    body: objToInsert,
                                    json: true
                                };
                                valuesToSave.push(options);
                            }
                            for (const theItem of columnsToDelete) {
                                delete task[theItem];
                            }
                            structure.forEach(item => {
                                if (item.type === "table") {
                                    item.childTable.forEach(child => {
                                        newStructure.push(Object.assign({}, child, { parentId: item.id, parentDisplayName: item.displayName }));
                                    });
                                }
                                else {
                                    newStructure.push(Object.assign({}, item));
                                }
                            });
                            const result = Object.keys(task).map(key => {
                                let isTable = false;
                                const match = newStructure.find(item => {
                                    if (item.parentDisplayName) {
                                        isTable = true;
                                        return item.parameterName === key;
                                    }
                                    else {
                                        isTable = false;
                                        return item.displayName === key;
                                    }
                                });
                                return {
                                    key: key,
                                    value: task[key],
                                    type: match ? match.type : null,
                                    table: isTable,
                                    required: match ? match.mandatoryField : false
                                };
                            });
                            const tables = generateFormOutput(mergedResults, task);
                            for (const table of tables) {
                                addInfos.push({
                                    "id": `${table.id}`,
                                    "value": [table.data],
                                    "label": table.name,
                                    "required": table ? table.required : false,
                                    "name": table.name,
                                    "addToTaskList": false
                                });
                            }
                            let ignore = false;
                            for (let i = 0; i < structure.length; i++) {
                                const the_structure = structure[i];
                                const match = result.find(item => item.key === the_structure.parameterName || item.key === the_structure.displayName);
                                const taskValue = task[the_structure.parameterName] || task[the_structure.displayName];
                                if (taskValue !== undefined && taskValue !== null) {
                                    if (match && match.table) {
                                        continue;
                                    }
                                    let val = taskValue;
                                    let convertToString = true;
                                    if (match && match.type === 'date') {
                                        // const excelEpoch = new Date(1899, 11, 30);
                                        // val = val == "" ? null : new Date(excelEpoch.getTime() + val * 86400000);
                                        const jsDate = new Date((val - 25569) * 86400 * 1000); // Convert to JS Date
                                        val = val == "" ? null : jsDate.getTime();
                                        convertToString = false;
                                    }
                                    else if (match && /multi/i.test(match.type)) {
                                        val = [val];
                                        convertToString = false;
                                    }
                                    const temp = {
                                        "id": `${i}`,
                                        "value": convertToString ? `${val}` : val,
                                        "label": the_structure.parameterName || the_structure.displayName,
                                        "required": match ? match.required : false,
                                        "name": the_structure.parameterName || the_structure.displayName,
                                        "addToTaskList": false
                                    };
                                    if (temp.required && (!temp.value || temp.value === "")) {
                                        ignore = true;
                                        break;
                                    }
                                    addInfos.push(temp);
                                }
                            }
                            if (ignore) {
                                failedCount++;
                                continue;
                            }
                            const tempObj = {
                                "accessControlList": theprocess.accessControlList,
                                "username": username,
                                "projectName": theprocess.name,
                                "taskDesc": "",
                                "projectId": theprocess._id,
                                "processId": theprocess.processId,
                                "customerId": theprocess.customerId,
                                "additionalInfo": addInfos,
                                "thingsToSave": valuesToSave
                            };
                            if (Array.isArray(theprocess.taskTemplateId) && theprocess.taskTemplateId.length > 1) {
                                tempObj['xtraTemplateIdsUsed'] = theprocess.taskTemplateId.filter((a, i) => i !== 0);
                            }
                            tasks.push(tempObj);
                        }
                        //const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
                        yield db.collection("events").updateMany({ "_id": eventId }, { "$set": { "additionalInfoVar.failedCount": failedCount } });
                        //await delay(delaySec);  // 1000ms = 1 second
                        const objs = [];
                        for (const task of tasks) {
                            const thingsToSave = task.thingsToSave;
                            if (thingsToSave && thingsToSave.length > 0) {
                                for (const thing of thingsToSave) {
                                    yield request(thing);
                                }
                            }
                            let body = {
                                accessControlList: task.accessControlList,
                                username: task.username,
                                projectName: task.projectName,
                                taskTemplateName: "",
                                taskDesc: "",
                                projectId: task.projectId,
                                processId: task.processId,
                                customerId: task.customerId,
                                additionalInfo: task.additionalInfo,
                                xtraTemplateIdsUsed: task.xtraTemplateIdsUsed,
                                parentEvent: {
                                    _id: eventId
                                }
                            };
                            objs.push(body);
                        }
                        try {
                            let options = {
                                "method": 'POST',
                                "url": env_2.env.routes.gibots_orch + "gibots-orch/event/addExecute/task",
                                "body": objs,
                                "headers": {
                                    'authorization': 'Bearer ' + token,
                                    'Content-Type': "application/json",
                                    "selectedorgid": orgId,
                                    "selectedgstin": "123456789876543"
                                },
                                json: true
                            };
                            let botResult = yield request(options);
                            if (botResult.status === 0) {
                                successCount += objs.length;
                            }
                            else {
                                failedCount += objs.length;
                            }
                            //console.log(botResult);
                            //results.push(botResult);
                            yield db.collection("events").updateMany({ "_id": eventId }, { "$set": { "additionalInfoVar.doneCount": successCount } });
                            yield db.collection("events").updateMany({ "_id": eventId }, { "$set": { "additionalInfoVar.failedCount": failedCount } });
                            //await delay(delaySec);  // 1000ms = 1 second
                        }
                        catch (e) {
                            console.log('Error processing task:', e);
                        }
                    });
                }
                const filepath = input.filepath;
                const theprocess = input.process;
                const username = input.userName;
                const token = yield this.createToken(input.userId, input.subscriberId, input.orgId);
                const orgId = input.orgId;
                const eventId = input.eventId;
                //const delayMS = input.delay || 10;
                //const delaySec = delayMS * 1000;
                const BATCH_SIZE = input.batchsize || 10;
                let failedCount = 0;
                let successCount = 0;
                if (theprocess.name === 'Smart AP') {
                    const workbook = new Excel.Workbook();
                    yield workbook.xlsx.readFile(filepath);
                    const sheetNameToUse = workbook.worksheets[0].name;
                    const worksheet = workbook.getWorksheet(sheetNameToUse);
                    if (!worksheet) {
                        throw new Error(`Sheet not found: ${sheetNameToUse}`);
                    }
                    const sheetData = [];
                    worksheet.eachRow((row) => {
                        const rowValues = row.values.slice(1);
                        if (rowValues.every((cell) => cell === null || cell === undefined || cell === "")) {
                            return;
                        }
                        sheetData.push(rowValues);
                    });
                    if (sheetData.length === 0) {
                        throw new Error("Sheet is empty");
                    }
                    const headers = sheetData[0].map(header => header.trim());
                    const validHeaders = headers.filter(header => header !== "");
                    const jsonData = sheetData.slice(1).map(row => {
                        const rowObject = {};
                        validHeaders.forEach((header, colIndex) => {
                            const cellValue = row[colIndex];
                            if (cellValue.type === Excel.ValueType.Date) {
                                rowObject[header] = cellValue.getTime();
                            }
                            else if (cellValue === null || cellValue === undefined || cellValue === "") {
                                rowObject[header] = "";
                            }
                            else {
                                rowObject[header] =
                                    typeof cellValue === "object" && cellValue !== null
                                        ? (cellValue.text || cellValue || "")
                                        : cellValue.toString().trim();
                            }
                        });
                        return rowObject;
                    }).filter(row => Object.values(row).some(value => value !== ""));
                    console.log(jsonData);
                }
                else {
                    const templateIds = theprocess.taskTemplateId;
                    const url = process.env.Application_URL + "gibots-orch/additionalInfo/list/get/multiple/" + templateIds;
                    const data = yield this.fetchTemplate(url, 'Bearer ' + token, input.orgId);
                    const structure = data.data.structure;
                    const addinfo = data.data.additionalInfo;
                    const mergedResults = [];
                    structure.forEach((item2, index) => {
                        if (item2.type === 'table' && item2.childTable && item2.childTable.length > 0) {
                            const firstChildName = item2.childTable[0].parameterName;
                            const matchingTables = addinfo.filter(item1 => {
                                return item1.name && item1.name.startsWith("myFormArray") &&
                                    item1.groupPrototype && item1.groupPrototype.some(prototype => prototype.label === firstChildName);
                            });
                            if (matchingTables.length > 0) {
                                matchingTables.forEach(matchingTable => {
                                    const mergedObject = Object.assign({}, matchingTable, item2, { realId: index, childTable: item2.childTable.map(child => {
                                            let relatedField;
                                            if (matchingTable.fields) {
                                                relatedField = matchingTable.fields.find(field => field.parameterName === child.parameterName);
                                            }
                                            return Object.assign({}, child, { relatedField: relatedField || null });
                                        }) });
                                    mergedResults.push(mergedObject);
                                });
                            }
                            else {
                                console.log('No matching table found for child:', firstChildName);
                            }
                        }
                    });
                    try {
                        const resp = yield getRowCount(filepath);
                        const rowCount = Number(Object.values(resp)[0]) - 1;
                        yield db.collection("events").updateMany({ "_id": eventId }, { "$set": { "additionalInfoVar.totalCount": rowCount } });
                        //console.log(`Total rows: ${rowCount}`);
                    }
                    catch (err) {
                        console.error('Error counting rows of excel:', err);
                    }
                    const workbook = new Excel.stream.xlsx.WorkbookReader(filepath);
                    let headers = [];
                    let validHeaders = [];
                    let batchData = [];
                    let rowCount = 0;
                    const referenceObj = {};
                    const columnsToDelete = [];
                    for (const item2 of structure) {
                        if (item2.additionalInfo && item2.additionalInfo !== '' && item2.freetext) {
                            const url = process.env.Application_URL + "gibots-orch/additionalInfo/list/get/multiple/" + item2.additionalInfo;
                            const data = yield fetch(url, {
                                headers: { 'Authorization': 'Bearer ' + token, 'orgId': input.orgId }
                            }).then(res => res.json());
                            const additionalStructure = data.data.structure;
                            const tablename = data.data.metadata.tableName;
                            const objToInsert = {
                                schema_name: tablename,
                                isMaster: false,
                                keys: [],
                                values: []
                            };
                            for (const item of additionalStructure) {
                                const fieldName = Array.isArray(item.FieldName) ? item.FieldName[0] : item.FieldName;
                                if (item.freetext && item.TableName && item.TableName !== '') {
                                    const innerObjToInsert = {
                                        schema_name: item.TableName,
                                        isMaster: false,
                                        keys: [fieldName],
                                        values: [item.displayName]
                                    };
                                    if (item.displayName !== item2.displayName) {
                                        referenceObj[item.displayName] = innerObjToInsert;
                                    }
                                    objToInsert['keys'].push(fieldName);
                                    objToInsert['values'].push(item.displayName);
                                }
                                else {
                                    objToInsert['keys'].push(fieldName);
                                    objToInsert['values'].push(item.displayName);
                                }
                                if (item.displayName !== item2.displayName) {
                                    columnsToDelete.push(item.displayName);
                                }
                            }
                            referenceObj[item2.displayName] = objToInsert;
                        }
                        else if (item2.freetext && item2.TableName && item2.TableName !== '') {
                            const fieldName = Array.isArray(item2.FieldName) ? item2.FieldName[0] : item2.FieldName;
                            referenceObj[item2.displayName] = {
                                schema_name: item2.TableName,
                                isMaster: false,
                                keys: [fieldName],
                                values: [item2.displayName]
                            };
                        }
                    }
                    try {
                        for (var workbook_1 = tslib_2.__asyncValues(workbook), workbook_1_1; workbook_1_1 = yield workbook_1.next(), !workbook_1_1.done;) {
                            const worksheet = workbook_1_1.value;
                            if (worksheet.name === "DropdownValues") {
                                continue;
                            }
                            //console.log(`Processing worksheet: ${worksheet.name}`);
                            let firstRowProcessed = false;
                            try {
                                for (var worksheet_1 = tslib_2.__asyncValues(worksheet), worksheet_1_1; worksheet_1_1 = yield worksheet_1.next(), !worksheet_1_1.done;) {
                                    const row = worksheet_1_1.value;
                                    if (!firstRowProcessed) {
                                        headers = row.values.slice(1) // Skip the first index (empty)
                                            .map(cell => (cell ? cell.toString().trim() : null));
                                        validHeaders = headers.filter(header => header !== "");
                                        firstRowProcessed = true;
                                        continue; // Skip further processing for the first row
                                    }
                                    const rowObject = {};
                                    let isRowEmpty = true;
                                    row.eachCell({ includeEmpty: true }, (cell, colNumber) => {
                                        const header = validHeaders[colNumber - 1];
                                        if (!header)
                                            return;
                                        if (cell.type === Excel.ValueType.Date) {
                                            rowObject[header] = cell.value.getTime();
                                            isRowEmpty = false;
                                        }
                                        else if (cell.type === Excel.ValueType.Number) {
                                            rowObject[header] = cell.value;
                                            isRowEmpty = false;
                                        }
                                        else if (cell.value === null || cell.value === undefined || cell.value === "") {
                                            rowObject[header] = "";
                                        }
                                        else {
                                            rowObject[header] = cell.value.toString().trim();
                                            isRowEmpty = false;
                                        }
                                    });
                                    if (!isRowEmpty) {
                                        batchData.push(rowObject);
                                        rowCount++;
                                    }
                                    if (rowCount % BATCH_SIZE === 0) {
                                        const jsonData = batchData.filter(row => Object.values(row).some(value => value !== ""));
                                        yield doRealWork(referenceObj, columnsToDelete, structure, jsonData, mergedResults);
                                        //console.log(`Processed a batch of ${jsonData.length} rows.`);
                                        batchData = []; // Reset batchData for the next batch
                                    }
                                }
                            }
                            catch (e_2_1) { e_2 = { error: e_2_1 }; }
                            finally {
                                try {
                                    if (worksheet_1_1 && !worksheet_1_1.done && (_b = worksheet_1.return)) yield _b.call(worksheet_1);
                                }
                                finally { if (e_2) throw e_2.error; }
                            }
                            // Process any remaining rows in the last batch for this worksheet
                            if (batchData.length > 0) {
                                const jsonData = batchData.filter(row => Object.values(row).some(value => value !== ""));
                                yield doRealWork(referenceObj, columnsToDelete, structure, jsonData, mergedResults);
                                //console.log(`Processed a batch of ${jsonData.length} rows.`);
                            }
                            // Break after processing the first worksheet, if needed
                            break;
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (workbook_1_1 && !workbook_1_1.done && (_a = workbook_1.return)) yield _a.call(workbook_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                outPut['successCount'] = successCount;
                outPut['failedCount'] = failedCount;
                outPut['message'] = "all items inserted successfully.";
                return { message: '', status: 0, data: outPut };
            }
            catch (e) {
                console.log("Error occurred while creating tasks", e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    fetchTemplate(url, token, orgId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let headers = { 'authorization': token, 'content-type': "application/json", "orgId": orgId, "selectedorgid": orgId };
            try {
                const response = yield fetch(url, {
                    method: "GET",
                    headers: headers
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                const data = yield response.json(); // Parse JSON response
                return data;
            }
            catch (error) {
                console.error("Error fetching additional info:", error);
            }
        });
    }
    fetchRules(obj) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const result = yield this.evaluateRuleSet(obj);
            console.log(result);
            return result;
        });
    }
    generateExcel(displayNames, dropdowns) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            //const filePath = 'generated_excel.xlsx';
            const workbook = yield XlsxPopulate.fromBlankAsync();
            const mainSheet = workbook.sheet(0).name('MainSheet');
            const hiddenSheet = workbook.addSheet('DropdownValues');
            let columnIndex = 1;
            // Populate the hidden sheet with dropdown values (for all dropdown fields)
            Object.keys(dropdowns).forEach((key) => {
                let columnLetter = '';
                let tempIndex = columnIndex;
                while (tempIndex > 0) {
                    const remainder = (tempIndex - 1) % 26;
                    columnLetter = String.fromCharCode(65 + remainder) + columnLetter;
                    tempIndex = Math.floor((tempIndex - 1) / 26);
                }
                // Populate the hidden sheet with values for the current dropdown
                dropdowns[key].forEach((value, rowIndex) => {
                    hiddenSheet.cell(`${columnLetter}${rowIndex + 1} `).value(value);
                });
                columnIndex++;
            });
            // Hide the dropdown values sheet
            hiddenSheet.hidden(true);
            let index = 0;
            // Loop through displayNames to generate the main sheet with validation
            displayNames.forEach((field) => {
                const { name, required, hidden } = field;
                if (hidden)
                    return;
                let columnLetter = '';
                let tempIndex = index + 1; // The column starts from 1
                index++;
                while (tempIndex > 0) {
                    const remainder = (tempIndex - 1) % 26;
                    columnLetter = String.fromCharCode(65 + remainder) + columnLetter;
                    tempIndex = Math.floor((tempIndex - 1) / 26);
                }
                // Set the header in the main sheet
                mainSheet.cell(`${columnLetter} 1`).value(name);
                mainSheet.column(columnLetter).width(name.length * 1.2);
                if (required) {
                    mainSheet.cell(`${columnLetter} 1`).style("fill", "FF0000");
                }
                // Apply dropdown validation only if it's a dropdown field (SELECT or CHECKBOX type)
                if (dropdowns[name]) {
                    let dropdownColumnLetter = '';
                    let tempDropdownIndex = Object.keys(dropdowns).indexOf(name) + 1;
                    while (tempDropdownIndex > 0) {
                        const remainder = (tempDropdownIndex - 1) % 26;
                        dropdownColumnLetter = String.fromCharCode(65 + remainder) + dropdownColumnLetter;
                        tempDropdownIndex = Math.floor((tempDropdownIndex - 1) / 26);
                    }
                    // Populate DropdownValues sheet with correct types (values array)
                    dropdowns[name].forEach((value, rowIndex) => {
                        hiddenSheet.cell(`${dropdownColumnLetter}${rowIndex + 1} `).value(value);
                    });
                    // Apply dropdown validation for the entire column
                    mainSheet.range(`${columnLetter} 2:${columnLetter} 1048576`).dataValidation({
                        type: 'list',
                        formula1: `'DropdownValues'!$${dropdownColumnLetter} $1:$${dropdownColumnLetter}$${dropdowns[name].length} `,
                        showErrorMessage: true,
                        errorTitle: `Invalid Input`,
                        error: `Please select a valid ${name} from the dropdown.`,
                    });
                }
                // Apply required field validation only if necessary and no existing validation
                if (required) {
                    const existingValidation = mainSheet.range(`${columnLetter} 2:${columnLetter} 1048576`).dataValidation();
                    if (!existingValidation) {
                        mainSheet.range(`${columnLetter} 2:${columnLetter} 1048576`).dataValidation({
                            type: 'custom',
                            formula1: `NOT(ISBLANK(${columnLetter}2))`,
                            showErrorMessage: true,
                            errorTitle: 'Field is required',
                            error: `Please enter a value for ${name}.This field is required.`,
                        });
                    }
                }
            });
            // Save the workbook to a file
            const buffer = yield workbook.outputAsync();
            //fs.writeFileSync(filePath, buffer);
            //console.log(`Excel file created with dropdown and required validation: ${ filePath } `);
            return buffer;
        });
    }
    oracleLookUp(collectionName, fieldsOnSearch, valuesToSearch, ConditionType, project, from, to, singleValue, groupBy) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let input = {};
                let output = {};
                input['username'] = env_2.env.fileConfig.OracleUser;
                input['password'] = env_2.env.fileConfig.OraclePassword;
                input['connectString'] = env_2.env.fileConfig.connectionString;
                input['isRuleEngine'] = true;
                // if ((env.fileConfig.OraclePwdEncrypt) && (!isNullOrUndefined(input['password'])) && (input['password'] != "")) {
                //     input["password"] = Buffer.from(input["password"], 'base64').toString()
                // }
                console.log("input of oracle lookup", input);
                if (!util_1.isNullOrUndefined(ConditionType) && ConditionType != "other" && ConditionType != "NextDate") {
                    input['parameter'] = "sql2";
                    input['tableName'] = collectionName;
                    input['whereClause'] = "";
                    input['fieldDisplay'] = "";
                    if (!util_1.isNullOrUndefined(fieldsOnSearch) && Array.isArray(fieldsOnSearch) && fieldsOnSearch.length > 0) {
                        fieldsOnSearch.forEach((row, i) => {
                            if (i > fieldsOnSearch.length) {
                                input['whereClause'] = input['whereClause'] + " " + row + ' = ' + valuesToSearch[i].toString() + " " + ConditionType;
                            }
                            else {
                                input['whereClause'] = input['whereClause'] + " " + row + ' = ' + valuesToSearch[i].toString();
                            }
                        });
                    }
                    else {
                        if (!util_1.isNullOrUndefined(ConditionType) && ConditionType == "Convert") {
                            input['tableParameter'] = !util_1.isNullOrUndefined(valuesToSearch) && !isNaN(Number(valuesToSearch)) ? valuesToSearch.toString() : valuesToSearch;
                        }
                        else {
                            input['tableParameter'] = valuesToSearch;
                        }
                        input['fieldType'] = fieldsOnSearch;
                    }
                    input['fieldDisplay'] = project;
                }
                else {
                    input['query'] = collectionName;
                    input['parameter'] = "singleKeyValue";
                }
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    let self = this;
                    console.log('select ' + input['fieldDisplay'] + ' from ' + input['tableName'] + ' where ' + input['fieldType'] + ' = :kbv');
                    output = yield self.oracleDBConnector(input, output, null, null, null);
                    if (!util_1.isNullOrUndefined(output) && !util_1.isNullOrUndefined(output['data']) && !util_1.isNullOrUndefined(output['data']['result'])) {
                        if (ConditionType != "NextDate") {
                            console.log("Output1 -- -- ", output['data']['result']['converted'][0][project]);
                            resolve(output['data']['result']['converted'][0][project]);
                        }
                        else {
                            input['query'] = input['query'].replace(/["]/g, "'");
                            let keys = Object.keys(output['data']['result']['converted'][0]);
                            console.log("Output3 -- -- ", output['data']['result']['converted'][0][keys[0]], " --- INPUT ---- ", keys);
                            resolve(output['data']['result']['converted'][0][keys[0]]);
                        }
                    }
                    else {
                        resolve(null);
                    }
                }));
            }
            catch (err) {
                console.log(" RRR ERRR ", err);
                return null;
            }
        });
    }
    oracleLookUpLength(collectionName, fieldsOnSearch, valuesToSearch, ConditionType, project, from, to, singleValue, groupBy) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let input = {};
                let output = {};
                input['username'] = env_2.env.fileConfig.OracleUser;
                input['password'] = env_2.env.fileConfig.OraclePassword;
                input['connectString'] = env_2.env.fileConfig.connectionString;
                input['isRuleEngine'] = true;
                if (!util_1.isNullOrUndefined(ConditionType) && ConditionType != "other" && ConditionType != "NextDate" && ConditionType != "Length") {
                    input['parameter'] = "sql2";
                    input['tableName'] = collectionName;
                    input['whereClause'] = "";
                    input['fieldDisplay'] = "";
                    if (!util_1.isNullOrUndefined(fieldsOnSearch) && Array.isArray(fieldsOnSearch) && fieldsOnSearch.length > 0) {
                        fieldsOnSearch.forEach((row, i) => {
                            if (i > fieldsOnSearch.length) {
                                input['whereClause'] = input['whereClause'] + " " + row + ' = ' + valuesToSearch[i].toString() + " " + ConditionType;
                            }
                            else {
                                input['whereClause'] = input['whereClause'] + " " + row + ' = ' + valuesToSearch[i].toString();
                            }
                        });
                    }
                    else {
                        if (!util_1.isNullOrUndefined(ConditionType) && ConditionType == "Convert") {
                            input['tableParameter'] = !util_1.isNullOrUndefined(valuesToSearch) && !isNaN(Number(valuesToSearch)) ? valuesToSearch.toString() : valuesToSearch;
                        }
                        else {
                            input['tableParameter'] = valuesToSearch;
                        }
                        input['fieldType'] = fieldsOnSearch;
                    }
                    input['fieldDisplay'] = project;
                }
                else {
                    input['query'] = collectionName;
                    input['parameter'] = "singleKeyValue";
                }
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    let self = this;
                    console.log('select ' + input['fieldDisplay'] + ' from ' + input['tableName'] + ' where ' + input['fieldType'] + ' = :kbv');
                    output = yield self.oracleDBConnector(input, output, null, null, null);
                    if (!util_1.isNullOrUndefined(output) && !util_1.isNullOrUndefined(output['data']) && !util_1.isNullOrUndefined(output['data']['result'])) {
                        if (ConditionType != "NextDate") {
                            console.log("Output1 -- -- ", output['data']['result']['converted'][0][project]);
                            resolve(output['data']['result']['converted'][0][project]);
                        }
                        else {
                            // console.log("CompleteOutput -- -- ", output);
                            input['query'] = input['query'].replace(/["]/g, "'");
                            console.log("CompleteConverted -- -- ", output['data']['result']['converted']);
                            let keys = Object.keys(output['data']['result']['converted'][0]);
                            if (output['data']['result']['converted'].length == 1) {
                                console.log("Output3 -- -- ", output['data']['result']['converted'][0][keys[0]], " --- INPUT ---- ", keys);
                                resolve(output['data']['result']['converted'][0][keys[0]]);
                            }
                            else {
                                console.log("Output2 -- -- ");
                                resolve(null);
                            }
                        }
                    }
                    else {
                        resolve(null);
                    }
                }));
            }
            catch (err) {
                console.log(" RRR ERRR ", err);
                return null;
            }
        });
    }
    //fuzzymatch("Vendor_Master","Supplier_Name","Al Hilal Takaful")
    fuzzyMatch(table_name, fieldtoSearch, valuetoSearch) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let stringSimilarity = require("string-similarity");
                console.log("Inside fuzzymatch");
                const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                const db = yield mClient.db(env_2.env.dbConfig.dbname);
                if (!util_1.isNullOrUndefined(table_name) && !util_1.isNullOrUndefined(fieldtoSearch) && !util_1.isNullOrUndefined(valuetoSearch)) {
                    let data = yield db.collection(table_name).find({}).toArray();
                    let datatoMatch = [];
                    let index = 0;
                    for (let i = 0; i < data.length; i++) {
                        !util_1.isNullOrUndefined(data[i][fieldtoSearch]);
                        {
                            datatoMatch.push(data[i][fieldtoSearch].toString().toLowerCase());
                            data[i]['myindex'] = index;
                            index++;
                        }
                    }
                    if (datatoMatch.length > 0) {
                        valuetoSearch = valuetoSearch.toString().toLowerCase();
                        let match = stringSimilarity.findBestMatch(valuetoSearch, datatoMatch);
                        console.log(match);
                        if (!util_1.isNullOrUndefined(match) && !util_1.isNullOrUndefined(match.ratings) && Array.isArray(match.ratings) && !util_1.isNullOrUndefined(match.bestMatch.rating) && match.bestMatch.rating > 0.6 && !util_1.isNullOrUndefined(match.bestMatchIndex)) {
                            let matchess = match.ratings.filter(a => a.rating === match.bestMatch.rating);
                            if (matchess.length == 1) {
                                let matchedData = data.filter(a => a.myindex == match.bestMatchIndex);
                                matchedData = matchedData.length == 1 ? matchedData[0] : {};
                                if (!util_1.isNullOrUndefined(matchedData[fieldtoSearch])) {
                                    console.info(" ----- Matched Data --------- Length == 1 ------------- ", matchedData[fieldtoSearch]);
                                    return matchedData[fieldtoSearch];
                                }
                            }
                            else {
                                let matchedData = data.filter(a => a.myindex == match.bestMatchIndex);
                                matchedData = matchedData.length > 0 ? matchedData[0] : {};
                                if (!util_1.isNullOrUndefined(matchedData[fieldtoSearch])) {
                                    console.info(" ----- Matched Data ---------Length > 1 ------------- ", matchedData[fieldtoSearch]);
                                    return matchedData[fieldtoSearch];
                                }
                            }
                        }
                    }
                }
                return '';
            }
            catch (err) {
                console.log("fuzzy :" + err);
                return '';
            }
        });
    }
    checkLoadBalance(V_N, check) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                const db = yield mClient.db(env_2.env.dbConfig.dbname);
                let self = this;
                if (check == "name") {
                    let collectionName = "Vendor_Master";
                    let query;
                    let dataAsPerDec;
                    if (!util_1.isNullOrUndefined(V_N) && V_N !== '') {
                        console.info(" ----- V_N ----- ", V_N);
                        let fuzzyMatch = yield self.fuzzyMatch("Vendor_Master", "Supplier_Name", V_N);
                        if (!util_1.isNullOrUndefined(fuzzyMatch) && fuzzyMatch.length > 1) {
                            query = [{ "$match": { "Supplier_Name": { "$regex": fuzzyMatch, "$options": 'i' } } }, { "$project": { "AP_User_Name": 1.0 } }];
                            dataAsPerDec = yield db.collection(collectionName).aggregate(query).toArray();
                        }
                    }
                    console.info(dataAsPerDec);
                    if (!util_1.isNullOrUndefined(dataAsPerDec) && dataAsPerDec.length > 0 && !util_1.isNullOrUndefined(dataAsPerDec[0]['AP_User_Name']) && dataAsPerDec[0]['AP_User_Name'].length > 1 && (V_N !== '' || !util_1.isNullOrUndefined(V_N))) {
                        let query1 = [{ "$match": { "personalInfo.name": dataAsPerDec[0]['AP_User_Name'], "count": { "$exists": true, "$ne": null } } }, { "$sort": { "count": 1 } }, { "$project": { "count": 1 } }];
                        let count = yield db.collection("users").aggregate(query1).toArray();
                        count = Number(count[0]['count']) + 1;
                        yield db.collection("users").findOneAndUpdate({ "personalInfo.name": dataAsPerDec[0]['AP_User_Name'] }, { "$set": { count: count } });
                        return dataAsPerDec[0]['AP_User_Name'];
                    }
                    else {
                        collectionName = "users";
                        let query1 = [{ "$match": { "count": { "$exists": true, "$ne": null } } }, { "$sort": { "count": 1 } }, { "$project": { "personalInfo": 1, "count": 1 } }];
                        dataAsPerDec = yield db.collection(collectionName).aggregate(query1).toArray();
                        console.info(" ---- ------- dataAsPerDec ------ --------- ", dataAsPerDec);
                        if (!util_1.isNullOrUndefined(dataAsPerDec) && dataAsPerDec.length > 0 && !util_1.isNullOrUndefined(dataAsPerDec[0]['personalInfo']['name'])) {
                            console.info(" ---- AP_USER ---- NAME ----- ", dataAsPerDec[0]['personalInfo']['name']);
                            let query2 = [{ "$match": { "personalInfo.name": dataAsPerDec[0]['personalInfo']['name'], "count": { "$exists": true, "$ne": null } } }, { "$sort": { "count": 1 } }, { "$project": { "count": 1 } }];
                            let count = yield db.collection("users").aggregate(query2).toArray();
                            count = Number(count[0]['count']) + 1;
                            console.info(" ---- AP_USER ---- NAME COUNT ----- ", count);
                            yield db.collection("users").findOneAndUpdate({ "personalInfo.name": dataAsPerDec[0]['personalInfo']['name'] }, { "$set": { count: count } });
                            return dataAsPerDec[0]['personalInfo']['name'];
                        }
                        else {
                            return "";
                        }
                    }
                    console.log(dataAsPerDec);
                }
                else if (check == "email") {
                    console.info("---- INSIDE EMAIl FUNCTION ----- ");
                    let collectionName = "users";
                    if (!util_1.isNullOrUndefined(V_N) && V_N !== '') {
                        collectionName = "users";
                        console.info("---- INSIDE EMAIl FUNCTION ----- ", V_N);
                        let query1 = [{ "$match": { "personalInfo.name": { "$regex": V_N, "$options": 'i' } } }, { "$project": { "personalInfo": 1 } }];
                        let emailData = yield db.collection(collectionName).aggregate(query1).toArray();
                        if (!util_1.isNullOrUndefined(emailData) && emailData.length > 0 && !util_1.isNullOrUndefined(emailData[0]['personalInfo']['email'])) {
                            return emailData[0]['personalInfo']['email'];
                        }
                        else {
                            return "";
                        }
                    }
                }
                else if (check == 'Reset') {
                    console.info(" ---- INSIDE RESET FUNCTION ------- ");
                    yield db.collection("users").updateMany({ "count": { "$exists": true, "$ne": null } }, { "$set": { "count": 0 } });
                }
                console.info("END OF FUNCTION");
            }
            catch (err) {
                console.error(err);
                return err;
            }
        });
    }
    lookUp(collectionName, fieldsOnSearch, valuesToSearch, project, from, to, singleValue, groupBy, mainSearch = '', castToObjectId = false) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let query = [];
                let count = 0;
                let projectObj = {};
                let match = {};
                let result;
                // console.log(collectionName);
                if (!util_1.isNullOrUndefined(valuesToSearch) && !util_1.isNullOrUndefined(fieldsOnSearch) && Array.isArray(valuesToSearch) && Array.isArray(fieldsOnSearch) && valuesToSearch.length == fieldsOnSearch.length) {
                    fieldsOnSearch.forEach(element => {
                        match[element] = valuesToSearch[count];
                        count++;
                    });
                    query.push({ "$match": match });
                }
                else if (!util_1.isNullOrUndefined(valuesToSearch) && !util_1.isNullOrUndefined(fieldsOnSearch)) {
                    match[fieldsOnSearch] = !isNaN(valuesToSearch) ? Number(valuesToSearch) : valuesToSearch;
                    query.push({ "$match": match });
                }
                if (!util_1.isNullOrUndefined(groupBy)) {
                    query.push({ "$group": { "_id": "$" + groupBy, "doc": { "$first": "$$ROOT" } } });
                }
                if (!util_1.isNullOrUndefined(collectionName)) {
                    if (Array.isArray(project) && project.length > 0) {
                        project.forEach(col => {
                            if (!util_1.isNullOrUndefined(groupBy)) {
                                projectObj[col] = "$doc." + col;
                            }
                            else {
                                projectObj[col] = 1;
                            }
                        });
                    }
                    else {
                        projectObj[project] = 1;
                    }
                }
                // const mClient = await MongoClient.connect(env.dbConfig.mongodb_uri);
                // const db = await mClient.db(env.dbConfig.dbname);
                if (util_1.isNullOrUndefined(from) && util_1.isNullOrUndefined(to)) {
                    // collectionName = "users"
                    // console.log("project ", projectObj);
                    if (!util_1.isNullOrUndefined(mainSearch) && mainSearch.length > 0) {
                        let query = JSON.parse(mainSearch);
                        //console.log(query)
                        if (typeof query == "object") {
                            if (castToObjectId) {
                                const keys = Object.keys(query);
                                for (let key of keys) {
                                    if (ObjectId.isValid(query[key])) {
                                        query[key] = ObjectId(query[key]);
                                    }
                                }
                            }
                            //  result = await db.collection(collectionName).find(query, projectObj).toArray()
                            result = yield (db.collection(collectionName)).find(query, projectObj);
                            result = JSON.parse(JSON.stringify(result));
                        }
                    }
                    else {
                        query.push({ "$project": projectObj });
                        result = yield (db.collection(collectionName)).aggregate(query);
                        result = JSON.parse(JSON.stringify(result));
                    }
                    //result = await db.collection(collectionName).aggregate(query).toArray()
                    result = !util_1.isNullOrUndefined(result) && result.length > 0 ? result : null;
                }
                else {
                    query.push({ "$project": projectObj });
                    query.push({ "$skip": from });
                    query.push({ "$limit": to });
                    result = yield (db.collection(collectionName)).aggregate(query);
                    result = JSON.parse(JSON.stringify(result));
                    result = !util_1.isNullOrUndefined(result) && result.length > 0 ? result : null;
                }
                if (!util_1.isNullOrUndefined(singleValue)) {
                    result = !util_1.isNullOrUndefined(result) && !util_1.isNullOrUndefined(result[0]) && !util_1.isNullOrUndefined(result[0][singleValue]) ? result[0][singleValue] : null;
                }
                // console.log("return   -- ", result, "  -- -- .... .   ", isNaN(result));
                if (typeof result == "string") {
                    return result;
                }
                else {
                    return JSON.stringify(result);
                }
            }
            catch (error) {
                return error["message"];
            }
        });
    }
    avg(array) {
        var i = 0, sum = 0, len = array.length;
        while (i < len) {
            sum = sum + array[i++];
        }
        return sum / len;
    }
    median(values) {
        values.sort((a, b) => a - b);
        let median = (values[(values.length - 1) >> 1] + values[values.length >> 1]) / 2;
        return median;
    }
    mean(numbers) {
        var total = 0, i;
        for (i = 0; i < numbers.length; i += 1) {
            total += numbers[i];
        }
        return total / numbers.length;
    }
    range(numbers) {
        numbers.sort();
        return [numbers[0], numbers[numbers.length - 1]];
    }
    count(array, countOff) {
        var i, count = 0;
        for (i = 0; i < array.length; i += 1) {
            if (array[i] == countOff) {
                count = count + 1;
            }
        }
        return count;
    }
    sum(array) {
        var i = 0, sum = 0;
        for (i = 0; i < array.length; i += 1) {
            sum = sum + array[i];
        }
        return sum;
    }
    evaluateOrganization(id, concatStr) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const orgData = yield this.OrganizationService.findOneById(id);
                console.log("Afttttttttttttt ===========>>>>>>>>      ", JSON.stringify(orgData.data.name));
                if (!util_1.isNullOrUndefined(concatStr) && concatStr !== '') {
                    return orgData.data.name + concatStr;
                }
                else {
                    return orgData.data.name;
                }
            }
            catch (err) {
                console.error(err);
                return err;
            }
        });
    }
    getStartDate(id) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // let endDate = new Date(new Date().toLocaleString('en-US', {
                //     timeZone: "America/Toronto"
                // }))
                let startDate = new Date();
                let a;
                startDate.setHours(startDate.getHours() - 1);
                startDate.setHours(startDate.getHours() + 5);
                startDate.setMinutes(startDate.getMinutes() + 30);
                // startDate.setDate(startDate.getDate() - 1)
                a = new Date(startDate).toISOString();
                console.log("a---------", a);
                console.log('startDate----------', startDate);
                return a;
            }
            catch (err) {
                console.error(err);
                return err;
            }
        });
    }
    getEndDate(id) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // let endDate = new Date(new Date().toLocaleString('en-US', {
                //     timeZone: "America/Toronto"
                // }))
                let endDate = new Date();
                console.log("eeeeeeeee", endDate);
                endDate.setHours(endDate.getHours() + 5);
                endDate.setMinutes(endDate.getMinutes() + 30);
                // let startDate = endDate;
                let a;
                // startDate.setHours(startDate.getHours() - 1)
                // startDate.setDate(startDate.getDate() - 1)
                a = new Date(endDate).toISOString();
                console.log("okkkkkkk", endDate, "yehhhhhh", a);
                return a;
            }
            catch (err) {
                console.error(err);
                return err;
            }
        });
    }
    evaluateParentOrg(id) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const orgData = yield this.OrganizationService.findOneById(id);
                if (!util_1.isNullOrUndefined(orgData.data.parentOrg) && orgData.data.parentOrg !== '') {
                    const parentOrg = yield this.OrganizationService.findOneById(orgData.data.parentOrg);
                    console.log("After --->>>   ", JSON.stringify(parentOrg.data.name));
                    return parentOrg.data.name;
                }
                else {
                    console.log("Afttttttttttttt ===========>>>>>>>>      ", JSON.stringify(orgData.data.name));
                    return orgData.data.name;
                }
            }
            catch (err) {
                console.error(err);
                return err;
            }
        });
    }
    evaluateBranch(BranchName, ProcessType) {
        console.warn("Inside EvaluateBranch ========>>>>>>>>----->>>>>>>>> ", BranchName, "   <<<<<<------Branch Name ------>>>ProcessType =====>>>>----->>>>>>  ", ProcessType);
        let queueName = BranchName + "_" + ProcessType;
        return queueName;
    }
    evaluateDiscrepency(startStr, id, endStr) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const eventdata = yield eventStatus_1.eventStatus.findOne({ eventId: ObjectId(id) }, { orgId: 1 });
                const orgData = yield this.OrganizationService.findOneById(eventdata['orgId']);
                return startStr + orgData.data.name + endStr;
            }
            catch (err) {
                console.error(err);
                return err;
            }
        });
    }
    findFootNotes(TableArray, superScript, suprScript, FoteNotes, isCrep) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let footNotes = [];
                let currentPageId = -1;
                let tableArry = [];
                for (let i = 0; i < TableArray.length; i++) {
                    let lineData = TableArray[i];
                    let words = lineData.line.split(/\s+/);
                    let allow = false;
                    let diff = 0;
                    let lastLineFontSize = -1;
                    let lastLineYScale = -1;
                    if (i > 0) {
                        let lastLine = TableArray[i - 1];
                        let lastLineBottom = lastLine.top - lastLine.fontSize;
                        lastLineFontSize = lastLine.fontSize;
                        lastLineYScale = lastLine.YScale;
                        diff = lastLineBottom - lineData.top;
                        // if(diff>lineData.fontSize){
                        //     percDff=(lineData.fontSize/diff)*100;
                        // }else{
                        //     percDff=(diff/lineData.fontSize)*100;
                        // }
                    }
                    if (words.length > 0 && (suprScript.length > 0 || superScript.length > 0)) {
                        if (suprScript.indexOf(words[0]) > -1 || (superScript.indexOf(words[0] + '_' + lineData.pageId) > -1 && ((lastLineFontSize >= lineData.fontSize && !isCrep) || (lastLineYScale >= lineData.YScale && isCrep)) && FoteNotes.filter(r => { return !util_1.isNullOrUndefined(r['FoteNoteId']) && r['FoteNoteId'].toString() == words[0] && r['pageId'] == lineData['pageId']; }).length == 0 && footNotes.filter(r => { return !util_1.isNullOrUndefined(r['FoteNoteId']) && r['FoteNoteId'].toString() == words[0] && r['pageId'] == lineData['pageId']; }).length == 0)) {
                            allow = true;
                        }
                    }
                    if (/^[\d*†‡]+/.test(lineData.line) && lineData['mayBeFootNote'] && currentPageId == -1 || (allow)) {
                        let splitArr = lineData.line.split(/\s/);
                        lineData['FoteNoteId'] = splitArr[0];
                        lineData['isFoteNote'] = true;
                        footNotes.push(lineData);
                        currentPageId = lineData.pageId;
                    }
                    else if (currentPageId == lineData.pageId && !lineData.line.includes("Company (Pty) Ltd") && !(/^[\d*]+$/.test(lineData.line))
                        && lineData.lineleft > 45 && diff < lastLineFontSize) {
                        if (/^[\d*†‡]+/.test(lineData.line) && lineData['mayBeFootNote']) {
                            let splitArr = lineData.line.split(/\s/);
                            lineData['FoteNoteId'] = splitArr[0];
                        }
                        lineData['isFoteNote'] = true;
                        footNotes.push(lineData);
                        currentPageId = lineData.pageId;
                    }
                    else {
                        tableArry.push(lineData);
                        currentPageId = -1;
                    }
                }
                return { footNotes: footNotes, TableArray: tableArry };
            }
            catch (err) {
                return [];
            }
        });
    }
    splitWords(lineData, newArr, words) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                lineData['line'] = words[0];
                lineData['tagline'] = words[0];
                lineData['italic'] = false;
                newArr.push(JSON.parse(JSON.stringify(lineData)));
                lineData['line'] = words[1];
                lineData['tagline'] = words[1];
                lineData['italic'] = true;
                newArr.push(JSON.parse(JSON.stringify(lineData)));
            }
            catch (e) {
                console.log("Error!!! -> " + e);
            }
        });
    }
    chkDic(before, after) {
        try {
            let checkWord = require('check-word'), words = checkWord('en');
            if ((before.charAt(0) === before.charAt(0).toUpperCase()) && (after.charAt(0) === after.charAt(0).toUpperCase()))
                return true;
            return isNaN(parseInt(before)) || isNaN(parseInt(after)) ? words.check(before.toLowerCase()) && words.check(after.toLowerCase()) && (!words.check((before + after).toLowerCase())) : true;
        }
        catch (e) {
            console.log("chkDic exception: ", e);
            return false;
        }
    }
    removePdfParserIssues(arr) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let newArr = [];
                for (let i = 0; i < arr.length; i++) {
                    let lineData = arr[i];
                    if (/\w+\;\w+/.test(lineData.line) && lineData.italic) {
                        let words = lineData.line.split(";");
                        words[0] = words[0] + ";";
                        yield this.splitWords(lineData, newArr, words);
                    }
                    else if ((/\(\d+\)\(\w+\)\(\w+\)/.test(lineData.line) || /\(\w+\)\(\w+\)/.test(lineData.line)) && lineData.italic) {
                        let words = lineData.line.split(/\([ivx]{1,4}\)/);
                        let words2 = lineData.line.match(/\([ivx]{1,4}\)/);
                        if (!util_1.isNullOrUndefined(words) && !util_1.isNullOrUndefined(words2)) {
                            lineData['line'] = words[0];
                            lineData['tagline'] = words[0];
                            lineData['italic'] = true;
                            newArr.push(JSON.parse(JSON.stringify(lineData)));
                            if (words.length == 2) {
                                if (/\(\w+\)/.test(words[1])) {
                                    lineData['line'] = words2[0];
                                    lineData['tagline'] = words2[0];
                                }
                                else {
                                    lineData['line'] = words2[0] + words[1];
                                    lineData['tagline'] = words2[0] + words[1];
                                }
                            }
                            else {
                                lineData['line'] = words2[0];
                                lineData['tagline'] = words2[0];
                            }
                            lineData['italic'] = false;
                            newArr.push(JSON.parse(JSON.stringify(lineData)));
                            if (/\(\w+\)/.test(words[1])) {
                                lineData['line'] = words[1];
                                lineData['tagline'] = words[1];
                                lineData['italic'] = true;
                                newArr.push(JSON.parse(JSON.stringify(lineData)));
                            }
                        }
                        else {
                            newArr.push(lineData);
                        }
                    }
                    else if (/\d+\w\–\w/.test(lineData.line) && lineData.italic) {
                        let words = lineData.line.split(/\w\–\w/);
                        let words2 = lineData.line.match(/\w\–\w/);
                        let newArray = [];
                        newArray.push(words[0] + "concatWord");
                        newArray.push(words2[0]);
                        yield this.splitWords(lineData, newArr, newArray);
                    }
                    else {
                        newArr.push(lineData);
                    }
                }
                return newArr;
            }
            catch (e) {
                console.log("Error!!! -> " + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    updateReport(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let collection = input.collection;
                let l1 = input.l1;
                let l2 = input.l2;
                let l3 = input.l3;
                // let date = new Date().toLocaleDateString();
                // let time = new Date().toLocaleTimeString();
                let date = moment().format('DD/MM/YYYY');
                let time = moment().format('hh:mm:ss a');
                let q1 = { "Success": l1, "Failure": l2, "AlreadyClaimed": l3, "Date": date, "Time": time };
                const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                const db = yield mClient.db(env_2.env.dbConfig.dbname);
                let result = yield db.collection(collection).insert(q1);
                console.log(result);
                outputParameters['outputBody'] = "updated database.";
                this.log.info("updated database.");
                return { message: "updated database.", status: 0, data: outputParameters };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to update database." + e);
                return { message: e, status: 1, data: e };
            }
            // })
            // })
            return false;
        });
    }
    cleanServerPath(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let folderPath = input.folderPath;
                if (!fs.existsSync(folderPath)) {
                    throw "folder does not exist";
                }
                fs.readdir(folderPath, (err, files) => {
                    if (err)
                        throw err;
                    for (const file of files) {
                        fs.unlink(path.join(folderPath, file), err => {
                            if (err)
                                throw err;
                        });
                    }
                });
                outputParameters['outputBody'] = "cleaned.";
                this.log.info("server folder cleaned.");
                return { message: "server folder cleaned.", status: 0, data: outputParameters };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to clean server folder." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    cleanerBotForUtility(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "filePath": input.filePath,
                    "successFolderPath": input.successFolderPath,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'cleanerBotForUtility',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("excelfile is at given folder path.");
                return { message: 'excelfile is at given folder path.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to give excel file path." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    readGoogleSheetForUtility(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "sheet_name": input.SheetName,
                    "url_of_the_sheet": input.LinkofSheet,
                    "headers": input.Headers,
                    "credentialPath": input.credentialPath,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'readGoogleSheetForUtility',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                // this.socket.emit('trigger-event2', obj.sheet_name);
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Your google sheet is readed and converted to array of objects.");
                return { message: 'Your google sheet is readed and converted to array of objects.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to read google sheet." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    updateGoogleSheetForUtility(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "url_of_the_sheet": input.url_of_the_sheet,
                    "excelPath": input.excelPath,
                    "successFolderPath": input.successFolderPath,
                    "credentialPath": input.credentialPath,
                    "bgColour": input.bgColour,
                    "textColour": input.textColour,
                    "bold": input.bold,
                    "font": input.font,
                    "fontsize": input.fontsize,
                    "padding": input.padding,
                    "border": input.border,
                    "horizontalAlignment": input.horizontalAlignment,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'updateGoogleSheetForUtility',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                // this.socket.emit('trigger-event2', obj.excelPath);
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Your excel file is updated at given google sheet.");
                return { message: 'Your excel file is updated at given google sheet.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to update google sheet." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    removeGoogleSheet(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "url_of_the_sheet": input.url_of_the_sheet,
                    "credentialPath": input.credentialPath,
                    "countDays": input.countDays,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'removeGoogleSheet',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Your google sheet updated by deleting 7 days before sheets.");
                return { message: 'Your google sheet updated by deleting 7 days before sheets.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to remove google sheet." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    readFromDateFromGoogleSheet_UT(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "url_of_the_sheet": input.url_of_the_sheet,
                    "credentialPath": input.credentialPath,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'readFromDateFromGoogleSheet_UT',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                // this.socket.emit('trigger-event2', obj.sheet_name);
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Your google sheet is readed and converted to array of objects.");
                return { message: 'Your google sheet is readed and converted to array of objects.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to read google sheet." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    correctNamesOfFile(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "html": input.html,
                    "systemExcel": input.systemExcel,
                    "dpath": input.dpath,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'correctNamesOfFile',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("names of excel files are changed.");
                return { message: 'names of excel files are changed.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to change names of excel files." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    asPerRequirementBotForUtility(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "extension": input.extension,
                    "folderPath": input.folderPath,
                    "successFolderPath": input.successFolderPath,
                    "scenario": input.scenario,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'asPerRequirementBotForUtility',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("excelfile is at given folder path.");
                return { message: 'excelfile is at given folder path.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to give excel file path." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    moveDataSavex(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "arrayOfObjects": input.arrayOfObjects,
                    "num": input.num,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'moveDataSavex',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("to move data.");
                return { message: 'to move data.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to move data." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    compareRecorderPageWithExcel(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "excelFolderPath": input.excelFolderPath,
                    "arrayOfHtmlPage": input.arrayOfHtmlPage,
                    "clientExcel": input.clientExcel,
                    "useCase": input.useCase,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'compareRecorderPageWithExcel',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("file is readed successfully.");
                return { message: 'compared client excel and recorder html page array successfully.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to compare client excel and recorder html page array." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    updateExcelSavex(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "excelPath": input.excelPath,
                    "filename": input.filename,
                    "clientExcelPath": input.clientExcelPath,
                    "month": input.month,
                    "year": input.year,
                    "useCase": input.useCase,
                    "startDate": input.startDate,
                    "endDate": input.endDate,
                    "mccCode": input.mccCode,
                    "subject": input.subject,
                    "programType": input.programType,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'updateExcelSavex',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("excelfile is at given folder path.");
                return { message: 'excelfile is at given folder path.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to give excel file path." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    readFileByExtension(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "filePath": input.filePath,
                    "fileData": input.fileData,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'readFileByExtension',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("file is readed successfully.");
                return { message: 'file is readed successfully.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to read file by extension." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    folderStructureForHPProgram(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "folderPath": input.folderPath,
                    "downloadPath": input.downloadPath,
                    "monthvalue": input.monthvalue,
                    "yearvalue": input.yearvalue,
                    "useCase": input.useCase,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'folderStructureForHPProgram',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Your folder is made at given folder path.");
                return { message: 'your folder is made at given folder path.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to give failure excel file path." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    textToExcelBotForUtility(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "textPath": input.textPath,
                    "folderPath": input.folderPath,
                    "delimiter": input.delimiter,
                    "headerLine": input.headerLine,
                    "bodyLine": input.bodyLine,
                    "successFolderPath": input.successFolderPath,
                    "allHeaders": input.allHeaders,
                    "useCase": input.useCase,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'textToExcelBotForUtility',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("excelfile is at given folder path.");
                return { message: 'excelfile is at given folder path.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to give excel file path." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    excelDivisionBotForUtility(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "excelPath": input.excelPath,
                    "folderPath": input.folderPath,
                    "column1": input.column1,
                    "column2": input.column2,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'excelDivisionBotForUtility',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Your folder is made at given folder path.");
                return { message: 'your folder is made at given folder path.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to give failure excel file path." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    toEmailArray(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "emailObject": input.emailObject,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'toEmailArray',
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Your folder is made at given folder path.");
                return { message: 'your folder is made at given folder path.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to give failure excel file path." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    readGoogleSheetForServer(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let credentialPath = input.credentialPath;
                let cred = require(credentialPath);
                console.log(cred);
                let sheet_name = input.sheet_name;
                let headers = JSON.parse(input.headers);
                //let headers = input.headers;
                //let headers = !isNullOrUndefined(input.invoiceData) && typeof input.invoiceData == 'string' ? JSON.parse(input.invoiceData) : input.invoiceData;
                // console.log(headers)
                let url_of_the_sheet = input.url_of_the_sheet;
                let split_url = url_of_the_sheet.split('/');
                let id_from_url = split_url[split_url.length - 2];
                // console.log(id_from_url)
                let updatedHeaders = [];
                for (let i = 0; i < headers.length; i++) {
                    let s = headers[i].replace(/[^a-zA-Z0-9 ]/g, '');
                    updatedHeaders.push(s);
                }
                var abc = [];
                //return new Promise(async (resolve, reject) => {
                // async function accessSpreadsheet() {
                const doc = new GoogleSpreadsheet(id_from_url);
                yield doc.useServiceAccountAuth({
                    client_email: cred.client_email,
                    private_key: cred.private_key,
                });
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    yield doc.loadInfo();
                    // console.log(doc.title);
                    const newSheet = yield doc.sheetsByTitle[sheet_name];
                    const rows = yield newSheet.getRows();
                    // console.log(rows.length)
                    let obj = {};
                    for (let i = 0; i < rows.length; i++) {
                        let data = rows[i]._rawData;
                        for (let j = 0; j < updatedHeaders.length; j++) {
                            obj[updatedHeaders[j]] = data[j];
                        }
                        abc.push(obj);
                        obj = {};
                    }
                    //console.log(JSON.stringify(abc))
                    outputParameters["arr_of_obj"] = JSON.stringify(abc);
                    //console.log(outputParameters)
                    resolve({ message: 'Your google sheet is readed and converted to array of objects.', status: 0, data: outputParameters });
                    //resolve({ message: "done", status: 0, data: abc });
                }));
                // console.log(abc)
                // await newSheet.delete();
                //}
                // async function main() {
                //     await accessSpreadsheet();
                // };
                // async function a() {
                //     await main();
                // }
                // a().then(function () {
                //let arr_of_obj = JSON.stringify(abc)
                //console.log(arr_of_obj)
                //outputParameters["arr_of_obj"] = arr_of_obj;
                //resolve({ message: "done", status: 0, data: abc });
                // return { message: 'Your google sheet is readed and converted to array of objects.', status: 0, data: outputParameters };
                // })
                //resolve({ message: "done", status: 0, data: abc });
                // });
                // console.log(JSON.stringify(abc))
                // outputParameters["arr_of_obj"] = JSON.stringify(abc)
                // console.log(outputParameters)
                // return { message: 'Your google sheet is readed and converted to array of objects.', status: 0, data: outputParameters };
            }
            catch (e) {
                console.log("Error in Socket triggering to read google sheet.", e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    readFromDateFromGoogleSheetServer(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let credentialPath = input.credentialPath;
                let cred = require(credentialPath);
                // console.log(cred)
                // console.log(input.url_of_the_sheet, typeof (input.url_of_the_sheet))
                let url_of_the_sheet = input.url_of_the_sheet;
                let split_url = url_of_the_sheet.split('/');
                let id_from_url = split_url[split_url.length - 2];
                // console.log(id_from_url)
                let fd, td;
                const today = moment();
                td = today.format('DD/MM/YYYY');
                fd = today.subtract(1, 'days').format('DD/MM/YYYY');
                //async function accessSpreadsheet() {
                const doc = new GoogleSpreadsheet(id_from_url);
                yield doc.useServiceAccountAuth({
                    client_email: cred.client_email,
                    private_key: cred.private_key,
                });
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    yield doc.loadInfo();
                    // console.log(doc.title);
                    let count = doc.sheetCount;
                    // console.log(count)
                    const sheet = doc.sheetsByIndex[count - 1];
                    let title = sheet.title;
                    // console.log(title)
                    let validdate = moment(title, 'YYYY-MM-DD', true).isValid();
                    //let dateTitle=Date.parse(title)
                    // console.log(dateTitle)
                    if (validdate) {
                        // console.log("yes")
                        const rows = yield sheet.getRows();
                        let tDate = rows[rows.length - 1]._rawData[0];
                        let b = tDate.split(' ');
                        // console.log(b)
                        let c = b[0];
                        // console.log(c)
                        const m2 = moment(c, 'DD-MM-YYYY');
                        let a = m2.subtract(1, 'days').format('DD/MM/YYYY');
                        fd = a;
                        // console.log(a,"yeh")
                        // console.log(fd)
                    }
                    outputParameters["Fromdate"] = fd;
                    outputParameters["Todate"] = td;
                    console.log(outputParameters);
                    resolve({ message: 'Your google sheet is readed and converted to array of objects.', status: 0, data: outputParameters });
                }));
                // async function main() {
                //     await accessSpreadsheet();
                // };
                // async function a(){
                //     await main();
                // }
                // a().then(function(){
                //     input['outputParameters'] = {statusCode: "200", successMessage: 'From date and To date are generated.', Fromdate: fd,Todate: td};
                // })
            }
            catch (e) {
                console.log("Error in Socket triggering to read google sheet.", e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    removeGoogleSheetForServer(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let credentialPath = input.credentialPath;
                let cred = require(credentialPath);
                // console.log(cred)
                // console.log(input.url_of_the_sheet, typeof (input.url_of_the_sheet))
                let url_of_the_sheet = input.url_of_the_sheet;
                let split_url = url_of_the_sheet.split('/');
                let id_from_url = split_url[split_url.length - 2];
                // console.log(id_from_url)
                let countDays = input.countDays;
                countDays = parseInt(countDays);
                //async function accessSpreadsheet() {
                const doc = new GoogleSpreadsheet(id_from_url);
                yield doc.useServiceAccountAuth({
                    client_email: cred.client_email,
                    private_key: cred.private_key,
                });
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    yield doc.loadInfo();
                    // console.log(doc,"yeh abhi bhi hai")
                    let count = doc.sheetCount;
                    // console.log(count);
                    // for(let i=0;i<count;i++)
                    for (let i = count - 1; i >= 0; i--) {
                        let sheet11 = doc.sheetsByIndex[i];
                        let a1 = sheet11.title;
                        // console.log(a1)
                        let validdate = moment(a1, 'YYYY-MM-DD', true).isValid();
                        // console.log(validdate)
                        if (validdate) {
                            let today = moment();
                            let before = today.subtract(countDays, 'days').format('YYYY-MM-DD');
                            // console.log(before,"mai before hoon")
                            // console.log(a1,"mai a1 hoon")
                            if (before > a1) {
                                const old1 = doc.sheetsByTitle[a1];
                                yield old1.delete();
                                console.log("working");
                            }
                            else {
                                console.log("not working");
                            }
                        }
                    }
                    outputParameters["update"] = "Done";
                    console.log(outputParameters);
                    resolve({ message: 'Your google sheet has been removed', status: 0, data: outputParameters });
                }));
                //}
                // async function main() {
                //     await accessSpreadsheet();
                // };
                // async function a(){
                //     await main();
                // }
                // a().then(function(){
                //     input['outputParameters'] = {statusCode: "200", successMessage: 'Google spreadsheet updated with last 7 days worksheets.', outputBody: 'done'};
                //     if(input.outputParameters.outputBody!=''){
                //         console.log("excelDataaaa>>>>>",input.outputParameters);
                //         socket.emit('utility_response', input);
                //     }
                // })
            }
            catch (e) {
                console.log("Error in Socket triggering to read google sheet.", e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    updateGoogleSheetForServer(input, outputParameters, botId, projectId, iterationId) {
        var iterationId;
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let credentialPath = input.credentialPath;
                let cred = require(credentialPath);
                // console.log(cred)
                ///////////////////////////////////new parameter
                /////////start
                // console.log(JSON.stringify(input),"/////////////////////all input")
                let bgColour = input.bgColour;
                let textColour = input.textColour;
                let bold = input.bold;
                let font = input.font;
                let fontsize = Number(input.fontsize);
                let padding = Number(input.padding);
                let border = input.border;
                let horizontalAlignment = input.horizontalAlignment;
                console.log(bgColour, textColour, bold, font, fontsize, padding, border, horizontalAlignment, "important");
                bgColour = JSON.parse(bgColour);
                textColour = JSON.parse(textColour);
                ////////////////////end
                let url_of_the_sheet = input.url_of_the_sheet;
                let split_url = url_of_the_sheet.split('/');
                let id_from_url = split_url[split_url.length - 2];
                iterationId = input.iterationId;
                let excelPathFile = input.excelPath;
                let successFolderPath = input.successFolderPath;
                let excelPath;
                let realPath;
                if (excelPathFile[0] == "[") {
                    excelPathFile = JSON.parse(input.excelPath);
                }
                else {
                    excelPathFile = input.excelPath;
                }
                if (Array.isArray(excelPathFile)) {
                    excelPath = excelPathFile[iterationId];
                    realPath = excelPath;
                    let b = excelPath.split('/');
                    excelPath = b[b.length - 1];
                }
                else {
                    excelPathFile = fs.readdirSync(input.excelPath);
                    excelPath = excelPathFile[0];
                    realPath = process.platform === 'win32' ? `${input.excelPath} \\${excelPath} ` : `${input.excelPath}/${excelPath}`;
                }
                var extension = path.extname(excelPath);
                var filename = path.basename(excelPath, extension);
                //async function accessSpreadsheet() {
                const doc = new GoogleSpreadsheet(id_from_url);
                yield doc.useServiceAccountAuth({
                    client_email: cred.client_email,
                    private_key: cred.private_key,
                });
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    yield doc.loadInfo();
                    const workSheetsFromFile = xlsx.parse(realPath);
                    var data = workSheetsFromFile[0].data;
                    if (doc.sheetsByTitle[filename] != undefined) {
                        const oldSheet = doc.sheetsByTitle[filename];
                        const rows = yield oldSheet.getRows();
                        let aabbcc = [];
                        var obj = {};
                        for (let i = 0; i < rows.length; i++) {
                            let dataold = rows[i]._rawData;
                            // dataold[2]='\''+dataold[2];
                            // dataold[4]='\''+dataold[4];
                            data.push(dataold);
                        }
                        // console.log(data.length,"aabbcc")
                        for (let i = 1; i < data.length; i++) {
                            for (let j = 0; j < data[0].length; j++) {
                                obj[data[0][j]] = data[i][j];
                            }
                            aabbcc.push(obj);
                            obj = {};
                        }
                        // console.log(aabbcc.length,"aabbcc ki length")
                        // console.log(data.length,"data ki length")
                        let arr = [];
                        arr = aabbcc;
                        let checker = "Reference No";
                        let a = 0, b = 0;
                        let abc = [];
                        for (let i = 0; i < arr.length; i++) {
                            if (arr[i][checker] == " ") {
                                for (let j = i + 1; j < arr.length; j++) {
                                    if (arr[i]["Transaction Date"] == arr[j]["Transaction Date"] && arr[i]["Transaction Amount"] == arr[j]["Transaction Amount"]) {
                                        a++;
                                        break;
                                    }
                                }
                                if (a == 0) {
                                    abc.push(arr[i]);
                                }
                                a = 0;
                            }
                            else {
                                for (let j = i + 1; j < arr.length; j++) {
                                    if (arr[i][checker] == arr[j][checker] && arr[i]["Transaction Date"] == arr[j]["Transaction Date"]) {
                                        b++;
                                        break;
                                    }
                                }
                                if (b == 0) {
                                    abc.push(arr[i]);
                                }
                                b = 0;
                            }
                        }
                        function abcde(ll) {
                            let aa = ll.split(" ");
                            let aaa = aa[0];
                            let bb = aaa.split('/');
                            let z = bb[0];
                            // z='20'+z;
                            bb[0] = '20' + bb[2];
                            bb[2] = z;
                            // console.log(bb)
                            // le
                            let dd = bb.join('/');
                            // console.log(dd)
                            let ee = [];
                            ee.push(dd);
                            ee.push(aa[1]);
                            // console.log(ee)
                            let ff = ee.join(' ');
                            // console.log(ff)
                            // console.log(new Date(ll))
                            ff: new Date(ff);
                            return ff;
                        }
                        abc.sort(function (a, b) {
                            var c = abcde(a['Transaction Date']);
                            var d = abcde(b['Transaction Date']);
                            return new Date(d).valueOf() - new Date(c).valueOf();
                        });
                        //   console.log(abc,"times//////////");
                        for (let i = 0; i < abc.length; i++) {
                            abc[i][checker] = '\'' + abc[i][checker];
                            abc[i]["Transaction Amount"] = '\'' + abc[i]["Transaction Amount"];
                        }
                        // console.log(aabbcc[(aabbcc.length)-1],"haaaaaaaaaaaan")
                        yield oldSheet.delete();
                        const newSheet = yield doc.addSheet({ title: filename, headerValues: data[0] });
                        const moreRows = yield newSheet.addRows(abc);
                        console.log(moreRows);
                        ///formating start
                        // border
                        //start
                        let l1 = abc.length;
                        console.log(l1, "output border");
                        l1 += 1;
                        const range = { startRowIndex: 0, endRowIndex: l1, startColumnIndex: 0, endColumnIndex: 5 };
                        yield newSheet.loadCells(range);
                        const baseStyle = { style: border };
                        for (let r = 0; r < range.endRowIndex - range.startRowIndex; r++) {
                            for (let c = 0; c < range.endColumnIndex - range.startColumnIndex; c++) {
                                newSheet.getCell(r, c).borders = { top: baseStyle, bottom: baseStyle, left: baseStyle, right: baseStyle };
                            }
                        }
                        //resizing sheet start
                        yield newSheet.updateDimensionProperties("COLUMNS", { pixelSize: padding }, { startIndex: 0, endIndex: 5 });
                        yield newSheet.updateDimensionProperties("COLUMNS", { pixelSize: padding * 3 }, { startIndex: 3, endIndex: 4 });
                        // resizing end
                        yield newSheet.loadCells('A1:E1');
                        const cellA1 = newSheet.getCell(0, 0);
                        cellA1.backgroundColor = bgColour;
                        cellA1.textFormat = { 'foregroundColor': textColour, bold: bold, fontSize: fontsize };
                        const cellA2 = newSheet.getCell(0, 1);
                        cellA2.backgroundColor = bgColour;
                        cellA2.textFormat = { 'foregroundColor': textColour, bold: bold, fontSize: fontsize };
                        const cellA3 = newSheet.getCell(0, 2);
                        cellA3.backgroundColor = bgColour;
                        cellA3.textFormat = { 'foregroundColor': textColour, bold: bold, fontSize: fontsize };
                        const cellA4 = newSheet.getCell(0, 3);
                        cellA4.backgroundColor = bgColour;
                        cellA4.textFormat = { 'foregroundColor': textColour, bold: bold, fontSize: fontsize };
                        const cellA5 = newSheet.getCell(0, 4);
                        cellA5.backgroundColor = bgColour;
                        cellA5.textFormat = { 'foregroundColor': textColour, bold: bold, fontSize: fontsize };
                        // const cellA6 = newSheet.getCell(0, 5);
                        // cellA6.backgroundColor = bgColour
                        // cellA6.textFormat = { 'foregroundColor': textColour, bold: bold, fontSize: fontsize }
                        yield newSheet.saveUpdatedCells();
                    }
                    else {
                        const newSheet = yield doc.addSheet({ title: filename, headerValues: data[0] });
                        var addArray = [];
                        for (let i = 1; i < data.length; i++) {
                            data[i][2] = '\'' + data[i][2];
                            data[i][4] = '\'' + data[i][4];
                            addArray.push(data[i]);
                        }
                        const moreRows = yield newSheet.addRows(addArray);
                        console.log(moreRows);
                        let l1 = data.length;
                        const range = { startRowIndex: 0, endRowIndex: l1, startColumnIndex: 0, endColumnIndex: 5 };
                        yield newSheet.loadCells(range);
                        const baseStyle = { style: border };
                        for (let r = 0; r < range.endRowIndex - range.startRowIndex; r++) {
                            for (let c = 0; c < range.endColumnIndex - range.startColumnIndex; c++) {
                                newSheet.getCell(r, c).borders = { top: baseStyle, bottom: baseStyle, left: baseStyle, right: baseStyle };
                            }
                        }
                        //resizing sheet start
                        yield newSheet.updateDimensionProperties("COLUMNS", { pixelSize: padding }, { startIndex: 0, endIndex: 5 });
                        yield newSheet.updateDimensionProperties("COLUMNS", { pixelSize: padding * 3 }, { startIndex: 3, endIndex: 4 });
                        // resizing end
                        yield newSheet.loadCells('A1:E1');
                        const cellA1 = newSheet.getCell(0, 0);
                        cellA1.backgroundColor = bgColour;
                        cellA1.textFormat = { 'foregroundColor': textColour, bold: bold, fontSize: fontsize };
                        const cellA2 = newSheet.getCell(0, 1);
                        cellA2.backgroundColor = bgColour;
                        cellA2.textFormat = { 'foregroundColor': textColour, bold: bold, fontSize: fontsize };
                        const cellA3 = newSheet.getCell(0, 2);
                        cellA3.backgroundColor = bgColour;
                        cellA3.textFormat = { 'foregroundColor': textColour, bold: bold, fontSize: fontsize };
                        const cellA4 = newSheet.getCell(0, 3);
                        cellA4.backgroundColor = bgColour;
                        cellA4.textFormat = { 'foregroundColor': textColour, bold: bold, fontSize: fontsize };
                        const cellA5 = newSheet.getCell(0, 4);
                        cellA5.backgroundColor = bgColour;
                        cellA5.textFormat = { 'foregroundColor': textColour, bold: bold, fontSize: fontsize };
                        // const cellA6 = newSheet.getCell(0, 5);
                        // cellA6.backgroundColor = bgColour
                        // cellA6.textFormat = { 'foregroundColor': textColour, bold: bold, fontSize: fontsize }
                        //end
                        yield newSheet.saveUpdatedCells();
                    }
                    let newPath1 = `${successFolderPath}\\success\\${filename}.xlsx`;
                    let newPath2 = `${successFolderPath}/success/${filename}.xlsx`;
                    let path = process.platform === 'win32' ? newPath1 : newPath2;
                    let oldPath = realPath;
                    let newPath = path;
                    let dir = process.platform === 'win32' ? `${successFolderPath}\\success` : `${successFolderPath}/success`;
                    if (!fs.existsSync(dir)) {
                        fs.mkdirSync(dir);
                    }
                    fs.rename(oldPath, newPath, function (err) {
                        if (err)
                            console.log('ERROR:failure ' + err);
                    });
                    outputParameters[" worksheet_name"] = filename;
                    outputParameters["output_data"] = "Done";
                    console.log(outputParameters);
                    resolve({ message: 'Your google sheet is readed and converted to array of objects.', status: 0, data: outputParameters });
                }));
                // async function main() {
                //     await accessSpreadsheet();
                // };
                // async function a(){
                //     await main()
                // }
                // a().then(function(){
                ///////
                // let newPath1=`${successFolderPath}\\success\\${filename}.xlsx`;
                // let newPath2=`${successFolderPath}/success/${filename}.xlsx`;
                // let path = process.platform === 'win32' ? newPath1 : newPath2;
                // let oldPath=realPath;
                // let newPath=path;
                // let dir=process.platform === 'win32' ? `${successFolderPath}\\success` : `${successFolderPath}/success`;
                // if (!fs.existsSync(dir)){
                //     fs.mkdirSync(dir);
                // }
                // fs.rename(oldPath, newPath, function(err) {
                //     if ( err ) console.log('ERROR:failure ' + err);
                // });
                //////
                //     input['outputParameters'] = {statusCode: "200", successMessage: 'excel updated on googlesheet successfully.', worksheet_name: filename,output_data:'done'};
                //     if(input.outputParameters.worksheet_name !="" ){
                //         console.log("excelDataaaa>>>>>",input.outputParameters);
                //         socket.emit('utility_response', input);
                //     }
                // })
            }
            catch (e) {
                console.log("Error in Socket triggering to read google sheet.", e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    cleanerBotForServer(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let filePath = input.filePath;
                // var files = fs.readdirSync(filePath);
                let successFolderPath = input.successFolderPath;
                let dir = process.platform === 'win32' ? `${successFolderPath}\\success` : `${successFolderPath}/success`;
                //return new Promise(async (resolve, reject) => {
                if (!fs.existsSync(dir)) {
                    fs.mkdirSync(dir);
                }
                // if (!isNullOrUndefined(filePath) || filePath !== "") {
                // let path1 = filePath.split(',')
                // let l1 = path1.length
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    if (!util_1.isNullOrUndefined(filePath) && filePath !== "") {
                        let path1 = filePath.split(',');
                        let l1 = path1.length;
                        for (let k = 0; k < l1; k++) {
                            //return new Promise(async (resolve, reject) => {
                            var files = yield fs.readdirSync(path1[k]);
                            for (let i = 0; i < files.length; i++) {
                                let file = files[i];
                                let oldPath = process.platform === 'win32' ? `${path1[k]}\\${file}` : `${path1[k]}/${file}`;
                                let newPath = process.platform === 'win32' ? `${successFolderPath}\\success\\${file}` : `${successFolderPath}/success/${file}`;
                                // fs.rename(oldPath, newPath, function(err) {
                                //     if ( err ) console.log('ERROR:failure ' + err);
                                //     else{
                                //         console.log("hurray done ")
                                //     }
                                // });
                                mv(oldPath, newPath, function (err) {
                                    if (err) {
                                        throw err;
                                    }
                                    else {
                                        console.log("Successfully moved the file!");
                                    }
                                });
                            }
                        }
                        outputParameters["update"] = "Done";
                        console.log(outputParameters);
                        resolve({ message: 'Your google sheet has been removed', status: 0, data: outputParameters });
                    }
                    else if (!util_1.isNullOrUndefined(input.tempFilepath)) {
                        let file = input.tempFilepath;
                        let oldPath = process.platform === 'win32' ? `${file}` : `${file}`;
                        var filename = input.tempFilepath.split("/")[input.tempFilepath.split("/").length - 1];
                        let newPath = process.platform === 'win32' ? `${successFolderPath}\\success\\${filename}` : `${successFolderPath}/success/${filename}`;
                        mv(oldPath, newPath, function (err) {
                            if (err) {
                                console.log(err);
                            }
                            else {
                                console.log("Successfully moved the file!");
                            }
                        });
                        outputParameters["update"] = "Done";
                        console.log(outputParameters);
                        resolve({ message: 'Your google sheet has been removed', status: 0, data: outputParameters });
                    }
                }));
                // }
                // else if (!isNullOrUndefined(input.tempFilepath)) {
                //     return new Promise(async (resolve, reject) => {
                //         let file = input.tempFilepath;
                //         let oldPath = process.platform === 'win32' ? `${file}` : `${file}`;
                //         var filename = input.tempFilepath.split("/")[input.tempFilepath.split("/").length - 1]
                //         let newPath = process.platform === 'win32' ? `${successFolderPath}\\success\\${filename}` : `${successFolderPath}/success/${filename}`;
                //         mv(oldPath, newPath, function (err) {
                //             if (err) {
                //                 throw err
                //             } else {
                //                 console.log("Successfully moved the file!");
                //             }
                //         });
                //         outputParameters["update"] = "Done"
                //         console.log(outputParameters)
                //         resolve({ message: 'Your google sheet has been removed', status: 0, data: outputParameters });
                //     });
                // }
                // return true;
                // outputParameters["update"] = "Done"
                // console.log(outputParameters)
                // resolve({ message: 'Your google sheet has been removed', status: 0, data: outputParameters });
                // input['outputParameters'] = {statusCode: "200", successMessage: 'All file path files moved to success folder path.', outputBody: 'done'};
                // if(input.outputParameters.outputBody!=''){
                //     console.log("excelDataaaa>>>>>",input.outputParameters);
                //     //socket.emit('utility_response', input);
                // }
            }
            catch (e) {
                console.log("Error in Socket triggering to read google sheet.", e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    asPerRequirementBotFoServer(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let scenario = JSON.parse(input.scenario);
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    if (scenario == "program_files") {
                        let extension = input.extension;
                        let successFolderPath = input.successFolderPath;
                        fs.readdir(successFolderPath, (err, files) => {
                            if (err)
                                throw err;
                            for (const file of files) {
                                let ext = file.split('.')[1];
                                console.log(ext);
                                if (ext == extension) {
                                    let folderPath = JSON.parse(input.folderPath);
                                    folderPath = folderPath[0];
                                    const spreadsheet = XLSX.readFile(folderPath);
                                    const sheets = spreadsheet.SheetNames;
                                    const secondSheetName = sheets[0];
                                    const secondSheet = spreadsheet.Sheets[secondSheetName];
                                    var data = XLSX.utils.sheet_to_json(secondSheet);
                                    let ab = {
                                        'Sr No': data.length + 1,
                                        'Program No': file,
                                        // 'Program Desc (Subject)': '',
                                        // 'MCC Code': '',
                                        // 'Program Type': '',
                                        // 'Start Date': '',
                                        // 'End Date': '',
                                        // 'Year': year,
                                        // 'Month': month,
                                        'PDF': 'yes/no',
                                        'Target': 'yes/no',
                                        'Working': 'yes/no'
                                    };
                                    data.push(ab);
                                    var newWB = XLSX.utils.book_new();
                                    var newWS = XLSX.utils.json_to_sheet(data);
                                    XLSX.utils.book_append_sheet(newWB, newWS, "output");
                                    XLSX.writeFile(newWB, folderPath);
                                    fs.unlink(path.join(successFolderPath, file), err => {
                                        if (err)
                                            throw err;
                                    });
                                }
                            }
                        });
                    }
                    else if (scenario == "folder") {
                        let folderPath = input.folderPath;
                        const removeDir = function (path) {
                            if (fs.existsSync(path)) {
                                const files = fs.readdirSync(path);
                                if (files.length > 0) {
                                    files.forEach(function (filename) {
                                        if (fs.statSync(path + "/" + filename).isDirectory()) {
                                            removeDir(path + "/" + filename);
                                        }
                                        else {
                                            fs.unlinkSync(path + "/" + filename);
                                        }
                                    });
                                    fs.rmdirSync(path);
                                }
                                else {
                                    fs.rmdirSync(path);
                                }
                            }
                            else {
                                console.log("Directory path not found.");
                            }
                        };
                        removeDir(folderPath);
                    }
                    outputParameters["update"] = "Done";
                    console.log(outputParameters);
                    resolve({ message: 'Your google sheet has been removed', status: 0, data: outputParameters });
                }));
            }
            catch (e) {
                console.log("Error in Socket triggering to read google sheet.", e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    reportSavex(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "useCaseData": input.useCaseData,
                    "array": input.array,
                    "useCase": input.useCase,
                    "excelFilePath": input.excelFilePath,
                    "collection": input.collection,
                    "filename": input.filename,
                    "month": input.month,
                    "year": input.year,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'reportSavex',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                // this.socket.emit('trigger-event2', obj.sheet_name);
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Report data updated in database.");
                return { message: 'Report data updated in database.', status: 0, data: null };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to update report in database." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    statuscaptureBotForUtility(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "clientTextPath": input.clientTextPath,
                    "textfilePath": input.textfilePath,
                    "ExcelfilePath": input.ExcelfilePath,
                    "processFlow": input.processFlow,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'statuscaptureBotForUtility',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("status capture done successfully.");
                return { message: 'status capture done successfully.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering for status capture." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    duplicationEntryCheckerBotForUtility(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "arrayOfObjects": input.arrayOfObjects,
                    "checker": input.checker,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'duplicationEntryCheckerBotForUtility',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                // this.socket.emit('trigger-event2', obj.arrayOfObjects);
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("all duplicate entries are removed.");
                return { message: 'all duplicate entries are removed.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to remove duplicate entry." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    jsonToExcelForUtility(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "arrayOfObjects": input.arrayOfObjects,
                    "folderPath": input.folderPath,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'jsonToExcelForUtility',
                    // "userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Your folder is made at given folder path.");
                return { message: 'your excel file is made at given folder path.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to give folder path." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    enhanceExcelSavex(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "folderPath": input.folderPath,
                    "successFolderPath": input.successFolderPath,
                    "useCase": input.useCase,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'enhanceExcelSavex',
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("updating excel file.");
                return { message: 'updating excel file.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to update excel file." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    MoveCompletedTask(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    let self = this;
                    let mongodb_uri = "mongodb://" + process.env.user + ":" + process.env.password + "@" + process.env.DB_HOST + ":" + process.env.port + "/" + process.env.DB_DATABASE; //+ process.env.user+ ":" + process.env.password + "@"
                    const mClient = yield MongoClient.connect(mongodb_uri);
                    const db = mClient.db(process.env.DB_DATABASE);
                    let eventsCompletedRecords = yield db.collection('events').find({ "eventStatus": "Completed" }).toArray();
                    let eventstatuses = yield db.collection('eventstatuses').find().toArray();
                    let eventsInsert = yield db.collection('eventsCompleted').initializeUnorderedBulkOp();
                    let eventstatusesInsert = yield db.collection('eventstatusesCompleted').initializeUnorderedBulkOp();
                    // let botInputOutputsInsert = await db.collection('botinputoutputsCompleted').initializeUnorderedBulkOp();
                    let eventsDelete = yield db.collection('events').initializeUnorderedBulkOp();
                    let eventstatusesDelete = yield db.collection('eventstatuses').initializeUnorderedBulkOp();
                    let botInputOutputsDelete = yield db.collection('botinputoutputs').initializeUnorderedBulkOp();
                    // let eventstatusesInsertionResult;
                    for (let eve of eventsCompletedRecords) {
                        eventsInsert.insert(eve);
                        for (let eve1 of eventstatuses) {
                            if (ObjectId(eve1.eventId).equals(ObjectId(eve._id))) {
                                eventstatusesInsert.insert(eve1);
                            }
                        }
                        eventsDelete.find({ "_id": ObjectId(eve._id) }).remove();
                        eventstatusesDelete.find({ "eventId": ObjectId(eve._id) }).remove();
                        botInputOutputsDelete.find({ "eventId": ObjectId(eve._id) }).remove();
                        let eventsInsertionRes = yield self.executeBulk(eventsInsert);
                        let eventstatusesInsertionResult = yield self.executeBulk(eventstatusesInsert);
                        if (eventsInsert.s.bulkResult['nInserted'] == eventsInsertionRes && eventstatusesInsert.s.bulkResult['nInserted'] == eventstatusesInsertionResult) {
                            yield self.executeBulk(eventsDelete);
                            yield self.executeBulk(eventstatusesDelete);
                            yield self.executeBulk(botInputOutputsDelete);
                            resolve({ info: 'Successfully exceuted', status: 0, data: [] });
                        }
                        else {
                            console.log("eventsInsertionResult===>", eventsInsertionRes);
                            console.log("eventstatusesInsertionResult===>", eventstatusesInsertionResult);
                            reject({ info: 'Error while  executing the process', status: 1, data: [] });
                        }
                    }
                }));
            }
            catch (err) {
                console.log("Data not saved" + err);
                return { info: 'Internal Server Error', status: 1, data: [] };
            }
        });
    }
    // public async remoteJobExecution(input, output, botId, projectId, iterationId) {
    //     try {
    //         let obj = {
    //             "command": input.command,
    //             "excelData": input.excelData,
    //             "username": input.username,
    //             "userpassword": input.userpassword,
    //             "projectId": projectId,
    //             "botId": botId,
    //             "iterationId": iterationId,
    //             "eventId": input.eventId,
    //             "from": 'remoteJobExecution',
    //             "accessControlList": input.accessControlList
    //         };
    //         this.socket.emit('trigger-event2', JSON.stringify(obj));
    //         return { message: 'Socket triggering to run commands.', status: 0, data: null };
    //     } catch (e) {
    //         this.log.error("Error in Socket triggering to read excel file utility." + e);
    //         return { message: e, status: 1, data: e };
    //     }
    // }
    // public async arrayToHtmlBot(input, output, botId, projectId, iterationId) {
    //     try {
    //         this.log.info('Inside array to html Bot' + JSON.stringify(input));
    //         let obj = input.data.slice(-5);
    //         console.log(obj);
    //         let htmlString;
    //         htmlString = "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <title>Bootstrap Example<\/title>\r\n  <meta charset=\"utf-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n  <style>\r\n  table { \r\n  width: 100%; \r\n  border-collapse: collapse; \r\n}\r\n\r\ntd { \r\n  padding: 6px; \r\n  border: 1px solid #ccc; \r\n  text-align: left; \r\n}\r\n\r\n  <\/style>\r\n <p><b>Dear Sir/Madam,<\/b><\/p> \r\n <p>The following shipments have crossed the threshold due to unfavorable weather conditions,Kindly take the appropriate mitigation measures<\/p>\r\n<\/head>\r\n<body>\r\n\r\n<div>           \r\n  <table border=\"1\">\r\n    \r\n        <head>\r\n          \r\n";
    //         htmlString = htmlString + "<\/head> \r\n    \r\n      \r\n      <tbody>    \r\n      <tr style=\"background:blue;color:white\">\r\n        <td>Shipment_House_Bill<\/td>\r\n        <td>Origin_Town<\/td>\r\n        <td>Destination_Town<\/td>\r\n        <td>Confirmed_Departure<\/td>\r\n        <td>Latest_Status_Location<\/td>\r\n        <td>Latest_Status_Date<\/td>\r\n        <td>Service<\/td>\r\n        <td>Transport_Mode<\/td>\r\n  <td>Reason_of_Catastrophic_Risk<\/td>\r\n   <td>Mitigation<\/td><\/tr>\r\n";
    //         for (let i = 0; i < obj.length; i++) {
    //             htmlString = htmlString + "<tr> <td>" + obj[i].Shipment_House_Bill + "</td>";
    //             htmlString = htmlString + "<td>\r\n" + obj[i].Origin_Town + "</td>";
    //             htmlString = htmlString + "<td>\r\n" + obj[i].Destination_Town + "</td>";
    //             htmlString = htmlString + "<td>\r\n" + obj[i].Confirmed_Departure + "</td>";
    //             htmlString = htmlString + "<td>\r\n" + obj[i].Latest_Status_Location + "</td>";
    //             htmlString = htmlString + "<td>\r\n" + obj[i].Latest_Status_Date + "</td>";
    //             //htmlString = htmlString + "<td>\r\n" + obj[i].Service + "</td>";
    //             htmlString = htmlString + "<td>\r\n" + obj[i].Transport_Mode + "</td>";
    //             htmlString = htmlString + "<td>\r\n" + obj[i].Reason_of_Catastrophic_Risk + "</td>";
    //             htmlString = htmlString + "<td>\r\n" + obj[i].Mitigation + "</td></tr>\r\n";
    //         }
    //         htmlString = htmlString + "<\/tbody>  \r\n  <\/table>\r\n<\/div>\r\n\r\n<\/body>\r\n<\/html>\r\n";
    //         output['htmlString'] = htmlString;
    //         return { message: '', status: 0, data: output };
    //     }
    //     catch (e) {
    //         console.log('Error in Reconcilation report', e);
    //         return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
    //     }
    // }
    readfilesFromFolders(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info("read files from folder.");
                if (!util_1.isNullOrUndefined(input) && !util_1.isNullOrUndefined(input.directoryPath)) {
                    let filesPath = [];
                    var a = input.directoryPath;
                    a = a.replace(/\[|\]/g, '').split(',');
                    var arr = typeof a == 'string' ? input.directoryPath : a[iterationId];
                    input.directoryPath = arr.replace(/"/g, '');
                    return new Promise((resolve, reject) => {
                        fs.readdir(input.directoryPath, function (err, data) {
                            if (err) {
                                output['filePath'] = null;
                                resolve({ status: 1, "message": err, data: output });
                            }
                            else {
                                data.forEach((files) => {
                                    filesPath.push(input.directoryPath + path.sep + files);
                                });
                                output['filePathJson'] = [];
                                output['filePath'] = JSON.stringify(filesPath);
                                output['dirPath'] = input.directoryPath;
                                filesPath.forEach(e => {
                                    output['filePathJson'].push({ path: e });
                                });
                                output['count'] = data.length;
                                resolve({ status: 0, "message": 'File read successfull', data: output });
                            }
                        });
                    });
                    // return { status: 0, "message": 'File read successfull', data: output };
                }
                else {
                    output['filePath'] = null;
                    return { status: 1, "message": 'directoryPath is not found', data: output };
                }
            }
            catch (e) {
                this.log.error("Error in Socket triggering for read file utility." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    transferDriveFiles(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("Starting file transfer from Google Drive...");
                const fs = require('fs');
                const path = require('path');
                //    const request = require('request');
                const unzipper = require('unzipper');
                const readline = require("readline");
                const { google } = require("googleapis");
                const { OAuth2Client } = require("google-auth-library");
                const SCOPES = ["https://www.googleapis.com/auth/gmail.readonly"];
                // /home/user/Desktop/KP/test/tokens_google1.json // local file place
                var TOKEN_PATH = "/home/user/1TB/kp-scripts/suportcred/tokens_google1.json"; // You can change this path if needed
                const { folderId, destinationPath, processingPath } = input;
                var googleflag = !util_1.isNullOrUndefined(input.Gflag) ? true : false;
                if (googleflag == true) {
                    // Load client secrets from a file and set up the OAuth2 client
                    if (!util_1.isNullOrUndefined(input.tokenFile))
                        TOKEN_PATH = input.tokenFile;
                    // /home/user/Desktop/KP/test/credentials.json // local file place
                    var credentialFile = "/home/user/1TB/kp-scripts/suportcred/credentials.json"; // You can change this path if needed
                    if (!util_1.isNullOrUndefined(input.credentialFile))
                        credentialFile = input.credentialFile;
                    // Load client secrets from a file and set up the OAuth2 client
                    console.log(credentialFile);
                    fs.readFile(credentialFile, (err, content) => {
                        if (err)
                            return console.log("Error loading client secret file:", err);
                        authorize(JSON.parse(content), listMessages);
                    });
                    function authorize(credentials, callback) {
                        const { client_secret, client_id, redirect_uris } = credentials.web;
                        const oAuth2Client = new OAuth2Client(client_id, client_secret, redirect_uris[0]);
                        // Check if we have previously stored a token
                        fs.readFile(TOKEN_PATH, (err, token) => {
                            if (err)
                                return getAccessToken(oAuth2Client, callback);
                            oAuth2Client.setCredentials(JSON.parse(token));
                            callback(oAuth2Client);
                        });
                    }
                    function getAccessToken(oAuth2Client, callback) {
                        const authUrl = oAuth2Client.generateAuthUrl({
                            access_type: "offline",
                            scope: SCOPES,
                        });
                        console.log("Authorize this app by visiting this URL:", authUrl);
                        const rl = readline.createInterface({
                            input: process.stdin,
                            output: process.stdout,
                        });
                        rl.question("Enter the code from that page here: ", (code) => {
                            rl.close();
                            oAuth2Client.getToken(code, (err, token) => {
                                if (err)
                                    return console.error("Error retrieving access token", err);
                                oAuth2Client.setCredentials(token);
                                // Store the token to disk for later program executions
                                fs.writeFile(TOKEN_PATH, JSON.stringify(token), (err) => {
                                    if (err)
                                        return console.error(err);
                                    console.log("Token stored to", TOKEN_PATH);
                                });
                                callback(oAuth2Client);
                            });
                        });
                    }
                    // const { folderId } = input;
                    let pageToken = null;
                    function listMessages(auth) {
                        return tslib_2.__awaiter(this, void 0, void 0, function* () {
                            const drive = google.drive({ version: 'v3', auth });
                            do {
                                const res = yield drive.files.list({
                                    q: `'${folderId}' in parents and trashed = false`,
                                    fields: 'nextPageToken, files(id, name, mimeType)',
                                    pageToken: pageToken || undefined,
                                });
                                const files = res.data.files;
                                pageToken = res.data.nextPageToken;
                                if (!files || files.length === 0) {
                                    console.log("No files found in the specified folder.");
                                    break;
                                }
                                for (const file of files) {
                                    // Check if the item is a file
                                    if (file.mimeType !== 'application/vnd.google-apps.folder') {
                                        const fileId = file.id;
                                        const fileName = file.name;
                                        const filePath = path.join(destinationPath, fileName);
                                        console.log(`Downloading file: ${fileName} to ${filePath}`);
                                        yield new Promise((resolve, reject) => {
                                            const dest = fs.createWriteStream(filePath);
                                            drive.files.get({ fileId: fileId, alt: 'media' }, { responseType: 'stream' }, (err, res) => {
                                                if (err) {
                                                    console.error(`Error downloading file: ${fileName}`, err);
                                                    return reject(err);
                                                }
                                                res.data
                                                    .on('end', () => {
                                                    console.log(`File downloaded successfully: ${filePath}`);
                                                    resolve();
                                                })
                                                    .on('error', (err) => {
                                                    console.error(`Error downloading file: ${fileName}`, err);
                                                    reject(err);
                                                })
                                                    .pipe(dest);
                                            });
                                        });
                                        // Check if the file is a ZIP file
                                        if (fileName.endsWith('.zip')) {
                                            console.log(`Unzipping file: ${filePath}`);
                                            // throw error if zip has nested zip file
                                            yield fs.createReadStream(filePath)
                                                .pipe(unzipper.Extract({ path: destinationPath }))
                                                .promise();
                                            console.log(`Unzipped file: ${filePath}`);
                                            // Delete the ZIP file
                                            fs.unlinkSync(filePath);
                                            console.log(`Deleted ZIP file: ${filePath}`);
                                        }
                                        // Delete folders within the unzipped content
                                        const unzippedItems = fs.readdirSync(destinationPath);
                                        for (const item of unzippedItems) {
                                            const itemPath = path.join(destinationPath, item);
                                            if (fs.lstatSync(itemPath).isDirectory()) {
                                                fs.rmdirSync(itemPath, { recursive: true });
                                                console.log(`Deleted folder: ${itemPath}`);
                                            }
                                        }
                                        // Move files from destinationPath to processingPath
                                        const filesToMove = fs.readdirSync(destinationPath);
                                        for (const file of filesToMove) {
                                            const srcPath = path.join(destinationPath, file);
                                            const destPath = path.join(processingPath, file);
                                            fs.renameSync(srcPath, destPath);
                                            console.log(`Moved file: ${file} to ${processingPath}`);
                                        }
                                    }
                                }
                            } while (pageToken);
                        });
                    }
                }
                else {
                    // Check if the file is a ZIP file
                    if (folderId.endsWith('.zip')) {
                        const filePath = path.join(destinationPath, folderId);
                        console.log(`Unzipping file: ${filePath}`); //fileName
                        // throw error if zip has nested zip file
                        yield fs.createReadStream(filePath)
                            .pipe(unzipper.Extract({ path: destinationPath }))
                            .promise();
                        console.log(`Unzipped file: ${processingPath}`);
                        // Delete the ZIP file
                        fs.unlinkSync(filePath);
                        console.log(`Deleted ZIP file: ${destinationPath}`);
                    }
                    // Move files from destinationPath to processingPath
                    const filePath_new = path.join(destinationPath, folderId.substring(0, folderId.length - 4));
                    const filesToMove = fs.readdirSync(filePath_new);
                    for (const file of filesToMove) {
                        const srcPath = path.join(filePath_new, file);
                        const destPath = path.join(processingPath, file);
                        fs.renameSync(srcPath, destPath);
                        console.log(`Moved file: ${file} to ${processingPath}`);
                    }
                    // Delete folders within the unzipped content
                    const unzippedItems = fs.readdirSync(processingPath);
                    for (const item of unzippedItems) {
                        const itemPath = path.join(processingPath, item);
                        if (fs.lstatSync(itemPath).isDirectory()) {
                            fs.rmdirSync(itemPath, { recursive: true });
                            console.log(`Deleted folder: ${itemPath}`);
                        }
                    }
                }
                console.log("File transfer completed.");
                output['result'] = 'moved';
                return { message: "Execution successful", status: 0, data: output };
            }
            catch (error) {
                console.error("Error during file transfer:", error);
                return { message: "Something went wrong", status: 1, data: error };
            }
        });
    }
    bankAdviceStatemant(input, output) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                var outData = JSON.parse(JSON.stringify(input.data));
                var pdfData = [];
                for (var i = 0; i < outData.length; i++) {
                    for (var j = 0; j < outData[i]["lineWithCombineWordsNew"].length; j++) {
                        for (var k = 0; k < outData[i]["lineWithCombineWordsNew"][j].length; k++) {
                            pdfData.push(outData[i]["lineWithCombineWordsNew"][j][k]);
                        }
                    }
                }
                return { message: "Process  sucessfully completed", status: 0, data: { pdfData: pdfData } };
            }
            catch (ex) {
                return { message: "Process  error", status: 1, data: ex };
            }
        });
    }
    pcfcBankStatemant(input, output) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                var bankName = "";
                if (input['documentType'].includes("CANARA")) {
                    bankName = "CANARA BANK";
                }
                else if (input['documentType'].includes("KOTAK")) {
                    bankName = "KOTAK BANK";
                }
                else if (input['documentType'].includes("INDUS")) {
                    bankName = "IDUSLAND BANK";
                }
                else if (input['documentType'].includes("YES")) {
                    bankName = "YES BANK";
                }
                else if (input['documentType'].includes("SBI")) {
                    bankName = "SBI BANK";
                }
                let data = yield (db.collection(input['documentType'])).findOne({ "referenceNumber": input["ref_num"] });
                var outData = [];
                data = JSON.parse(JSON.stringify(data));
                for (var i = 0; i < data["invoiceItems"].length; i++) {
                    switch (bankName) {
                        case "CANARA BANK":
                            if (data["invoiceItems"][i]["Account No"].includes("PCFC") && !data["invoiceItems"][i]["Account No"].includes(" ")) {
                                var obj = {};
                                var desc = "PCFC" + data["invoiceItems"][i]["Account No"].split("PCFC")[1].trim();
                                console.log(desc);
                                var dta = data["invoiceItems"][i]["Sr No"].trim().split(" ")[0];
                                var dt = dta.split("/");
                                console.log(dt);
                                obj["bankName"] = bankName;
                                obj["orgId"] = data['orgId'];
                                obj["currencyType"] = "USD";
                                obj["loanReferenceNo"] = desc;
                                obj["repaymentDate"] = dta;
                                obj["debit"] = Number(data["invoiceItems"][i]["Debit Amount"].trim());
                                obj["credit"] = data["invoiceItems"][i]["Credit Amount"].trim().replace(",", "");
                                obj["balance"] = data["invoiceItems"][i]["Balance"].replace(/[^0-9.]/g, '');
                                obj["status"] = "notUse";
                                outData.push(obj);
                            }
                            break;
                        default:
                            break;
                    }
                }
                if (outData.length != 0) {
                    yield (db.collection("Loan_Statement_PCFC")).insertMany(outData);
                }
                return { message: "Process  sucessfully completed", status: 0, data: { data: outData } };
            }
            catch (ex) {
                return { message: "Process  error", status: 1, data: ex };
            }
        });
    }
    currentBankStatemant(input, output) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let data = yield (db.collection("Bank_CurrentAccount_Statement")).findOne({ "referenceNumber": input["ref_num"] });
                var outData = [];
                data = JSON.parse(JSON.stringify(data));
                var bankName = "";
                if (data['filePath'].toLocaleLowerCase().includes("can_")) {
                    bankName = "CANARA BANK";
                }
                else if (data['filePath'].toLocaleLowerCase().includes("kotak")) {
                    bankName = "KOTAK BANK";
                }
                else if (data['filePath'].toLocaleLowerCase().includes("indus")) {
                    bankName = "IDUSLAND BANK";
                }
                else if (data['filePath'].toLocaleLowerCase().includes("yes")) {
                    bankName = "YES BANK";
                }
                else if (data['filePath'].toLocaleLowerCase().includes("sbi")) {
                    bankName = "SBI BANK";
                }
                for (var i = 0; i < data["invoiceItems"].length; i++) {
                    switch (bankName) {
                        case "CANARA BANK":
                            if (data["invoiceItems"][i]["BANK"].toLocaleLowerCase().includes("pay") && !util_1.isNullOrUndefined(data["invoiceItems"][i]["Name of the Account Description"]) && data["invoiceItems"][i]["Name of the Account Description"].includes("PCFC")) {
                                var obj = {};
                                var desc = data["invoiceItems"][i]["Name of the Account Description"].split("REF NO")[1].trim();
                                if (desc.split(" ")[0].trim() == ".") {
                                    desc = desc.substring(1).trim();
                                }
                                var dt = data["invoiceItems"][i]["Account: Date"].split("-");
                                obj["bankName"] = bankName;
                                obj["orgId"] = data['orgId'];
                                obj["currencyType"] = data['currencyType'];
                                obj["description"] = desc.split(" ")[0].trim();
                                obj["date"] = new Date(dt[1] + "-" + dt[0] + "-" + dt[2]);
                                obj["type"] = "PAY";
                                obj["debit"] = Number(data["invoiceItems"][i]["Debit"].trim());
                                obj["credit"] = (data["invoiceItems"][i]["Credit"].trim().replace(",", ""));
                                obj["balance"] = data["invoiceItems"][i]["Balance"].replace(/[^0-9.]/g, '');
                                obj["status"] = "notUse";
                                outData.push(obj);
                            }
                            break;
                        case "KOTAK BANK":
                            if (!util_1.isNullOrUndefined(data["invoiceItems"][i]["Narration"]) && data["invoiceItems"][i]["Narration"].includes("PCF")) {
                                var obj = {};
                                var desc;
                                if (data["invoiceItems"][i]["Narration"].split("CRE").length > 1) {
                                    desc = data["invoiceItems"][i]["Narration"].split("CRE")[0].trim();
                                }
                                else if (data["invoiceItems"][i]["Narration"].split("CONSOLIDATED")[0].trim()) {
                                    desc = data["invoiceItems"][i]["Narration"].split("CONSOLIDATED")[0].trim();
                                }
                                desc = "PCFC" + desc.split("PCFC")[1];
                                var dt = data["invoiceItems"][i]["Date"].trim().split("-");
                                var dt1;
                                if (dt[2].length === 4) {
                                    dt1 = new Date(dt[2] + "/" + dt[1] + "/" + dt[0]);
                                }
                                else if (Number(dt[2]) > 13)
                                    dt1 = new Date(dt[0] + "/" + dt[2] + "/" + dt[1]);
                                else
                                    dt1 = dt;
                                obj["bankName"] = bankName;
                                obj["orgId"] = data['orgId'];
                                obj["currencyType"] = data['currencyType'];
                                obj["description"] = desc.replace("-", "");
                                obj["date"] = dt1;
                                obj["type"] = "PAY";
                                obj["debit"] = Number(data["invoiceItems"][i]["Deposit(Cr)"].trim());
                                obj["credit"] = (data["invoiceItems"][i]["Withdrawal (Dr)"].trim().replace(",", ""));
                                obj["balance"] = data["invoiceItems"][i]["Balance"].replace(/[^0-9.]/g, '');
                                obj["status"] = "notUse";
                                outData.push(obj);
                            }
                            break;
                        case "IDUSLAND BANK":
                            if (data["invoiceItems"][i]["BANK"].toLocaleLowerCase().includes("pay") && !util_1.isNullOrUndefined(data["invoiceItems"][i]["Name of the Account Description"]) && data["invoiceItems"][i]["Name of the Account Description"].includes("PCFC")) {
                                var obj = {};
                                var desc = data["invoiceItems"][i]["Name of the Account Description"].split("REF NO")[1].trim();
                                obj["bankName"] = bankName;
                                obj["orgId"] = data['orgId'];
                                obj["currencyType"] = data['currencyType'];
                                obj["description"] = desc.split(" ")[0].trim();
                                obj["date"] = new Date(data["invoiceItems"][i]["Account: Date"]);
                                obj["type"] = "PAY";
                                obj["debit"] = Number(data["invoiceItems"][i]["Debit"].trim());
                                obj["credit"] = (data["invoiceItems"][i]["Credit"].trim().replace(",", ""));
                                obj["balance"] = data["invoiceItems"][i]["Balance"].replace(/[^0-9.]/g, '');
                                obj["status"] = "notUse";
                                outData.push(obj);
                            }
                            break;
                        case "YES BANK":
                            if (!util_1.isNullOrUndefined(data["invoiceItems"][i]["Description"]) && data["invoiceItems"][i]["Description"].includes("PCFC")) {
                                var obj = {};
                                var desc = data["invoiceItems"][i]["Description"].split(" ")[0].trim();
                                desc = "PCFC" + desc.split("PCFC")[1];
                                var keyname = Object.keys(data["invoiceItems"][i])[0];
                                var dt = data["invoiceItems"][i][keyname].split(" ")[0].trim().split("/");
                                var dt1;
                                if (dt[2].length === 4) {
                                    dt1 = new Date(dt[2] + "/" + dt[1] + "/" + dt[0]);
                                }
                                else if (Number(dt[2]) > 13)
                                    dt1 = new Date(dt[0] + "/" + dt[2] + "/" + dt[1]);
                                else
                                    dt1 = dt;
                                obj["bankName"] = bankName;
                                obj["orgId"] = data['orgId'];
                                obj["currencyType"] = data['currencyType'];
                                obj["description"] = desc.split(" ")[0].trim();
                                obj["date"] = new Date(dt1);
                                obj["type"] = "PAY";
                                obj["debit"] = Number(data["invoiceItems"][i]["Debit Amount"].replace(/[^0-9.]/g, ''));
                                obj["credit"] = (data["invoiceItems"][i]["Credit Amount"].trim().replace(",", ""));
                                obj["balance"] = data["invoiceItems"][i]["Running Balance"].replace(/[^0-9.]/g, '');
                                obj["status"] = "notUse";
                                outData.push(obj);
                            }
                            break;
                        case "SBI BANK":
                            if (!util_1.isNullOrUndefined(data["invoiceItems"][i]["Description"]) && data["invoiceItems"][i]["Description"].includes("PCFC")) {
                                var obj = {};
                                var desc = data["invoiceItems"][i]["Description"].split("REF NO")[1].trim();
                                //  console.log(desc)
                                obj["bankName"] = bankName;
                                obj["orgId"] = data['orgId'];
                                obj["currencyType"] = data['currencyType'];
                                obj["description"] = desc.split(" ")[0].trim();
                                obj["date"] = new Date(data["invoiceItems"][i]["Account: Date"]);
                                obj["type"] = "PAY";
                                obj["debit"] = Number(data["invoiceItems"][i]["Debit"].trim());
                                obj["credit"] = (data["invoiceItems"][i]["Credit"].trim().replace(",", ""));
                                obj["balance"] = data["invoiceItems"][i]["Balance"].replace(/[^0-9.]/g, '');
                                obj["status"] = "notUse";
                                outData.push(obj);
                            }
                            break;
                        default:
                            break;
                    }
                }
                if (outData.length != 0) {
                    yield (db.collection("Bank_Current_Account_Statement")).insertMany(outData);
                }
                return { message: "Process  sucessfully completed", status: 0, data: outData };
            }
            catch (ex) {
                return { message: "Process  error", status: 1, data: ex };
            }
        });
    }
    dailyLoanStatement(input, output) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // let data = await (db.collection("Bank_CurrentAccount_Statement")).findOne({ "referenceNumber": input["ref_num"] });
                var outData = [];
                let data = input.pdfData[input.pdfData.length - 1];
                var dt;
                var dt1;
                if (data["bankName"] == "KOTAK BANK") {
                    dt1 = new Date(data["kotakdate"]);
                }
                else if (data["bankName"] == "INDUSIAND BANK") {
                    dt1 = new Date(data["indusDate"]);
                }
                else {
                    dt = data["takenDate1"].split("/");
                    if (dt[2].length === 4)
                        dt1 = new Date(dt[2] + "/" + dt[1] + "/" + dt[0]);
                    else if (Number(dt[2]) > 13)
                        dt1 = new Date(dt[0] + "/" + dt[2] + "/" + dt[1]);
                    else
                        dt1 = dt;
                }
                outData["fileType"] = data["fileType"],
                    outData["fileName"] = data["fileName"];
                outData["date"] = dt1,
                    outData["adviceType"] = data["adviceType"];
                outData["customerName"] = data["customerName"];
                outData["address"] = data["address"];
                outData["contractNo"] = data["contractNo"];
                outData["billReferenceNo"] = data["billReferenceNo"];
                outData["panNumber"] = data["panNumber"];
                outData["customerId"] = data["customerId"];
                outData["interestType"] = data["interestType"];
                outData["currencyType"] = data["currencyType"];
                outData["bankName"] = data["bankName"];
                outData["accountNo"] = data["accountNo"];
                outData["invoiceNumber"] = "",
                    outData["invoiceDate"] = "";
                outData["loanReferenceNo"] = data["loanReferenceNo"];
                outData["loanAmountInUSD"] = data["loanAmountInUSD"];
                outData["loanAmountInINR"] = data["loanAmountInINR"];
                outData["convertedRateLoanTaken"] = 0;
                //    outData["bankConvertedRate"]= 0
                //    outData["tenor"]= 0
                //    outData["netInt" ]=""
                var dt2 = new Date(dt1);
                outData["takenDate"] = dt1;
                outData["dueDate"] = new Date(dt2.setDate(dt1.getDate() + 90));
                //    outData["repaymentDate"]=",
                //    outData["repaymentAmountInUSD" : 0,
                //    outData["bankRepaymentAmountInUSD" : 0,
                //    outData["bankRepaymentAmountInINR" : 0,
                outData["status"] = "notComplete";
                outData["orgId"] = "6363808106dd8e68cb19c88d";
                if (outData.length != 0) {
                    yield (db.collection("DailyLoanDetails")).insertMany(outData);
                }
                return { message: "Process  sucessfully completed", status: 0, data: outData };
            }
            catch (ex) {
                return { message: "Process  error", status: 1, data: ex };
            }
        });
    }
    abc(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("Shyam");
                outputParameters["hello"] = "done";
                return { message: 'Your google sheet has been removed', status: 0, data: outputParameters };
            }
            catch (e) {
                console.log("Error in Socket triggering to read google sheet.", e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    fetch_allcompany_tally(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    // "creditor": input.creditor,
                    // "debtors": input.Debtors,
                    //"data": input.data,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'fetch_allcompany_tally',
                    // "userId": input.userId,
                    //"accessControlList": input.accessControlList
                    "accessControlList": input.accessControlList
                };
                console.log(obj);
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Ledger id fetched from tally.");
                return { message: 'Ledger id fetched from tally.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("There is error" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    // public async sh(cmd) {
    //     return new Promise(function (resolve, reject) {
    //         exec(cmd, { maxBuffer: 1024 * 1024 * 500 }, (err, stdout, stderr) => {
    //             if (err) {
    //                 resolve({ status: 1, err: err });
    //             } if (stderr !== '') {
    //                 resolve({ status: 1, err: stderr });
    //             } else {
    //                 resolve({ status: 0, output: stdout });
    //             }
    //         });
    //     });
    // }
    RemoveSpace(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let filepath = input.filepath;
                var filename = filepath.endsWith('/') ? filepath.split("/")[filepath.split("/").length - 2] : filepath.split("/")[filepath.split("/").length - 1];
                var newpath = "";
                var array = filepath.split("/");
                var fileExtention = filename.substring(filename.lastIndexOf('.'));
                filename = filename.replace(/\s/g, "_");
                filename = filename.replace(/[!@#$%^&*()<>~{}?|]/g, "_");
                filename = filename.substring(0, filename.lastIndexOf('.'));
                filename = filename.replace(/\./g, '_') + fileExtention;
                console.log("new file:", filename);
                var loopCount = filepath.endsWith('/') ? array.length - 2 : array.length - 1;
                for (let index = 0; index < loopCount; index++) {
                    newpath += array[index] + "/";
                }
                newpath += filename;
                console.log("new path:", newpath);
                yield fs.renameSync(filepath, newpath);
                outPut["filepath"] = newpath;
                return { message: '', status: 0, data: outPut };
            }
            catch (error) {
                console.log(error);
                return { message: '', status: 1, data: error };
            }
        });
    }
    removeMargineCode(filterArray) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // let lineRight=0;
                let count = 0;
                let lastUnicode = 0;
                let caseA = "";
                let caseB = "";
                let firstPageId = filterArray[0].pageId;
                let lastPageId = filterArray[filterArray.length - 1].pageId;
                // let newFilterArray=[];
                let margineDetails = [];
                let compDiff = 6;
                for (let i = 0; i < filterArray.length; i++) {
                    let a = filterArray[i];
                    let na = a.line.charCodeAt(0);
                    if ((a.line.length == 1 && a.line.toUpperCase() == "A") || (a.line.length == 1 && firstPageId == a.pageId)) {
                        // lineRight=a.lineright;
                        if (a.line.toUpperCase() == a.line) {
                            caseA = "upperCase";
                        }
                        else {
                            caseA = "lowerCase";
                        }
                        count = 0;
                        for (let j = i + 1; j < filterArray.length; j++) {
                            let b = filterArray[j];
                            if (b.line.toUpperCase() == b.line) {
                                caseB = "upperCase";
                            }
                            else {
                                caseB = "lowerCase";
                            }
                            if (b.line.length == 1 && a.pageId == b.pageId && caseA == caseB) {
                                let nb = b.line.charCodeAt(0);
                                // if(b.line.toUpperCase()=="A" && Math.round(b.lineright) > Math.round(a.lineright)){
                                //     break;
                                // }else
                                let alineRight = Math.trunc(a.lineright);
                                let blineRight = Math.trunc(b.lineright);
                                let diff = 100;
                                if (alineRight > blineRight) {
                                    diff = alineRight - blineRight;
                                }
                                else {
                                    diff = blineRight - alineRight;
                                }
                                let unicodeDiff = nb - na;
                                if (unicodeDiff !== 1) {
                                    unicodeDiff = nb - lastUnicode;
                                }
                                if (diff < compDiff && unicodeDiff == 1 && (/[a-zA-Z]/.test(b.line))) {
                                    count++;
                                    lastUnicode = nb;
                                    // console.log("margineCode------" + b.line + "-------index-----" + j + "------" + a.pageId + "--------" + diff);
                                    if (count == 3 || (lastPageId == b.pageId && count == 1) || (firstPageId == b.pageId && count == 1)) {
                                        let obj = {
                                            pageId: a.pageId,
                                            lineright: a.lineright
                                        };
                                        margineDetails.push(obj);
                                        // for(let k=0;k<filterArray.length;k++){
                                        //     let c= filterArray[k];
                                        //     if(Math.trunc(c.lineright)==Math.trunc(a.lineright)){
                                        //         // filterArray[k].line="";
                                        //     }else{
                                        //         newFilterArray.push(c);
                                        //     }
                                        // }
                                    }
                                }
                            }
                        }
                    }
                }
                let result = margineDetails.reduce((unique, o) => {
                    if (!unique.some(obj => obj.pageId === o.pageId)) {
                        unique.push(o);
                    }
                    return unique;
                }, []);
                for (let i = 0; i < result.length; i++) {
                    let a = result[i];
                    for (let k = 0; k < filterArray.length; k++) {
                        let b = filterArray[k];
                        let alineRight = Math.trunc(a.lineright);
                        let blineRight = Math.trunc(b.lineright);
                        let diff = 100;
                        if (alineRight > blineRight) {
                            diff = alineRight - blineRight;
                        }
                        else {
                            diff = blineRight - alineRight;
                        }
                        if (diff < compDiff && a.pageId == b.pageId) {
                            // filterArray[k].line="";
                            if (!(/\d+/.test(b.line)) && b.line.length == 1) {
                                filterArray[k]['delete'] = true;
                            }
                        }
                    }
                }
                let final = filterArray.filter((obj, i) => {
                    return util_1.isNullOrUndefined(obj['delete']);
                });
                // filterArray=final;
                return final;
            }
            catch (e) {
                console.log("Error!!! -> " + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    addFotNoteAndSuperScript(a, b, c, d, subtype, superScript, type) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                //a == lines[0] i.e first Word of line;
                //b == lines[index] i.e other Word then first one;
                //c == verticle lines;
                if (subtype == "superscript") {
                    let regexMatch = /([*∗+†‡]{0,4})/g;
                    //let preDiff = 21;
                    let lineTop = 0;
                    let precentDiff = 100;
                    let aTop = Number(a['top']);
                    let bTop = Number(b['top']);
                    //let pTop = Number(d['top']);
                    let aFt = Number(a['fontSize']);
                    let bFt = Number(b['fontSize']);
                    let aBot = aTop - aFt;
                    let bBot = bTop - bFt;
                    let aMidBot = aTop - (aFt / 2);
                    let bMidBot = bTop - (bFt / 2);
                    let isSupMatch = false;
                    let refMaxHeight = 88;
                    let refMInHeight = 13;
                    a['line'] = a['line'].replace(/\∗/g, "*");
                    b['tagline'] = b['tagline'].replace(/\∗/g, "*");
                    if (!util_1.isNullOrUndefined(aTop)) {
                        precentDiff = Number(aTop) * 100 / Number(a['pageHeight']);
                    }
                    const regexForQuote = /[”"“‘“‘‘"‘`'“’’”’""']/g;
                    //let pageNo = 0;
                    if (Math.round(Number(a['pageHeight'])) > 600) {
                        refMaxHeight = 91;
                        refMInHeight = 15;
                    }
                    if (Math.round(Number(a['pageHeight'])) > 800) {
                        refMaxHeight = 93;
                        refMInHeight = 15;
                    }
                    if (Math.round(Number(a['pageHeight'])) > 850 && Math.round(Number(a['pageHeight'])) < 857 && Math.round(Number(a['pageWidth'])) >= 590 && type == "journals") {
                        refMaxHeight = 91;
                        refMInHeight = 15;
                    }
                    if (Math.round(Number(a['pageHeight'])) > 750 && Math.round(Number(a['pageHeight'])) < 758 && Math.round(Number(a['pageWidth'])) >= 480 && Math.round(Number(a['pageWidth'])) <= 488 && type == "journals" && a['cropboxY'] == 0 && a['cropboxX'] == 0) {
                        refMaxHeight = 84;
                        refMInHeight = 15;
                    }
                    if (!util_1.isNullOrUndefined(c) && c.length > 0) {
                        c.forEach((r, i) => {
                            let split = r.split('_');
                            if (Number(a.pageId) == Number(split[1])) {
                                lineTop = Number(split[2]) + Number(a['cropboxY']);
                            }
                            if ((Number(lineTop) * 100 / Number(a['pageHeight'])) < refMaxHeight - 10 && (Number(lineTop) * 100 / Number(a['pageHeight'])) > refMInHeight + 20) {
                                lineTop = Number(lineTop);
                            }
                            else {
                                lineTop = 0;
                            }
                        });
                        //Hello Ananta At<sb:TM> Welcome to new Era.
                    }
                    //b.left - a.lineright < 2 this condition added due to file CILS_075 for superscript '167' and b.left - a.lineright < 3.5 && a.line.includes(".") for JOlJ file;
                    if (precentDiff < refMaxHeight && precentDiff > refMInHeight && !(/^\°/g.test(a['line']))) {
                        if (aFt > bFt && bBot > aBot && aMidBot <= bBot && b.left > a.left && ((b.left - a.lineright < 1 || b.left - a.lineright < 2.7 || (b.left - a.lineright < 3.9) || (b.left - a.lineright < 5 && a['line'].endsWith(".") && !isNaN(b['line']))) && b.left - a.lineright > -1)) {
                            let isLength = !util_1.isNullOrUndefined(b['line']) && b['line'].split(" ").length > 1 ? true : false;
                            let bSplit = b['line'].split(" ");
                            let isMatch = (!isLength && regexMatch.test(bSplit[0])) || (regexMatch.test(bSplit[0]) && regexMatch.test(b['line'].trim().substring(b['line'].lastIndexOf(" "), b['line'].length))) ? true : false;
                            let pgId = b['pageId'];
                            if (!util_1.isNullOrUndefined(superScript) && superScript.length > 0) {
                                for (let r = 0; r < superScript.length; r++) {
                                    let k = superScript[r].split("_");
                                    if (Number(k[1]) == Number(pgId) && (k[0] == b['line'])) {
                                        isSupMatch = true;
                                        break;
                                    }
                                }
                            }
                            if ((!isNaN(Number(b['line'])) && Number(b['line']) != 0 && (!regexForQuote.test(b['line'])) || (regexForQuote.test(b['line']) && b['line'].length > 3) || isMatch) && !isSupMatch) {
                                if (Number(lineTop) < Number(bTop)) {
                                    a['isSuperScript'] = true;
                                    a['line'] = a['line'] + " " + "<sp:" + b['line'] + '>';
                                    //a['tagline']=a['tagline'].replace(b['tagline'],'');
                                    let isSupTxt = this.superScriptNumber(b['line']);
                                    let splitTagLine = a['tagline'].split(/\s/);
                                    if (/^\d+$/.test(isSupTxt)) {
                                        let tagline = "";
                                        for (let kk = 0; kk < splitTagLine.length; kk++) {
                                            if (splitTagLine[kk] == isSupTxt) {
                                                tagline = tagline + " " + "<sp:" + isSupTxt + ">";
                                            }
                                            else {
                                                tagline = tagline + " " + splitTagLine[kk];
                                            }
                                        }
                                        a['tagline'] = tagline;
                                    }
                                    else {
                                        a['tagline'] = a['tagline'].replace(isSupTxt, "<sp:" + isSupTxt + ">");
                                    }
                                    //a['tagline'] = a['tagline'] + "<sp:" + b['tagline'] + '>';
                                    b['line'] = this.superScriptNumber(b['line']);
                                    superScript.push(b['line'] + "_" + b['pageId']);
                                    console.log("b['line'] --A-- ", b['line'], a['line']);
                                    return { "a": a, "superScript": superScript };
                                }
                                else {
                                    if (!util_1.isNullOrUndefined(a['lastword_concat']) && a['lastword_concat'] == false)
                                        a['line'] = a['line'] + " " + b['line'];
                                    a['isSuperScript'] = util_1.isNullOrUndefined(a['isSuperScript']) || a['isSuperScript'] !== true ? false : a['isSuperScript'];
                                    //console.log("b['line'] --B--   ISFOTNOTE");
                                    return { "a": a, "superScript": superScript };
                                }
                            }
                            else {
                                if (!util_1.isNullOrUndefined(a['lastword_concat']) && a['lastword_concat'] == false)
                                    a['line'] = a['line'] + " " + b['line'];
                                a['isSuperScript'] = util_1.isNullOrUndefined(a['isSuperScript']) || a['isSuperScript'] !== true ? false : a['isSuperScript'];
                                //console.log("Simple Concat --- A ---");
                                return { "a": a, "superScript": superScript };
                            }
                        }
                        else if (aFt < bFt && bBot < aBot && aBot >= bMidBot && a['YScale'] !== b['YScale'] && b.left > a.left && (b.left - a.lineright < 1 && b.left - a.lineright > -1)) {
                            let isLength = !util_1.isNullOrUndefined(a['line']) && a['line'].split(" ").length == 1 ? true : false;
                            let aSplit = a['line'].split(" ");
                            let isMatch = (!isLength && regexMatch.test(aSplit[0])) || (regexMatch.test(aSplit[0])) ? true : false;
                            let pgId = a['pageId'];
                            if (!util_1.isNullOrUndefined(superScript) && superScript.length > 0) {
                                for (let r = 0; r <= superScript.length - 1; r++) {
                                    let k = superScript[r].split("_");
                                    if (Number(k[1]) == Number(pgId) && (k[0] == a['line'] || a['isSuperScript'] || k[0] == aSplit[0])) {
                                        isSupMatch = true;
                                        break;
                                    }
                                }
                            }
                            if ((!isNaN(Number(a['line'])) && (!regexForQuote.test(a['line'])) || isMatch) && !isSupMatch) {
                                if (Number(lineTop) < Number(aTop)) {
                                    a['isSuperScript'] = true;
                                    let isSupTxt = this.superScriptNumber(a['line']);
                                    a['tagline'] = a['tagline'].replace(isSupTxt, "<sp:" + isSupTxt + ">");
                                    a['line'] = "<sp:" + a['line'] + '>' + " " + b['line'];
                                    //a['tagline'] = "<sp:" + a['tagline'] + '>' + " " + b['tagline'];
                                    let isSupText = this.superScriptNumber(a['line']);
                                    superScript.push(isSupText + "_" + b['pageId']);
                                    console.log("a['line'] --A-- ", a['line'], b['line']);
                                    return { "a": a, "superScript": superScript };
                                }
                                else {
                                    a['line'] = a['line'] + " " + b['line'];
                                    a['isSuperScript'] = util_1.isNullOrUndefined(a['isSuperScript']) || a['isSuperScript'] !== true ? false : a['isSuperScript'];
                                    //console.log("a['line'] --B-- ISFOTNOTE");
                                    return { "a": a, "superScript": superScript };
                                }
                            }
                            else {
                                if (!util_1.isNullOrUndefined(a['lastword_concat']) && a['lastword_concat'] == false)
                                    a['line'] = a['line'] + " " + b['line'];
                                a['isSuperScript'] = util_1.isNullOrUndefined(a['isSuperScript']) || a['isSuperScript'] !== true ? false : a['isSuperScript'];
                                //console.log("a['line'] --B-- ISFOTNOTE");
                                return { "a": a, "superScript": superScript };
                            }
                        }
                        else {
                            let isTrue = /([*+†‡])/g.test(b['line']);
                            let preSuper = !util_1.isNullOrUndefined(superScript) && superScript.length > 0 ? superScript[superScript.length - 1].split("_") : null;
                            isTrue = !util_1.isNullOrUndefined(preSuper) && (Number(preSuper[0]) + 1 == Number(b['line']) || Number(preSuper[0]) + 1 == Number(a['line'])) && isTrue == false ? true : isTrue;
                            a['isSuper'] = !util_1.isNullOrUndefined(preSuper) && Number(preSuper[0]) + 1 == Number(a['line']) && isTrue == true ? Number(a['line']) : delete a['isSuper'];
                            if (!util_1.isNullOrUndefined(a['lastword_concat']) && a['lastword_concat'] == false)
                                a['line'] = a['line'] + " " + b['line'];
                            a['isSuperScript'] = util_1.isNullOrUndefined(a['isSuperScript']) || a['isSuperScript'] !== true ? false : a['isSuperScript'];
                            if (isTrue && !util_1.isNullOrUndefined(superScript) && superScript.length > -1) {
                                for (let r = 0; r < superScript.length; r++) {
                                    let k = superScript[r].split("_");
                                    if (isTrue) {
                                        let isSupTxt = this.superScriptNumber(b['line']);
                                        if (Number(k[1]) == Number(b['pageId']) && (k[0] == isSupTxt && (!util_1.isNullOrUndefined(a['isSuperScript']) && a['isSuperScript']))) {
                                            isSupMatch = true;
                                            break;
                                        }
                                    }
                                }
                                ;
                                if (isTrue && !isSupMatch && /([*†‡])/g.test(b['line'])) {
                                    a['line'] = a['line'].replace(/\∗/g, "*");
                                    a['tagline'] = a['tagline'].replace(/\∗/g, "*");
                                    //b['line'] = b['line'].replace(/\∗/g,"*");
                                    let isSupTxt = this.superScriptNumber(b['line']);
                                    a['tagline'] = a['tagline'].replace(isSupTxt, " <sp:" + isSupTxt + ">");
                                    a['line'] = a['line'].replace(isSupTxt, " <sp:" + isSupTxt + ">");
                                    a['isSuperScript'] = true;
                                    superScript.push(isSupTxt + "_" + a['pageId']);
                                    console.log("regexMatch --- E --- ", a["line"]);
                                }
                                else if (isTrue && !isSupMatch && (/^\d+$/.test(b['line']) || (!util_1.isNullOrUndefined(a['isSuper']) && /^\d+$/.test(a['isSuper']))) && type !== "journals" && Math.round(a['top']) !== Math.round(b['top'])) {
                                    if (!util_1.isNullOrUndefined(a['isSuper']) && /^\d+$/.test(a['isSuper']) && superScript.indexOf(a['isSuper'].toString() + "_" + a['pageId'].toString()) == -1) {
                                        a['tagline'] = a['tagline'].replace(a['isSuper'], " <sp:" + a['isSuper'] + ">");
                                        a['line'] = a['line'].replace(a['isSuper'], " <sp:" + a['isSuper'] + ">");
                                        a['isSuperScript'] = util_1.isNullOrUndefined(a['isSuperScript']) || a['isSuperScript'] !== true ? true : a['isSuperScript'];
                                        superScript.push(a['isSuper'] + "_" + a['pageId']);
                                        console.log("regexMatch --- G --- ", a["line"]);
                                        delete a['isSuper'];
                                    }
                                    if (/^\d+$/.test(b['line']) && superScript.indexOf(b['line'].toString() + "_" + b['pageId'].toString()) == -1 && a['isSuperScript']) {
                                        a['tagline'] = a['tagline'].replace(b['tagline'], " <sp:" + b['tagline'] + ">");
                                        a['line'] = a['line'].replace(b['line'], " <sp:" + b['line'] + ">");
                                        a['isSuperScript'] = util_1.isNullOrUndefined(a['isSuperScript']) || a['isSuperScript'] !== true ? true : a['isSuperScript'];
                                        superScript.push(b['line'] + "_" + a['pageId']);
                                        console.log("regexMatch --- H --- ", a["line"]);
                                    }
                                }
                            }
                            //console.log("Simple Concat --- B ---");
                            return { "a": a, "superScript": superScript };
                        }
                    }
                    else {
                        if (!util_1.isNullOrUndefined(a['lastword_concat']) && a['lastword_concat'] == false)
                            a['line'] = a['line'] + " " + b['line'];
                        a['isSuperScript'] = util_1.isNullOrUndefined(a['isSuperScript']) || a['isSuperScript'] !== true ? false : a['isSuperScript'];
                        //console.log("Simple Concat --- C ----");
                        return { "a": a, "superScript": superScript };
                    }
                }
                else if (subtype == "fotLines") {
                    let foteNote = [];
                    let tableArray = [];
                    let regexMatch = /(^[*∗+†‡]{0,4})/g;
                    let prefotFt = 0;
                    //let prefotScale = 0;
                    let fotleft = 0;
                    let prefotTop = 0;
                    let lineTop = 0;
                    let precentDiff = 0;
                    //let fotTop = 0;
                    let fName = "";
                    let refMaxHeight = 91;
                    let refMInHeight = 15;
                    if (!util_1.isNullOrUndefined(a) && a.length > 1) {
                        let preFotD = a.filter((r, i) => {
                            let supPag = [];
                            if (!util_1.isNullOrUndefined(c) && c.length > 0 && c.filter(r => { return r == "0_0_0"; }).length !== c.length) {
                                for (let l = 0; l <= superScript.length - 1; l++) {
                                    let splitSu = superScript[l].split("_");
                                    if (c[splitSu[1]] !== "0_0_0") {
                                        supPag = superScript[l].length < 6 ? superScript[l].split("_") : superScript[l + 1].split("_");
                                        break;
                                    }
                                }
                                if (r['line'].trim().substring(0, r['line'].indexOf(" ")) == supPag[0] && Number(r.pageId) == Number(supPag[1]) && Number(a[i - 1]['top'] - a[i - 1]['fontSize']) - Number(r['top']) > 12) {
                                    prefotTop = Number(a[i - 1]['top'] - a[i - 1]['fontSize']) - Number(r['top']) > 30 ? 0 : Number(a[i - 1]['top'] - a[i - 1]['fontSize']) - Number(r['top']);
                                    return r;
                                }
                            }
                            else {
                                for (let l = 0; l <= superScript.length - 1; l++) {
                                    supPag = superScript[l].length < 6 ? superScript[l].split("_") : superScript[l].split("_");
                                    if (r['line'].trim().substring(0, r['line'].indexOf(" ")) == supPag[0] && Number(r.pageId) == Number(supPag[1]) && Number(a[i - 1]['top'] - a[i - 1]['fontSize']) - Number(r['top']) > 12) {
                                        prefotTop = Number(a[i - 1]['top'] - a[i - 1]['fontSize']) - Number(r['top']) > 30 ? 0 : Number(a[i - 1]['top'] - a[i - 1]['fontSize']) - Number(r['top']);
                                        return r;
                                    }
                                }
                            }
                            ;
                        });
                        preFotD = JSON.parse(JSON.stringify(preFotD));
                        fName = preFotD.length > 0 ? preFotD[0]['fontName'] : null;
                        prefotFt = preFotD.length > 0 ? Number(preFotD[0]['fontSize']) : 0;
                        //prefotScale = Number(preFotD[0]['YScale']);
                        let pageNo = preFotD.length > 0 ? Number(preFotD[0]['pageId']) : -1;
                        let split = [];
                        let pgId = -1;
                        let isFtStart = false;
                        let isUnderline = false;
                        let currentPageId = -1;
                        //Extract FotNote Array Ieration;
                        let lastFootNote = "-1";
                        let lastFootNoteLeft = -1;
                        let afterSuperScriptFont = -1;
                        for (let i = 0; i < a.length; i++) {
                            //Specific Page Top
                            if (Number(a[i]['pageHeight']) > 600) {
                                refMaxHeight = 91;
                                refMInHeight = 13;
                            }
                            if (Number(a[i]['pageHeight']) > 800) {
                                refMaxHeight = 93;
                                refMInHeight = 15;
                            }
                            if (/^\d\*\s/.test(a[i].line)) {
                                a[i].line = a[i].line.replace(/^\d\*\s/, "* ");
                                a[i].tagline = a[i].tagline.replace(/^\d\*\s/, "* ");
                            }
                            if ((/\∗/g.test(a[i]["line"]))) {
                                a[i]['line'] = a[i]['line'].replace(/\∗/g, "*");
                                a[i]['tagline'] = a[i]['tagline'].replace(/\∗/g, "*");
                            }
                            if (!util_1.isNullOrUndefined(a[i]['pageId']) && pgId < a[i]['pageId']) {
                                let aFoot = a.filter((r) => {
                                    if (r.line.includes("<sp:") && Number(r.pageId) == Number(a[i]['pageId'])) {
                                        return true;
                                    }
                                    else if (Number(r.pageId) > Number(a[i]['pageId']) || Number(r.pageId) < Number(a[i]['pageId'])) {
                                        return false;
                                    }
                                    else {
                                        return false;
                                    }
                                });
                                if (aFoot.length > 0) {
                                    afterSuperScriptFont = Number(aFoot[aFoot.length - 1]['top']) + Number(aFoot[aFoot.length - 1]['fontSize']);
                                }
                                else {
                                    afterSuperScriptFont = -1;
                                }
                                ;
                            }
                            let isTrue = type !== "Law_Reports" ? true : false;
                            isUnderline = !util_1.isNullOrUndefined(a[i].pageId) && pgId !== a[i]['pageId'] ? false : isUnderline;
                            lineTop = !util_1.isNullOrUndefined(a[i].pageId) && pgId !== a[i]['pageId'] && !isTrue ? -1 : lineTop;
                            isFtStart = !util_1.isNullOrUndefined(a[i].pageId) && pgId !== a[i]['pageId'] ? false : isFtStart;
                            pgId = !util_1.isNullOrUndefined(a[i].pageId) && (pgId == -1 || pgId !== a[i].pageId) ? a[i].pageId : pgId;
                            let preDiff = type == "Law_Reports" ? 21 : 18;
                            if (Number(a[i]['pageHeight']) < 600 && !isTrue) {
                                refMaxHeight = 89;
                                refMInHeight = 8;
                            }
                            if (Number(a[i]['pageHeight']) > 840 && Number(a[i]['pageWidth']) > 595 && !isTrue) {
                                refMaxHeight = 90;
                                refMInHeight = 10;
                            }
                            let preOfPD = 11;
                            let precount = Number(i - 1); //preLine index
                            let aTop = Number(a[i]['top']);
                            let bTop = i > 0 ? Number(a[i - 1]['top']) : 0;
                            //let aBot = Number(a[i]['top'] - a[i]['YScale']);
                            let bBot = i > 0 ? Number(a[i - 1]['top'] - a[i - 1]['YScale']) : null;
                            let aFt = Number(a[i]['fontSize']);
                            //let aBot = Number(a[i]['top']) - Number(a[i]['YScale']);
                            let bFt = i > 0 ? Number(a[i - 1]['fontSize']) : null;
                            a[i]['line'] = a[i]['line'].replace(/\∗/g, "*");
                            // For AHRLJ File their is an hidden text i.e 1 so i handled that . for SAMERLJ file no. 115
                            let fstLet = !a[i]['line'].includes(" ") ? a[i]['line'].trim().substring(0, a[i]['line'].length) : a[i]['line'].trim().substring(0, a[i]['line'].indexOf(" "));
                            fstLet = a[i]['line'].includes("*1") || a[i]['line'].includes("*LLB") ? a[i]['line'].trim().substring(0, 1) : fstLet;
                            if (!util_1.isNullOrUndefined(c) && c.length > 0 && ((lineTop == -1 && !isTrue) || isTrue)) {
                                if (!util_1.isNullOrUndefined(c[Number(a[i]['pageId'])]) && Number(a[i]['pageId']) !== 0) {
                                    split = c[Number(a[i]['pageId'])].split('_');
                                    if (Number(split[2]) > 0 && pageNo != -1) { //
                                        lineTop = Number(split[2]) + Number(a[i]['cropboxY']);
                                        pageNo = Number(split[1]);
                                        //fotTop = 0;
                                        //isFtStart = false;
                                    }
                                    else if (c[Number(a[i]['pageId'])].toString() == "0_0_0") {
                                        lineTop = 0;
                                        pageNo = a[i]['pageId'];
                                    }
                                }
                                else {
                                    split = !util_1.isNullOrUndefined(c[Number(a[i]['pageId'])]) && Number(a[i]['pageId']) <= c.length ? c[Number(a[i]['pageId'])].split('_') : split;
                                    if (Number(split[2]) > 0 && pageNo != -1) { //&& c[Number(a[i]['pageId'])] != "192.560_0_649.440" && c[Number(a[i]['pageId'])] != "630.966_0_211.034"
                                        lineTop = Number(split[2]) + Number(a[i]['cropboxY']);
                                        pageNo = Number(split[1]);
                                    }
                                    else if (c[Number(a[i]['pageId'])].toString() == "0_0_0") {
                                        lineTop = 0;
                                        pageNo = a[i]['pageId'];
                                    }
                                }
                            }
                            ;
                            //Difference from top;
                            if (!util_1.isNullOrUndefined(aTop)) {
                                precentDiff = aTop * 100 / Number(a[i]['pageHeight']);
                            }
                            //previousLine to Previous Difference
                            if (!util_1.isNullOrUndefined(precount) && precount > 0 && i > 1 && a[precount - 1]['pageId'] == a[precount]['pageId']) {
                                preOfPD = Number(Number(a[precount - 1]['top']) + Number(a[precount - 1]['YScale'])) - bTop;
                            }
                            //Difference as a refernce
                            if (i > 0 && ((bTop - aFt) - aTop) - preOfPD > 0 && Number(a[precount]['Height']) - Number(a[i]['Height']) > 0) {
                                preDiff = Number(a[precount]['Height']) * Number(3);
                            }
                            // || (lineTop != 0 && prefotFt >= a[i]['YScale'] && !isTrue)
                            if (Math.round(precentDiff) >= refMInHeight && Math.round(precentDiff) <= refMaxHeight && ((prefotFt >= aFt || (lineTop != 0 && prefotFt >= a[i]['YScale'] && !isTrue)) || (prefotFt >= a[i]['YScale'] && isTrue) || prefotFt == 0 || isFtStart)) {
                                if (pageNo !== -1 && lineTop != 0 && i > 0 && ((a[i - 1]['tagline'].includes('#u$') && !isTrue) || (a[i]['tagline'].includes('#u$') && !isTrue))) {
                                    if (a[i - 1]['top'] < lineTop + 5 || a[i]['top'] < lineTop + 5) {
                                        lineTop = 0;
                                        isUnderline = false;
                                    }
                                    else {
                                        isUnderline = false;
                                    }
                                    tableArray.push(a[i]);
                                    continue;
                                }
                                if (pageNo !== -1 && lineTop != 0 && !isUnderline) {
                                    if ((!util_1.isNullOrUndefined(aTop) && i > 0 && aTop < Number(lineTop) && Number(a[i]['pageId']) == Number(pageNo) && aFt <= bFt) || ((Number(a[i]['cropboxY']) == 0) && aTop - 10 < Number(lineTop) && Number(a[i]['pageId']) == Number(pageNo) && aFt <= bFt && isTrue) || isFtStart) {
                                        console.log("FotNote --- A --- ", i, " FotNotes Index  ", foteNote.length, "  TableArray ", tableArray.length);
                                        if ((!isNaN(Number(fstLet)) || (regexMatch.test(a[i]['line']) || regexMatch.test(fstLet))) && superScript.indexOf(fstLet + "_" + a[i]["pageId"]) > -1) {
                                            fotleft = Number(a[i]['lineleft']);
                                            //fotTop = aTop;
                                            prefotFt = Number(a[i]['fontSize']);
                                            if (fotleft >= Number(a[i]['lineleft']) && foteNote.filter(r => { return r['FoteNoteId'] == fstLet && r['pageId'] == a[i]['pageId']; }).length == 0) {
                                                if (/^\d+$/.test(fstLet) && /^\d+$/.test(lastFootNote) && lastFootNote !== "-1") {
                                                    let leftDiff = 0;
                                                    // if(a[i].left>lastFootNoteLeft){
                                                    //     leftDiff=a[i].left-lastFootNoteLeft;
                                                    // }else{
                                                    //     leftDiff=lastFootNoteLeft-a[i].left;
                                                    // }
                                                    if (Number(fstLet) - Number(lastFootNote) == 1 && (leftDiff < 15 || lastFootNoteLeft == 0)) {
                                                        a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                                        lastFootNote = fstLet;
                                                        lastFootNoteLeft = a[i].left;
                                                    }
                                                }
                                                else {
                                                    a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                                    if (/^\d+$/.test(fstLet) && lastFootNote == "-1") {
                                                        lastFootNote = fstLet;
                                                        lastFootNoteLeft = a[i].left;
                                                    }
                                                }
                                                a[i]['isFoteNote'] = true;
                                            }
                                            else {
                                                a[i]['isFoteNote'] = true;
                                            }
                                            ;
                                            isFtStart = true;
                                            foteNote.push(a[i]);
                                            a[i]['puhsed'] = true;
                                            currentPageId = a[i].pageId;
                                        }
                                        else {
                                            //fotTop = aTop;
                                            foteNote.push(a[i]);
                                            a[i]['puhsed'] = true;
                                            currentPageId = a[i].pageId;
                                        }
                                        ;
                                    }
                                    else {
                                        // tableArray.push(a[i]);
                                        if (util_1.isNullOrUndefined(a[i]['puhsed']) && currentPageId == a[i].pageId && !a[i].line.includes("Company (Pty) Ltd") && !(/^[\d*]+$/.test(a[i].line)) && a[i].lineleft > 45 && isTrue) {
                                            console.log("FotNote --- F --- ", i, " FotNotes Index  ", foteNote.length, "  TableArray ", tableArray.length);
                                            //console.log('Fotnote --- F --- ',i);
                                            let diff = bBot - aTop;
                                            let percDff = 0;
                                            if (diff > aFt) {
                                                percDff = (aFt / diff) * 100;
                                            }
                                            else {
                                                percDff = (diff / aFt) * 100;
                                            }
                                            if ((!isNaN(Number(fstLet)) || regexMatch.test(fstLet)) && superScript.indexOf(fstLet + "_" + a[i]["pageId"]) > -1 && percDff < 60) {
                                                fotleft = Number(a[i]['lineleft']);
                                                //fotTop = aTop;
                                                fName = a[i]['fontName'];
                                                prefotFt = Number(a[i]['fontSize']);
                                                if (fotleft >= Number(a[i]['lineleft']) && foteNote.filter(r => { return r['FoteNoteId'] == fstLet; }).length == 0) {
                                                    //     a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                                    // a[i]['isFoteNote'] = true;
                                                    if (/^\d+$/.test(fstLet) && /^\d+$/.test(lastFootNote) && lastFootNote !== "-1") {
                                                        let leftDiff = 0;
                                                        // if(a[i].left>lastFootNoteLeft){
                                                        //     leftDiff=a[i].left-lastFootNoteLeft;
                                                        // }else{
                                                        //     leftDiff=lastFootNoteLeft-a[i].left;
                                                        // }
                                                        if (Number(fstLet) - Number(lastFootNote) == 1 && (leftDiff < 15 || lastFootNoteLeft == 0)) {
                                                            a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                                            lastFootNote = fstLet;
                                                            lastFootNoteLeft = a[i].left;
                                                        }
                                                    }
                                                    else {
                                                        a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                                        if (/^\d+$/.test(fstLet) && lastFootNote == "-1") {
                                                            lastFootNote = fstLet;
                                                            lastFootNoteLeft = a[i].left;
                                                        }
                                                    }
                                                }
                                                else {
                                                    a[i]['isFoteNote'] = true;
                                                }
                                                ;
                                                foteNote.push(a[i]);
                                                a[i]['puhsed'] = true;
                                                currentPageId = a[i].pageId;
                                            }
                                        }
                                        else {
                                            tableArray.push(a[i]);
                                        }
                                    }
                                }
                                else if (i > 0 && !util_1.isNullOrUndefined(prefotFt) && !util_1.isNullOrUndefined(fName) && (aFt < bFt && a[i]['YScale'] !== a[precount]['YScale'] && aFt <= prefotFt && fName == a[i]['fontName'] && ((bBot - aTop) * 2) >= prefotTop && prefotTop !== 0 && afterSuperScriptFont != -1 && afterSuperScriptFont > a[i]['top']) || isFtStart) {
                                    console.log("FotNote --- B --- ", i, " FotNotes Index  ", foteNote.length, "  TableArray ", tableArray.length);
                                    //console.log("FotNote --- B --- ", i);
                                    if ((!isNaN(Number(fstLet)) || (regexMatch.test(a[i]['line']) || regexMatch.test(fstLet))) && superScript.indexOf(fstLet + "_" + a[i]["pageId"]) > -1) {
                                        fotleft = Number(a[i]['lineleft']);
                                        //fotTop = aTop;
                                        prefotFt = Number(a[i]['fontSize']);
                                        if (fotleft >= Number(a[i]['lineleft']) && foteNote.filter(r => { return r['FoteNoteId'] == fstLet && r['pageId'] == a[i]['pageId']; }).length == 0) {
                                            //     a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                            // a[i]['isFoteNote'] = true;
                                            if (/^\d+$/.test(fstLet) && /^\d+$/.test(lastFootNote) && lastFootNote !== "-1") {
                                                let leftDiff = 0;
                                                // if(a[i].left>lastFootNoteLeft){
                                                //     leftDiff=a[i].left-lastFootNoteLeft;
                                                // }else{
                                                //     leftDiff=lastFootNoteLeft-a[i].left;
                                                // }
                                                if (Number(fstLet) - Number(lastFootNote) == 1 && (leftDiff < 15 || lastFootNoteLeft == 0)) {
                                                    a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                                    lastFootNote = fstLet;
                                                    lastFootNoteLeft = a[i].left;
                                                }
                                            }
                                            else {
                                                a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                                if (/^\d+$/.test(fstLet) && lastFootNote == "-1") {
                                                    lastFootNote = fstLet;
                                                    lastFootNoteLeft = a[i].left;
                                                }
                                            }
                                        }
                                        else {
                                            a[i]['isFoteNote'] = true;
                                        }
                                        ;
                                        isFtStart = true;
                                        foteNote.push(a[i]);
                                        a[i]['puhsed'] = true;
                                        currentPageId = a[i].pageId;
                                    }
                                    else {
                                        isFtStart = true;
                                        //fotTop = aTop;
                                        foteNote.push(a[i]);
                                        a[i]['puhsed'] = true;
                                        currentPageId = a[i].pageId;
                                    }
                                }
                                else if (i > 0 && (aFt <= 8 && afterSuperScriptFont != -1 && afterSuperScriptFont > a[i]['top'] || ((aFt <= 9 && a[i]['YScale'] < a[i - 1]['YScale'] && afterSuperScriptFont != -1 && afterSuperScriptFont > a[i]['top'] && isTrue) || isFtStart)) && ((aFt < bFt && afterSuperScriptFont != -1 && afterSuperScriptFont > a[i]['top'] || (a[i]['YScale'] < a[i - 1]['YScale'] && isTrue && afterSuperScriptFont != -1 && afterSuperScriptFont > a[i]['top'])) && ((((Math.round((bBot - aTop) * 2) >= preDiff) && isTrue && (Math.round((bBot - aTop)) >= 10)) || (((bBot - aTop) >= preDiff) && !isTrue)) && ((((bBot - aTop) >= prefotTop / 2.25) && isTrue) || (((bBot - aTop) >= prefotTop) && !isTrue)))) || isFtStart) {
                                    console.log("FotNote --- C --- ", i, " FotNotes Index  ", foteNote.length, "  TableArray ", tableArray.length);
                                    //console.log("FotNote --- C --- ", i);
                                    if ((!isNaN(Number(fstLet)) || regexMatch.test(fstLet)) && superScript.indexOf(fstLet + "_" + a[i]["pageId"]) > -1) {
                                        fotleft = Number(a[i]['lineleft']);
                                        //fotTop = aTop;
                                        fName = a[i]['fontName'];
                                        prefotFt = Number(a[i]['fontSize']);
                                        if (fotleft >= Number(a[i]['lineleft']) && foteNote.filter(r => { return r['FoteNoteId'] == fstLet && r['pageId'] == a[i]['pageId']; }).length == 0) {
                                            //     a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                            // a[i]['isFoteNote'] = true;
                                            if (/^\d+$/.test(fstLet) && /^\d+$/.test(lastFootNote) && lastFootNote !== "-1") {
                                                let leftDiff = 0;
                                                // if(a[i].left>lastFootNoteLeft){
                                                //     leftDiff=a[i].left-lastFootNoteLeft;
                                                // }else{
                                                //     leftDiff=lastFootNoteLeft-a[i].left;
                                                // }
                                                if (Number(fstLet) - Number(lastFootNote) == 1 && (leftDiff < 15 || lastFootNoteLeft == 0)) {
                                                    a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                                    lastFootNote = fstLet;
                                                    lastFootNoteLeft = a[i].left;
                                                }
                                            }
                                            else {
                                                a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                                if (/^\d+$/.test(fstLet) && lastFootNote == "-1") {
                                                    lastFootNote = fstLet;
                                                    lastFootNoteLeft = a[i].left;
                                                }
                                            }
                                        }
                                        else {
                                            a[i]['isFoteNote'] = true;
                                        }
                                        ;
                                        isFtStart = true;
                                        foteNote.push(a[i]);
                                        a[i]['puhsed'] = true;
                                        currentPageId = a[i].pageId;
                                    }
                                    else {
                                        //fotTop = aTop;
                                        isFtStart = true;
                                        foteNote.push(a[i]);
                                        a[i]['puhsed'] = true;
                                        currentPageId = a[i].pageId;
                                    }
                                }
                                else { //
                                    if (util_1.isNullOrUndefined(a[i]['puhsed']) && currentPageId == a[i].pageId && !a[i].line.includes("Company (Pty) Ltd") && !(/^[\d*]+$/.test(a[i].line)) && a[i].lineleft > 45 && a[i].lineleft <= a[i - 1].lineleft && aFt < bFt && afterSuperScriptFont != -1 && afterSuperScriptFont > a[i]['top'] && isTrue) {
                                        console.log("FotNote --- D --- ", i, " FotNotes Index  ", foteNote.length, "  TableArray ", tableArray.length);
                                        //console.log('Fotnote --- D --- ',i);
                                        let diff = bBot - aTop;
                                        let percDff = 0;
                                        if (diff > aFt) {
                                            percDff = (aFt / diff) * 100;
                                        }
                                        else {
                                            percDff = (diff / aFt) * 100;
                                        }
                                        if ((!isNaN(Number(fstLet)) || regexMatch.test(fstLet)) && superScript.indexOf(fstLet + "_" + a[i]["pageId"]) > -1 && percDff < 60) {
                                            fotleft = Number(a[i]['lineleft']);
                                            //fotTop = aTop;
                                            fName = a[i]['fontName'];
                                            prefotFt = Number(a[i]['fontSize']);
                                            if (fotleft >= Number(a[i]['lineleft']) && foteNote.filter(r => { return r['FoteNoteId'] == fstLet; }).length == 0) {
                                                //     a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                                // a[i]['isFoteNote'] = true;
                                                if (/^\d+$/.test(fstLet) && /^\d+$/.test(lastFootNote) && lastFootNote !== "-1") {
                                                    let leftDiff = 0;
                                                    // if(a[i].left>lastFootNoteLeft){
                                                    //     leftDiff=a[i].left-lastFootNoteLeft;
                                                    // }else{
                                                    //     leftDiff=lastFootNoteLeft-a[i].left;
                                                    // }
                                                    if (Number(fstLet) - Number(lastFootNote) == 1 && (leftDiff < 15 || lastFootNoteLeft == 0)) {
                                                        a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                                        lastFootNote = fstLet;
                                                        lastFootNoteLeft = a[i].left;
                                                    }
                                                }
                                                else {
                                                    a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                                    if (/^\d+$/.test(fstLet) && lastFootNote == "-1") {
                                                        lastFootNote = fstLet;
                                                        lastFootNoteLeft = a[i].left;
                                                    }
                                                }
                                            }
                                            else {
                                                a[i]['isFoteNote'] = true;
                                            }
                                            ;
                                            isFtStart = true;
                                            foteNote.push(a[i]);
                                            a[i]['puhsed'] = true;
                                            currentPageId = a[i].pageId;
                                        }
                                    }
                                    else {
                                        tableArray.push(a[i]);
                                    }
                                }
                            }
                            else {
                                if (util_1.isNullOrUndefined(a[i]['puhsed']) && currentPageId == a[i].pageId && !a[i].line.includes("Company (Pty) Ltd") && !(/^[\d*]+$/.test(a[i].line)) && a[i].lineleft > 45 && afterSuperScriptFont != -1 && afterSuperScriptFont > a[i]['top'] && isTrue) {
                                    console.log("FotNote --- E --- ", i, " FotNotes Index  ", foteNote.length, "  TableArray ", tableArray.length);
                                    //console.log("FotNote --- E --- ", i);
                                    // foteNote.push(a[i]);
                                    let diff = bBot - aTop;
                                    // let percDff=0;
                                    // if(diff>aFt){
                                    //      percDff=(aFt/diff)*100;
                                    // }else{
                                    //      percDff=(diff/aFt)*100;
                                    // }
                                    if ((!isNaN(Number(fstLet)) || regexMatch.test(fstLet)) && superScript.indexOf(fstLet + "_" + a[i]["pageId"]) > -1 && diff < aFt) {
                                        fotleft = Number(a[i]['lineleft']);
                                        //fotTop = aTop;
                                        fName = a[i]['fontName'];
                                        prefotFt = Number(a[i]['fontSize']);
                                        if (fotleft >= Number(a[i]['lineleft']) && foteNote.filter(r => { return r['FoteNoteId'] == fstLet; }).length == 0) {
                                            //     a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                            // a[i]['isFoteNote'] = true;
                                            if (/^\d+$/.test(fstLet) && /^\d+$/.test(lastFootNote) && lastFootNote !== "-1") {
                                                let leftDiff = 0;
                                                // if(a[i].left>lastFootNoteLeft){
                                                //     leftDiff=a[i].left-lastFootNoteLeft;
                                                // }else{
                                                //     leftDiff=lastFootNoteLeft-a[i].left;
                                                // }
                                                if (Number(fstLet) - Number(lastFootNote) == 1 && (leftDiff < 15 || lastFootNoteLeft == 0)) {
                                                    a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                                    lastFootNote = fstLet;
                                                    lastFootNoteLeft = a[i].left;
                                                }
                                            }
                                            else {
                                                a[i]['FoteNoteId'] = !isNaN(Number(fstLet)) ? Number(fstLet) : fstLet;
                                                if (/^\d+$/.test(fstLet) && lastFootNote == "-1") {
                                                    lastFootNote = fstLet;
                                                    lastFootNoteLeft = a[i].left;
                                                }
                                            }
                                        }
                                        else {
                                            a[i]['isFoteNote'] = true;
                                        }
                                        ;
                                        foteNote.push(a[i]);
                                        a[i]['puhsed'] = true;
                                        currentPageId = a[i].pageId;
                                    }
                                    else if (diff < aFt) {
                                        foteNote.push(a[i]);
                                        a[i]['puhsed'] = true;
                                        a[i]['isFoteNote'] = true;
                                        currentPageId = a[i].pageId;
                                    }
                                }
                                else {
                                    tableArray.push(a[i]);
                                }
                                //     tableArray.push(a[i]);
                            }
                        }
                        ;
                        return {
                            "foteNote": foteNote,
                            "tableArray": tableArray
                        };
                    }
                    return {
                        "foteNote": null,
                        "tableArray": a
                    };
                }
                else if (subtype == "separateSubscript") {
                    let supSc = superScript;
                    let fotNotes = b;
                    //let supPag = [];
                    let fotIn = [];
                    let fotIndexs = [];
                    if (fotNotes.length > 0) {
                        fotNotes.filter((r, i) => {
                            if (!util_1.isNullOrUndefined(r['FoteNoteId']) && fotIndexs.indexOf(r['FoteNoteId']) == -1) {
                                fotIndexs.push(r['FoteNoteId'] + "_" + r['pageId']);
                            }
                            ;
                        });
                    }
                    else {
                        return a;
                    }
                    console.log(fotIndexs);
                    if (!util_1.isNullOrUndefined(supSc) && supSc.length > 0 && fotIndexs.length > 0) {
                        supSc.forEach(element => {
                            fotIndexs.forEach(element2 => {
                                if (element2.trim() == element.trim() && fotIn.indexOf(element2) == -1) {
                                    fotIn.push(element2);
                                }
                            });
                        });
                        if (!util_1.isNullOrUndefined(fotIn) && fotIn.length > 0 && !util_1.isNullOrUndefined(a) && a.length > 0) {
                            for (let k = 0; k < fotIn.length; k++) {
                                let isOnce = true;
                                for (let n = 0; n <= a.length - 1; n++) {
                                    fotIn[k] = !util_1.isNullOrUndefined(fotIn[k]) && fotIn[k].length > 0 && typeof fotIn[k] == "string" ? fotIn[k].split("_") : fotIn[k];
                                    if (Number(a[n]['pageId']) == Number(fotIn[k][1]) && a[n]['line'].includes("<sp:" + fotIn[k][0] + ">") && isOnce) {
                                        a[n]['line'] = a[n]['line'].replace("<sp:" + fotIn[k][0] + ">", "<ft:" + fotIn[k][0] + ">").trim();
                                        a[n]['tagline'] = a[n]['tagline'].replace("<sp:" + fotIn[k][0] + ">", "<ft:" + fotIn[k][0] + ">").trim();
                                        isOnce = false;
                                        break;
                                    }
                                }
                                continue;
                            }
                            a.forEach((e, i) => {
                                if (e.line.includes("<sp:")) {
                                    let supScript = this.superScriptNumber(e.line);
                                    e.line = e.line.replace("<sp:" + supScript + ">", supScript).trim();
                                    e.tagline = e.tagline.replace("<sp:" + supScript + ">", supScript).trim();
                                }
                            });
                            return a;
                        }
                        return a;
                    }
                    return a;
                }
                else {
                    return null;
                }
            }
            catch (err) {
                console.log("Error!!! -> " + err);
                return { message: err, status: 1, data: err };
            }
        });
    }
    arrayIterator(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("INPUT --- >>> ", input);
                if (!util_1.isNullOrUndefined(input.iteratorCount) && input.iteratorCount !== "") {
                    input.iteratorCount = Number(input.iteratorCount);
                    //  iterationId = input.iteratorCount;
                    if (!util_1.isNullOrUndefined(input.lengthCount) && (input.lengthCount !== "")) {
                        if (input.iteratorCount == (input.lengthCount - 1)) {
                            output["iteratorCount"] = 0;
                        }
                        else {
                            output["iteratorCount"] = input.iteratorCount + 1;
                        }
                    }
                    else {
                        output["iteratorCount"] = input.iteratorCount + 1;
                    }
                }
                let inputArray = input.fileArr;
                if (typeof inputArray === "string") {
                    inputArray = JSON.parse(inputArray);
                }
                let currentJson = inputArray[iterationId];
                output["obj"] = currentJson;
                return { message: '', status: 0, data: output };
            }
            catch (e) {
                console.log('bot1 Error', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    arrayIteratorNew(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let finalArray = [];
                console.log("INPUT --- >>> ", input);
                console.log(input.fileArr[iterationId], "$$$$$$$$$$");
                if (!util_1.isNullOrUndefined(input.iteratorCount) && input.iteratorCount !== "") {
                    input.iteratorCount = Number(input.iteratorCount);
                    iterationId = input.iteratorCount;
                    if (!util_1.isNullOrUndefined(input.lengthCount) && (input.lengthCount !== "")) {
                        if (input.iteratorCount == (input.lengthCount - 1)) {
                            output["iteratorCount"] = 0;
                        }
                        else {
                            output["iteratorCount"] = input.iteratorCount + 1;
                        }
                    }
                    else {
                        output["iteratorCount"] = input.iteratorCount + 1;
                    }
                }
                let inputArray = input.fileArr;
                if (typeof inputArray === "string") {
                    inputArray = JSON.parse(inputArray);
                }
                let currentJson = inputArray[iterationId];
                finalArray.push({ fileName: currentJson.fileName, RecordingName: currentJson.RecordingName, Timestamp: currentJson.Timestamp, ProjectName: currentJson.ProjectName, batchName: currentJson.batchName, rootPath: currentJson.rootPath });
                console.log(finalArray);
                console.log(iterationId, "### iteration ID");
                output["obj"] = currentJson;
                output["rootPath"] = output.obj.rootPath;
                output["fileName"] = output.obj.fileName;
                output["RecordingName"] = output.obj.RecordingName;
                output["Timestamp"] = output.obj.Timestamp;
                output["batchName"] = output.obj.batchName;
                output["ProjectName"] = output.obj.ProjectName;
                return { message: '', status: 0, data: output };
            }
            catch (e) {
                console.log('bot1 Error', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    recursiveBot(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            console.log(".........recursive bot  ...............", input);
            try {
                //  const fs = require('fs');
                let pngFiles = [];
                let list = [];
                let isImagereader = false;
                let finalArray = [];
                // let filepathArray = [
                //     // '/home/user/Documents/POC/I2I/Gibots Annotation/Gibots Annotation/Timestamp/Batch1/Recordings/Input',
                //     // '/home/user/Documents/POC/I2I/Gibots Annotation/Gibots Annotation/Timestamp/Batch2/Recordings2/Input',
                //     // '/home/user/Documents/POC/I2I/Gibots Annotation/Gibots Annotation/Timestamp/Batch3/Recordings3/Input'
                // ];
                console.log(input.filepathArray);
                if (fs.existsSync(input.filepathArray)) {
                    console.log('File path is present.........');
                    isImagereader = true;
                }
                else {
                    console.log('File path not found...........');
                    isImagereader = false;
                    outputParameters['isImage'] = isImagereader;
                    return { info: 'File path not Exits', status: 0, data: outputParameters };
                }
                function traverseDir(dir) {
                    console.log("transeDir function");
                    list = fs.readdirSync(dir);
                    if (list.length != 0) {
                        console.log("check the dir length");
                        list.forEach(function (file) {
                            file = dir + '/' + file;
                            var stat = fs.statSync(file);
                            if (stat && stat.isDirectory()) {
                                traverseDir(file);
                            }
                            else {
                                if ((/(\.jpg)$/.test(file) || /(\.png)$/.test(file)) && list.length != 0) {
                                    console.log("check image file");
                                    pngFiles.push(file);
                                    isImagereader = true;
                                }
                                else {
                                    pngFiles.push("notImages");
                                    isImagereader = false;
                                }
                            }
                        });
                    }
                    else {
                        pngFiles.push("notImages");
                        isImagereader = false;
                    }
                }
                //  filepathArray.forEach((ele) => {
                console.log("check the filepath");
                traverseDir(input.filepathArray);
                console.log("check the filepath 2");
                // })
                // Array of obect ====>
                pngFiles.forEach((e) => {
                    if (e != "notImages") {
                        let imagepath = e.toString();
                        let img = imagepath.split('/');
                        finalArray.push({ fileName: img[img.length - 1], RecordingName: input.RecordingName, Timestamp: input.Timestamp, ProjectName: input.ProjectName, batchName: input.batchName, rootPath: imagepath });
                        isImagereader = true;
                    }
                    else {
                        isImagereader = false;
                    }
                });
                console.log(finalArray);
                //outputParameters = finalArray
                outputParameters['count'] = finalArray.length;
                outputParameters['objectsArray'] = finalArray;
                outputParameters['isImage'] = isImagereader;
                console.log(outputParameters.isImage);
                console.log(" $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$");
                console.log(isImagereader);
                return { info: 'array of objects found', status: 0, data: outputParameters };
            }
            catch (e) {
                console.log(e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    compareJSON(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            console.log("......... compare JSON  ...............", input);
            try {
                let file1 = require(input.file1);
                let file2 = require(input.file2);
                //count the category(rectanglelabels)== (class Error) & Attribute error
                let lableCount = 0;
                let attributeCount = 0;
                file1.forEach((element, index) => {
                    element.annotations.forEach((element2, index2) => {
                        element2.result.forEach((element3, index3) => {
                            //attribute Error
                            if ((String(Object.keys(element3.value)) == "text") || (String(Object.keys(element3.value)) == "choices")) {
                                if (Object.values(element3.value).pop().toString() != Object.values(file2[index].annotations[index2].result[index3].value).pop().toString()) {
                                    attributeCount++;
                                    console.log('number of attribute error ', attributeCount);
                                }
                            }
                            else if (Object.values(element3.value).pop().toString() != Object.values(file2[index].annotations[index2].result[index3].value).pop().toString()) {
                                lableCount++;
                                console.log('number of class error ', lableCount);
                            }
                        });
                    });
                });
                console.log('Number of class error ', lableCount);
                //missing object
                let difference;
                let totalObjectcount;
                file1.forEach((element, index) => {
                    let file1Length = element.annotations[0].result.length;
                    let file2Length = file2[index].annotations[0].result.length;
                    if (file1Length == file2Length) {
                        console.log('same length');
                    }
                    else {
                        console.log('file1 length is ', file1Length);
                        console.log('file2 length is ', file2Length);
                    }
                    if (file1Length > file2Length) {
                        difference = Number(file1Length) - Number(file2Length);
                        console.log('Missing Objects count :  ', difference);
                    }
                    else {
                        difference = Number(file2Length) - Number(file1Length);
                        console.log('Missing Objects count :  ', difference);
                    }
                    // Total number of objects
                    let array = [];
                    array.push(file1Length);
                    array.push(file2Length);
                    totalObjectcount = Math.max(...array);
                    console.log('Total Number of Object count :', totalObjectcount);
                });
                // pixel error
                let pixelCount = 0;
                file1.forEach((element, index) => {
                    element.annotations.forEach((element2, index2) => {
                        element2.result.forEach((element3, index3) => {
                            if ((Object.keys(element3.value).pop().toString() == "rectanglelabels") || (Object.keys(element3.value).pop().toString() == "keypointlabels")) {
                                //console.log(Object.values(element3.value)[0] == "rectanglelabels")
                                if (((Object.values(element3.value)[0] != Object.values(file2[index].annotations[index2].result[index3].value)[0]) ||
                                    (Object.values(element3.value)[1] != Object.values(file2[index].annotations[index2].result[index3].value)[1]))) {
                                    pixelCount++;
                                }
                            }
                            else if (Object.keys(element3.value).pop().toString() == "polygonlabels") {
                                if ((JSON.stringify(element3.value.points[0])) != JSON.stringify(file2[index].annotations[index2].result[index3].value.points[0]) ||
                                    (JSON.stringify(element3.value.points[1])) != JSON.stringify(file2[index].annotations[index2].result[index3].value.points[1]) ||
                                    (JSON.stringify(element3.value.points[2])) != JSON.stringify(file2[index].annotations[index2].result[index3].value.points[2])) {
                                    pixelCount++;
                                    console.log("calculating pixel error for the Segmentation polygon");
                                }
                            }
                        });
                    });
                });
                console.log("Count of pixel error is ", pixelCount);
                //Incorrect label= pixel error+class error
                //Incorrect label= attribute error
                let IncorrectLabels;
                if (pixelCount != 0) {
                    IncorrectLabels = pixelCount + lableCount;
                    console.log('Number of Incorrect labels', IncorrectLabels);
                }
                else if (pixelCount == 0) {
                    console.log("******");
                    IncorrectLabels = attributeCount;
                    console.log("No. of Incrrect labels", IncorrectLabels);
                }
                // Formulation of Precision and Recall
                let precision = Number((((totalObjectcount - IncorrectLabels) / totalObjectcount) * 100).toFixed(2));
                console.log("Precision Factor is ", precision);
                let recall = Number((((totalObjectcount - difference) / totalObjectcount) * 100).toFixed(2));
                console.log("Recall Factor is ", recall);
                //output of bot
                outputParameters['classError'] = lableCount;
                outputParameters['MissingObjects'] = difference;
                outputParameters['TotalObjects'] = totalObjectcount;
                outputParameters['pixelError'] = pixelCount;
                outputParameters['IncorrectLabelsError'] = IncorrectLabels;
                outputParameters['attributeCount'] = attributeCount;
                outputParameters['precisionFactor'] = precision;
                outputParameters['recallFactor'] = recall;
                return { info: 'comparison found', status: 0, data: outputParameters };
            }
            catch (e) {
                console.log(e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    saveintoDB(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            console.log("......... save into DB ...............", input);
            try {
                let datetime = new Date();
                let Name = "Annotator1";
                let I = 1;
                console.log("currrent date is==", datetime);
                console.log("Annotator Name is==", Name);
                console.log(I);
                let Batch_Name = input.Batch_Name;
                // console.log("batch name is===", Batch_Name);
                let datetime1 = new Date();
                let fileName = input.fileName;
                let classError = input.classError;
                let MissingObjects = input.MissingObjects;
                let TotalObjects = input.TotalObjects;
                let pixelError = input.pixelError;
                let IncorrectLabelsError = input.IncorrectLabelsError;
                let attributeCount = input.attributeCount;
                let precisionFactor = input.precisionFactor;
                let recallFactor = input.recallFactor;
                console.log("start");
                yield db.collection("ErrorCount").findOneAndUpdate({ "Image_ID": fileName, }, { $set: { Name: "Annotator1", Batch_Name: Batch_Name, datetime1: datetime1, I: "1", class_Error: classError, Missing_Objects: MissingObjects, Total_Objects: TotalObjects, pixel_Error: pixelError, Incorrect_LabelsError: IncorrectLabelsError, attribute_Count: attributeCount, precision_Factor: precisionFactor, recall_Factor: recallFactor } }, { upsert: true });
                console.log("end");
                return { message: 'Data updated in database', status: 0, data: outputParameters };
            }
            catch (e) {
                console.log(e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    accessToken(input, outputParameters, botId, projectId, iterationId) {
        console.log(".........Genrate Access Token  ...............", input);
        try {
            return new Promise((resolve, reject) => {
                let tenantID = input.tenantID;
                let cookie = input.cookie;
                let clientID = input.clientID;
                let clientSecret = input.clientSecret;
                let body1;
                let token;
                let request = require('request');
                let options = {
                    'method': 'POST',
                    'url': 'https://login.microsoftonline.com/' + tenantID + '/oauth2/token',
                    'headers': {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Cookie': cookie
                    },
                    form: {
                        'grant_type': 'client_credentials',
                        'client_id': clientID,
                        'client_secret': clientSecret,
                        'resource': 'https://graph.microsoft.com'
                    }
                };
                request(options, function (error, response) {
                    if (error) {
                        resolve({ message: 'Something Went Wrong.Please try after sometime.', status: 1, data: error });
                    }
                    // console.log(response.body);
                    body1 = JSON.parse(response.body);
                    //console.log(body1)
                    token = body1.access_token;
                    // console.log(token)
                    outputParameters['Accesstoken'] = token;
                    resolve({ info: 'Access Token genrated', status: 0, data: outputParameters });
                });
            });
        }
        catch (e) {
            console.log(e);
            return { message: e, status: 1, data: e };
        }
    }
    driveFiles(input, outputParameters, botId, projectId, iterationId) {
        console.log(".........Get drive files  ...............", input);
        try {
            return new Promise((resolve, reject) => {
                let token = input.token;
                let emailID = input.emailID;
                let imagePath = input.imagePath;
                let imagePath2 = '';
                let imageNameArray;
                let body1;
                let itemID;
                if ((imagePath.includes('.com') && imagePath.includes('OneDrive'))) {
                    imagePath2 = imagePath.substring(imagePath.indexOf('.com') + 5);
                }
                else if (imagePath.includes('OneDrive')) {
                    imagePath2 = imagePath.substring(imagePath.indexOf('OneDrive') + 9);
                }
                else {
                    imagePath2 = imagePath;
                }
                let request = require('request');
                let options = {
                    'method': 'GET',
                    'url': 'https://graph.microsoft.com/v1.0/users/' + emailID + '/drive/root:/' + imagePath2 + ':/children',
                    'headers': {
                        'Host': 'graph.microsoft.com',
                        'Authorization': 'Bearer ' + token,
                        'SdkVersion': 'postman-graph/v1.0',
                        'Connection-Type': 'application/json'
                    }
                };
                request(options, function (error, response) {
                    if (error) {
                        resolve({ message: 'Something Went Wrong.Please try after sometime.', status: 1, data: error });
                    }
                    const str = JSON.parse(response.body);
                    if (str.value != undefined && str.value.length > 0) {
                        body1 = JSON.parse(response.body);
                        imageNameArray = body1.value.map(a => a.name);
                        outputParameters['imagesNames'] = imageNameArray;
                        itemID = body1.value[0].parentReference["id"];
                        outputParameters['itemID'] = itemID;
                        outputParameters['emailID'] = emailID;
                        outputParameters['imagePath'] = imagePath2;
                        resolve({ info: 'got the files names', status: 0, data: outputParameters });
                    }
                    else {
                        resolve({ info: 'got the files names', status: 0, data: outputParameters });
                    }
                });
            });
        }
        catch (e) {
            console.log(e);
            return { message: e, status: 1, data: e };
        }
    }
    newRecursive(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            console.log(".........New recursive bot  ...............", input);
            try {
                //  const fs = require('fs');
                let pngFiles = [];
                let isImagereader = false;
                let finalArray = [];
                let imagesName = input.imagesName;
                if (imagesName == '') {
                    pngFiles.push("notImages");
                    isImagereader = false;
                }
                else if (imagesName != '') {
                    imagesName.forEach((ele) => {
                        ele.split(ele.length - 3);
                        if (/(\.jpg)$/.test(ele) || /(\.png)$/.test(ele)) {
                            pngFiles.push(ele);
                            isImagereader = true;
                        }
                        else {
                            pngFiles.push("notImages");
                            isImagereader = false;
                        }
                    });
                }
                // Array of obect ====>
                pngFiles.forEach((e) => {
                    if (e != "notImages") {
                        let imagepath = e.toString();
                        finalArray.push({ fileName: imagepath, RecordingName: input.RecordingName, Timestamp: input.Timestamp, batchName: input.batchName, ProjectName: input.ProjectName });
                        isImagereader = true;
                    }
                    else {
                        isImagereader = false;
                    }
                });
                outputParameters['count'] = finalArray.length;
                outputParameters['objectsArray'] = finalArray;
                outputParameters['isImage'] = isImagereader;
                return { info: 'array of objects found', status: 0, data: outputParameters };
            }
            catch (e) {
                console.log(e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    addPermissions(input, outputParameters, botId, projectId, iterationId) {
        console.log("......... Add Access to the users  ...............", input);
        try {
            return new Promise((resolve, reject) => {
                var request = require('request');
                //let body1;
                let permissionID;
                let token = input.token;
                let senderEmailID = input.senderEmailID;
                // let receiverEmailID = input.receiverEmailID;
                let itemID = input.itemID;
                var body2;
                let body3;
                let body;
                body = { "requireSignIn": true, "sendInvitation": true, "roles": ["write"], "recipients": [{ "email": input.receiverEmailID }], "message": "string" };
                body2 = body;
                body2 = JSON.stringify(body);
                var options = {
                    'method': 'POST',
                    'url': 'https://graph.microsoft.com/v1.0/users/' + senderEmailID + '/drive/items/' + itemID + '/invite',
                    'headers': {
                        'Host': 'graph.microsoft.com',
                        'SdkVersion': 'postman-graph/v1.0',
                        'Authorization': 'Bearer ' + token,
                        'Content-Type': 'application/json'
                    },
                    'body': body2
                };
                request(options, function (error, response) {
                    if (error) {
                        resolve({ message: 'Something Went Wrong.Please try after sometime.', status: 1, data: error });
                    }
                    body3 = JSON.parse(response.body);
                    console.log(response.body);
                    permissionID = body3.value[0].id;
                    outputParameters['permissionID'] = permissionID;
                    resolve({ info: 'got the files names', status: 0, data: outputParameters });
                });
            });
        }
        catch (e) {
            console.log(e);
            return { message: e, status: 1, data: e };
        }
    }
    removePermissions(input, outputParameters, botId, projectId, iterationId) {
        console.log("......... remove Access to the users  ...............", input);
        try {
            return new Promise((resolve, reject) => {
                let token = input.token;
                let itemID = input.itemID;
                let permissionID = input.permissionID;
                let senderEmailID = input.senderEmailID;
                var request = require('request');
                var options = {
                    'method': 'DELETE',
                    'url': 'https://graph.microsoft.com/v1.0/users/' + senderEmailID + '/drive/items/' + itemID + '/permissions/' + permissionID + '',
                    'headers': {
                        'Host': 'graph.microsoft.com',
                        'SdkVersion': 'postman-graph/v1.0',
                        'Authorization': 'Bearer ' + token
                    }
                };
                request(options, function (error, response) {
                    if (error) {
                        resolve({ message: 'Something Went Wrong.Please try after sometime.', status: 1, data: error });
                    }
                    console.log(response.body);
                    resolve({ info: 'got the files names', status: 0, data: outputParameters });
                });
            });
        }
        catch (e) {
            console.log(e);
            return { message: e, status: 1, data: e };
        }
    }
    comparisonJSON(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            console.log("......... compare JSON  ...............", input);
            try {
                let file1 = require(input.file1);
                let file2 = require(input.file2);
                //count the category(rectanglelabels)== (class Error) & Attribute error
                let lableCount = 0;
                let attributeCount = 0;
                file1.forEach((element, index) => {
                    if (((file2[index] != undefined) && (file1[index] != undefined))) {
                        if ((String(Object.keys(element.value)) == "text") || (String(Object.keys(element.value)) == "choices") || (String(Object.keys(element.value)) == "labels")) {
                            console.log("$$$$$$$$");
                            if ((file2[index] != undefined) && Object.values(element.value).pop().toString() != Object.values(file2[index].value).pop().toString()) {
                                attributeCount++;
                                console.log('number of attribute error ', attributeCount);
                            }
                        }
                        else if ((file2[index] != undefined) && Object.values(element.value).pop().toString() != Object.values(file2[index].value).pop().toString()) {
                            lableCount++;
                            console.log("****");
                            console.log('number of class error ', lableCount);
                            console.log("kkkkkkkkkkk");
                            console.log("nnnnnnnnnnnn");
                            console.log("file11", element);
                            console.log("file 22", index);
                        }
                    }
                    else {
                        console.log("matched");
                        console.log(file2[index] != undefined);
                    }
                });
                console.log('Number of class error ', lableCount);
                //missing object
                let totalObjectcount;
                let difference;
                file1.forEach((element, index) => {
                    if (((file2[index] != undefined) && (file1[index] != undefined))) {
                        let file1Length = file1.length;
                        let file2Length = file2.length;
                        if (file1Length == file2Length) {
                            console.log('same length');
                        }
                        //   else{
                        //       console.log('file1 length is ',file1Length);
                        //       console.log('file2 length is ',file2Length);
                        //   }
                        if (file1Length > file2Length) {
                            difference = Number(file1Length) - Number(file2Length);
                            console.log('Missing Objects count :  ', difference);
                        }
                        else {
                            difference = Number(file2Length) - Number(file1Length);
                            console.log('Missing Objects count :  ', difference);
                        }
                        // Total number of objects
                        let array = [];
                        array.push(file1Length);
                        array.push(file2Length);
                        totalObjectcount = Math.max(...array);
                        console.log('Total Number of Object count :', totalObjectcount);
                    }
                    else {
                        console.log("NOt matched");
                    }
                });
                // pixel error
                let pixelCount = 0;
                file1.forEach((element, index) => {
                    if (((file2[index] != undefined) && (file1[index] != undefined))) {
                        if ((Object.keys(element.value).pop().toString() == "rectanglelabels") || (Object.keys(element.value).pop().toString() == "keypointlabels")) {
                            //console.log(Object.values(element.value)[0] == "rectanglelabels")
                            if ((file2[index] != undefined) && ((Object.values(element.value)[0] != Object.values(file2[index].value)[0]) ||
                                (Object.values(element.value)[1] != Object.values(file2[index].value)[1]))) {
                                pixelCount++;
                                console.log(typeof (element.value, "*******"));
                            }
                        }
                        else if (Object.keys(element.value).pop().toString() == "polygonlabels") {
                            if ((file2[index] != undefined) && (JSON.stringify(element.value.points[0])) != JSON.stringify(file2[index].value.points[0]) ||
                                (JSON.stringify(element.value.points[1])) != JSON.stringify(file2[index].value.points[1]) ||
                                (JSON.stringify(element.value.points[2])) != JSON.stringify(file2[index].value.points[2])) {
                                pixelCount++;
                                console.log("calculating pixel error for the Segmentation polygon");
                            }
                        }
                    }
                    else {
                        console.log("NOt matched");
                    }
                });
                console.log("Count of pixel error is ", pixelCount);
                //Incorrect label= pixel error+class error
                //Incorrect label= attribute error
                let IncorrectLabels;
                if (pixelCount != 0) {
                    IncorrectLabels = pixelCount + lableCount;
                    console.log('Number of Incorrect labels', IncorrectLabels);
                }
                else if (pixelCount == 0) {
                    console.log("******");
                    IncorrectLabels = attributeCount;
                    console.log("No. of Incrrect labels", IncorrectLabels);
                }
                // Formulation of Precision and Recall
                let precision = Number((((totalObjectcount - IncorrectLabels) / totalObjectcount) * 100).toFixed(2));
                console.log("Precision Factor is ", precision);
                let recall = Number((((totalObjectcount - difference) / totalObjectcount) * 100).toFixed(2));
                console.log("Recall Factor is ", recall);
                console.log(difference);
                //output of bot
                outputParameters['classError'] = lableCount;
                outputParameters['MissingObjects'] = difference;
                outputParameters['TotalObjects'] = totalObjectcount;
                outputParameters['pixelError'] = pixelCount;
                outputParameters['IncorrectLabelsError'] = IncorrectLabels;
                outputParameters['attributeCount'] = attributeCount;
                outputParameters['precisionFactor'] = precision;
                outputParameters['recallFactor'] = recall;
                return { info: 'comparison found', status: 0, data: outputParameters };
            }
            catch (e) {
                console.log(e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    superScriptNumber(superScript) {
        if (superScript.includes('<sp:')) {
            const regex = /\<sp\:(\d+)/gm;
            const regexSp = /\<sp\:([*∗+†‡]{0,3})/gm;
            const str = superScript;
            let num = superScript;
            let m;
            while ((m = regex.exec(str)) !== null || (m = regexSp.exec(str)) !== null) {
                // This is necessary to avoid infinite loops with zero-width matches
                if (m.index === regex.lastIndex) {
                    regex.lastIndex++;
                }
                // The result can be accessed through the m-variable.
                m.forEach((match, groupIndex) => {
                    //console.log(Found match, group ${groupIndex}: ${match});
                    if (groupIndex == 1 && match !== "") {
                        num = match;
                    }
                });
            }
            console.log(num);
            return num;
        }
        else if (/([*+†‡])/g.test(superScript)) {
            const regexMatch = /([*+†‡]{0,4})/gm;
            const str = superScript;
            let num = superScript;
            let m;
            while ((m = regexMatch.exec(str)) !== null) {
                // This is necessary to avoid infinite loops with zero-width matches
                if (m.index === regexMatch.lastIndex) {
                    regexMatch.lastIndex++;
                }
                // The result can be accessed through the m-variable.
                m.forEach((match, groupIndex) => {
                    //console.log(Found match, group ${groupIndex}: ${match});
                    if (groupIndex == 1 && match !== "") {
                        num = match;
                    }
                });
            }
            console.log(num);
            return num;
        }
        else {
            return superScript;
        }
    }
    pdfParserWordExtractionBot(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let PDF_PATH = input.PDF_PATH;
                //let renamedPATH = PDF_PATH.replace(/[ !@#$%^&*()<>~{}?|]/g, '');
                //console.log(renamedPATH);
                //fs.renameSync(PDF_PATH, renamedPATH);
                let randomNo = Math.floor(Math.random() * 10000);
                let randomString = randomNo.toString();
                let javaJsonFolder = env_2.env.fileConfig.javaJsonFolder; //"../javaJsonFolder/";
                javaJsonFolder = javaJsonFolder.replace("\"", "");
                if (!fs.existsSync(javaJsonFolder)) {
                    fs.mkdirSync(javaJsonFolder);
                }
                let jsonFileName = PDF_PATH.substring(PDF_PATH.lastIndexOf('/') + 1) + ".json";
                let finalJsonPath = javaJsonFolder + randomString + jsonFileName;
                //let jsonPath = "../../../../../.." + jsonFileName;
                //console.log(process.cwd());
                //let repoRootPath = process.cwd();
                //let jsonPath = repoRootPath.substring(0, repoRootPath.lastIndexOf('/'));
                let isType = !util_1.isNullOrUndefined(input['type']) && (input.type == "Law_Reports" || input.type == "journals") ? true : false;
                let inputType = isType ? "true" : "false";
                let inputObj = {
                    "finalJsonPath": finalJsonPath,
                    "pdfPath": PDF_PATH,
                    "isType": inputType
                };
                let parameters = JSON.stringify(JSON.stringify(inputObj));
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    let res = yield this.sh("java -cp .:json-20190722.jar:pdfbox-2.0.3.jar:fontbox-2.0.3.jar:commons-logging-1.2.jar:json-simple-1.1.1.jar:jbig2-imageio-3.0.0.jar:itextpdf-5.5.13.1.jar:kernel-7.1.12.jar:io-7.1.12.jar:layout-7.1.12.jar:slf4j-api-1.7.30.jar:slf4j-simple-1.7.30.jar:commons-lang3-3.11.jar GetPdfData " + parameters);
                    if (!util_1.isNullOrUndefined(res)) {
                        if (res['status'] == 1 && !util_1.isNullOrUndefined(res['err']) && !util_1.isNullOrUndefined(res['err']['message']) && res['err']['message'].includes('Command failed')) {
                            resolve({ message: res['err'] + PDF_PATH, status: 1, data: 'Seems some issue while reading the PDF' + PDF_PATH });
                        }
                        let finalArray;
                        if (fs.existsSync(finalJsonPath)) {
                            finalArray = JSON.parse(fs.readFileSync(finalJsonPath, { encoding: 'utf8' }));
                        }
                        else {
                            console.log("Error while reading JSON file!");
                        }
                        finalArray = finalArray.filter(obj => obj.line.trim() != '');
                        output['output'] = finalArray;
                        resolve({ message: "Process sucessfully completed", status: 0, data: output });
                    }
                }));
            }
            catch (err) {
                console.log("Error!!! -> " + err);
                return { message: err, status: 1, data: err };
            }
        });
    }
    jsonSearchKey(input, output, botId, projectId, iterationId) {
        try {
            if (!util_1.isNullOrUndefined(input.jsonObjArr) && !util_1.isNullOrUndefined(input.searchArr)) {
                let jsonArr;
                let searchArr;
                if (typeof input.jsonObjArr === "string") {
                    jsonArr = JSON.parse(input.jsonObjArr);
                }
                else {
                    jsonArr = input.jsonObjArr;
                }
                if (typeof input.searchArr === "string") {
                    searchArr = JSON.parse(input.searchArr);
                }
                else {
                    searchArr = input.searchArr;
                }
                let fileName = input.fileName;
                searchArr = searchArr[fileName];
                let result = searchArr.reduce((final, el) => {
                    let value = "";
                    jsonArr.forEach((obj) => {
                        let top = obj.pageHeight - obj.top;
                        if ((obj.left > el.left) && (obj.lineright < el.right) && (top > el.top) && (top + obj.Height < el.bottom)) {
                            value = value + obj.text + " ";
                        }
                    });
                    final[el.key] = value.trim();
                    return final;
                }, {});
                output['result'] = JSON.stringify(result);
                console.log(output);
            }
            return { message: "Process sucessfull completed", status: 0, data: output };
        }
        catch (err) {
            console.log("Error!!! -> " + err);
            return { message: err, status: 1, data: err };
        }
    }
    pdfParserJava(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            console.log("In new pdfParserJava, FileName==" + input.PDF_PATH);
            try {
                let PDF_PATH = input.PDF_PATH;
                //let renamedPATH = PDF_PATH.replace(/[ !@#$%^&*()<>~{}?|]/g, '');
                //console.log(renamedPATH);
                //fs.renameSync(PDF_PATH, renamedPATH);
                let randomNo = Math.floor(Math.random() * 10000);
                let randomString = randomNo.toString();
                let javaJsonFolder = env_2.env.fileConfig.javaJsonFolder; //"../javaJsonFolder/";
                javaJsonFolder = javaJsonFolder.replace("\"", "");
                if (!fs.existsSync(javaJsonFolder)) {
                    fs.mkdirSync(javaJsonFolder);
                }
                let jsonFileName = PDF_PATH.substring(PDF_PATH.lastIndexOf('/') + 1) + ".json";
                let finalJsonPath = javaJsonFolder + randomString + jsonFileName;
                //let jsonPath = "../../../../../.." + jsonFileName;
                //console.log(process.cwd());
                //let repoRootPath = process.cwd();
                //let jsonPath = repoRootPath.substring(0, repoRootPath.lastIndexOf('/'));
                let isType = !util_1.isNullOrUndefined(input['type']) && (input.type == "Law_Reports" || input.type == "journals") ? true : false;
                let inputType = isType ? "true" : "false";
                let inputObj = {
                    "finalJsonPath": finalJsonPath,
                    "pdfPath": PDF_PATH,
                    "isType": inputType
                };
                let parameters = JSON.stringify(JSON.stringify(inputObj));
                let suprScript = [];
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    let res = yield this.sh("java -cp .:json-20190722.jar:pdfbox-2.0.3.jar:fontbox-2.0.3.jar:commons-logging-1.2.jar:json-simple-1.1.1.jar:jbig2-imageio-3.0.0.jar:itextpdf-5.5.13.1.jar:kernel-7.1.12.jar:io-7.1.12.jar:layout-7.1.12.jar:slf4j-api-1.7.30.jar:slf4j-simple-1.7.30.jar:commons-lang3-3.11.jar GetPdfData " + parameters);
                    if (!util_1.isNullOrUndefined(res)) {
                        console.log("res[status]---->>", res);
                        if (res['status'] == 1 && !util_1.isNullOrUndefined(res['err']) && !util_1.isNullOrUndefined(res['err']['message']) && res['err']['message'].includes('Command failed')) {
                            console.log("res[status]-in If  --->>", res['status']);
                            resolve({ message: res['err'] + PDF_PATH, status: 1, data: 'Seems some issue while reading the PDF' + PDF_PATH });
                        }
                        let finalArray;
                        if (fs.existsSync(finalJsonPath)) {
                            finalArray = JSON.parse(fs.readFileSync(finalJsonPath, { encoding: 'utf8' }));
                        }
                        else {
                            console.log("Error while reading JSON file!");
                        }
                        finalArray = finalArray.filter(obj => obj.line.trim() != '');
                        let words;
                        finalArray = yield this.removeMargineCode(finalArray);
                        finalArray = yield this.removePdfParserIssues(finalArray);
                        let lines = [];
                        let TableArray = [];
                        let superScript = [];
                        let superScriptWithPage = [];
                        let self = this;
                        let type = input['type'];
                        let isCrep = PDF_PATH.toLowerCase().includes("crep") ? true : false;
                        ;
                        let fotLines;
                        if (isType) {
                            console.log("sudo python3 juta.py " + '"' + PDF_PATH + '"' + " " + '"' + "findLines" + '"' + " " + '"' + input.type + '"');
                            fotLines = yield this.sh("sudo python3 juta.py " + '"' + PDF_PATH + '"' + " " + '"' + "findLines" + '"' + " " + '"' + input.type + '"');
                        }
                        if (!PDF_PATH.toLowerCase().includes("crep")) {
                            let res1;
                            res1 = yield this.sh("sudo python3 juta.py " + PDF_PATH + " " + "findUnderline dummy");
                            if (res1.output) {
                                words = !util_1.isNullOrUndefined(JSON.parse(res1.output)) ? JSON.parse(res1.output) : res1.output.replace('[', '').replace(']', '').replace(/"/g, '').replace(/\\u2019/g, '’').replace(/\\u2018/g, '‘').replace(/\\u2022/g, '•').replace(/\\u201c/g, '“').replace(/\\u201d/g, '”').replace(/\\u02bb/g, 'ʻ').replace(/\\t/g, '  ').split(', ');
                            }
                            let first = true;
                            let pretag = "none";
                            let intag = false;
                            for (let i = 0; i < finalArray.length - 1; i++) {
                                //START - SUSHANT
                                // await this.removePdfParserIssues(finalArray[i],finalArray,i)
                                intag = false;
                                let thistag = "";
                                if (res1.output && !util_1.isNullOrUndefined(words)) {
                                    let pageWords = words.filter(a => a.substring(a.lastIndexOf('#') + 1, a.lastIndexOf('$')) == finalArray[i + 1].pageId);
                                    pageWords = (!util_1.isNullOrUndefined(pageWords) && pageWords.length >= 0) ? pageWords : words;
                                    pageWords.map((word) => {
                                        word = word.split(/\s/).join(' ');
                                        if (i < finalArray.length - 2 && word.includes('#') && word.includes('$') && word.substring(0, word.indexOf('#')).replace(/\s/g, '') != '' && word.substring(word.indexOf('#') + 1, word.indexOf('$')) == finalArray[i + 1].pageId && Number(word.substring(word.indexOf('$') + 1).replace(/\n/g, '')) + finalArray[i + 1].cropboxY >= finalArray[i + 1].top - 7 && Number(word.substring(word.indexOf('$') + 1).replace(/\n/g, '')) + finalArray[i + 1].cropboxY <= finalArray[i + 1].top + 7 && Number(word.substring(word.indexOf('^') + 1, word.indexOf('#')).replace(/\n/g, '')) < finalArray[i + 1].lineleft && (word.trim().includes(finalArray[i + 1].line.trim()) || (finalArray[i + 1].line.trim().split(/’’|”/).length == 2 && (word.trim().includes(finalArray[i + 1].line.trim().split(/’’|”/)[0]))) || (finalArray[i + 1].line.match(/^“/) && finalArray[i + 1].line.split('“').length == 2 && word.trim().includes(finalArray[i + 1].line.split('“')[1])))) {
                                            finalArray[i + 1]['underline'] = true;
                                            if (finalArray[i + 1].line.trim().split(/’’|”/).length == 2 && (word.trim().includes(finalArray[i + 1].line.trim().split(/’’|”/)[0]))) {
                                                intag = true;
                                            }
                                        }
                                    });
                                }
                                //for first object
                                if (first) {
                                    if (finalArray[0]['italic'] == true && finalArray[0]['bold'] == true && finalArray[0]['underline'] != undefined && finalArray[0]['underline'] == true) {
                                        thistag = "#biu$";
                                    }
                                    else if (finalArray[0]['italic'] == false && finalArray[0]['bold'] == true && finalArray[0]['underline'] != undefined && finalArray[0]['underline'] == true) {
                                        thistag = "#bu$";
                                    }
                                    else if (finalArray[0]['italic'] == true && finalArray[0]['bold'] == false && finalArray[0]['underline'] != undefined && finalArray[0]['underline'] == true) {
                                        thistag = "#iu$";
                                    }
                                    else if (finalArray[0]['italic'] == false && finalArray[0]['bold'] == false && finalArray[0]['underline'] != undefined && finalArray[0]['underline'] == true) {
                                        thistag = "#u$";
                                    }
                                    else if (finalArray[0]['italic'] == true && finalArray[0]['bold'] == true && finalArray[0]['underline'] == undefined) {
                                        thistag = "#bi$";
                                    }
                                    else if (finalArray[0]['italic'] == true && finalArray[0]['bold'] == false && finalArray[0]['underline'] == undefined) {
                                        thistag = "#i$";
                                    }
                                    else if (finalArray[0]['italic'] == false && finalArray[0]['bold'] == true && finalArray[0]['underline'] == undefined) {
                                        thistag = "#b$";
                                    }
                                    else if (finalArray[0]['italic'] == false && finalArray[0]['bold'] == false && finalArray[0]['underline'] == undefined) {
                                        thistag = "";
                                    }
                                    if (pretag == 'none') {
                                        if (thistag == '') {
                                            finalArray[0]['tagline'] = finalArray[0]['line'];
                                        }
                                        else {
                                            finalArray[0]['tagline'] = thistag + ' ' + finalArray[0]['line'];
                                        }
                                    }
                                    else if (pretag != thistag) {
                                        if (thistag == '') {
                                            finalArray[0]['tagline'] = '#/' + pretag.substring(pretag.indexOf('#') + 1) + ' ' + finalArray[0]['line'];
                                        }
                                        else {
                                            finalArray[0]['tagline'] = '#/' + pretag.substring(pretag.indexOf('#') + 1) + ' ' + thistag + ' ' + finalArray[0]['line'];
                                        }
                                    }
                                    pretag = thistag;
                                }
                                first = false;
                                //for rest of the objects
                                if (finalArray[i + 1]['italic'] == true && finalArray[i + 1]['bold'] == true && finalArray[i + 1]['underline'] != undefined && finalArray[i + 1]['underline'] == true) {
                                    thistag = "#biu$";
                                }
                                else if (finalArray[i + 1]['italic'] == false && finalArray[i + 1]['bold'] == true && finalArray[i + 1]['underline'] != undefined && finalArray[i + 1]['underline'] == true) {
                                    thistag = "#bu$";
                                }
                                else if (finalArray[i + 1]['italic'] == true && finalArray[i + 1]['bold'] == false && finalArray[i + 1]['underline'] != undefined && finalArray[i + 1]['underline'] == true) {
                                    thistag = "#iu$";
                                }
                                else if (finalArray[i + 1]['italic'] == false && finalArray[i + 1]['bold'] == false && finalArray[i + 1]['underline'] != undefined && finalArray[i + 1]['underline'] == true) {
                                    thistag = "#u$";
                                }
                                else if (finalArray[i + 1]['italic'] == true && finalArray[i + 1]['bold'] == true && finalArray[i + 1]['underline'] == undefined) {
                                    thistag = "#bi$";
                                }
                                else if (finalArray[i + 1]['italic'] == true && finalArray[i + 1]['bold'] == false && finalArray[i + 1]['underline'] == undefined) {
                                    thistag = "#i$";
                                }
                                else if (finalArray[i + 1]['italic'] == false && finalArray[i + 1]['bold'] == true && finalArray[i + 1]['underline'] == undefined) {
                                    thistag = "#b$";
                                }
                                else if (finalArray[i + 1]['italic'] == false && finalArray[i + 1]['bold'] == false && finalArray[i + 1]['underline'] == undefined) {
                                    thistag = "";
                                }
                                if (pretag == 'none' && !intag) {
                                    if (thistag == '') {
                                        finalArray[i + 1]['tagline'] = finalArray[i + 1]['line'];
                                    }
                                    else {
                                        finalArray[i + 1]['tagline'] = ' ' + thistag + ' ' + finalArray[i + 1]['line'];
                                    }
                                }
                                else if (pretag != thistag && !intag) {
                                    if (thistag == '') {
                                        if (finalArray[i]['fontSize'] != finalArray[i + 1]['fontSize'] || finalArray[i]['top'] != finalArray[i + 1]['top']) {
                                            finalArray[i]['tagline'] = finalArray[i]['tagline'] + ' #/' + pretag.substring(pretag.indexOf('#') + 1) + ' ';
                                            finalArray[i + 1]['tagline'] = finalArray[i + 1]['line'];
                                        }
                                        else {
                                            // finalArray[i]['tagline'] = finalArray[i]['tagline'] + ' #/' + pretag.substring(pretag.indexOf('#') + 1) + ' '
                                            finalArray[i + 1]['tagline'] = ' #/' + pretag.substring(pretag.indexOf('#') + 1) + ' ' + finalArray[i + 1]['line'];
                                        }
                                    }
                                    else {
                                        if (finalArray[i]['fontSize'] != finalArray[i + 1]['fontSize'] || finalArray[i]['top'] != finalArray[i + 1]['top']) {
                                            finalArray[i]['tagline'] = finalArray[i]['tagline'] + ' #/' + pretag.substring(pretag.indexOf('#') + 1) + ' ';
                                            finalArray[i + 1]['tagline'] = ' ' + thistag + ' ' + finalArray[i + 1]['line'];
                                        }
                                        else
                                            finalArray[i + 1]['tagline'] = ' #/' + pretag.substring(pretag.indexOf('#') + 1) + ' ' + thistag + ' ' + finalArray[i + 1]['line'];
                                    }
                                }
                                else if (intag) {
                                    finalArray[i + 1]['tagline'] = '';
                                    let word = !util_1.isNullOrUndefined(finalArray[i + 1].line.trim().split(/\s/)) && finalArray[i + 1].line.trim().split(/\s/).length > 1 ? finalArray[i + 1].line.trim().substring(finalArray[i + 1].line.trim().lastIndexOf(' ')) : finalArray[i + 1].line.trim();
                                    let att = word.trim().split(/’’/).length == 2 ? ' ’’' : (word.trim().split(/”/).length == 2 ? ' ”' : '');
                                    let con;
                                    if (word.trim() == finalArray[i + 1].line.trim()) {
                                        con = word.trim().split(/’’|”/)[0];
                                    }
                                    else {
                                        if (pretag != thistag) {
                                            if (pretag == 'none') {
                                                finalArray[i + 1]['tagline'] = ' ' + thistag + ' ' + finalArray[i + 1].line.trim().substring(0, finalArray[i + 1].line.trim().lastIndexOf(' ')) + ' ';
                                            }
                                            else {
                                                finalArray[i + 1]['tagline'] = ' #/' + pretag.substring(pretag.indexOf('#') + 1) + ' ' + thistag + ' ' + finalArray[i + 1].line.trim().substring(0, finalArray[i + 1].line.trim().lastIndexOf(' ')) + ' ';
                                            }
                                        }
                                        else {
                                            finalArray[i + 1]['tagline'] = finalArray[i + 1].line.trim().substring(0, finalArray[i + 1].line.trim().lastIndexOf(' ')) + ' ';
                                        }
                                        con = word.trim().split(/’’|”/)[0];
                                    }
                                    if (pretag != thistag) {
                                        if (pretag == 'none') {
                                            finalArray[i + 1]['tagline'] = finalArray[i + 1]['tagline'] + ' #x$ ' + con + ' #/x$ #/' + thistag.substring(thistag.indexOf('#') + 1) + att + word.trim().split(/’’|”/)[1];
                                        }
                                        else {
                                            finalArray[i + 1]['tagline'] = finalArray[i + 1]['tagline'] + ' #/' + pretag.substring(pretag.indexOf('#') + 1) + ' ' + thistag + ' #x$ ' + con + ' #/x$ #/' + thistag.substring(thistag.indexOf('#') + 1) + att + word.trim().split(/’’|”/)[1];
                                        }
                                    }
                                    else {
                                        finalArray[i + 1]['tagline'] = finalArray[i + 1]['tagline'] + ' #x$ ' + con + ' #/x$ #/' + thistag.substring(thistag.indexOf('#') + 1) + att + word.trim().split(/’’|”/)[1];
                                    }
                                    thistag = '';
                                }
                                else {
                                    // For seperate tags for paras
                                    if (finalArray[i]['fontSize'] != finalArray[i + 1]['fontSize'] || finalArray[i]['top'] != finalArray[i + 1]['top']) {
                                        finalArray[i]['tagline'] = finalArray[i]['tagline'] + ' #/' + pretag.substring(pretag.indexOf('#') + 1) + ' ';
                                        finalArray[i + 1]['tagline'] = ' ' + thistag + ' ' + finalArray[i + 1]['line'];
                                    }
                                    else
                                        finalArray[i + 1]['tagline'] = finalArray[i + 1]['line'];
                                }
                                pretag = thistag;
                                if (thistag == "") {
                                    pretag = 'none';
                                }
                                //END -SUSHANT
                                if (finalArray[i].text == '.') {
                                    if (finalArray[i - 1].top != finalArray[i].top && finalArray[i + 1].top == finalArray[i].top && finalArray[i + 2].top == finalArray[i].top && finalArray[i + 1].text == '.' && finalArray[i + 2].text == '.' && finalArray[i + 3].top != finalArray[i].top) {
                                        finalArray[i]['tripledot'] = true;
                                    }
                                }
                                if (finalArray[i].fontSize > 50) {
                                    finalArray[i].fontSize = finalArray[i].fontSize / 10;
                                }
                                if ((finalArray[i + 1].top === finalArray[i].top)) {
                                    let threshold = ((finalArray[i + 1].left - finalArray[i].lineright) / finalArray[i].height) * 100;
                                    let compareValue = threshold;
                                    if (compareValue < 3) {
                                        finalArray[i]['text'] = finalArray[i]['text'] + finalArray[i + 1]['text'];
                                        finalArray[i]['line'] = finalArray[i]['line'] + finalArray[i + 1]['line'];
                                        finalArray[i]['tagline'] = finalArray[i]['tagline'] + finalArray[i + 1]['tagline'];
                                        finalArray[i]['lineright'] = finalArray[i + 1]['lineright'];
                                        finalArray[i]['top'] = finalArray[i + 1]['top'];
                                        finalArray.splice(i + 1, 1);
                                        i = i - 1;
                                    }
                                }
                            }
                            let topEqual = false;
                            let lastDis;
                            for (let i = 0; i < finalArray.length; i++) {
                                //  console.log(tablesData[i].text,'-------TopY',tablesData[i].top,'---height',tablesData[i].height)
                                let previousLine = "";
                                let preObj = {};
                                if (i < finalArray.length - 1) {
                                    const regex = /^\w+\.\d+$/gm;
                                    const regexMatch = /([*+†‡]{0,4})/g;
                                    let a = finalArray[i];
                                    let isSupMatch = false;
                                    let b = finalArray[i + 1];
                                    let aFontSize = a.fontSize;
                                    let bFontSize = b.fontSize;
                                    let percentSizeDiff = 100;
                                    let precCompVal = 70;
                                    let allCon = false;
                                    if (/^\d+$/.test(a.line) && Number(a.top) > Number(b.top)
                                        && Number(a.top) > (Number(b.top) - Number(b.fontSize)) && a.left > b.left) {
                                        precCompVal = 52;
                                    }
                                    if ((/^\d+$/.test(b.line) || /^\*+$/.test(b.line) || /^\†+$/.test(b.line)) && b.left > a.left && (b.left - a.lineright < 1 && b.left - a.lineright > -1)) {
                                        precCompVal = 45;
                                        if (/\w+\.\”/.test(a.line)) {
                                            allCon = true;
                                        }
                                    }
                                    if (/^\†+$/.test(b.line)) {
                                        suprScript.push(b.line);
                                    }
                                    if (regex.test(a.line)) {
                                        a.fontSize = finalArray[i - 1].fontSize;
                                    }
                                    if (/\.[A-Z][a-z]/.test(a.line)) {
                                        a.line = a.line.replace(".", ". ");
                                    }
                                    if (/\.[A-Z][a-z]/.test(b.line)) {
                                        b.line = b.line.replace(".", ". ");
                                    }
                                    if (/\.[A-Z][a-z]/.test(a.tagline)) {
                                        a.tagline = a.tagline.replace(".", ". ");
                                    }
                                    if (/\.[A-Z][a-z]/.test(b.tagline)) {
                                        b.tagline = b.tagline.replace(".", ". ");
                                    }
                                    if (/\;[A-Z][a-z]/.test(a.line)) {
                                        a.line = a.line.replace(";", "; ");
                                    }
                                    if (/\;[A-Z][a-z]/.test(b.line)) {
                                        b.line = b.line.replace(";", "; ");
                                    }
                                    if (/\;[A-Z][a-z]/.test(a.tagline)) {
                                        a.tagline = a.tagline.replace(";", "; ");
                                    }
                                    if (/\;[A-Z][a-z]/.test(b.tagline)) {
                                        b.tagline = b.tagline.replace(";", "; ");
                                    }
                                    if (/\[\d+\]\w+/.test(a.line)) {
                                        a.line = a.line.replace("]", "] ");
                                    }
                                    if (/\[\d+\]\w+/.test(b.line)) {
                                        b.line = b.line.replace("]", "] ");
                                    }
                                    if (/\[\d+\]\w+/.test(a.tagline)) {
                                        a.tagline = a.tagline.replace("]", "] ");
                                    }
                                    if (/\[\d+\]\w+/.test(b.tagline)) {
                                        b.tagline = b.tagline.replace("]", "] ");
                                    }
                                    if (/\w+\’\w+/.test(a.line)) {
                                        a.line = a.line.replace("’", "’ ");
                                    }
                                    if (/\w+\’\w+/.test(b.line)) {
                                        b.line = b.line.replace("’", "’ ");
                                    }
                                    if (/\w+\’\w+/.test(a.tagline)) {
                                        a.tagline = a.tagline.replace("’", "’ ");
                                    }
                                    if (/\w+\’\w+/.test(b.tagline)) {
                                        b.tagline = b.tagline.replace("’", "’ ");
                                    }
                                    if (/\w+\-\s\w+/.test(a.line)) {
                                        a.line = a.line.replace("- ", "");
                                    }
                                    if (/\w+\-\s\w+/.test(b.line)) {
                                        b.line = b.line.replace("- ", "");
                                    }
                                    if (/\w+\-\s\w+/.test(a.tagline)) {
                                        a.tagline = a.tagline.replace("- ", "");
                                    }
                                    if (/\w+\-\s\w+/.test(b.tagline)) {
                                        b.tagline = b.tagline.replace("- ", "");
                                    }
                                    if (aFontSize >= bFontSize && a.lineright > b.left) {
                                        percentSizeDiff = (bFontSize / aFontSize) * 100;
                                    }
                                    if (aFontSize <= bFontSize && a.lineright > b.left) {
                                        percentSizeDiff = (aFontSize / bFontSize) * 100;
                                    }
                                    if (/\w+\*+$/.test(a.line) && !(/^\d/.test(a.line))) {
                                        a['mayBeSuperScript'] = true;
                                        let index = a.line.indexOf("*");
                                        let stars = a.line.substring(index, a.line.length);
                                        suprScript.push(stars);
                                    }
                                    if (/\.+\∗+$/.test(a.line)) {
                                        a['mayBeSuperScript'] = true;
                                        let index = a.line.indexOf("∗");
                                        let stars = a.line.substring(index, a.line.length);
                                        suprScript.push(stars);
                                        stars = stars.replace(/\∗+/, "*");
                                        a.line = a.line.replace(/\∗+/, "*");
                                    }
                                    if (a.tripledot) {
                                        if (lines.length > 0) {
                                            for (let index = 1; index < lines.length; index++) {
                                                //Mahadev-0
                                                lastDis = lines[index].lineleft - lines[index - 1].lineright;
                                                if (lastDis < 1 && lines[index].top == lines[index - 1].top) {
                                                    let after = lines[index].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "").length >= 1 ? lines[index].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "")[0] : '';
                                                    let wordss = lines[0].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "");
                                                    let predict = wordss.length >= 1 ? self.chkDic(wordss[wordss.length - 1], after) : false;
                                                    if (!predict || Math.round(lastDis) == 0) {
                                                        lines[0]['text'] = lines[0]['text'] + lines[index]['text'];
                                                        lines[0]['line'] = lines[0]['line'] + lines[index]['line'];
                                                        lines[0]['tagline'] = lines[0]['tagline'] + lines[index]['tagline'];
                                                        lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                    }
                                                    else {
                                                        lines[0]['text'] = lines[0]['text'] + " " + lines[index]['text'];
                                                        lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                        lines[0]['tagline'] = lines[0]['tagline'] + " " + lines[index]['tagline'];
                                                        lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                    }
                                                    // console.log(wordss[wordss.length - 1] + " " +after+ "----VK-------" + predict + "\n" + lines[0].line)
                                                }
                                                else {
                                                    lines[0]['text'] = lines[0]['text'] + " " + lines[index]['text'];
                                                    lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                    lines[0]['tagline'] = lines[0]['tagline'] + " " + lines[index]['tagline'];
                                                    lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                }
                                                //Mahadev-1
                                                // lines[0]['text'] = lines[0]['text'] + " " + lines[index]['text'];
                                                // lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                // lines[0]['tagline'] = lines[0]['tagline'] + " " + lines[index]['tagline'];
                                                // lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                lines[0]['lineright'] = lines[index]['lineright'];
                                                if (Number(lines[index]['lineright']) > Number(lines[index]['pageWidth']) && lines.length > 1) {
                                                    lines[0]['lineright'] = lines[index]['lineleft'] + 2;
                                                }
                                            }
                                            TableArray.push(lines[0]);
                                            lines = [];
                                        }
                                        finalArray[i]['line'] = '. . .';
                                        finalArray[i]['tagline'] = '. . .';
                                        TableArray.push(finalArray[i]);
                                        i = i + 2;
                                        continue;
                                    }
                                    if (Number(b.top) > Number(a.top)) {
                                        if (Number(a.top) > (Number(b.top) - Number(b.fontSize)) - Number('0.4') && percentSizeDiff >= precCompVal || (allCon)) {
                                            lines.push(a);
                                        }
                                        else {
                                            lines.push(a);
                                            if (lines.length > 0) {
                                                lines.sort(function (a, b) {
                                                    return Number(a.left) - Number(b.left);
                                                });
                                                for (let index = 1; index < lines.length; index++) {
                                                    //Mahadev-0
                                                    lastDis = lines[index].lineleft - lines[index - 1].lineright;
                                                    if (lastDis < 1 && lines[index].top == lines[index - 1].top) {
                                                        let after = lines[index].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "").length >= 1 ? lines[index].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "")[0] : '';
                                                        let wordss = lines[0].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "");
                                                        let predict = wordss.length >= 1 ? self.chkDic(wordss[wordss.length - 1], after) : false;
                                                        if (!predict || Math.round(lastDis) == 0) {
                                                            lines[0]['text'] = lines[0]['text'] + lines[index]['text'];
                                                            lines[0]['line'] = lines[0]['line'] + lines[index]['line'];
                                                            lines[0]['tagline'] = lines[0]['tagline'] + lines[index]['tagline'];
                                                            lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                            lines[0]['lastword_concat'] = true;
                                                        }
                                                        else {
                                                            lines[0]['text'] = lines[0]['text'] + " " + lines[index]['text'];
                                                            //lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                            lines[0]['tagline'] = lines[0]['tagline'] + " " + lines[index]['tagline'];
                                                            lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                            lines[0]['lastword_concat'] = false;
                                                        }
                                                        // console.log(wordss[wordss.length - 1] + " " +after+ "----VK-------" + predict + "\n" + lines[0].line)
                                                    }
                                                    else {
                                                        lines[0]['text'] = lines[0]['text'] + " " + lines[index]['text'];
                                                        //lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                        lines[0]['tagline'] = lines[0]['tagline'] + " " + lines[index]['tagline'];
                                                        lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                        lines[0]['lastword_concat'] = false;
                                                    }
                                                    //Mahadev-1
                                                    // lines[0]['text'] = lines[0]['text'] + " " + lines[index]['text'];
                                                    // //lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                    // lines[0]['tagline'] = lines[0]['tagline'] + " " + lines[index]['tagline'];
                                                    // lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                    if (isType && !util_1.isNullOrUndefined(fotLines.output) && fotLines.output != "") {
                                                        previousLine = util_1.isNullOrUndefined(TableArray[TableArray.length - 1]) ? 0 : TableArray[TableArray.length - 1];
                                                        preObj = yield self.addFotNoteAndSuperScript(lines[0], lines[index], JSON.parse(fotLines.output), previousLine, "superscript", superScript, type);
                                                        lines[0] = preObj['a'];
                                                        superScript = preObj['superScript'];
                                                    }
                                                    else {
                                                        if (!util_1.isNullOrUndefined(lines[0]['lastword_concat']) && lines[0]['lastword_concat'] == false)
                                                            lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                    }
                                                    lines[0]['lineright'] = lines[index]['lineright'];
                                                    if (Number(lines[index]['lineright']) > Number(lines[index]['pageWidth']) && lines.length > 1) {
                                                        lines[0]['lineright'] = lines[index]['lineleft'] + 2;
                                                    }
                                                    if (lines[0]['RealfontSize'] == undefined) {
                                                        lines[0]['RealfontSize'] = lines[0]['fontSize'];
                                                    }
                                                    if (lines[0]['fontSize'] < lines[index]['fontSize']) {
                                                        lines[0]['fontSize'] = lines[index]['fontSize'];
                                                    }
                                                }
                                                // Last Word Or SuperScript Extraction Logic
                                                if (isType) {
                                                    previousLine = util_1.isNullOrUndefined(TableArray[TableArray.length - 1]) ? null : TableArray[TableArray.length - 1];
                                                    if (!util_1.isNullOrUndefined(superScript) && superScript.length > 0) {
                                                        for (let r = 0; r < superScript.length; r++) {
                                                            let k = superScript[r].split("_");
                                                            if (Number(k[1]) == Number(lines[0]['pageId']) && (k[0] == a['line'] || (!util_1.isNullOrUndefined(lines[0]['isSuperScript']) && lines[0]['isSuperScript']))) {
                                                                isSupMatch = true;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    // Last Word Or SuperScript Extraction Logic
                                                    if (!util_1.isNullOrUndefined(previousLine) && Number(previousLine['fontSize']) > Number(lines[0]['fontSize']) && Number(previousLine['top']) - Number(lines[0]['top']) < 11 && (!isNaN(Number(lines[0]['line'])) || regexMatch.test(lines[0]['line'])) && lines.length == 1 && !isSupMatch) {
                                                        lines[0]['isSuperScript'] = true;
                                                        lines[0]['line'] = "<sp:" + lines[0]['line'] + '>';
                                                        //lines[0]['tagline'] = "<sp:" + lines[0]['tagline'] + '>';
                                                        let isSupTxt = this.superScriptNumber(lines[0]['line']);
                                                        lines[0]['tagline'] = lines[0]['tagline'].replace(isSupTxt, "<sp:" + isSupTxt + ">");
                                                        superScript.push(isSupTxt + "_" + lines[0]['pageId']);
                                                        console.log("a['line'] --R-- ", lines[0]['line']);
                                                    }
                                                }
                                                TableArray.push(lines[0]);
                                                lines = [];
                                            }
                                        }
                                        topEqual = false;
                                    }
                                    else if (Number(a.top) > Number(b.top)) {
                                        if (Number(b.top) > (Number(a.top) - Number(a.fontSize)) - Number('0.4') && percentSizeDiff >= precCompVal) {
                                            // && isNullOrUndefined(a['KriMarked'])
                                            let aBottom = (Number(a.top) - Number(a.fontSize));
                                            if (/^[\d*]+$/.test(a.line) && Number(b.top) - aBottom < 4 && Number(b.top) - aBottom > 0) {
                                                a['mayBeFootNote'] = true;
                                            }
                                            let bBottom = (Number(b.top) - Number(b.fontSize));
                                            if (i < finalArray.length - 3 && /^[\d*]+$/.test(b.line) && Number(finalArray[i + 2].top) - bBottom < 4 && Number(finalArray[i + 2].top) - bBottom > 0) {
                                                b['mayBeFootNote'] = true;
                                            }
                                            if ((topEqual && a.left > b.left && a['mayBeFootNote'] !== true) || (a.left > b.left && a['mayBeFootNote'] !== true && b['mayBeFootNote'] == true)) {
                                                lines.push(a);
                                                if (lines.length > 0) {
                                                    lines.sort(function (a, b) {
                                                        return Number(a.left) - Number(b.left);
                                                    });
                                                    for (let index = 1; index < lines.length; index++) {
                                                        //Mahadev-0
                                                        lastDis = lines[index].lineleft - lines[index - 1].lineright;
                                                        if (lastDis < 1 && lines[index].top == lines[index - 1].top) {
                                                            let after = lines[index].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "").length >= 1 ? lines[index].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "")[0] : '';
                                                            let wordss = lines[0].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "");
                                                            let predict = wordss.length >= 1 ? self.chkDic(wordss[wordss.length - 1], after) : false;
                                                            if (!predict || Math.round(lastDis) == 0) {
                                                                lines[0]['text'] = lines[0]['text'] + lines[index]['text'];
                                                                lines[0]['line'] = lines[0]['line'] + lines[index]['line'];
                                                                lines[0]['tagline'] = lines[0]['tagline'] + lines[index]['tagline'];
                                                                lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                                lines[0]['lastword_concat'] = true;
                                                            }
                                                            else {
                                                                lines[0]['text'] = lines[0]['text'] + " " + lines[index]['text'];
                                                                // lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                                lines[0]['tagline'] = lines[0]['tagline'] + " " + lines[index]['tagline'];
                                                                lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                                lines[0]['lastword_concat'] = false;
                                                            }
                                                            // console.log(wordss[wordss.length - 1] + " " +after+ "----VK-------" + predict + "\n" + lines[0].line)
                                                        }
                                                        else {
                                                            lines[0]['text'] = lines[0]['text'] + " " + lines[index]['text'];
                                                            //lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                            lines[0]['tagline'] = lines[0]['tagline'] + " " + lines[index]['tagline'];
                                                            lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                            lines[0]['lastword_concat'] = false;
                                                        }
                                                        //Mahadev-1
                                                        // Last Word Or SuperScript Extraction Logic
                                                        if (isType && !util_1.isNullOrUndefined(fotLines.output) && fotLines.output != "") {
                                                            previousLine = util_1.isNullOrUndefined(TableArray[TableArray.length - 1]) ? null : TableArray[TableArray.length - 1];
                                                            preObj = yield self.addFotNoteAndSuperScript(lines[0], lines[index], JSON.parse(fotLines.output), previousLine, "superscript", superScript, type);
                                                            lines[0] = preObj['a'];
                                                            superScript = preObj['superScript'];
                                                        }
                                                        else {
                                                            if (!util_1.isNullOrUndefined(lines[0]['lastword_concat']) && lines[0]['lastword_concat'] == false)
                                                                lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                        }
                                                        lines[0]['lineright'] = lines[index]['lineright'];
                                                        if (Number(lines[index]['lineright']) > Number(lines[index]['pageWidth']) && lines.length > 1) {
                                                            lines[0]['lineright'] = lines[index]['lineleft'] + 2;
                                                        }
                                                        if (lines[0]['RealfontSize'] == undefined) {
                                                            lines[0]['RealfontSize'] = lines[0]['fontSize'];
                                                        }
                                                        if (lines[0]['fontSize'] < lines[index]['fontSize']) {
                                                            lines[0]['fontSize'] = lines[index]['fontSize'];
                                                        }
                                                    }
                                                    if (isType) {
                                                        previousLine = util_1.isNullOrUndefined(TableArray[TableArray.length - 1]) ? null : TableArray[TableArray.length - 1];
                                                        if (!util_1.isNullOrUndefined(superScript) && superScript.length > 0) {
                                                            for (let r = 0; r < superScript.length; r++) {
                                                                let k = superScript[r].split("_");
                                                                if (Number(k[1]) == Number(lines[0]['pageId']) && (k[0] == a['line'] || (!util_1.isNullOrUndefined(lines[0]['isSuperScript']) && lines[0]['isSuperScript']))) {
                                                                    isSupMatch = true;
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                        if (!util_1.isNullOrUndefined(previousLine) && Number(previousLine['fontSize']) > Number(lines[0]['fontSize']) && Number(previousLine['top']) - Number(lines[0]['top']) < 11 && (!isNaN(Number(lines[0]['line'])) || regexMatch.test(lines[0]['line'])) && lines.length == 1 && !isSupMatch) {
                                                            lines[0]['isSuperScript'] = true;
                                                            lines[0]['line'] = "<sp:" + lines[0]['line'] + '>';
                                                            //lines[0]['tagline'] = "<sp:" + lines[0]['tagline'] + '>';
                                                            let isSupTxt = this.superScriptNumber(lines[0]['line']);
                                                            lines[0]['tagline'] = lines[0]['tagline'].replace(isSupTxt, "<sp:" + isSupTxt + ">");
                                                            superScript.push(isSupTxt + "_" + lines[0]['pageId']);
                                                            console.log("a['line'] --S-- ", lines[0]['line']);
                                                        }
                                                    }
                                                    // End --- Last Word Or SuperScript Extraction Logic
                                                    TableArray.push(lines[0]);
                                                    lines = [];
                                                }
                                            }
                                            else {
                                                lines.push(a);
                                            }
                                            // else if(lines.length == 0 || lines[lines.length-1].left < a.left) {
                                            //     lines.push(a);
                                            // } else if(lines.length > 0 && lines[lines.length-1].left > a.left){
                                            //     a['KriMarked'] = true;
                                            //     i = i - 1;
                                            // }
                                            // }
                                        }
                                        else {
                                            // if(isNullOrUndefined(a['KriMarked'])){
                                            //     lines.push(a);
                                            // }
                                            lines.push(a);
                                            if (lines.length > 0) {
                                                lines.sort(function (a, b) {
                                                    return Number(a.left) - Number(b.left);
                                                });
                                                for (let index = 1; index < lines.length; index++) {
                                                    //Mahadev-0
                                                    lastDis = lines[index].lineleft - lines[index - 1].lineright;
                                                    if (lastDis < 1 && lines[index].top == lines[index - 1].top) {
                                                        let after = lines[index].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "").length >= 1 ? lines[index].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "")[0] : '';
                                                        let wordss = lines[0].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "");
                                                        let predict = wordss.length >= 1 ? self.chkDic(wordss[wordss.length - 1], after) : false;
                                                        if (!predict || Math.round(lastDis) == 0) {
                                                            lines[0]['text'] = lines[0]['text'] + lines[index]['text'];
                                                            lines[0]['line'] = lines[0]['line'] + lines[index]['line'];
                                                            lines[0]['tagline'] = lines[0]['tagline'] + lines[index]['tagline'];
                                                            lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                            lines[0]['lastword_concat'] = true;
                                                        }
                                                        else {
                                                            lines[0]['text'] = lines[0]['text'] + " " + lines[index]['text'];
                                                            //lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                            lines[0]['tagline'] = lines[0]['tagline'] + " " + lines[index]['tagline'];
                                                            lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                            lines[0]['lastword_concat'] = false;
                                                        }
                                                        // console.log(wordss[wordss.length - 1] + " " +after+ "----VK-------" + predict + "\n" + lines[0].line)
                                                    }
                                                    else {
                                                        lines[0]['text'] = lines[0]['text'] + " " + lines[index]['text'];
                                                        //lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                        lines[0]['tagline'] = lines[0]['tagline'] + " " + lines[index]['tagline'];
                                                        lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                        lines[0]['lastword_concat'] = false;
                                                    }
                                                    //Mahadev-1
                                                    // Last Word Or SuperScript Extraction Logic
                                                    if (isType && !util_1.isNullOrUndefined(fotLines.output) && fotLines.output != "") {
                                                        previousLine = util_1.isNullOrUndefined(TableArray[TableArray.length - 1]) ? null : TableArray[TableArray.length - 1];
                                                        preObj = yield self.addFotNoteAndSuperScript(lines[0], lines[index], JSON.parse(fotLines.output), previousLine, "superscript", superScript, type);
                                                        lines[0] = preObj['a'];
                                                        superScript = preObj['superScript'];
                                                    }
                                                    else {
                                                        if (!util_1.isNullOrUndefined(lines[0]['lastword_concat']) && lines[0]['lastword_concat'] == false)
                                                            lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                    }
                                                    lines[0]['lineright'] = lines[index]['lineright'];
                                                    if (Number(lines[index]['lineright']) > Number(lines[index]['pageWidth']) && lines.length > 1) {
                                                        lines[0]['lineright'] = lines[index]['lineleft'] + 2;
                                                    }
                                                    if (lines[0]['RealfontSize'] == undefined) {
                                                        lines[0]['RealfontSize'] = lines[0]['fontSize'];
                                                    }
                                                    if (lines[0]['fontSize'] < lines[index]['fontSize']) {
                                                        lines[0]['fontSize'] = lines[index]['fontSize'];
                                                    }
                                                }
                                                if (isType) {
                                                    previousLine = util_1.isNullOrUndefined(TableArray[TableArray.length - 1]) ? null : TableArray[TableArray.length - 1];
                                                    let isTrue = /([*+†‡])/g.test(lines[0]['line']);
                                                    if (!util_1.isNullOrUndefined(superScript) && superScript.length > 0) {
                                                        for (let r = 0; r < superScript.length; r++) {
                                                            let k = superScript[r].split("_");
                                                            if (!isTrue) {
                                                                if (Number(k[1]) == Number(lines[0]['pageId']) && (k[0] == lines[0]['line'] || (!util_1.isNullOrUndefined(lines[0]['isSuperScript']) && lines[0]['isSuperScript']))) {
                                                                    isSupMatch = true;
                                                                    break;
                                                                }
                                                            }
                                                            else {
                                                                let isSupTxt = this.superScriptNumber(lines[0]['line']);
                                                                if (Number(k[1]) == Number(lines[0]['pageId']) && (k[0] == isSupTxt || (!util_1.isNullOrUndefined(lines[0]['isSuperScript']) && lines[0]['isSuperScript']))) {
                                                                    isSupMatch = true;
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    if (!util_1.isNullOrUndefined(previousLine) && Number(previousLine['fontSize']) > Number(lines[0]['fontSize']) && Number(previousLine['top']) - Number(lines[0]['top']) < 11 && (!isNaN(Number(lines[0]['line'])) || regexMatch.test(lines[0]['line'])) && lines.length == 1 && !isSupMatch) {
                                                        lines[0]['isSuperScript'] = true;
                                                        if (!(/[*∗+†‡]/.test(lines[0]["line"]))) {
                                                            lines[0]['line'] = "<sp:" + lines[0]['line'] + '>';
                                                            let isSupTxt = this.superScriptNumber(lines[0]['line']);
                                                            lines[0]['tagline'] = lines[0]['tagline'].replace(isSupTxt, "<sp:" + isSupTxt + ">");
                                                            isSupTxt = this.superScriptNumber(lines[0]['line']);
                                                            superScript.push(isSupTxt + "_" + lines[0]['pageId']);
                                                            console.log("a['line'] --F-- ", lines[0]['line']);
                                                        }
                                                        else {
                                                            lines[0]['line'] = lines[0]['line'].replace(/\∗/g, "*");
                                                            lines[0]['tagline'] = lines[0]['tagline'].replace(/\∗/g, "*");
                                                            let isSupTxt = this.superScriptNumber(lines[0]['line']);
                                                            lines[0]['line'] = lines[0]['line'].replace(isSupTxt, "<sp:" + isSupTxt + ">");
                                                            lines[0]['tagline'] = lines[0]['tagline'].replace(isSupTxt, "<sp:" + isSupTxt + ">");
                                                            superScript.push(isSupTxt + "_" + lines[0]['pageId']);
                                                            lines[0]['isSuperScript'] = true;
                                                            console.log("regexMatch --U-- ", lines[0]['line']);
                                                        }
                                                        //lines[0]['tagline'] = "<sp:" + lines[0]['tagline'] + '>';
                                                        //return {"a" : a, "superScript" : superScript};
                                                    }
                                                    else if (isTrue && !isSupMatch && !(/^[*+†‡]/.test(lines[0]["line"])) && !(/\+/g.test(lines[0]["line"])) && input.type == 'journals') {
                                                        lines[0]['line'] = lines[0]['line'].replace(/\∗/g, "*");
                                                        let isSupTxt = this.superScriptNumber(lines[0]['line']);
                                                        lines[0]['line'] = lines[0]['line'].replace(isSupTxt, "<sp:" + isSupTxt + ">");
                                                        lines[0]['tagline'] = lines[0]['tagline'].replace(isSupTxt, "<sp:" + isSupTxt + ">");
                                                        superScript.push(isSupTxt + "_" + lines[0]['pageId']);
                                                        lines[0]['isSuperScript'] = true;
                                                        console.log("regexMatch --- D --- ", lines[0]["line"]);
                                                    }
                                                }
                                                // End ---  Last Word Or SuperScript Extraction Logic
                                                TableArray.push(lines[0]);
                                                lines = [];
                                            }
                                            // if(!isNullOrUndefined(a['KriMarked']) && a['KriMarked']){
                                            //     lines.push(a);
                                            // }
                                        }
                                        topEqual = false;
                                    }
                                    else if (Math.round(a.top) == Math.round(b.top)) {
                                        topEqual = true;
                                        let allowBreak = true;
                                        let bottom = 0;
                                        let bottom1 = 0;
                                        if (lines.length > 0) {
                                            bottom = Math.trunc(lines[lines.length - 1]['top'] - lines[lines.length - 1]['fontSize']);
                                            bottom1 = Math.trunc(lines[0]['top'] - lines[0]['fontSize']);
                                        }
                                        if ((bottom < Math.trunc(a.top)) || ((bottom1 < Math.trunc(a.top)))) {
                                            allowBreak = false;
                                        }
                                        if (allowBreak && i > 1 && lines.length == 1) {
                                            let prv = finalArray[i - 2];
                                            if (prv.fontSize == a.fontSize && a.fontSize == b.fontSize && lines[lines.length - 1]['fontSize'] < a.fontSize) {
                                                allowBreak = false;
                                            }
                                        }
                                        if (lines.length > 0 && Math.round(lines[lines.length - 1]['top']) != Math.round(a.top) &&
                                            allowBreak) {
                                            lines.sort(function (a, b) {
                                                return Number(a.left) - Number(b.left);
                                            });
                                            for (let index = 1; index < lines.length; index++) {
                                                //Mahadev-0
                                                lastDis = lines[index].lineleft - lines[index - 1].lineright;
                                                if (lastDis < 1 && lines[index].top == lines[index - 1].top) {
                                                    let after = lines[index].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "").length >= 1 ? lines[index].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "")[0] : '';
                                                    let wordss = lines[0].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "");
                                                    let predict = wordss.length >= 1 ? self.chkDic(wordss[wordss.length - 1], after) : false;
                                                    if (!predict || Math.round(lastDis) == 0) {
                                                        lines[0]['text'] = lines[0]['text'] + lines[index]['text'];
                                                        lines[0]['line'] = lines[0]['line'] + lines[index]['line'];
                                                        lines[0]['tagline'] = lines[0]['tagline'] + lines[index]['tagline'];
                                                        lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                        lines[0]['lastword_concat'] = true;
                                                    }
                                                    else {
                                                        lines[0]['text'] = lines[0]['text'] + " " + lines[index]['text'];
                                                        //lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                        lines[0]['tagline'] = lines[0]['tagline'] + " " + lines[index]['tagline'];
                                                        lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                        lines[0]['lastword_concat'] = false;
                                                    }
                                                    // console.log(wordss[wordss.length - 1] + " " +after+ "----VK-------" + predict + "\n" + lines[0].line)
                                                }
                                                else {
                                                    lines[0]['text'] = lines[0]['text'] + " " + lines[index]['text'];
                                                    //lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                    lines[0]['tagline'] = lines[0]['tagline'] + " " + lines[index]['tagline'];
                                                    lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                    lines[0]['lastword_concat'] = false;
                                                }
                                                //Mahadev-1
                                                // lines[0]['text'] = lines[0]['text'] + " " + lines[index]['text'];
                                                // //lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                // lines[0]['tagline'] = lines[0]['tagline'] + " " + lines[index]['tagline'];
                                                // lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                // Last Word Or SuperScript Extraction Logic
                                                if (isType && !util_1.isNullOrUndefined(fotLines.output) && fotLines.output != "") {
                                                    previousLine = util_1.isNullOrUndefined(TableArray[TableArray.length - 1]) ? null : TableArray[TableArray.length - 1];
                                                    preObj = yield self.addFotNoteAndSuperScript(lines[0], lines[index], JSON.parse(fotLines.output), previousLine, "superscript", superScript, type);
                                                    lines[0] = preObj['a'];
                                                    superScript = preObj['superScript'];
                                                }
                                                else {
                                                    if (!util_1.isNullOrUndefined(lines[0]['lastword_concat']) && lines[0]['lastword_concat'] == false)
                                                        lines[0]['line'] = lines[0]['line'] + " " + lines[index]['line'];
                                                }
                                                lines[0]['lineright'] = lines[index]['lineright'];
                                                if (Number(lines[index]['lineright']) > Number(lines[index]['pageWidth']) && lines.length > 1) {
                                                    lines[0]['lineright'] = lines[index]['lineleft'] + 2;
                                                }
                                                if (lines[0]['RealfontSize'] == undefined) {
                                                    lines[0]['RealfontSize'] = lines[0]['fontSize'];
                                                }
                                                if (lines[0]['fontSize'] < lines[index]['fontSize']) {
                                                    lines[0]['fontSize'] = lines[index]['fontSize'];
                                                }
                                            }
                                            if (isType) {
                                                previousLine = util_1.isNullOrUndefined(TableArray[TableArray.length - 1]) ? null : TableArray[TableArray.length - 1];
                                                if (!util_1.isNullOrUndefined(superScript) && superScript.length > 0) {
                                                    for (let r = 0; r < superScript.length; r++) {
                                                        let k = superScript[r].split("_");
                                                        if (Number(k[1]) == Number(lines[0]['pageId']) && (k[0] == a['line'] || (!util_1.isNullOrUndefined(lines[0]['isSuperScript']) && lines[0]['isSuperScript']))) {
                                                            isSupMatch = true;
                                                            break;
                                                        }
                                                    }
                                                }
                                                if (!util_1.isNullOrUndefined(previousLine) && Number(previousLine['fontSize']) > Number(lines[0]['fontSize']) && Number(previousLine['top']) - Number(lines[0]['top']) < 11 && (!isNaN(Number(lines[0]['line'])) || regexMatch.test(lines[0]['line'])) && lines.length == 1 && !isSupMatch) {
                                                    lines[0]['isSuperScript'] = true;
                                                    lines[0]['line'] = "<sp:" + lines[0]['line'] + '>';
                                                    lines[0]['tagline'] = "<sp:" + lines[0]['tagline'] + '>';
                                                    let isSupTxt = this.superScriptNumber(lines[0]['line']);
                                                    superScript.push(isSupTxt + "_" + lines[0]['pageId']);
                                                    console.log("a['line'] --G-- ", lines[0]['line']);
                                                    //return {"a" : a, "superScript" : superScript};
                                                }
                                            }
                                            // End --- Last Word Or SuperScript Extraction Logic
                                            TableArray.push(lines[0]);
                                            lines = [];
                                            lines.push(a);
                                        }
                                        else {
                                            lines.push(a);
                                        }
                                    }
                                }
                                else {
                                    if (lines.length > 0) {
                                        lines.sort(function (a, b) {
                                            return Number(a.left) - Number(b.left);
                                        });
                                        for (let k = 1; k < lines.length; k++) {
                                            //Mahadev-0
                                            lastDis = lines[k].lineleft - lines[k - 1].lineright;
                                            if (lastDis < 1 && lines[k].top == lines[k - 1].top) {
                                                let after = lines[k].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "").length >= 1 ? lines[k].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "")[0] : '';
                                                let wordss = lines[0].line.split(/[- ./\\()"',;<>~!@#$%^&*|+=[\]{}`~?:’‘]/).filter(str => str != "");
                                                let predict = wordss.length >= 1 ? self.chkDic(wordss[wordss.length - 1], after) : false;
                                                if (!predict || Math.round(lastDis) == 0) {
                                                    lines[0]['text'] = lines[0]['text'] + lines[k]['text'];
                                                    lines[0]['line'] = lines[0]['line'] + lines[k]['line'];
                                                    lines[0]['tagline'] = lines[0]['tagline'] + lines[k]['tagline'];
                                                    lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                    lines[0]['lastword_concat'] = true;
                                                }
                                                else {
                                                    lines[0]['text'] = lines[0]['text'] + " " + lines[k]['text'];
                                                    // lines[0]['line'] = lines[0]['line'] + " " + lines[k]['line'];
                                                    lines[0]['tagline'] = lines[0]['tagline'] + " " + lines[k]['tagline'];
                                                    lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                    lines[0]['lastword_concat'] = false;
                                                }
                                                // console.log(wordss[wordss.length - 1] + " " +after + "----VK-------" + predict + "\n" + lines[0].line)
                                            }
                                            else {
                                                lines[0]['text'] = lines[0]['text'] + " " + lines[k]['text'];
                                                //lines[0]['line'] = lines[0]['line'] + " " + lines[k]['line'];
                                                lines[0]['tagline'] = lines[0]['tagline'] + " " + lines[k]['tagline'];
                                                lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                                lines[0]['lastword_concat'] = false;
                                            }
                                            //Mahadev-1
                                            // lines[0]['text'] = lines[0]['text'] + " " + lines[k]['text'];
                                            // //lines[0]['line'] = lines[0]['line'] + " " + lines[k]['line'];
                                            // lines[0]['tagline'] = lines[0]['tagline'] + " " + lines[k]['tagline'];
                                            // lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                            if (isType && !util_1.isNullOrUndefined(fotLines.output) && fotLines.output != "") {
                                                previousLine = util_1.isNullOrUndefined(TableArray[TableArray.length - 1]) ? null : TableArray[TableArray.length - 1];
                                                preObj = yield self.addFotNoteAndSuperScript(lines[0], lines[k], JSON.parse(fotLines.output), previousLine, "superscript", superScript, type);
                                                lines[0] = preObj['a'];
                                                superScript = preObj['superScript'];
                                            }
                                            else {
                                                if (!util_1.isNullOrUndefined(lines[0]['lastword_concat']) && lines[0]['lastword_concat'] == false)
                                                    lines[0]['line'] = lines[0]['line'] + " " + lines[k]['line'];
                                            }
                                            lines[0]['lineright'] = lines[k]['lineright'];
                                            if (Number(lines[k]['lineright']) > Number(lines[k]['pageWidth']) && lines.length > 1) {
                                                lines[0]['lineright'] = lines[k - 1]['lineright'] + 1;
                                            }
                                        }
                                        lines[0]['text'] = lines[0]['text'] + " " + finalArray[finalArray.length - 1]['text'];
                                        //lines[0]['line'] = lines[0]['line'] + " " + finalArray[finalArray.length - 1]['line'];
                                        lines[0]['tagline'] = lines[0]['tagline'] + " " + finalArray[finalArray.length - 1]['tagline'];
                                        lines[0]['tagline'] = lines[0]['tagline'].replace(/  /, " ");
                                        // Last Word Or SuperScript Extraction Logic
                                        if (isType && !util_1.isNullOrUndefined(fotLines.output) && fotLines.output != "") {
                                            previousLine = util_1.isNullOrUndefined(TableArray[TableArray.length - 1]) ? null : TableArray[TableArray.length - 1];
                                            preObj = yield self.addFotNoteAndSuperScript(lines[0], finalArray[finalArray.length - 1], JSON.parse(fotLines.output), previousLine, "superscript", superScript, type);
                                            lines[0] = preObj['a'];
                                            superScript = preObj['superScript'];
                                        }
                                        else {
                                            lines[0]['line'] = lines[0]['line'] + " " + finalArray[finalArray.length - 1]['line'];
                                        }
                                        // End -- Last Word Or SuperScript Extraction Logic
                                        lines[0]['lineright'] = finalArray[finalArray.length - 1]['lineright'];
                                        TableArray.push(lines[0]);
                                    }
                                    else if (i == (finalArray.length - 1)) {
                                        TableArray.push(finalArray[i]);
                                    }
                                }
                            }
                        }
                        else {
                            // finalArray = final;
                            // final = null;
                            console.log("Inside CREP parser-------------->");
                            let pageCenter = Number(finalArray[0].pageWidth) / 2;
                            let countCenter = new Array(Math.floor(finalArray[0].pageWidth)).fill(0);
                            console.log(countCenter);
                            let avgDis = 0;
                            let countDis = 0;
                            let res1;
                            res1 = yield this.sh("sudo python3 juta.py " + PDF_PATH + " " + "findUnderline dummy");
                            if (res1.output) {
                                words = res1.output.replace('[', '').replace(']', '').replace(/"/g, '').replace(/\\u2019/g, '’').replace(/\\u2018/g, '‘').replace(/\\u2022/g, '•').replace(/\\u201c/g, '“').replace(/\\u201d/g, '”').replace(/\\u02bb/g, 'ʻ').replace(/\\t/g, '  ').split(',');
                            }
                            let first = true;
                            let pretag = "none";
                            console.log(type);
                            for (let i = 0; i < finalArray.length - 1; i++) {
                                //START - SUSHANT
                                let thistag = "";
                                if (res1.output && !util_1.isNullOrUndefined(words)) {
                                    words.map((word) => {
                                        if (i < finalArray.length - 2 && word.includes('#') && word.includes('$') && word.substring(0, word.indexOf('#')).replace(/\s/g, '') != '' && word.substring(word.indexOf('#') + 1, word.indexOf('$')) == finalArray[i + 1].pageId && Number(word.substring(word.indexOf('$') + 1).replace(/\n/g, '')) + finalArray[i + 1].cropboxY >= finalArray[i + 1].top - 7 && Number(word.substring(word.indexOf('$') + 1).replace(/\n/g, '')) + finalArray[i + 1].cropboxY <= finalArray[i + 1].top + 7 && word.trim().includes(finalArray[i + 1].line.trim())) {
                                            finalArray[i + 1]['underline'] = true;
                                        }
                                    });
                                }
                                //for first object
                                if (first) {
                                    if (finalArray[0]['italic'] == true && finalArray[0]['bold'] == true && finalArray[0]['underline'] != undefined && finalArray[0]['underline'] == true) {
                                        thistag = "#biu$";
                                    }
                                    else if (finalArray[0]['italic'] == false && finalArray[0]['bold'] == true && finalArray[0]['underline'] != undefined && finalArray[0]['underline'] == true) {
                                        thistag = "#bu$";
                                    }
                                    else if (finalArray[0]['italic'] == true && finalArray[0]['bold'] == false && finalArray[0]['underline'] != undefined && finalArray[0]['underline'] == true) {
                                        thistag = "#iu$";
                                    }
                                    else if (finalArray[0]['italic'] == false && finalArray[0]['bold'] == false && finalArray[0]['underline'] != undefined && finalArray[0]['underline'] == true) {
                                        thistag = "#u$";
                                    }
                                    else if (finalArray[0]['italic'] == true && finalArray[0]['bold'] == true && finalArray[0]['underline'] == undefined) {
                                        thistag = "#bi$";
                                    }
                                    else if (finalArray[0]['italic'] == true && finalArray[0]['bold'] == false && finalArray[0]['underline'] == undefined) {
                                        thistag = "#i$";
                                    }
                                    else if (finalArray[0]['italic'] == false && finalArray[0]['bold'] == true && finalArray[0]['underline'] == undefined) {
                                        thistag = "#b$";
                                    }
                                    else if (finalArray[0]['italic'] == false && finalArray[0]['bold'] == false && finalArray[0]['underline'] == undefined) {
                                        thistag = "";
                                    }
                                    if (pretag == 'none') {
                                        if (thistag == '') {
                                            finalArray[0]['tagline'] = finalArray[0]['line'];
                                        }
                                        else {
                                            finalArray[0]['tagline'] = thistag + ' ' + finalArray[0]['line'];
                                        }
                                    }
                                    else if (pretag != thistag) {
                                        if (thistag == '') {
                                            finalArray[0]['tagline'] = '#/' + pretag.substring(pretag.indexOf('#') + 1) + ' ' + finalArray[0]['line'];
                                        }
                                        else {
                                            finalArray[0]['tagline'] = '#/' + pretag.substring(pretag.indexOf('#') + 1) + ' ' + thistag + ' ' + finalArray[0]['line'];
                                        }
                                    }
                                    pretag = thistag;
                                }
                                first = false;
                                //for rest of the objects
                                if (finalArray[i + 1]['italic'] == true && finalArray[i + 1]['bold'] == true && finalArray[i + 1]['underline'] != undefined && finalArray[i + 1]['underline'] == true) {
                                    thistag = "#biu$";
                                }
                                else if (finalArray[i + 1]['italic'] == false && finalArray[i + 1]['bold'] == true && finalArray[i + 1]['underline'] != undefined && finalArray[i + 1]['underline'] == true) {
                                    thistag = "#bu$";
                                }
                                else if (finalArray[i + 1]['italic'] == true && finalArray[i + 1]['bold'] == false && finalArray[i + 1]['underline'] != undefined && finalArray[i + 1]['underline'] == true) {
                                    thistag = "#iu$";
                                }
                                else if (finalArray[i + 1]['italic'] == false && finalArray[i + 1]['bold'] == false && finalArray[i + 1]['underline'] != undefined && finalArray[i + 1]['underline'] == true) {
                                    thistag = "#u$";
                                }
                                else if (finalArray[i + 1]['italic'] == true && finalArray[i + 1]['bold'] == true && finalArray[i + 1]['underline'] == undefined) {
                                    thistag = "#bi$";
                                }
                                else if (finalArray[i + 1]['italic'] == true && finalArray[i + 1]['bold'] == false && finalArray[i + 1]['underline'] == undefined) {
                                    thistag = "#i$";
                                }
                                else if (finalArray[i + 1]['italic'] == false && finalArray[i + 1]['bold'] == true && finalArray[i + 1]['underline'] == undefined) {
                                    thistag = "#b$";
                                }
                                else if (finalArray[i + 1]['italic'] == false && finalArray[i + 1]['bold'] == false && finalArray[i + 1]['underline'] == undefined) {
                                    thistag = "";
                                }
                                if (pretag == 'none') {
                                    if (thistag == '') {
                                        finalArray[i + 1]['tagline'] = finalArray[i + 1]['line'];
                                    }
                                    else {
                                        finalArray[i + 1]['tagline'] = ' ' + thistag + ' ' + finalArray[i + 1]['line'];
                                    }
                                }
                                else if (pretag != thistag) {
                                    if (thistag == '') {
                                        finalArray[i + 1]['tagline'] = ' #/' + pretag.substring(pretag.indexOf('#') + 1) + ' ' + finalArray[i + 1]['line'];
                                    }
                                    else {
                                        finalArray[i + 1]['tagline'] = ' #/' + pretag.substring(pretag.indexOf('#') + 1) + ' ' + thistag + ' ' + finalArray[i + 1]['line'];
                                    }
                                }
                                else {
                                    finalArray[i + 1]['tagline'] = finalArray[i + 1]['line'];
                                }
                                pretag = thistag;
                                if (thistag == "") {
                                    pretag = 'none';
                                }
                                //END -SUSHANT
                                if (finalArray[i].fontSize > 50) {
                                    finalArray[i].fontSize = finalArray[i].fontSize / 10;
                                }
                                if ((finalArray[i + 1].top === finalArray[i].top)) {
                                    avgDis = avgDis + (finalArray[i + 1].lineleft - finalArray[i].lineright);
                                    countDis++;
                                    let threshold = ((finalArray[i + 1].left - finalArray[i].lineright) / finalArray[i].height) * 100;
                                    let compareValue = threshold;
                                    if (compareValue < 3) {
                                        finalArray[i]['text'] = finalArray[i]['text'] + finalArray[i + 1]['text'];
                                        finalArray[i]['line'] = finalArray[i]['line'] + finalArray[i + 1]['line'];
                                        finalArray[i]['lineright'] = finalArray[i + 1]['lineright'];
                                        finalArray[i]['top'] = finalArray[i + 1]['top'];
                                        finalArray.splice(i + 1, 1);
                                        i = i - 1;
                                    }
                                }
                            }
                            let starting = Math.floor(pageCenter - 15);
                            let ending = Math.floor(pageCenter + 15);
                            for (let i = 0; i < (finalArray.length - 1); i++) {
                                let left = Math.floor(finalArray[i].lineleft);
                                let right = Math.floor(finalArray[i].lineright);
                                if ((left >= starting && right <= ending) || (left <= starting && right >= starting) || (left <= ending && right >= ending))
                                    for (let start = left; start <= right; start++) {
                                        if (start > (starting) && start < (ending))
                                            countCenter[start]++;
                                    }
                                if (finalArray[i].pageId != finalArray[i + 1].pageId)
                                    break;
                            }
                            // let s1=0,s2=0,s3=0
                            // for(let i=starting,j=0;i<ending;i++,j++)
                            // {
                            //     if(j<10)
                            //         s1=s1+countCenter[i]
                            //     else if(j<21)
                            //         s2=s2+countCenter[i]
                            //     else
                            //         s3=s3+countCenter[i]
                            // }
                            // s1=s1/10
                            // s2=s2/11
                            // s3=s3/10
                            // let centralRegion=[0,0]
                            // if(s1/s2>2 || s3/s2>2)
                            //     {
                            //         centralRegion[0]=pageCenter-5
                            //         centralRegion[1]=pageCenter+5
                            //     }
                            // else if(s2/s3>2 || s1/s3>2)
                            //     {
                            //         centralRegion[0]=pageCenter+4
                            //         centralRegion[1]=pageCenter+14
                            //     }
                            // else if(s3/s1>2 || s2/s1>2)
                            //     {
                            //         centralRegion[0]=pageCenter-14
                            //         centralRegion[1]=pageCenter-5
                            //     }
                            // else{
                            //         centralRegion[0]=pageCenter-5
                            //         centralRegion[1]=pageCenter+5
                            // }
                            for (let i = starting + 1; i < ending - 1; i++) {
                                if (countCenter[i] / countCenter[i + 1] > 2 || countCenter[i + 1] / countCenter[i] > 2) {
                                    if (countCenter[i] > countCenter[i + 1])
                                        pageCenter = i + 1;
                                    else
                                        pageCenter = i;
                                    break;
                                }
                            }
                            // let totalPages=finalArray[finalArray.length-1].pageId
                            // let starting=0
                            // let ending=0
                            // let sum=0
                            // for( let i=0;i<countCenter.length;i++)
                            // {
                            //             sum=sum+countCenter[i]
                            // }
                            // sum=sum/countCenter.length
                            // for(let i=0;i<countReset.length;i++)
                            // {
                            //     if(countCenter[i]>sum)
                            //         starting=i
                            // }
                            // for(let i=countReset.length-1;i>=0;i++)
                            // {
                            //     if(countCenter[i]>sum)
                            //         ending=i
                            // }
                            let space = Number((avgDis / countDis) * 3);
                            let lines = [];
                            // let TableArray = [];
                            let partition = false;
                            let endLines = [];
                            let leftLines = [];
                            let rightLines = [];
                            let rightIndex = -1;
                            let leftIndex = -1;
                            let reg = /[a-zA-Z.’].([\d+])$/;
                            let temp;
                            let topEqual = false;
                            // let rArry=[];
                            for (let i = 0; i < finalArray.length; i++) {
                                //  console.log(tablesData[i].text,'-------TopY',tablesData[i].top,'---height',tablesData[i].height)
                                let previousLine = "";
                                let preObj = {};
                                if (i < finalArray.length - 1) {
                                    const regex = /^\w+\.\d+$/gm;
                                    const regexMatch = /([*+†‡]{0,4})/g;
                                    let a = finalArray[i];
                                    let isSupMatch = false;
                                    let b = finalArray[i + 1];
                                    let aFontSize = a.fontSize;
                                    let bFontSize = b.fontSize;
                                    let percentSizeDiff = 100;
                                    let precCompVal = 70;
                                    let allCon = false;
                                    if (/^\d+$/.test(a.line) && Number(a.top) > Number(b.top)
                                        && Number(a.top) > (Number(b.top) - Number(b.fontSize)) && a.left > b.left) {
                                        precCompVal = 52;
                                    }
                                    if ((/^\d+$/.test(b.line) || /^\*+$/.test(b.line)) && b.left > a.left && (b.left - a.lineright < 1 && b.left - a.lineright > -1)) {
                                        precCompVal = 45;
                                        if (/\w+\.\”/.test(a.line)) {
                                            allCon = true;
                                        }
                                    }
                                    if (/^\†+$/.test(b.line)) {
                                        suprScript.push(b.line);
                                    }
                                    if (a.line.match(reg) != null) {
                                        let ss = a.line.match(/\d+/g);
                                        ss.length >= 1 ? superScript.push(ss[ss.length - 1] + "_" + a.pageId) : " ";
                                        a.line = a.line.replace(ss[ss.length - 1], " <sp:" + ss[ss.length - 1] + ">");
                                        a.tagline = a.tagline.replace(ss[ss.length - 1], " <sp:" + ss[ss.length - 1] + ">");
                                    }
                                    if (regex.test(a.line)) {
                                        a.fontSize = finalArray[i - 1].fontSize;
                                    }
                                    if (/\w+\*+$/.test(a.line) && !(/^\d/.test(a.line))) {
                                        a['mayBeSuperScript'] = true;
                                        let index = a.line.indexOf("*");
                                        let stars = a.line.substring(index, a.line.length);
                                        suprScript.push(stars);
                                    }
                                    if (/\.+\∗+$/.test(a.line)) {
                                        a['mayBeSuperScript'] = true;
                                        let index = a.line.indexOf("∗");
                                        let stars = a.line.substring(index, a.line.length);
                                        suprScript.push(stars);
                                        stars = stars.replace(/\∗+/, "*");
                                        a.line = a.line.replace(/\∗+/, "*");
                                    }
                                    //Range of Partition
                                    // if(a.fromCenter==0 || b.fromCenter==0)
                                    //     partition=false
                                    // let last;
                                    // if(i!=0){
                                    //     last= finalArray[i - 1];
                                    // }
                                    if (aFontSize >= bFontSize && a.lineright > b.left) {
                                        percentSizeDiff = (bFontSize / aFontSize) * 100;
                                    }
                                    if (aFontSize <= bFontSize && a.lineright > b.left) {
                                        percentSizeDiff = (aFontSize / bFontSize) * 100;
                                    }
                                    if (Number(b.top) > Number(a.top)) {
                                        if (Number(a.top) > (Number(b.top) - Number(b.fontSize)) - Number('0.4') && percentSizeDiff >= precCompVal || (allCon)) {
                                            // if (lines.length > 0) {
                                            //     lines[lines.length - 1].text = lines[lines.length - 1].text + ' ' + b.text;
                                            //     lines[lines.length - 1].line = lines[lines.length - 1].line + ' ' + b.line;
                                            //     lines[lines.length - 1].width = lines[lines.length - 1].width + b.width;
                                            //     lines[lines.length - 1].lineright = b.lineright;
                                            //     //   tablesData[i+1]['marked']=true;
                                            // } else {
                                            lines.push(a);
                                            // }
                                        }
                                        else {
                                            lines.push(a);
                                            if (lines.length > 0) {
                                                rightIndex = -1;
                                                leftIndex = -1;
                                                for (let i = 0; i < lines.length - 1; i++) {
                                                    if (i != (lines.length - 1) && Math.abs(lines[i].lineright - lines[i + 1].lineleft) > space && lines[i].lineright < pageCenter && lines[i + 1].lineleft > pageCenter) {
                                                        partition = true;
                                                    }
                                                    else if (i == 0 && lines[i].lineleft > pageCenter) {
                                                        partition = true;
                                                    }
                                                }
                                                for (let index = 0; index < lines.length; index++) {
                                                    if ((lines[index].lineleft > pageCenter) && (partition)) {
                                                        if (rightIndex == -1) {
                                                            rightIndex = index;
                                                        }
                                                        if (rightIndex != index) {
                                                            lines[rightIndex]['text'] = lines[rightIndex]['text'] + " " + lines[index]['text'];
                                                            //lines[rightIndex]['line'] = lines[rightIndex]['line'] + " " + lines[index]['line'];
                                                            lines[rightIndex]['tagline'] = lines[rightIndex]['tagline'] + " " + lines[index]['tagline'];
                                                            lines[rightIndex]['tagline'] = lines[rightIndex]['tagline'].replace(/  /, " ");
                                                            lines[rightIndex]['lastword_concat'] = false;
                                                        }
                                                        if (rightIndex != -1 && isType && !util_1.isNullOrUndefined(fotLines.output) && fotLines.output != "") {
                                                            previousLine = util_1.isNullOrUndefined(rightLines[rightLines.length - 1]) ? 0 : rightLines[rightLines.length - 1];
                                                            preObj = yield self.addFotNoteAndSuperScript(lines[rightIndex], lines[index], JSON.parse(fotLines.output), previousLine, "superscript", superScript, type);
                                                            lines[rightIndex] = preObj['a'];
                                                            superScript = preObj['superScript'];
                                                        }
                                                        else {
                                                            if (!util_1.isNullOrUndefined(lines[rightIndex]['lastword_concat']) && lines[rightIndex]['lastword_concat'] == false)
                                                                lines[rightIndex]['line'] = lines[rightIndex]['line'] + " " + lines[index]['line'];
                                                        }
                                                        lines[rightIndex]['lineright'] = lines[index]['lineright'];
                                                        if (Number(lines[index]['lineright']) > Number(lines[index]['pageWidth']) && lines.length > 1) {
                                                            lines[rightIndex]['lineright'] = lines[index]['lineleft'] + 2;
                                                        }
                                                        if (lines[rightIndex]['RealfontSize'] == undefined) {
                                                            lines[rightIndex]['RealfontSize'] = lines[rightIndex]['fontSize'];
                                                        }
                                                        if (lines[rightIndex]['fontSize'] < lines[index]['fontSize']) {
                                                            lines[rightIndex]['fontSize'] = lines[index]['fontSize'];
                                                        }
                                                    }
                                                    else {
                                                        if (leftIndex == -1) {
                                                            leftIndex = index;
                                                        }
                                                        if (leftIndex != index) {
                                                            lines[leftIndex]['text'] = lines[leftIndex]['text'] + " " + lines[index]['text'];
                                                            //lines[leftIndex]['line'] = lines[leftIndex]['line'] + " " + lines[index]['line'];
                                                            lines[leftIndex]['tagline'] = lines[leftIndex]['tagline'] + " " + lines[index]['tagline'];
                                                            lines[leftIndex]['tagline'] = lines[leftIndex]['tagline'].replace(/  /, " ");
                                                            lines[leftIndex]['lastword_concat'] = false;
                                                        }
                                                        if (leftIndex != -1 && isType && !util_1.isNullOrUndefined(fotLines.output) && fotLines.output != "") {
                                                            previousLine = util_1.isNullOrUndefined(TableArray[TableArray.length - 1]) ? 0 : TableArray[TableArray.length - 1];
                                                            preObj = yield self.addFotNoteAndSuperScript(lines[leftIndex], lines[index], JSON.parse(fotLines.output), previousLine, "superscript", superScript, type);
                                                            lines[leftIndex] = preObj['a'];
                                                            superScript = preObj['superScript'];
                                                        }
                                                        else {
                                                            if (!util_1.isNullOrUndefined(lines[leftIndex]['lastword_concat']) && lines[leftIndex]['lastword_concat'] == false)
                                                                lines[leftIndex]['line'] = lines[leftIndex]['line'] + " " + lines[index]['line'];
                                                        }
                                                        lines[leftIndex]['lineright'] = lines[index]['lineright'];
                                                        if (Number(lines[index]['lineright']) > Number(lines[index]['pageWidth']) && lines.length > 1) {
                                                            lines[leftIndex]['lineright'] = lines[index]['lineleft'] + 2;
                                                        }
                                                        if (lines[leftIndex]['RealfontSize'] == undefined) {
                                                            lines[leftIndex]['RealfontSize'] = lines[leftIndex]['fontSize'];
                                                        }
                                                        if (lines[leftIndex]['fontSize'] < lines[index]['fontSize']) {
                                                            lines[leftIndex]['fontSize'] = lines[index]['fontSize'];
                                                        }
                                                    }
                                                }
                                                if (isType && leftIndex != -1) {
                                                    previousLine = util_1.isNullOrUndefined(leftLines[leftLines.length - 1]) ? null : leftLines[leftLines.length - 1];
                                                    temp = leftIndex;
                                                    if (!util_1.isNullOrUndefined(superScript) && superScript.length > 0) {
                                                        for (let r = 0; r < superScript.length; r++) {
                                                            let k = superScript[r].split("_");
                                                            if (Number(k[1]) == Number(lines[temp]['pageId']) && (k[0] == a['line'] || (!util_1.isNullOrUndefined(lines[temp]['isSuperScript']) && lines[temp]['isSuperScript']))) {
                                                                isSupMatch = true;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    if (!util_1.isNullOrUndefined(previousLine) && Number(previousLine['fontSize']) > Number(lines[temp]['fontSize']) && Number(previousLine['top']) - Number(lines[temp]['top']) < 11 && (!isNaN(Number(lines[temp]['line'])) || regexMatch.test(lines[temp]['line'])) && lines[temp]['line'].split(" ").length == 1 && !isSupMatch) {
                                                        lines[temp]['isSuperScript'] = true;
                                                        lines[temp]['line'] = "<sp:" + lines[temp]['line'] + '>';
                                                        lines[temp]['tagline'] = "<sp:" + lines[temp]['tagline'] + '>';
                                                        let isSupTxt = this.superScriptNumber(lines[temp]['line']);
                                                        superScript.push(isSupTxt + "_" + lines[temp]['pageId']);
                                                        console.log("a['line'] --U-- ", lines[temp]['line']);
                                                        //return {"a" : a, "superScript" : superScript};
                                                    }
                                                }
                                                if (leftIndex != -1 && lines[leftIndex].top < 100)
                                                    endLines.push(lines[leftIndex]);
                                                else if (leftIndex != -1 && partition)
                                                    leftLines.push(lines[leftIndex]);
                                                else if (leftIndex != -1 && partition == false && rightLines.length == 0)
                                                    TableArray.push(lines[leftIndex]);
                                                else if (leftIndex != -1 && partition == false && leftLines.length == 0)
                                                    TableArray.push(lines[leftIndex]);
                                                else if (leftIndex != -1 && partition == false && rightLines.length != 0)
                                                    if ((lines[leftIndex].fontName == leftLines[leftLines.length - 1].fontName) && (lines[leftIndex].fontSize == leftLines[leftLines.length - 1].fontSize) && (Math.floor(lines[leftIndex].Height) == Math.floor(leftLines[leftLines.length - 1].Height))) {
                                                        leftLines.push(lines[leftIndex]);
                                                    }
                                                    else {
                                                        endLines.push(lines[leftIndex]);
                                                    }
                                                // if(isleft){
                                                //     if(rightLines.length>0)
                                                //     {
                                                //         if(rightLines[rightLines.length-1].fontSize!=lines[0].fontSize || rightLines[rightLines.length-1].fontName!=lines[0].fontName || rightLines[rightLines.length-1].height!=lines[0].height && TableArray[TableArray.length-1].lineleft!=lines[0].lineleft)
                                                //         {
                                                //             endLines.push(lines[0])
                                                //         }
                                                //         else
                                                //         {
                                                //             TableArray.push(lines[0]);
                                                //         }
                                                //     }
                                                //     else
                                                //     TableArray.push(lines[0]);
                                                // }
                                                // try{
                                                if (rightIndex != -1) {
                                                    if (isType) {
                                                        previousLine = util_1.isNullOrUndefined(rightLines[rightLines.length - 1]) ? null : rightLines[rightLines.length - 1];
                                                        temp = rightIndex;
                                                        if (!util_1.isNullOrUndefined(superScript) && superScript.length > 0) {
                                                            for (let r = 0; r < superScript.length; r++) {
                                                                let k = superScript[r].split("_");
                                                                if (Number(k[1]) == Number(lines[temp]['pageId']) && (k[0] == a['line'] || (!util_1.isNullOrUndefined(lines[temp]['isSuperScript']) && lines[temp]['isSuperScript']))) {
                                                                    isSupMatch = true;
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                        if (!util_1.isNullOrUndefined(previousLine) && Number(previousLine['fontSize']) > Number(lines[temp]['fontSize']) && Number(previousLine['top']) - Number(lines[temp]['top']) < 11 && (!isNaN(Number(lines[temp]['line'])) || regexMatch.test(lines[temp]['line'])) && lines[temp]['line'].split(" ").length == 1 && !isSupMatch) {
                                                            lines[temp]['isSuperScript'] = true;
                                                            lines[temp]['line'] = "<sp:" + lines[temp]['line'] + '>';
                                                            lines[temp]['tagline'] = "<sp:" + lines[temp]['tagline'] + '>';
                                                            let isSupTxt = this.superScriptNumber(lines[temp]['line']);
                                                            superScript.push(isSupTxt + "_" + lines[temp]['pageId']);
                                                            console.log("a['line'] --Y-- ", lines[temp]['line']);
                                                            //return {"a" : a, "superScript" : superScript};
                                                        }
                                                    }
                                                    rightLines.push(lines[rightIndex]);
                                                }
                                                // }
                                                // catch(err){
                                                //     console.log(err)
                                                // }
                                                lines = [];
                                                partition = false;
                                            }
                                        }
                                        topEqual = false;
                                    }
                                    else if (Number(a.top) > Number(b.top)) {
                                        if (Number(b.top) > (Number(a.top) - Number(a.fontSize)) - Number('0.4') && percentSizeDiff >= precCompVal) {
                                            if (topEqual && a.left > b.left) {
                                                lines.push(a);
                                                if (lines.length > 0) {
                                                    rightIndex = -1;
                                                    leftIndex = -1;
                                                    for (let i = 0; i < lines.length - 1; i++) {
                                                        if (i != (lines.length - 1) && Math.abs(lines[i].lineright - lines[i + 1].lineleft) > space && lines[i].lineright < pageCenter && lines[i + 1].lineleft > pageCenter) {
                                                            partition = true;
                                                        }
                                                        else if (i == 0 && lines[i].lineleft > pageCenter) {
                                                            partition = true;
                                                        }
                                                    }
                                                    for (let index = 0; index < lines.length; index++) {
                                                        if ((lines[index].lineleft > pageCenter) && (partition)) {
                                                            if (rightIndex == -1) {
                                                                rightIndex = index;
                                                            }
                                                            if (rightIndex != index) {
                                                                lines[rightIndex]['text'] = lines[rightIndex]['text'] + " " + lines[index]['text'];
                                                                //lines[rightIndex]['line'] = lines[rightIndex]['line'] + " " + lines[index]['line'];
                                                                lines[rightIndex]['tagline'] = lines[rightIndex]['tagline'] + " " + lines[index]['tagline'];
                                                                lines[rightIndex]['tagline'] = lines[rightIndex]['tagline'].replace(/  /, " ");
                                                                lines[rightIndex]['lastword_concat'] = false;
                                                            }
                                                            if (rightIndex != -1 && isType && !util_1.isNullOrUndefined(fotLines.output) && fotLines.output != "") {
                                                                previousLine = util_1.isNullOrUndefined(rightLines[rightLines.length - 1]) ? 0 : rightLines[rightLines.length - 1];
                                                                preObj = yield self.addFotNoteAndSuperScript(lines[rightIndex], lines[index], JSON.parse(fotLines.output), previousLine, "superscript", superScript, type);
                                                                lines[rightIndex] = preObj['a'];
                                                                superScript = preObj['superScript'];
                                                            }
                                                            else {
                                                                if (!util_1.isNullOrUndefined(lines[rightIndex]['lastword_concat']) && lines[rightIndex]['lastword_concat'] == false)
                                                                    lines[rightIndex]['line'] = lines[rightIndex]['line'] + " " + lines[index]['line'];
                                                            }
                                                            lines[rightIndex]['lineright'] = lines[index]['lineright'];
                                                            if (Number(lines[index]['lineright']) > Number(lines[index]['pageWidth']) && lines.length > 1) {
                                                                lines[rightIndex]['lineright'] = lines[index]['lineleft'] + 2;
                                                            }
                                                            if (lines[rightIndex]['RealfontSize'] == undefined) {
                                                                lines[rightIndex]['RealfontSize'] = lines[rightIndex]['fontSize'];
                                                            }
                                                            if (lines[rightIndex]['fontSize'] < lines[index]['fontSize']) {
                                                                lines[rightIndex]['fontSize'] = lines[index]['fontSize'];
                                                            }
                                                        }
                                                        else {
                                                            if (leftIndex == -1) {
                                                                leftIndex = index;
                                                            }
                                                            if (leftIndex != index) {
                                                                lines[leftIndex]['text'] = lines[leftIndex]['text'] + " " + lines[index]['text'];
                                                                //lines[leftIndex]['line'] = lines[leftIndex]['line'] + " " + lines[index]['line'];
                                                                lines[leftIndex]['tagline'] = lines[leftIndex]['tagline'] + " " + lines[index]['tagline'];
                                                                lines[leftIndex]['tagline'] = lines[leftIndex]['tagline'].replace(/  /, " ");
                                                                lines[leftIndex]['lastword_concat'] = false;
                                                            }
                                                            if (leftIndex != -1 && isType && !util_1.isNullOrUndefined(fotLines.output) && fotLines.output != "") {
                                                                previousLine = util_1.isNullOrUndefined(TableArray[TableArray.length - 1]) ? 0 : TableArray[TableArray.length - 1];
                                                                preObj = yield self.addFotNoteAndSuperScript(lines[leftIndex], lines[index], JSON.parse(fotLines.output), previousLine, "superscript", superScript, type);
                                                                lines[leftIndex] = preObj['a'];
                                                                superScript = preObj['superScript'];
                                                            }
                                                            else {
                                                                if (!util_1.isNullOrUndefined(lines[leftIndex]['lastword_concat']) && lines[leftIndex]['lastword_concat'] == false)
                                                                    lines[leftIndex]['line'] = lines[leftIndex]['line'] + " " + lines[index]['line'];
                                                            }
                                                            lines[leftIndex]['lineright'] = lines[index]['lineright'];
                                                            if (Number(lines[index]['lineright']) > Number(lines[index]['pageWidth']) && lines.length > 1) {
                                                                lines[leftIndex]['lineright'] = lines[index]['lineleft'] + 2;
                                                            }
                                                            if (lines[leftIndex]['RealfontSize'] == undefined) {
                                                                lines[leftIndex]['RealfontSize'] = lines[leftIndex]['fontSize'];
                                                            }
                                                            if (lines[leftIndex]['fontSize'] < lines[index]['fontSize']) {
                                                                lines[leftIndex]['fontSize'] = lines[index]['fontSize'];
                                                            }
                                                        }
                                                    }
                                                    if (isType && leftIndex != -1) {
                                                        previousLine = util_1.isNullOrUndefined(leftLines[leftLines.length - 1]) ? null : leftLines[leftLines.length - 1];
                                                        temp = leftIndex;
                                                        if (!util_1.isNullOrUndefined(superScript) && superScript.length > 0) {
                                                            for (let r = 0; r < superScript.length; r++) {
                                                                let k = superScript[r].split("_");
                                                                if (Number(k[1]) == Number(lines[temp]['pageId']) && (k[0] == a['line'] || (!util_1.isNullOrUndefined(lines[temp]['isSuperScript']) && lines[temp]['isSuperScript']))) {
                                                                    isSupMatch = true;
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                        if (!util_1.isNullOrUndefined(previousLine) && Number(previousLine['fontSize']) > Number(lines[temp]['fontSize']) && Number(previousLine['top']) - Number(lines[temp]['top']) < 11 && (!isNaN(Number(lines[temp]['line'])) || regexMatch.test(lines[temp]['line'])) && lines[temp]['line'].split(" ").length == 1 && !isSupMatch) {
                                                            lines[temp]['isSuperScript'] = true;
                                                            lines[temp]['line'] = "<sp:" + lines[temp]['line'] + '>';
                                                            lines[temp]['tagline'] = "<sp:" + lines[temp]['tagline'] + '>';
                                                            let isSupTxt = this.superScriptNumber(lines[temp]['line']);
                                                            superScript.push(isSupTxt + "_" + lines[temp]['pageId']);
                                                            console.log("a['line'] --O-- ", lines[temp]['line']);
                                                            //return {"a" : a, "superScript" : superScript};
                                                        }
                                                    }
                                                    if (leftIndex != -1 && lines[leftIndex].top < 100)
                                                        endLines.push(lines[leftIndex]);
                                                    else if (leftIndex != -1 && partition)
                                                        leftLines.push(lines[leftIndex]);
                                                    else if (leftIndex != -1 && partition == false && rightLines.length == 0)
                                                        TableArray.push(lines[leftIndex]);
                                                    else if (leftIndex != -1 && partition == false && leftLines.length == 0)
                                                        TableArray.push(lines[leftIndex]);
                                                    else if (leftIndex != -1 && partition == false && rightLines.length != 0)
                                                        if ((lines[leftIndex].fontName == leftLines[leftLines.length - 1].fontName) && (lines[leftIndex].fontSize == leftLines[leftLines.length - 1].fontSize) && (Math.floor(lines[leftIndex].Height) == Math.floor(leftLines[leftLines.length - 1].Height))) {
                                                            leftLines.push(lines[leftIndex]);
                                                        }
                                                        else {
                                                            endLines.push(lines[leftIndex]);
                                                        }
                                                    if (rightIndex != -1) {
                                                        if (isType) {
                                                            previousLine = util_1.isNullOrUndefined(rightLines[rightLines.length - 1]) ? null : rightLines[rightLines.length - 1];
                                                            temp = rightIndex;
                                                            if (!util_1.isNullOrUndefined(superScript) && superScript.length > 0) {
                                                                for (let r = 0; r < superScript.length; r++) {
                                                                    let k = superScript[r].split("_");
                                                                    if (Number(k[1]) == Number(lines[temp]['pageId']) && (k[0] == a['line'] || (!util_1.isNullOrUndefined(lines[temp]['isSuperScript']) && lines[temp]['isSuperScript']))) {
                                                                        isSupMatch = true;
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                            if (!util_1.isNullOrUndefined(previousLine) && Number(previousLine['fontSize']) > Number(lines[temp]['fontSize']) && Number(previousLine['top']) - Number(lines[temp]['top']) < 11 && (!isNaN(Number(lines[temp]['line'])) || regexMatch.test(lines[temp]['line'])) && lines[temp]['line'].split(" ").length == 1 && !isSupMatch) {
                                                                lines[temp]['isSuperScript'] = true;
                                                                lines[temp]['line'] = "<sp:" + lines[temp]['line'] + '>';
                                                                lines[temp]['tagline'] = "<sp:" + lines[temp]['tagline'] + '>';
                                                                let isSupTxt = this.superScriptNumber(lines[temp]['line']);
                                                                superScript.push(isSupTxt + "_" + lines[temp]['pageId']);
                                                                console.log("a['line'] --P-- ", lines[temp]['line']);
                                                                //return {"a" : a, "superScript" : superScript};
                                                            }
                                                        }
                                                        rightLines.push(lines[rightIndex]);
                                                    }
                                                    lines = [];
                                                    partition = false;
                                                }
                                            }
                                            else {
                                                lines.push(a);
                                            }
                                        }
                                        else {
                                            lines.push(a);
                                            if (lines.length > 0) {
                                                rightIndex = -1;
                                                leftIndex = -1;
                                                for (let i = 0; i < lines.length - 1; i++) {
                                                    if (i != (lines.length - 1) && Math.abs(lines[i].lineright - lines[i + 1].lineleft) > space && lines[i].lineright < pageCenter && lines[i + 1].lineleft > pageCenter) {
                                                        partition = true;
                                                    }
                                                    else if (i == 0 && lines[i].lineleft > pageCenter) {
                                                        partition = true;
                                                    }
                                                }
                                                for (let index = 0; index < lines.length; index++) {
                                                    if ((lines[index].lineleft > pageCenter) && (partition)) {
                                                        if (rightIndex == -1) {
                                                            rightIndex = index;
                                                        }
                                                        if (rightIndex != index) {
                                                            lines[rightIndex]['text'] = lines[rightIndex]['text'] + " " + lines[index]['text'];
                                                            //lines[rightIndex]['line'] = lines[rightIndex]['line'] + " " + lines[index]['line'];
                                                            lines[rightIndex]['tagline'] = lines[rightIndex]['tagline'] + " " + lines[index]['tagline'];
                                                            lines[rightIndex]['tagline'] = lines[rightIndex]['tagline'].replace(/  /, " ");
                                                            lines[rightIndex]['lastword_concat'] = false;
                                                        }
                                                        if (rightIndex != -1 && isType && !util_1.isNullOrUndefined(fotLines.output) && fotLines.output != "") {
                                                            previousLine = util_1.isNullOrUndefined(rightLines[rightLines.length - 1]) ? 0 : rightLines[rightLines.length - 1];
                                                            preObj = yield self.addFotNoteAndSuperScript(lines[rightIndex], lines[index], JSON.parse(fotLines.output), previousLine, "superscript", superScript, type);
                                                            lines[rightIndex] = preObj['a'];
                                                            superScript = preObj['superScript'];
                                                        }
                                                        else {
                                                            if (!util_1.isNullOrUndefined(lines[rightIndex]['lastword_concat']) && lines[rightIndex]['lastword_concat'] == false)
                                                                lines[rightIndex]['line'] = lines[rightIndex]['line'] + " " + lines[index]['line'];
                                                        }
                                                        lines[rightIndex]['lineright'] = lines[index]['lineright'];
                                                        if (Number(lines[index]['lineright']) > Number(lines[index]['pageWidth']) && lines.length > 1) {
                                                            lines[rightIndex]['lineright'] = lines[index]['lineleft'] + 2;
                                                        }
                                                        if (lines[rightIndex]['RealfontSize'] == undefined) {
                                                            lines[rightIndex]['RealfontSize'] = lines[rightIndex]['fontSize'];
                                                        }
                                                        if (lines[rightIndex]['fontSize'] < lines[index]['fontSize']) {
                                                            lines[rightIndex]['fontSize'] = lines[index]['fontSize'];
                                                        }
                                                    }
                                                    else {
                                                        if (leftIndex == -1) {
                                                            leftIndex = index;
                                                        }
                                                        if (leftIndex != index) {
                                                            lines[leftIndex]['text'] = lines[leftIndex]['text'] + " " + lines[index]['text'];
                                                            //lines[leftIndex]['line'] = lines[leftIndex]['line'] + " " + lines[index]['line'];
                                                            lines[leftIndex]['tagline'] = lines[leftIndex]['tagline'] + " " + lines[index]['tagline'];
                                                            lines[leftIndex]['tagline'] = lines[leftIndex]['tagline'].replace(/  /, " ");
                                                            lines[leftIndex]['lastword_concat'] = false;
                                                        }
                                                        if (leftIndex != -1 && isType && !util_1.isNullOrUndefined(fotLines.output) && fotLines.output != "") {
                                                            previousLine = util_1.isNullOrUndefined(TableArray[TableArray.length - 1]) ? 0 : TableArray[TableArray.length - 1];
                                                            preObj = yield self.addFotNoteAndSuperScript(lines[leftIndex], lines[index], JSON.parse(fotLines.output), previousLine, "superscript", superScript, type);
                                                            lines[leftIndex] = preObj['a'];
                                                            superScript = preObj['superScript'];
                                                        }
                                                        else {
                                                            if (!util_1.isNullOrUndefined(lines[leftIndex]['lastword_concat']) && lines[leftIndex]['lastword_concat'] == false)
                                                                lines[leftIndex]['line'] = lines[leftIndex]['line'] + " " + lines[index]['line'];
                                                        }
                                                        lines[leftIndex]['lineright'] = lines[index]['lineright'];
                                                        if (Number(lines[index]['lineright']) > Number(lines[index]['pageWidth']) && lines.length > 1) {
                                                            lines[leftIndex]['lineright'] = lines[index]['lineleft'] + 2;
                                                        }
                                                        if (lines[leftIndex]['RealfontSize'] == undefined) {
                                                            lines[leftIndex]['RealfontSize'] = lines[leftIndex]['fontSize'];
                                                        }
                                                        if (lines[leftIndex]['fontSize'] < lines[index]['fontSize']) {
                                                            lines[leftIndex]['fontSize'] = lines[index]['fontSize'];
                                                        }
                                                    }
                                                }
                                                if (isType && leftIndex != -1) {
                                                    previousLine = util_1.isNullOrUndefined(leftLines[leftLines.length - 1]) ? null : leftLines[leftLines.length - 1];
                                                    temp = leftIndex;
                                                    if (!util_1.isNullOrUndefined(superScript) && superScript.length > 0) {
                                                        for (let r = 0; r < superScript.length; r++) {
                                                            let k = superScript[r].split("_");
                                                            if (Number(k[1]) == Number(lines[temp]['pageId']) && (k[0] == a['line'] || (!util_1.isNullOrUndefined(lines[temp]['isSuperScript']) && lines[temp]['isSuperScript']))) {
                                                                isSupMatch = true;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    if (!util_1.isNullOrUndefined(previousLine) && Number(previousLine['fontSize']) > Number(lines[temp]['fontSize']) && Number(previousLine['top']) - Number(lines[temp]['top']) < 11 && (!isNaN(Number(lines[temp]['line'])) || regexMatch.test(lines[temp]['line'])) && lines[temp]['line'].split(" ").length == 1 && !isSupMatch) {
                                                        lines[temp]['isSuperScript'] = true;
                                                        lines[temp]['line'] = "<sp:" + lines[temp]['line'] + '>';
                                                        lines[temp]['tagline'] = "<sp:" + lines[temp]['tagline'] + '>';
                                                        let isSupTxt = this.superScriptNumber(lines[temp]['line']);
                                                        superScript.push(isSupTxt + "_" + lines[temp]['pageId']);
                                                        console.log("a['line'] --W-- ", lines[temp]['line']);
                                                        //return {"a" : a, "superScript" : superScript};
                                                    }
                                                }
                                                if (leftIndex != -1 && lines[leftIndex].top < 100)
                                                    endLines.push(lines[leftIndex]);
                                                else if (leftIndex != -1 && partition)
                                                    leftLines.push(lines[leftIndex]);
                                                else if (leftIndex != -1 && partition == false && rightLines.length == 0)
                                                    TableArray.push(lines[leftIndex]);
                                                else if (leftIndex != -1 && partition == false && leftLines.length == 0)
                                                    TableArray.push(lines[leftIndex]);
                                                else if (leftIndex != -1 && partition == false && rightLines.length != 0)
                                                    if ((lines[leftIndex].fontName == leftLines[leftLines.length - 1].fontName) && (lines[leftIndex].fontSize == leftLines[leftLines.length - 1].fontSize) && (Math.floor(lines[leftIndex].Height) == Math.floor(leftLines[leftLines.length - 1].Height))) {
                                                        leftLines.push(lines[leftIndex]);
                                                    }
                                                    else {
                                                        endLines.push(lines[leftIndex]);
                                                    }
                                                if (rightIndex != -1) {
                                                    if (isType) {
                                                        previousLine = util_1.isNullOrUndefined(rightLines[rightLines.length - 1]) ? null : rightLines[rightLines.length - 1];
                                                        temp = rightIndex;
                                                        if (!util_1.isNullOrUndefined(superScript) && superScript.length > 0) {
                                                            for (let r = 0; r < superScript.length; r++) {
                                                                let k = superScript[r].split("_");
                                                                if (Number(k[1]) == Number(lines[temp]['pageId']) && (k[0] == a['line'] || (!util_1.isNullOrUndefined(lines[temp]['isSuperScript']) && lines[temp]['isSuperScript']))) {
                                                                    isSupMatch = true;
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                        if (!util_1.isNullOrUndefined(previousLine) && Number(previousLine['fontSize']) > Number(lines[temp]['fontSize']) && Number(previousLine['top']) - Number(lines[temp]['top']) < 11 && (!isNaN(Number(lines[temp]['line'])) || regexMatch.test(lines[temp]['line'])) && lines[temp]['line'].split(" ").length == 1 && !isSupMatch) {
                                                            lines[temp]['isSuperScript'] = true;
                                                            lines[temp]['line'] = "<sp:" + lines[temp]['line'] + '>';
                                                            lines[temp]['tagline'] = "<sp:" + lines[temp]['tagline'] + '>';
                                                            let isSupTxt = this.superScriptNumber(lines[temp]['line']);
                                                            superScript.push(isSupTxt + "_" + lines[temp]['pageId']);
                                                            console.log("a['line'] --Q-- ", lines[temp]['line']);
                                                            //return {"a" : a, "superScript" : superScript};
                                                        }
                                                    }
                                                    rightLines.push(lines[rightIndex]);
                                                }
                                                lines = [];
                                                partition = false;
                                            }
                                        }
                                        topEqual = false;
                                    }
                                    else if (Math.round(a.top) == Math.round(b.top)) {
                                        topEqual = true;
                                        if (lines.length > 0 && Math.round(lines[lines.length - 1]['top']) != Math.round(a.top) &&
                                            (lines[lines.length - 1]['top'] - lines[lines.length - 1]['fontSize']) > a.top) {
                                            rightIndex = -1;
                                            leftIndex = -1;
                                            for (let i = 0; i < lines.length - 1; i++) {
                                                if (i != (lines.length - 1) && Math.abs(lines[i].lineright - lines[i + 1].lineleft) > space && lines[i].lineright < pageCenter && lines[i + 1].lineleft > pageCenter) {
                                                    partition = true;
                                                }
                                                else if (i == 0 && lines[i].lineleft > pageCenter) {
                                                    partition = true;
                                                }
                                            }
                                            for (let index = 0; index < lines.length; index++) {
                                                if ((lines[index].lineleft > pageCenter) && (partition)) {
                                                    if (rightIndex == -1) {
                                                        rightIndex = index;
                                                    }
                                                    if (rightIndex != index) {
                                                        lines[rightIndex]['text'] = lines[rightIndex]['text'] + " " + lines[index]['text'];
                                                        //lines[rightIndex]['line'] = lines[rightIndex]['line'] + " " + lines[index]['line'];
                                                        lines[rightIndex]['tagline'] = lines[rightIndex]['tagline'] + " " + lines[index]['tagline'];
                                                        lines[rightIndex]['tagline'] = lines[rightIndex]['tagline'].replace(/  /, " ");
                                                        lines[rightIndex]['lastword_concat'] = false;
                                                    }
                                                    if (rightIndex != -1 && isType && !util_1.isNullOrUndefined(fotLines.output) && fotLines.output != "") {
                                                        previousLine = util_1.isNullOrUndefined(rightLines[rightLines.length - 1]) ? 0 : rightLines[rightLines.length - 1];
                                                        preObj = yield self.addFotNoteAndSuperScript(lines[rightIndex], lines[index], JSON.parse(fotLines.output), previousLine, "superscript", superScript, type);
                                                        lines[rightIndex] = preObj['a'];
                                                        superScript = preObj['superScript'];
                                                    }
                                                    else {
                                                        if (!util_1.isNullOrUndefined(lines[rightIndex]['lastword_concat']) && lines[rightIndex]['lastword_concat'] == false)
                                                            lines[rightIndex]['line'] = lines[rightIndex]['line'] + " " + lines[index]['line'];
                                                    }
                                                    lines[rightIndex]['lineright'] = lines[index]['lineright'];
                                                    if (Number(lines[index]['lineright']) > Number(lines[index]['pageWidth']) && lines.length > 1) {
                                                        lines[rightIndex]['lineright'] = lines[index]['lineleft'] + 2;
                                                    }
                                                    if (lines[rightIndex]['RealfontSize'] == undefined) {
                                                        lines[rightIndex]['RealfontSize'] = lines[rightIndex]['fontSize'];
                                                    }
                                                    if (lines[rightIndex]['fontSize'] < lines[index]['fontSize']) {
                                                        lines[rightIndex]['fontSize'] = lines[index]['fontSize'];
                                                    }
                                                }
                                                else {
                                                    if (leftIndex == -1) {
                                                        leftIndex = index;
                                                    }
                                                    if (leftIndex != index) {
                                                        lines[leftIndex]['text'] = lines[leftIndex]['text'] + " " + lines[index]['text'];
                                                        //lines[leftIndex]['line'] = lines[leftIndex]['line'] + " " + lines[index]['line'];
                                                        lines[leftIndex]['tagline'] = lines[leftIndex]['tagline'] + " " + lines[index]['tagline'];
                                                        lines[leftIndex]['tagline'] = lines[leftIndex]['tagline'].replace(/  /, " ");
                                                        lines[leftIndex]['lastword_concat'] = false;
                                                    }
                                                    if (leftIndex != -1 && isType && !util_1.isNullOrUndefined(fotLines.output) && fotLines.output != "") {
                                                        previousLine = util_1.isNullOrUndefined(TableArray[TableArray.length - 1]) ? 0 : TableArray[TableArray.length - 1];
                                                        preObj = yield self.addFotNoteAndSuperScript(lines[leftIndex], lines[index], JSON.parse(fotLines.output), previousLine, "superscript", superScript, type);
                                                        lines[leftIndex] = preObj['a'];
                                                        superScript = preObj['superScript'];
                                                    }
                                                    else {
                                                        if (!util_1.isNullOrUndefined(lines[leftIndex]['lastword_concat']) && lines[leftIndex]['lastword_concat'] == false)
                                                            lines[leftIndex]['line'] = lines[leftIndex]['line'] + " " + lines[index]['line'];
                                                    }
                                                    lines[leftIndex]['lineright'] = lines[index]['lineright'];
                                                    if (Number(lines[index]['lineright']) > Number(lines[index]['pageWidth']) && lines.length > 1) {
                                                        lines[leftIndex]['lineright'] = lines[index]['lineleft'] + 2;
                                                    }
                                                    if (lines[leftIndex]['RealfontSize'] == undefined) {
                                                        lines[leftIndex]['RealfontSize'] = lines[leftIndex]['fontSize'];
                                                    }
                                                    if (lines[leftIndex]['fontSize'] < lines[index]['fontSize']) {
                                                        lines[leftIndex]['fontSize'] = lines[index]['fontSize'];
                                                    }
                                                }
                                            }
                                            if (isType && leftIndex != -1) {
                                                previousLine = util_1.isNullOrUndefined(leftLines[leftLines.length - 1]) ? null : leftLines[leftLines.length - 1];
                                                temp = leftIndex;
                                                if (!util_1.isNullOrUndefined(superScript) && superScript.length > 0) {
                                                    for (let r = 0; r < superScript.length; r++) {
                                                        let k = superScript[r].split("_");
                                                        if (Number(k[1]) == Number(lines[temp]['pageId']) && (k[0] == a['line'] || (!util_1.isNullOrUndefined(lines[temp]['isSuperScript']) && lines[temp]['isSuperScript']))) {
                                                            isSupMatch = true;
                                                            break;
                                                        }
                                                    }
                                                }
                                                if (!util_1.isNullOrUndefined(previousLine) && Number(previousLine['fontSize']) > Number(lines[temp]['fontSize']) && Number(previousLine['top']) - Number(lines[temp]['top']) < 11 && (!isNaN(Number(lines[temp]['line'])) || regexMatch.test(lines[temp]['line'])) && lines[temp]['line'].split(" ").length == 1 && !isSupMatch) {
                                                    lines[temp]['isSuperScript'] = true;
                                                    lines[temp]['line'] = "<sp:" + lines[temp]['line'] + '>';
                                                    lines[temp]['tagline'] = "<sp:" + lines[temp]['tagline'] + '>';
                                                    let isSupTxt = this.superScriptNumber(lines[temp]['line']);
                                                    superScript.push(isSupTxt + "_" + lines[temp]['pageId']);
                                                    console.log("a['line'] --V-- ", lines[temp]['line']);
                                                    //return {"a" : a, "superScript" : superScript};
                                                }
                                            }
                                            if (leftIndex != -1 && lines[leftIndex].top < 100)
                                                endLines.push(lines[leftIndex]);
                                            else if (leftIndex != -1 && partition)
                                                leftLines.push(lines[leftIndex]);
                                            else if (leftIndex != -1 && partition == false && rightLines.length == 0)
                                                TableArray.push(lines[leftIndex]);
                                            else if (leftIndex != -1 && partition == false && leftLines.length == 0)
                                                TableArray.push(lines[leftIndex]);
                                            else if (leftIndex != -1 && partition == false && rightLines.length != 0) {
                                                if ((lines[leftIndex].fontName == leftLines[leftLines.length - 1].fontName) && (lines[leftIndex].fontSize == leftLines[leftLines.length - 1].fontSize) && (Math.floor(lines[leftIndex].Height) == Math.floor(leftLines[leftLines.length - 1].Height))) {
                                                    leftLines.push(lines[leftIndex]);
                                                }
                                                else {
                                                    endLines.push(lines[leftIndex]);
                                                }
                                            }
                                            if (rightIndex != -1) {
                                                if (isType) {
                                                    previousLine = util_1.isNullOrUndefined(rightLines[rightLines.length - 1]) ? null : rightLines[rightLines.length - 1];
                                                    temp = rightIndex;
                                                    if (!util_1.isNullOrUndefined(superScript) && superScript.length > 0) {
                                                        for (let r = 0; r < superScript.length; r++) {
                                                            let k = superScript[r].split("_");
                                                            if (Number(k[1]) == Number(lines[temp]['pageId']) && (k[0] == a['line'] || (!util_1.isNullOrUndefined(lines[temp]['isSuperScript']) && lines[temp]['isSuperScript']))) {
                                                                isSupMatch = true;
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    if (!util_1.isNullOrUndefined(previousLine) && Number(previousLine['fontSize']) > Number(lines[temp]['fontSize']) && Number(previousLine['top']) - Number(lines[temp]['top']) < 11 && (!isNaN(Number(lines[temp]['line'])) || regexMatch.test(lines[temp]['line'])) && lines[temp]['line'].split(" ").length == 1 && !isSupMatch) {
                                                        lines[temp]['isSuperScript'] = true;
                                                        lines[temp]['line'] = "<sp:" + lines[temp]['line'] + '>';
                                                        lines[temp]['tagline'] = "<sp:" + lines[temp]['tagline'] + '>';
                                                        let isSupTxt = this.superScriptNumber(lines[temp]['line']);
                                                        superScript.push(isSupTxt + "_" + lines[temp]['pageId']);
                                                        console.log("a['line'] --C-- ", lines[temp]['line']);
                                                        //return {"a" : a, "superScript" : superScript};
                                                    }
                                                }
                                                rightLines.push(lines[rightIndex]);
                                            }
                                            lines = [];
                                            partition = false;
                                            lines.push(a);
                                        }
                                        else {
                                            lines.push(a);
                                        }
                                    }
                                }
                                else {
                                    TableArray.push(finalArray[finalArray.length - 1]);
                                }
                                if (i != (finalArray.length - 1))
                                    if (finalArray[i].pageId < finalArray[i + 1].pageId) {
                                        TableArray = TableArray.concat(leftLines);
                                        TableArray = TableArray.concat(rightLines);
                                        TableArray = TableArray.concat(endLines);
                                        // console.log(TableArray.length)
                                        rightLines = [];
                                        leftLines = [];
                                        endLines = [];
                                        pageCenter = Number(finalArray[i + 1].pageWidth / 2);
                                        starting = Math.floor(pageCenter - 15);
                                        ending = Math.floor(pageCenter + 15);
                                        countCenter = new Array(Math.floor(finalArray[i + 1].pageWidth)).fill(0);
                                        for (let j = i + 1; j < (finalArray.length - 1); j++) {
                                            let left = Math.floor(finalArray[j].lineleft);
                                            let right = Math.floor(finalArray[j].lineright);
                                            if ((left >= starting && right <= ending) || (left <= starting && right >= starting) || (left <= ending && right >= ending))
                                                for (let start = left; start <= right; start++) {
                                                    if (start > (starting) && start < (ending))
                                                        countCenter[start]++;
                                                }
                                            if (finalArray[j].pageId != finalArray[j + 1].pageId)
                                                break;
                                        }
                                        for (let i = starting + 1; i < ending - 1; i++) {
                                            if (i + 1 != ending)
                                                if (countCenter[i] / countCenter[i + 1] > 2 || countCenter[i + 1] / countCenter[i] > 2) {
                                                    if (countCenter[i] > countCenter[i + 1])
                                                        pageCenter = i + 1;
                                                    else
                                                        pageCenter = i;
                                                    break;
                                                }
                                        }
                                    }
                                // console.log(TableArray)
                            }
                            TableArray = TableArray.concat(leftLines);
                            TableArray = TableArray.concat(rightLines);
                            TableArray = TableArray.concat(endLines);
                            // console.log(TableArray.length)
                            rightLines = [];
                            leftLines = [];
                            endLines = [];
                        }
                        yield this.sh("sudo chown -R " + env_2.env.fileConfig.fileUser + ":" + env_2.env.fileConfig.fileUser + " " + PDF_PATH);
                        for (let i = 0; i < TableArray.length; i++) {
                            // let isUnderlined = false;
                            // if (res1.output) {
                            //     let outputarr = res1.output.replace('[', '').replace(']', '').replace(/"/g, '').replace(/\\u2019/g, '’').replace(/\\u2018/g, '‘').split(',');
                            //     let words = outputarr.filter(function (value, index, arr) {
                            //         return /\S/.test(value);
                            //     });
                            //     words.map((word) => {
                            //         if (TableArray[i].line.toLowerCase().replace(/\s/g, '') == word.toLowerCase().replace(/\s/g, '')) {
                            //             isUnderlined = true;
                            //         }
                            //     });
                            // }
                            // TableArray[i]["underline"] = isUnderlined;
                            // let currentLine = TableArray[i]["line"];
                            // let currentTagLine = TableArray[i]["tagline"];
                            if (!isType) {
                                if (TableArray[i]["line"].includes('’’means') && TableArray[i]["bold"]) {
                                    TableArray[i]["line"] = TableArray[i]["line"].replace('’’means', '’’ means');
                                    TableArray[i]["tagline"] = TableArray[i]["tagline"].replace(' #/b$', '');
                                    TableArray[i]["tagline"] = TableArray[i]["tagline"].replace(/’’means/, '’’ #/b$ means');
                                }
                            }
                            if (input.type == "Law_Reports") {
                                if (TableArray[i]["line"].match(/\’\./)) {
                                    TableArray[i]["line"] = TableArray[i].line.replace(' \’.', '\’.');
                                }
                            }
                            TableArray[i]["lineNo"] = i;
                            if (!util_1.isNullOrUndefined(TableArray[i]) && !util_1.isNullOrUndefined(TableArray[i]["line"])) {
                                TableArray[i]["line"] = TableArray[i].line.replace(/\s+/g, ' ').trim(); //Replace multiple whitespaces with single space.....also removing first and last whitespace
                                TableArray[i]["line"] = TableArray[i].line.replace(/]$/, '@@');
                                TableArray[i]["line"] = TableArray[i].line.replace(/"/g, '#%');
                            }
                            if (!util_1.isNullOrUndefined(TableArray[i]) && !util_1.isNullOrUndefined(TableArray[i]["tagline"])) {
                                // TableArray[i]["tagline"] = TableArray[i].tagline.replace(/]$/, '@@');
                                TableArray[i]["tagline"] = TableArray[i].tagline.replace(/]$/, '@@');
                                TableArray[i]["tagline"] = TableArray[i].tagline.replace(/"/g, '#%');
                                TableArray[i]["tagline"] = TableArray[i].tagline.replace(/]$/, '@@');
                            }
                            let isCenterAligned = false;
                            let isLeftAligned = false;
                            let isRightAligned = false;
                            let rightmargin = TableArray[i]["pageWidth"] - TableArray[i]["lineright"];
                            if (Math.abs(TableArray[i]["lineleft"] - rightmargin) < 25) {
                                isCenterAligned = true;
                            }
                            let pageCenter = Math.floor(TableArray[i]["pageWidth"] / 2);
                            if (!isCenterAligned) {
                                if (TableArray[i]["lineleft"] < pageCenter) {
                                    isLeftAligned = true;
                                }
                                else {
                                    isRightAligned = true;
                                }
                            }
                            TableArray[i]["centerAligned"] = isCenterAligned;
                            TableArray[i]["leftAligned"] = isLeftAligned;
                            TableArray[i]["rightAligned"] = isRightAligned;
                        }
                        // FotNote Extraction Logic -- Start ---
                        if (isType && !util_1.isNullOrUndefined(superScript) && superScript.length > 0) {
                            // FotLines
                            fotLines = JSON.parse(JSON.stringify(fotLines));
                            console.info("FotLines--- ---- --- --- > > >>   ", fotLines);
                            fotLines = !util_1.isNullOrUndefined(fotLines) && !util_1.isNullOrUndefined(fotLines.output) && fotLines.output.length > 0 ? JSON.parse(fotLines.output) : [];
                            //FotNote Extraction Logic -- Start --- Function Called i.e addFotNoteAndSuperScript for parameter fotLines
                            let obj = !util_1.isNullOrUndefined(superScript) && superScript.length > 0 ? yield self.addFotNoteAndSuperScript(TableArray, null, fotLines, null, "fotLines", superScript, input.type) : {};
                            TableArray = !util_1.isNullOrUndefined(obj) && !util_1.isNullOrUndefined(obj['tableArray']) && obj['tableArray'].length > 1 ? obj['tableArray'] : TableArray;
                            let FoteNotes = !util_1.isNullOrUndefined(obj) && !util_1.isNullOrUndefined(obj['foteNote']) && obj['foteNote'].length > 0 ? obj['foteNote'] : [];
                            //if(FoteNotes.length==0){
                            if (input.type == "journals") {
                                let rObj = yield self.findFootNotes(TableArray, superScript, suprScript, FoteNotes, isCrep);
                                if (!util_1.isNullOrUndefined(rObj['footNotes']) && FoteNotes.length != rObj['footNotes'].length) {
                                    TableArray = rObj['TableArray'];
                                    FoteNotes = FoteNotes.concat(rObj['footNotes']);
                                    superScript = superScript.concat(superScriptWithPage);
                                    let sortArr = FoteNotes.sort((a, b) => a.pageId - b.pageId);
                                    FoteNotes = sortArr;
                                }
                            }
                            //FotNote Extraction Logic -- Start --- Function Called i.e addFotNoteAndSuperScript for parameter separateSubscript
                            TableArray = JSON.parse(JSON.stringify(yield self.addFotNoteAndSuperScript(TableArray, FoteNotes, fotLines, null, "separateSubscript", superScript, input.type)));
                            // }
                            output['FoteNotes'] = FoteNotes;
                            output['SuperScript'] = superScript;
                        }
                        output['output'] = TableArray;
                        //console.log(output['output']);
                        finalArray = [];
                    }
                    resolve({ message: "Process sucessfully completed", status: 0, data: output });
                }));
            }
            catch (err) {
                console.log("Error!!! -> " + err);
                return { message: err, status: 1, data: err };
            }
        });
    }
    parseFields(input, output, botId, projectId, iterationId) {
        try {
            let re = /\s*([^{:|^,:]+):/g;
            let objToString;
            if (!util_1.isNullOrUndefined(input.obj)) {
                objToString = JSON.stringify(input.obj);
            }
            let m;
            do {
                m = re.exec(objToString);
                if (m) {
                    objToString = objToString.replace(m[0], m[0].replace(/\./g, '_'));
                }
            } while (m);
            output['result'] = JSON.parse(objToString);
            return { message: "Process completed", status: 0, data: output };
        }
        catch (err) {
            console.log("Error!!! -> " + err);
            return { message: err, status: 1, data: err };
        }
    }
    // public async pdfParserJava(input, output, botId, projectId, iterationId) {
    //     console.log("In new pdfParserJava, FileName==" + input.PDF_PATH);
    //     try {
    //         let PDF_PATH = input.PDF_PATH;
    //         //let renamedPATH = PDF_PATH.replace(/[ !@#$%^&*()<>~{}?|]/g, '');
    //         //console.log(renamedPATH);
    //         //fs.renameSync(PDF_PATH, renamedPATH);
    //         let randomNo = Math.floor(Math.random() * 10000);
    //         let randomString = randomNo.toString();
    //         let javaJsonFolder = env.fileConfig.javaJsonFolder;
    //         javaJsonFolder = javaJsonFolder.replace("\"", "");  //"../javaJsonFolder/";
    //         if (!fs.existsSync(javaJsonFolder)) {
    //             fs.mkdirSync(javaJsonFolder);
    //         }
    //         let jsonFileName = PDF_PATH.substring(PDF_PATH.lastIndexOf('/') + 1) + ".json";
    //         let finalJsonPath = javaJsonFolder + randomString + jsonFileName;
    //         //let jsonPath = "../../../../../.." + jsonFileName;
    //         //console.log(process.cwd());
    //         //let repoRootPath = process.cwd();
    //         //let jsonPath = repoRootPath.substring(0, repoRootPath.lastIndexOf('/'));
    //         let inputObj = {
    //             "finalJsonPath": finalJsonPath,
    //             "pdfPath": PDF_PATH
    //         };
    //         let parameters = JSON.stringify(JSON.stringify(inputObj));
    //         return new Promise(async (resolve, reject) => {
    //             let res = await this.sh("java -cp .:json-20190722.jar:pdfbox-2.0.3.jar:fontbox-2.0.3.jar:commons-logging-1.2.jar:json-simple-1.1.1.jar:jbig2-imageio-3.0.0.jar:itextpdf-5.5.13.1.jar:kernel-7.1.12.jar:io-7.1.12.jar:layout-7.1.12.jar:slf4j-api-1.7.30.jar:slf4j-simple-1.7.30.jar:commons-lang3-3.11.jar GetPdfData " + parameters);
    //             if (!isNullOrUndefined(res)) {
    //                 console.log("res[status]---->>", res);
    //                 if (res['status'] == 1 && !isNullOrUndefined(res['err']) && !isNullOrUndefined(res['err']['message']) && res['err']['message'].includes('Command failed')) {
    //                     console.log("res[status]-in If  --->>", res['status']);
    //                     resolve({ message: res['err'] + PDF_PATH, status: 1, data: 'Seems some issue while reading the PDF' + PDF_PATH });
    //                 }
    //                 let finalArray
    //                 if (fs.existsSync(finalJsonPath)) {
    //                     finalArray = JSON.parse(fs.readFileSync(finalJsonPath, { encoding: 'utf8' }));
    //                 }
    //                 else {
    //                     console.log("Error while reading JSON file!")
    //                 }
    //                 finalArray = finalArray.filter(obj => obj.line.trim() != '');
    //                 output['output'] = finalArray;
    //                 resolve({ message: "Process sucessfully completed", status: 0, data: output });
    //             }
    //         });
    //     }
    //     catch (err) {
    //         console.log("Error!!! -> " + err);
    //         return { message: err, status: 1, data: err };
    //     }
    // }
    getWPText(wpObject) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let style;
            let D = {
                'Style Name': style,
                'Line': ''
            };
            if (wpObject["w:pPr"] && wpObject["w:pPr"]["w:pStyle"] && wpObject["w:pPr"]["w:pStyle"]["w:val"] && typeof wpObject["w:pPr"]["w:pStyle"]["w:val"] == 'string') {
                style = wpObject["w:pPr"]["w:pStyle"]["w:val"];
            }
            else {
                style = 'DefaultStyle';
            }
            if (wpObject["w:r"] && Array.isArray(wpObject["w:r"])) {
                let words = JSON.parse(JSON.stringify(wpObject["w:r"]));
                D = {
                    'Style Name': style,
                    'Line': ''
                };
                for (let j = 0; j < words.length; j++) {
                    if (!util_1.isNullOrUndefined(words[j]["w:t"]) && typeof words[j]["w:t"] == 'string') {
                        D['Line'] = D['Line'] + words[j]["w:t"];
                        // let D = {'Style Name' : style,
                        //         'Line' : words[j]["w:t"] }
                        if (j > 0 && !util_1.isNullOrUndefined(words[j - 1]["w:tab"])) {
                            D['Line'] = '<tab>' + D['Line'];
                        }
                        // finalArray.push(JSON.parse(JSON.stringify(D)))
                    }
                    else if (words[j]["w:t"] && typeof words[j]["w:t"] == 'object' && !util_1.isNullOrUndefined(words[j]["w:t"]["$t"]) && typeof words[j]["w:t"]["$t"] == 'string') {
                        // let D;
                        if (!util_1.isNullOrUndefined(words[j]["w:t"]["xml:space"]) && words[j]["w:t"]["xml:space"] == "preserve") {
                            // D = {'Style Name' : style,
                            //     'Line' : words[j]["w:t"]["$t"]+'<space>' }
                            D['Line'] = D['Line'] + words[j]["w:t"]["$t"] + '<space>';
                        }
                        else {
                            // D = {'Style Name' : style,
                            //     'Line' : words[j]["w:t"]["$t"] }
                            D['Line'] = D['Line'] + words[j]["w:t"]["$t"];
                        }
                        if (j > 0 && !util_1.isNullOrUndefined(words[j - 1]["w:tab"])) {
                            D['Line'] = '<tab>' + D['Line'];
                        }
                        // finalArray.push(JSON.parse(JSON.stringify(D)))
                    }
                }
                return D;
                //finalArray.push(JSON.parse(JSON.stringify(D)))
            }
            else if (wpObject["w:r"] && !util_1.isNullOrUndefined(wpObject["w:r"]["w:t"]) && typeof wpObject["w:r"]["w:t"] == 'string') {
                D = {
                    'Style Name': style,
                    'Line': wpObject["w:r"]["w:t"]
                };
                return D;
                //finalArray.push(JSON.parse(JSON.stringify(D)))
            }
            else if (wpObject["w:r"] && !util_1.isNullOrUndefined(wpObject["w:r"]["w:t"]) && !util_1.isNullOrUndefined(wpObject["w:r"]["w:t"]["$t"]) && typeof wpObject["w:r"]["w:t"]["$t"] == 'string') {
                D = {
                    'Style Name': style,
                    'Line': wpObject["w:r"]["w:t"]["$t"]
                };
                return D;
                //finalArray.push(JSON.parse(JSON.stringify(D)))
            }
            return D;
        });
    }
    getWPText2(wpObject) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let data = wpObject;
            let wpArray = [];
            // getWPText();
            if (Array.isArray(data)) {
                for (let i = 0; i < data.length; i++) {
                    let wpCurrentObject = yield this.getWPText(data[i]);
                    if (wpCurrentObject) {
                        wpArray.push(JSON.parse(JSON.stringify(wpCurrentObject)));
                    }
                }
                return wpArray;
            }
            else {
                let wpCurrentObject = yield this.getWPText(data);
                return wpCurrentObject;
            }
        });
    }
    wColumnToText(wColumn) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let columnArray = [];
            if (Array.isArray(wColumn)) {
                for (let columnNumber = 0; columnNumber < wColumn.length; columnNumber++) {
                    if (wColumn[columnNumber]['w:p']) {
                        let finalWpObject = yield this.getWPText2(wColumn[columnNumber]['w:p']);
                        if (finalWpObject) {
                            columnArray.push(JSON.parse(JSON.stringify(finalWpObject)));
                        }
                    }
                }
            }
            else {
                if (wColumn['w:p']) {
                    let finalWpObject = yield this.getWPText2(wColumn['w:p']);
                    if (finalWpObject) {
                        columnArray.push(JSON.parse(JSON.stringify(finalWpObject)));
                    }
                }
            }
            return {
                columns: columnArray
            };
        });
    }
    wRowToText(wRow) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let rowArray = [];
            let rows = [];
            let tableArray = [];
            let tableNumber;
            if (Array.isArray(wRow)) {
                for (let rowNumber = 0; rowNumber < wRow.length; rowNumber++) {
                    if (wRow[rowNumber]['w:tc']) {
                        let columns = yield this.wColumnToText(wRow[rowNumber]['w:tc']);
                        if (columns.columns.length > 0) {
                            rowArray.push(JSON.parse(JSON.stringify(columns)));
                        }
                    }
                }
            }
            else {
                if (rows['w:tc']) {
                    let columns = yield this.wColumnToText(rows['w:tc']);
                    tableArray[tableNumber].rows.push({
                        columns: []
                    });
                    if (columns.columns.length > 0) {
                        rowArray.push(JSON.parse(JSON.stringify(columns)));
                    }
                }
            }
            return {
                rows: rowArray
            };
        });
    }
    sh(cmd) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            return new Promise(function (resolve, reject) {
                exec(cmd, { maxBuffer: 1024 * 1024 * 500 }, (err, stdout, stderr) => {
                    if (err) {
                        resolve({ status: 1, err: err });
                    }
                    if (stderr !== '') {
                        resolve({ status: 1, err: stderr });
                    }
                    else {
                        resolve({ status: 0, output: stdout });
                    }
                });
            });
        });
    }
    getReferenceNumber(inputData, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            /*Generate unique reference number for each documents*/
            const crypto = require('crypto');
            try {
                if (!util_1.isNullOrUndefined(inputData.subscriberId) && !util_1.isNullOrUndefined(inputData.orgId)) {
                    console.log(JSON.stringify(inputData));
                    let tempTime = (new Date()).getTime();
                    let randomPart = Math.floor(Math.random() * 100000);
                    let subscriber = inputData.subscriberId.substring(0, 9);
                    let organisation = inputData.orgId.substring(0, 9);
                    let hashString = tempTime + subscriber + organisation + randomPart;
                    let hash = yield crypto.createHash('md5').update(hashString).digest('hex');
                    console.log("RefNo-------", 'File' + hash);
                    if (hash) {
                        outputParameters['refNo'] = 'File' + hash;
                        outputParameters['hash'] = hash;
                    }
                    return { message: "Process completed", status: 0, data: outputParameters, refNo: 'File' + hash };
                }
                else {
                    throw "Not proper Input";
                }
            }
            catch (err) {
                console.log("Error!!! -> " + err);
                return { message: err, status: 1, data: err };
            }
        });
    }
    messageExtraction(message, all, idHeader, outputParameters, bodydata, from, to, subject, htmlbody, textbody, inputData, Attachfilename, cc) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                return new Promise((res, rej) => {
                    try {
                        simpleParser(idHeader + all.body, (err, mail) => {
                            if (err) {
                                res({});
                            }
                            else {
                                console.info("MESSAGE FETCH FROM MAIL ");
                                from = mail.from.value[0].address;
                                to = mail.to.value[0].address;
                                if (!util_1.isNullOrUndefined(mail.cc)) {
                                    cc = mail.cc.value[0].address;
                                }
                                subject = mail.subject;
                                htmlbody = mail.html;
                                textbody = mail.text;
                                let mailDate = mail.date;
                                let messageId = mail.messageId;
                                bodydata.push({ 'fromMail': from, 'tomail': to, 'ccmail': cc, 'subject': subject, 'date': mailDate, 'textbody': textbody, 'htmlbody': htmlbody, "messageId": messageId });
                                outputParameters['bodydata'] = bodydata;
                                //console.info(" --- --- BODY DATA ----- -----   ",bodydata);
                                if (mail.attachments.length === 0 && mail.subject.startsWith(subject)) {
                                    inputData['outputParameters'] = { statusCode: "200", successMessage: 'File read successfull', fromMail: from, tomail: to, subject: subject, attachment_path: Attachfilename, textbody: textbody, body: textbody, htmlbody: htmlbody, "messageId": messageId };
                                    console.warn("INSIDE BODYDATA FOUND");
                                    outputParameters['subject'] = inputData['outputParameters']['subject'];
                                    outputParameters['fromMail'] = inputData['outputParameters']['from'];
                                    outputParameters['tomail'] = inputData['outputParameters']['to'];
                                    outputParameters['textbody'] = inputData['outputParameters']['textbody'].replace(/\n/g, ' ');
                                    outputParameters['htmlbody'] = inputData['outputParameters']['htmlbody'].replace(/\n/g, ' ');
                                    outputParameters['attachment_path'] = inputData['outputParameters']['attachment_path'];
                                    outputParameters['body'] = inputData['outputParameters']['body'];
                                    outputParameters['AttachFolder'] = inputData['outputParameters']['AttachFolder'];
                                    outputParameters['messageId'] = inputData['outputParameters']['messageId'];
                                    //this.socket.emit('utility_response', inputData);
                                    res(outputParameters);
                                }
                                else {
                                    res(outputParameters);
                                }
                            }
                        });
                    }
                    catch (e) {
                        res({ bodydata: bodydata ? bodydata : [] });
                    }
                });
            }
            catch (err) {
                console.error(err);
                return err;
            }
        });
    }
    fetchFileData(part, connection, message, getSub, inputData) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {};
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    let data = yield connection.getPartData(message, part);
                    if (inputData.isSubjectWise === "yes") {
                        obj = { "filename": `${getSub[0].body.subject[0].replace(/ /g, "_")}${message.attributes.uid}/${part.disposition.params.filename.replace(/ /g, "_").replace(/[(#,&*)]/g, "")}`, "data": data };
                        resolve(obj);
                    }
                    else {
                        obj = { "filename": part.disposition.params.filename, "data": data };
                        resolve(obj);
                    }
                }));
            }
            catch (err) {
                console.error("IN FETCHFILE DATA -------    ", err);
                return err;
            }
        });
    }
    matchKeyWords(regex, str) {
        const regexMatch = regex;
        let num = false;
        let m;
        while ((m = regexMatch.exec(str)) !== null) {
            // This is necessary to avoid infinite loops with zero-width matches
            if (m.index === regexMatch.lastIndex) {
                regexMatch.lastIndex++;
            }
            // The result can be accessed through the `m`-variable.
            m.forEach((match, groupIndex) => {
                //console.log(`Found match, group ${groupIndex}: ${match}`);
                if (groupIndex == 1) {
                    num = true;
                }
            });
        }
        console.log(num);
        return num;
    }
    keywordSearchForCustomerMail(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let data = input.textbody; // Text body of mail
                data = data.replace(/(\r\n|\n|\r)/gm, "");
                let keys = input.keys.split(",");
                //keys to search the text body
                let formatKey = keys.reduce((match, key) => {
                    let pos = data.indexOf(key);
                    if (pos >= 0) {
                        match.push({ search: key, index: data.indexOf(key) });
                    }
                    return match;
                }, []);
                formatKey = formatKey.sort((a, b) => a.index - b.index);
                formatKey = formatKey.reduce((final, key) => {
                    const res = formatKey.reduce((result, eachKey) => {
                        if (eachKey.search.indexOf(key.search) >= 0) {
                            result.push(eachKey);
                        }
                        return result;
                    }, []);
                    if (res.length === 1) {
                        final.push(res[0]);
                    }
                    return final;
                }, []);
                const res = formatKey.reduce((final, key, ind, totKeys) => {
                    if (key.index > -1) {
                        //let startPos = data.indexOf(">",ind) + 4
                        let startPos = key.index + key.search.length;
                        // console.log(data[startPos-1])
                        let endPos;
                        if (ind < totKeys.length - 1) {
                            endPos = data.indexOf(totKeys[ind + 1].search);
                        }
                        else {
                            endPos = data.length - 1;
                        }
                        let matchedStr = data.substring(startPos, endPos).trim();
                        //console.log(matchedStr[matchedStr.length-1] )
                        final[key.search] = matchedStr;
                    }
                    return final;
                }, {});
                let genericKey = input.regexKeys.split(",");
                let primaryKeys = genericKey.map(el => {
                    const ind = el.indexOf("|");
                    if (ind >= 0) {
                        el = el.slice(0, ind);
                    }
                    return el.replace(" ", "").replace(/[#|:|^]/, "").replace(" ", "");
                });
                let commonKeys = {};
                genericKey = genericKey.map(key => new RegExp(key, "i"));
                if (primaryKeys.length === genericKey.length) {
                    primaryKeys.forEach((item, i) => {
                        let result = res[Object.keys(res).find(k => genericKey[i].test(k))] || "";
                        if (result[result.length - 1] === "·") {
                            result = result.slice(0, -1);
                        }
                        commonKeys[item] = result.replace(/\*/g, "");
                    });
                }
                output = commonKeys;
                return { info: 'keyword search successfull', status: 0, data: output };
            }
            catch (e) {
                console.log('Error in fetching details', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    invoiceCheck(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const fileString = input.ocrString;
                const key = input.keyword;
                let filePath = input.filePath;
                if (Array.isArray(filePath)) {
                    //input from convert pdf to image
                    filePath = input.filePath[0];
                }
                const invoicePath = input.invoicePath;
                const nonInvoicePath = input.nonInvoicePath;
                const fileName = path.basename(filePath);
                const currentPath = filePath;
                const regexKey = new RegExp(key, "i");
                let isInvoice = false;
                if (regexKey.test(fileString)) {
                    console.log("fileNamee isss-----", fileName);
                    const destinationPath = invoicePath + fileName;
                    console.log(destinationPath);
                    isInvoice = true;
                    fs.rename(currentPath, destinationPath, (err) => {
                        if (err) {
                            throw err;
                        }
                        else {
                            output["invoicePath"] = destinationPath;
                            console.log("Successfully moved the file!");
                        }
                    });
                }
                else {
                    console.log("fileNamee isss-----", fileName);
                    const destinationPath = nonInvoicePath + fileName;
                    //isInvoice = true
                    fs.rename(currentPath, destinationPath, (err) => {
                        if (err) {
                            throw err;
                        }
                        else {
                            output["nonInvoicePath"] = destinationPath;
                            console.log("Successfully moved the file!");
                        }
                    });
                }
                output["invoiceCheck"] = isInvoice;
                return { info: 'invoicec check successfull', status: 0, data: output };
            }
            catch (e) {
                console.log('Error in fetching details', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    getRecords(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const { Questionreference, name, DateCreated, Assigned, address, CONTACTNO, model, serial, problem, ActionTaken } = input;
                const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                const db = mClient.db(env_2.env.dbConfig.dbname);
                if (Questionreference === "" || name === "") {
                    return { info: 'error occured', status: 1, data: 'no ticket/customer name provided' };
                }
                const custData = {
                    "Customer_Name": name,
                    "Address": address,
                    "Contact_No": CONTACTNO,
                    "Model_No": model,
                    "Serial_No": serial,
                    "First_Call_Made": DateCreated,
                    "Request_Handled_By": Assigned,
                    "Issue_highlighted_by_Customer": problem,
                    "Troubleshooting_Steps_Followed": ActionTaken,
                    "Ticket_Number": Questionreference
                };
                let customerComplainData = yield db.collection('Lenovo_Product').findOne({ $or: [{ "Customer_Name": name }, { "Ticket_Number": Questionreference }, { "Serial_No": serial }] });
                if (!customerComplainData) {
                    //Create a new document
                    const newTicketEntry = yield db.collection('Lenovo_Product').insertOne(custData);
                    if (!newTicketEntry) {
                        return { info: 'error occured', status: 1, data: 'unable to save' };
                    }
                    else {
                        customerComplainData = yield db.collection('Lenovo_Product').findOne({ "Ticket_Number": Questionreference });
                    }
                }
                let customerDataArr;
                if (customerComplainData) {
                    customerDataArr = Object.entries(customerComplainData);
                    console.log(" ------------->", customerDataArr);
                    const emptyValueDb = customerDataArr.filter(d => d[1] === "");
                    let emptyFieldsDb = emptyValueDb.map(el => el[0]);
                    console.log(emptyFieldsDb);
                    const updateKeys = emptyFieldsDb.reduce((updateObj, field) => {
                        if (custData[field] !== "") {
                            updateObj[field] = custData[field];
                        }
                        return updateObj;
                    }, {});
                    if (Object.keys(updateKeys).length > 0) {
                        const updatedData = yield db.collection('Lenovo_Product').update({ "Ticket_Number": Questionreference }, {
                            $set: updateKeys
                        });
                        if (updatedData.result.nModified > 0) {
                            customerComplainData = yield db.collection('Lenovo_Product').findOne({ "Ticket_Number": customerComplainData["Ticket_Number"] });
                        }
                    }
                }
                if (customerComplainData) {
                    delete customerComplainData._id;
                    customerDataArr = Object.entries(customerComplainData);
                }
                const emptyValue = customerDataArr.filter(d => d[1] === "");
                let dataAvailable = "true"; //Flag to check if the mail contains all data or not
                let emptyFields = emptyValue.map(el => el[0]);
                if (emptyValue.length > 0) {
                    dataAvailable = "false";
                }
                const displayOutput = customerDataArr.reduce((final, data) => {
                    final.push({ "Key": data[0], "value": data[1] });
                    return final;
                }, []);
                console.log("->", dataAvailable);
                output["displayOutput"] = displayOutput;
                if (dataAvailable === "true") {
                    output["mailTopText"] = `Dear user, your ticket reference ${customerComplainData.Ticket_Number} has been processed. Please review the details below.`;
                }
                else {
                    if (!util_1.isNullOrUndefined(emptyFields) && emptyFields.length !== 0) {
                        output["mailTopText"] = `Dear user, your ticket reference ${customerComplainData.Ticket_Number} has been processed. Your request is missing ${emptyFields}. Kindly provide the missing data.`;
                    }
                    else {
                        output["mailTopText"] = `Dear user, your ticket reference ${customerComplainData.Ticket_Number} has been processed. Your request is missing data. Kindly provide the missing data.`;
                    }
                }
                output["mailBottomText"] = `Regards,<br>Admin`;
                output['dataAvailable'] = dataAvailable;
                output['ticketNumber'] = customerComplainData.Ticket_Number;
                output['emptyFields'] = emptyFields;
                output["output"] = [customerComplainData];
                return { info: 'mail recieve successfully', status: 0, data: output };
            }
            catch (e) {
                console.log('Error in fetching details', e);
                return { message: 'Errrr in fetching data', status: 1, data: e };
            }
        });
    }
    updateCustomerRecords(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const tickeNo = input.tickeNo;
                const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                const db = mClient.db(env_2.env.dbConfig.dbname);
                let customerComplainData = yield db.collection('Lenovo_Product').findOne({ "Ticket_Number": tickeNo });
                let searchText = input.searchText.split(","); //["Customer_Name","Address","Serial_No"]
                let fieldsToUpdate = searchText.reduce((res, text) => {
                    if (customerComplainData[text] === "" || customerComplainData[text] === null) {
                        if (input[text] !== "") {
                            res[text] = input[text];
                        }
                    }
                    return res;
                }, {});
                if (Object.keys(fieldsToUpdate).length > 0) {
                    const updated = yield db.collection('Lenovo_Product').update({ "Ticket_Number": customerComplainData["Ticket_Number"] }, {
                        $set: fieldsToUpdate
                    });
                    if (updated.result.nModified > 0) {
                        customerComplainData = yield db.collection('Lenovo_Product').findOne({ "Ticket_Number": customerComplainData["Ticket_Number"] });
                    }
                }
                let customerDataArr;
                if (customerComplainData) {
                    delete customerComplainData._id;
                    customerDataArr = Object.entries(customerComplainData);
                }
                const emptyValue = customerDataArr.filter(d => d[1] === "");
                let emptyFields = emptyValue.map(el => el[0]);
                let dataAvailable = "true"; //Flag to check if the mail contains all data or not after update
                if (emptyValue.length > 0) {
                    dataAvailable = "false";
                }
                const displayOutput = customerDataArr.reduce((final, data) => {
                    final.push({ "Key": data[0], "value": data[1] });
                    return final;
                }, []);
                if (dataAvailable === "true") {
                    output["mailTopText"] = `Dear user, your ticket reference ${customerComplainData.Ticket_Number} has been processed. Please review the details below.`;
                }
                else {
                    if (!util_1.isNullOrUndefined(emptyFields) && emptyFields.length !== 0) {
                        output["mailTopText"] = `Dear user, your ticket reference ${customerComplainData.Ticket_Number} has been processed. Your request is missing ${emptyFields}. Kindly provide the missing data.`;
                    }
                    else {
                        output["mailTopText"] = `Dear user, your ticket reference ${customerComplainData.Ticket_Number} has been processed. Your request is missing data. Kindly provide the missing data.`;
                    }
                }
                output['dataCheck'] = dataAvailable;
                output['display'] = displayOutput;
                return { info: 'details updated successfully', status: 0, data: output };
            }
            catch (e) {
                console.log('Error in fetching details', e);
                return { message: 'Errrr in fetching data', status: 1, data: e };
            }
        });
    }
    objectToHtml(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let objectToParse = input.objToParse;
                let topText = input.top;
                let bottomText = input.bottom;
                if (!Array.isArray(objectToParse)) {
                    objectToParse = [objectToParse];
                }
                const tableHeaders = Object.keys(objectToParse[0]); //table headers considering all objects in array are with same key
                //const tableData = objectToParse.map(item => Object.values(item)) //table values
                const html = `<!DOCTYPE html>
            <html lang="en">

            <head>
                <meta charset="UTF-8">
                <meta http-equiv="X-UA-Compatible" content="IE=edge">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>Document</title>
            </head>

            <body>
                    <h3>${topText}</h3>
                  <table border = "1" cellspacing=”0” cellpadding=”0” width=”640” align=”center”>
                     <tr>
                        ${tableHeaders.reduce((result, element) => result += `<th>${element}</th>`, "")}
                     </tr>

                     ${objectToParse.reduce((result, element) => {
                    let rowValues = '';
                    tableHeaders.forEach(h => {
                        rowValues += `<td>${element[h]}</td>`;
                    });
                    return result += `<tr>${rowValues}</tr>`;
                }, "")}
                  </table>
                  <p>${bottomText}</p>
               </body>
            </html>`;
                console.log(html);
                output["toHTML"] = html;
                return { info: 'object converted to html successfully', status: 0, data: output };
            }
            catch (e) {
                console.log('Error in fetching details', e);
                return { message: 'Errrr in fetching data', status: 1, data: e };
            }
        });
    }
    createPdfFromHtml(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            //invoiceData = "";
            try {
                let pdf = require('html-pdf');
                let filePath = input.filePath;
                let invoiceData = input.invoiceData;
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    yield pdf.create(invoiceData, {
                        height: "17in",
                        width: "17in",
                        border: {
                            "top": "0.3in",
                            "right": "0.2in",
                            "left": "0.2in",
                            "bottom": "0in"
                        }
                    }).toFile(filePath, function (err, res) {
                        if (err)
                            return console.log(err);
                        console.log("filepath of the file", res);
                        output['result'] = res.filename;
                        resolve({ info: 'html converted to pdf successfully', status: 0, data: output });
                    });
                }));
            }
            catch (e) {
                console.log('Error in fetching details', e);
                return { message: 'Errrr in fetching data', status: 1, data: e };
            }
        });
    }
    accuracyrules(invoiceObject, doctype) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("Inside Accuracy Rules");
                //let invoiceKeys = [];
                // for (key in invoiceObject) {
                //     invoiceKeys.push(key);
                //     if (invoiceObject[key].toString().toLowerCase().includes('date')) {
                //         delete invoiceObject[key]
                //     }
                // }
                /////////////////////////////////////////////////////
                //-------------------------------------------------//
                if ((doctype == "GE_Doctype") && !util_1.isNullOrUndefined(invoiceObject['Invoice_Number'])) {
                    invoiceObject['Invoice_Number'] = invoiceObject['Invoice_Number'].replace('$', 'S');
                }
                let headerlevelFields = ['InvoiceTotalAmount', 'Tax_Amount'];
                for (let i = 0; i < headerlevelFields.length; i++) {
                    if (!util_1.isNullOrUndefined(invoiceObject[headerlevelFields[i]])) {
                        let currency = /(\s[A-Z]{3,3}$)|(\s[A-Z]{3,3}\s)|(^[A-Z]{3,3}$)/;
                        let currency1 = /(\$)|(USD)/;
                        let currency2 = /(AED)/;
                        invoiceObject[headerlevelFields[i]] = invoiceObject[headerlevelFields[i]].toString();
                        if (invoiceObject[headerlevelFields[i]].match(currency) && invoiceObject[headerlevelFields[i]].match(currency).length >= 1) {
                            invoiceObject['Currency'] = invoiceObject[headerlevelFields[i]].match(currency)[0].trim();
                        }
                        else if (currency1.test(invoiceObject[headerlevelFields[i]])) {
                            invoiceObject['Currency'] = 'USD';
                        }
                        else if (currency2.test(invoiceObject[headerlevelFields[i]])) {
                            invoiceObject['Currency'] = 'AED';
                        }
                    }
                }
                if (!util_1.isNullOrUndefined(invoiceObject['Currency'])) {
                    let currency = /(AED)|(AFI)|(AFD)|(AF)|(AD)/;
                    if (currency.test(invoiceObject['Currency'].toLowerCase()) || currency.test(invoiceObject['Currency'].toUpperCase())) {
                        invoiceObject['Currency'] = 'AED';
                    } // Match Against Currency Code Table
                    // else if (invoiceObject['Currency'] == '' || !/^[A-Z]{3,3}$/.test(invoiceObject['Currency'])) {
                    //     invoiceObject['Currency'] = 'AED';
                    // }
                }
                let headerNumericalFields = ['Tax_Amount', 'InvoiceTotalAmount'];
                for (let i = 0; i < headerNumericalFields.length; i++) {
                    if (!util_1.isNullOrUndefined(invoiceObject[headerNumericalFields[i]])) {
                        invoiceObject[headerNumericalFields[i]] = invoiceObject[headerNumericalFields[i]].replace(/([a-zA-Z\n$\]\[\|\/\\\%-])/g, '').trim();
                        let lastthree = invoiceObject[headerNumericalFields[i]].substr(-3);
                        lastthree = lastthree.toString().replace(/(,)/g, ".");
                        console.log(lastthree);
                        let firstNumeric = invoiceObject[headerNumericalFields[i]].slice(0, invoiceObject[headerNumericalFields[i]].length - 3);
                        firstNumeric = firstNumeric.toString().replace(/([a-zA-Z\n.:$\]\[\|\/\\\%,])/g, '').trim();
                        invoiceObject[headerNumericalFields[i]] = firstNumeric.concat(lastthree);
                        invoiceObject[headerNumericalFields[i]] = !util_1.isNullOrUndefined(invoiceObject[headerNumericalFields[i]]) && !isNaN(parseFloat(invoiceObject[headerNumericalFields[i]])) ? (invoiceObject[headerNumericalFields[i]]) : '';
                        //invoiceObject[headerNumericalFields[i]] = invoiceObject[headerNumericalFields[i]].toString().replace(/([a-zA-Z\n.:\]\[\|\/\\\%,])/g, '').trim();
                        //invoiceObject[headerNumericalFields[i]] = !isNullOrUndefined(invoiceObject[headerNumericalFields[i]]) && !isNaN(parseFloat(invoiceObject[headerNumericalFields[i]])) ? parseFloat(invoiceObject[headerNumericalFields[i]]) : '';
                    }
                }
                if (doctype !== "GE_Doctype") {
                    if (!util_1.isNullOrUndefined(invoiceObject['Supplier_TRN'])) {
                        invoiceObject['Supplier_TRN'] = invoiceObject['Supplier_TRN'].toString().replace(/([a-zA-Z\n.:\]\[\|\/\\\%,#])/g, '').trim();
                        if (invoiceObject['Supplier_TRN'] == '100270983800003') {
                            let temp = invoiceObject['Supplier_TRN'];
                            invoiceObject['Supplier_TRN'] = invoiceObject['Customer_TRN'];
                            invoiceObject['Customer_TRN'] = temp;
                        }
                        else if (invoiceObject['Supplier_TRN'].length >= 30) {
                            let splits = invoiceObject['Supplier_TRN'].split('100270983800003');
                            splits[0] = (splits[0] == '') ? '100270983800003' : splits[0];
                            splits[1] = (splits[1] == '') ? '100270983800003' : splits[1];
                            if (splits.length == 2) {
                                invoiceObject['Customer_TRN'] = splits[0].includes('100270983800003') ? splits[0] : splits[1];
                                invoiceObject['Supplier_TRN'] = !splits[0].includes('100270983800003') ? splits[0] : splits[1];
                            }
                        }
                    }
                    if (!util_1.isNullOrUndefined(invoiceObject['Customer_TRN'])) {
                        invoiceObject['Customer_TRN'] = invoiceObject['Customer_TRN'].toString().replace(/([a-zA-Z\n.:\]\[\|\/\\\%,#])/g, '').trim();
                        if (invoiceObject['Customer_TRN'].length >= 30) {
                            let splits = invoiceObject['Customer_TRN'].split('100270983800003');
                            splits[0] = (splits[0] == '') ? '100270983800003' : splits[0];
                            splits[1] = (splits[1] == '') ? '100270983800003' : splits[1];
                            if (splits.length == 2) {
                                invoiceObject['Customer_TRN'] = splits[0].includes('100270983800003') ? splits[0] : splits[1];
                                invoiceObject['Supplier_TRN'] = !splits[0].includes('100270983800003') ? splits[0] : splits[1];
                            }
                        }
                    }
                }
                if (!util_1.isNullOrUndefined(invoiceObject['PO_Number'])) {
                    let regex = /((PO|PO NO|PO#|PO No.|PO No|No.|Cust P.O.|Cust|P.O.|LPO#|LPO number #|LPO #|LPO #|LPO)(\s{0,}\d+|\d+))/;
                    let regex2 = /(AUH\/\d{0,}\/)|(TEC\/CPD\/)/;
                    if (invoiceObject['PO_Number'].match(regex) && invoiceObject['PO_Number'].match(regex).length >= 1) {
                        let PO = !util_1.isNullOrUndefined(invoiceObject['PO_Number'].match(regex)[0]) ? invoiceObject['PO_Number'].match(regex)[0] : invoiceObject['PO_Number'];
                        invoiceObject['PO_Number'] = PO.replace(/(PO|PO NO|PO#|PO No.|No.|Cust P.O.|Cust|P.O.|PO No|LPO#|LPO number #|LPO #|LPO #|LPO|#|-)/g, '').trim();
                        invoiceObject['PO_Number'] = !util_1.isNullOrUndefined(invoiceObject['PO_Number']) ? invoiceObject['PO_Number'] : PO;
                    }
                    else if (invoiceObject['PO_Number'].match(regex2) && invoiceObject['PO_Number'].match(regex2).length >= 1) {
                        let PO = !util_1.isNullOrUndefined(invoiceObject['PO_Number'].match(regex2)[0]) ? invoiceObject['PO_Number'].match(regex2)[0] : invoiceObject['PO_Number'];
                        invoiceObject['PO_Number'] = invoiceObject['PO_Number'].replace(regex2, '').replace('/[#-]/g', '').trim();
                        invoiceObject['PO_Number'] = !util_1.isNullOrUndefined(invoiceObject['PO_Number']) ? invoiceObject['PO_Number'] : PO;
                    }
                    if ((doctype == "GE_Doctype")) {
                        invoiceObject['PO_Number'] = invoiceObject['PO_Number'].substr(0, invoiceObject['PO_Number'].indexOf("d"));
                    }
                }
                if (!util_1.isNullOrUndefined(invoiceObject['Invoice_Type']) && !util_1.isNullOrUndefined(invoiceObject['Invoice_Title']) && invoiceObject['Invoice_Type'] !== '') {
                    invoiceObject['Invoice_Title'] = invoiceObject['Invoice_Type'];
                }
                if (doctype !== "GE_Doctype") {
                    // if (!isNullOrUndefined(invoiceObject['Invoice_Title'])) {
                    //     let credit = /(credit)|(Note)|(memo)/;
                    //     let prepayment = /(PRO-FORMA INVOICE)|(prepayment)|(proforma)|(PROFORMA)|(Performa)/;
                    //     if (credit.test(invoiceObject['Invoice_Title'].toLowerCase()) || credit.test(invoiceObject['Invoice_Title'].toUpperCase())) {
                    //         invoiceObject['Invoice_Type'] = 'CREDIT';
                    //     }
                    //     else if (prepayment.test(invoiceObject['Invoice_Title'].toLowerCase()) || prepayment.test(invoiceObject['Invoice_Title'].toUpperCase())) {
                    //         invoiceObject['Invoice_Type'] = 'PREPAYMENT';
                    //     }
                    //     else {
                    //         invoiceObject['Invoice_Type'] = 'STANDARD';
                    //     }
                    // }
                    // else {
                    //     invoiceObject['Invoice_Type'] = 'STANDARD';
                    // }
                    //invoiceObject['Invoice_Type'] = 'MIXED';
                }
                if (!util_1.isNullOrUndefined(invoiceObject['Invoice_Number'])) {
                    let invoiceno = /(Invoice No)|(INVOICE NUMBER)|(Invoice No.)|(INVOIC)|(INVOICE)|(No)|(No.)|(Reference)|(Number)|(number)|(invoice)/g;
                    if (invoiceno.test(invoiceObject['Invoice_Number'].toLowerCase()) || invoiceno.test(invoiceObject['Invoice_Number'].toUpperCase())) {
                        invoiceObject['Invoice_Number'] = invoiceObject['Invoice_Number'].replace(invoiceno, '').trim();
                    }
                }
                if (!util_1.isNullOrUndefined(invoiceObject['Invoice_Date'])) {
                    let invoiceno = /(Date)|(INVOICE DATE)|(Invoice Date.)|(date)|(INVOICE)|(Performa)|(Proforma)|(Reference)|(date)(reference)/g;
                    if (invoiceno.test(invoiceObject['Invoice_Date'].toLowerCase()) || invoiceno.test(invoiceObject['Invoice_Date'].toUpperCase())) {
                        invoiceObject['Invoice_Date'] = invoiceObject['Invoice_Date'].replace(invoiceno, '').trim();
                    }
                }
                if (!util_1.isNullOrUndefined(invoiceObject['Vendor_Name']) && (invoiceObject['Vendor_Name'] == '') && !util_1.isNullOrUndefined(!util_1.isNullOrUndefined(invoiceObject['Vendor_Name']))) {
                    if (invoiceObject['Supplier_Address'].includes('LLC')) {
                        invoiceObject['Vendor_Name'] = invoiceObject['Supplier_Address'].substring(0, invoiceObject['Supplier_Address'].indexOf('LLC') + 3);
                    }
                    else if (invoiceObject['Supplier_Address'].includes('l.l.c')) {
                        invoiceObject['Vendor_Name'] = invoiceObject['Supplier_Address'].substring(0, invoiceObject['Supplier_Address'].indexOf('l.l.c') + 5);
                    }
                    else if (invoiceObject['Supplier_Address'].includes('llc')) {
                        invoiceObject['Vendor_Name'] = invoiceObject['Supplier_Address'].substring(0, invoiceObject['Supplier_Address'].indexOf('llc') + 3);
                    }
                }
                /////////////////////////////////////////////////////
                //----------------Table level fields---------------//
                let NumericalFields = ['Unit_Price', 'Taxable_Amount', 'Tax_Amount1', 'Quantity', 'Line_Total_Amount', 'Unit_Price', 'Tax_Rate', 'Item_PO_Number'];
                let standardAmount = ['Taxable_Amount', 'Tax_Amount1', 'Line_Total_Amount', 'Unit_Price'];
                if (!util_1.isNullOrUndefined(invoiceObject.invoiceItems) && Array.isArray(invoiceObject.invoiceItems)) {
                    let INVOICE_ITEMS = JSON.parse(JSON.stringify(invoiceObject.invoiceItems));
                    if (Array.isArray(INVOICE_ITEMS)) {
                        invoiceObject.invoiceItems = [];
                        for (let index = 0; index < INVOICE_ITEMS.length; index++) {
                            let element = JSON.parse(JSON.stringify(INVOICE_ITEMS[index]));
                            let tableKeys = [];
                            let key;
                            //Discarding Rows---start
                            let discardRow = false;
                            let discardRegex = /('Total In')|('Total For')/;
                            let vatRegex = /(Value Added Tax :)|(VAT \(5%)|VAT (0%)/;
                            for (key in element) {
                                if (NumericalFields.includes(key) && NumericalFields.indexOf(key) > -1 && key !== 'Item_PO_Number') {
                                    if (discardRegex.test(element[key])) {
                                        discardRow = true;
                                        break;
                                    }
                                }
                                if (vatRegex.test(element[key]) && doctype !== "GE_Doctype") {
                                    element[key] = !util_1.isNullOrUndefined(element[key]) ? element[key].toString().replace(/[a-zA-Z\]\[\|\/\\\%,]/g, '').trim() : '';
                                    if (!isNaN(parseFloat(element[key]))) {
                                        console.log("Fetching Tax_RATE..");
                                        if (parseFloat(element[key]) > 0) {
                                            invoiceObject['Tax_code'] = 'VAT_TWZ_DR';
                                        }
                                        else if ((!util_1.isNullOrUndefined(invoiceObject['Invoice_Title']) && invoiceObject['Invoice_Title'].includes('TAX')) || (!util_1.isNullOrUndefined(invoiceObject['Supplier_TRN']) && invoiceObject['Supplier_TRN'] == '')) {
                                            invoiceObject['Tax_code'] = 'VAT_TEC_0';
                                        }
                                        else {
                                            invoiceObject['Tax_code'] = 'VAT_OOS';
                                        }
                                    }
                                    discardRow = true;
                                }
                            }
                            if (discardRow) {
                                continue;
                            }
                            //Discarding Rows---end
                            //clearing numerical Data
                            for (key in element) {
                                tableKeys.push(key);
                                // if (element[key].toString().toLowerCase().includes('date')) {
                                //     delete element[key]
                                // }
                                if (NumericalFields.includes(key) && NumericalFields.indexOf(key) > -1) {
                                    element[key] = !util_1.isNullOrUndefined(element[key]) ? element[key].toString().replace(/[a-zA-Z\]\[\|\/\\\%,-]/g, '').trim() : '';
                                    // OCR issues handled for Decimal Values
                                    if (element[key].indexOf('.') !== element[key].lastIndexOf('.') && element[key].length > 4) {
                                        element[key] = element[key].substring(0, element[key].length - 3).replace('.', '');
                                    }
                                    else if (standardAmount.includes(key) && standardAmount.indexOf(key) > -1 && !util_1.isNullOrUndefined(element[key]) && !element[key].includes('.')) {
                                        element[key] = element[key].length > 2 ? element[key].replace(/(\d\d)$/, '.$1') : element[key];
                                        element[key] = element[key].length > 2 ? element[key].replace(/[\/\-]/g, '') : element[key];
                                    }
                                    element[key] = !util_1.isNullOrUndefined(element[key]) && !isNaN(parseFloat(element[key])) ? parseFloat(element[key]) : '';
                                }
                            }
                            //Discarding Rows---start
                            let numericalFieldsCount = 0;
                            let nonnumericFields = 0;
                            for (key in element) {
                                if (NumericalFields.includes(key) && NumericalFields.indexOf(key) > -1 && key !== 'Item_PO_Number') {
                                    numericalFieldsCount++;
                                    if (!util_1.isNullOrUndefined(element[key]) && !/\d/.test(element[key])) {
                                        nonnumericFields++;
                                    }
                                }
                            }
                            if (numericalFieldsCount > 0) {
                                if ((nonnumericFields == numericalFieldsCount) || (nonnumericFields > Math.round(numericalFieldsCount / 3))) {
                                    discardRow = true;
                                    continue;
                                }
                            }
                            //Discarding Rows---start
                            for (let i = 0; i < NumericalFields.length; i++) {
                                element[NumericalFields[i]] = !util_1.isNullOrUndefined(element[NumericalFields[i]]) && !isNaN(parseFloat(element[NumericalFields[i]])) ? parseFloat(element[NumericalFields[i]]) : '';
                            }
                            //Quantity using formulae
                            if (tableKeys.includes('Quantity') && (!util_1.isNullOrUndefined(element["Quantity"]) && isNaN(parseFloat(element["Quantity"])))) {
                                if (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && !util_1.isNullOrUndefined(element["Unit_Price"]) && !isNaN(parseFloat(element["Taxable_Amount"])) && !isNaN(parseFloat(element["Unit_Price"]))) {
                                    element["Quantity"] = parseFloat(element["Taxable_Amount"]) / parseFloat(element["Unit_Price"]);
                                    element["Quantity"] = !isNaN(element["Quantity"]) ? element["Quantity"] : '';
                                }
                            }
                            //Unit_Price using formulae
                            if (tableKeys.includes('Unit_Price') && (!util_1.isNullOrUndefined(element["Unit_Price"]) && isNaN(parseFloat(element["Unit_Price"])))) {
                                if (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && !util_1.isNullOrUndefined(element["Quantity"]) && !isNaN(parseFloat(element["Taxable_Amount"])) && !isNaN(parseFloat(element["Quantity"]))) {
                                    element["Unit_Price"] = parseFloat(element["Taxable_Amount"]) / parseFloat(element["Quantity"]);
                                    element["Unit_Price"] = !isNaN(element["Unit_Price"]) ? element["Unit_Price"] : '';
                                }
                            }
                            //Taxable_Amount using formulae
                            if (tableKeys.includes('Taxable_Amount') && (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && isNaN(parseFloat(element["Taxable_Amount"])))) {
                                if (!util_1.isNullOrUndefined(element["Unit_Price"]) && !util_1.isNullOrUndefined(element["Quantity"]) && !isNaN(parseFloat(element["Unit_Price"])) && !isNaN(parseFloat(element["Quantity"]))) {
                                    element["Taxable_Amount"] = parseFloat(element["Unit_Price"]) * parseFloat(element["Quantity"]);
                                    element["Taxable_Amount"] = !isNaN(element["Taxable_Amount"]) ? element["Taxable_Amount"] : '';
                                }
                                else if (!util_1.isNullOrUndefined(element["Line_Total_Amount"]) && !util_1.isNullOrUndefined(element["Tax_Amount1"]) && !isNaN(parseFloat(element["Line_Total_Amount"])) && !isNaN(parseFloat(element["Tax_Amount1"]))) {
                                    element["Taxable_Amount"] = parseFloat(element["Line_Total_Amount"]) - parseFloat(element["Tax_Amount1"]);
                                    element["Taxable_Amount"] = !isNaN(element["Taxable_Amount"]) ? element["Taxable_Amount"] : '';
                                }
                            }
                            else if ((!util_1.isNullOrUndefined(element["Taxable_Amount"]) && (!util_1.isNullOrUndefined(element["Unit_Price"])) && (!util_1.isNullOrUndefined(element["Quantity"])))) {
                                if (!isNaN(parseFloat(element["Unit_Price"])) && !isNaN(parseFloat(element["Tax_Amount1"])) && !isNaN(parseFloat(element["Taxable_Amount"]))) {
                                    let chk = parseFloat(element["Unit_Price"]) * parseFloat(element["Quantity"]);
                                    if (chk !== parseFloat(element["Taxable_Amount"])) {
                                        let err = {
                                            "Taxable_Amount": "EX166 - Taxable_Amount is not matching with Unit_Price X Quantity"
                                        };
                                        if (!util_1.isNullOrUndefined(invoiceObject["error"]) && Array.isArray(invoiceObject["error"])) {
                                            invoiceObject["error"].push(err);
                                        }
                                        else {
                                            invoiceObject["error"] = [];
                                            invoiceObject["error"].push(err);
                                        }
                                    }
                                }
                            }
                            //Tax_Amount1 using formulae
                            if (tableKeys.includes('Tax_Amount1') && (!util_1.isNullOrUndefined(element["Tax_Amount1"]) && isNaN(parseFloat(element["Tax_Amount1"])))) {
                                if (!util_1.isNullOrUndefined(element["Line_Total_Amount"]) && !util_1.isNullOrUndefined(element["Taxable_Amount"]) && !isNaN(parseFloat(element["Line_Total_Amount"])) && !isNaN(parseFloat(element["Taxable_Amount"]))) {
                                    element["Tax_Amount1"] = parseFloat(element["Line_Total_Amount"]) - parseFloat(element["Taxable_Amount"]);
                                    element["Tax_Amount1"] = !isNaN(element["Tax_Amount1"]) ? element["Tax_Amount1"] : '';
                                }
                                else if (!util_1.isNullOrUndefined(element["Tax_Rate"]) && !util_1.isNullOrUndefined(element["Taxable_Amount"]) && !isNaN(parseFloat(element["Tax_Rate"])) && !isNaN(parseFloat(element["Taxable_Amount"]))) {
                                    element["Tax_Amount1"] = (parseFloat(element["Tax_Rate"]) / 100) * parseFloat(element["Taxable_Amount"]);
                                    element["Tax_Amount1"] = !isNaN(element["Tax_Amount1"]) ? element["Tax_Amount1"] : '';
                                }
                            }
                            //Tax_Rate using formulae
                            if (tableKeys.includes('Tax_Rate') && (!util_1.isNullOrUndefined(element["Tax_Rate"]) && isNaN(parseFloat(element["Tax_Rate"])))) {
                                if (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && !util_1.isNullOrUndefined(element["Tax_Amount1"]) && !isNaN(parseFloat(element["Taxable_Amount"])) && !isNaN(parseFloat(element["Tax_Amount1"]))) {
                                    element["Tax_Rate"] = Math.round((parseFloat(element["Tax_Amount1"]) / parseFloat(element["Taxable_Amount"])) * 100);
                                    element["Tax_Rate"] = !isNaN(element["Tax_Rate"]) && element["Tax_Rate"] > 0 ? 5 : 0;
                                }
                            }
                            //Line_Total_Amount using formulae
                            if (tableKeys.includes('Line_Total_Amount') && (!util_1.isNullOrUndefined(element["Line_Total_Amount"]) && isNaN(parseFloat(element["Line_Total_Amount"])))) {
                                if (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && !util_1.isNullOrUndefined(element["Tax_Amount1"]) && !isNaN(parseFloat(element["Taxable_Amount"])) && !isNaN(parseFloat(element["Tax_Amount1"]))) {
                                    element["Line_Total_Amount"] = parseFloat(element["Tax_Amount1"]) + parseFloat(element["Taxable_Amount"]);
                                    element["Line_Total_Amount"] = !isNaN(element["Line_Total_Amount"]) ? element["Line_Total_Amount"] : '';
                                }
                            }
                            else if (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && !isNaN(parseFloat(element["Taxable_Amount"])) && isNaN(parseFloat(element["Line_Total_Amount"]))) {
                                element["Line_Total_Amount"] = element["Taxable_Amount"];
                                element["TAXABLE_FLAG"] = "Y";
                            }
                            else {
                                element["TAXABLE_FLAG"] = "N";
                            }
                            // Item_description Extraction
                            if (!util_1.isNullOrUndefined(element["Item_Description"])) {
                                element["Item_Description"] = element["Item_Description"].replace(/["']/g, '');
                            }
                            // Item_PO_Number Extraction
                            if (util_1.isNullOrUndefined(element["Item_PO_Number"]) || (!/\d+/.test(element["Item_PO_Number"]))) {
                                let regex = /((PO|PO NO|PO#|PO No.|No.|Cust P.O.|Cust|P.O.|PO No|LPO#|LPO number #|LPO #|LPO #|LPO)(\s{0,}\d+|\d+))/;
                                if (!util_1.isNullOrUndefined(element["Item_Description"]) && regex.test(element["Item_Description"]) && element["Item_Description"].match(regex) && element["Item_Description"].match(regex).length >= 1) {
                                    let PO = !util_1.isNullOrUndefined(element["Item_Description"].match(regex)[0]) ? element["Item_Description"].match(regex)[0] : element["Item_Description"];
                                    PO = PO.replace(/(PO|PO NO|PO#|PO No.|No.|Cust P.O.|Cust|P.O.|PO No|LPO#|LPO number #|LPO #|LPO #|LPO|#|-)/g, '').trim();
                                    element['Item_PO_Number'] = !util_1.isNullOrUndefined(PO) && /^\d/.test(PO) && /\d$/.test(PO) ? PO : element['Item_PO_Number'];
                                }
                                else if (!util_1.isNullOrUndefined(invoiceObject['PO_Number']) && isNaN(parseFloat(element["Item_PO_Number"]))) {
                                    element['Item_PO_Number'] = invoiceObject['PO_Number'];
                                }
                            }
                            if (element) {
                                element['LINE_TYPE_LOOKUP_CODE'] = "ITEM";
                                element['LINE_NUMBER'] = index + 1;
                                invoiceObject.invoiceItems.push(element);
                            }
                            //   console.log("-------------",element,tableKeys);
                        }
                    }
                    let invoiceItems = JSON.parse(JSON.stringify(invoiceObject.invoiceItems));
                    //Extracting Header Level PO_Number
                    if (!util_1.isNullOrUndefined(invoiceObject['PO_Number']) && (!/^\d/.test(invoiceObject['PO_Number'])) && (!/\d$/.test(invoiceObject['PO_Number']))) {
                        for (let index = 0; index < invoiceItems.length; index++) {
                            if (!util_1.isNullOrUndefined(invoiceItems[index]['Item_PO_Number']) && (/^\d/.test(invoiceItems[index]['Item_PO_Number'])) && (/\d$/.test(invoiceItems[index]['Item_PO_Number']))) {
                                invoiceObject['PO_Number'] = invoiceObject['PO_Number'] != '' ? invoiceObject['PO_Number'] + ',' + invoiceItems[index]['Item_PO_Number'] : invoiceItems[index]['Item_PO_Number'];
                            }
                        }
                    }
                    // Calculating Total
                    invoiceObject['Calculated_Invoice_Total'] = 0;
                    invoiceObject['Calculated_Taxable_Total'] = 0;
                    invoiceObject['Calculated_Tax_Total'] = 0;
                    for (let index = 0; index < invoiceItems.length; index++) {
                        if (!util_1.isNullOrUndefined(invoiceItems[index]['Line_Total_Amount']) && (!isNaN(parseFloat(invoiceItems[index]['Line_Total_Amount'])))) {
                            invoiceObject['Calculated_Invoice_Total'] = invoiceObject['Calculated_Invoice_Total'] + invoiceItems[index]['Line_Total_Amount'];
                        }
                        else {
                            invoiceObject['Calculated_Invoice_Total'] = '';
                            break;
                        }
                    }
                    for (let index = 0; index < invoiceItems.length; index++) {
                        if (!util_1.isNullOrUndefined(invoiceItems[index]['Taxable_Amount']) && (!isNaN(parseFloat(invoiceItems[index]['Taxable_Amount'])))) {
                            invoiceObject['Calculated_Taxable_Total'] = invoiceObject['Calculated_Taxable_Total'] + invoiceItems[index]['Taxable_Amount'];
                        }
                        else {
                            invoiceObject['Calculated_Taxable_Total'] = '';
                            break;
                        }
                    }
                    for (let index = 0; index < invoiceItems.length; index++) {
                        if (!util_1.isNullOrUndefined(invoiceItems[index]['Tax_Amount1']) && (!isNaN(parseFloat(invoiceItems[index]['Tax_Amount1'])))) {
                            invoiceObject['Calculated_Tax_Total'] = invoiceObject['Calculated_Tax_Total'] + invoiceItems[index]['Tax_Amount1'];
                        }
                        else {
                            invoiceObject['Calculated_Tax_Total'] = '';
                            break;
                        }
                    }
                    if (!util_1.isNullOrUndefined(invoiceItems) && !util_1.isNullOrUndefined(invoiceItems.length) && invoiceItems.length > 0) {
                        let items = invoiceItems.map(v => Object.assign(v, { "Tax_code": invoiceObject['Tax_code'] }));
                        invoiceObject["invoiceItems"] = JSON.parse(JSON.stringify(items));
                    }
                }
                if ((!util_1.isNullOrUndefined(invoiceObject['Calculated_Tax_Total']) && invoiceObject['Calculated_Tax_Total'] > 0) || (!util_1.isNullOrUndefined(invoiceObject['Tax_Amount']) && parseFloat(invoiceObject['Tax_Amount']) > 0)) {
                    invoiceObject['Tax_code'] = 'VAT_TWZ_DR';
                }
                else if ((!util_1.isNullOrUndefined(invoiceObject['Invoice_Title']) && invoiceObject['Invoice_Title'].includes('TAX')) || (!util_1.isNullOrUndefined(invoiceObject['Supplier_TRN']) && invoiceObject['Supplier_TRN'] == '')) {
                    invoiceObject['Tax_code'] = 'VAT_TEC_0';
                }
                else {
                    invoiceObject['Tax_code'] = 'VAT_OOS';
                }
                return invoiceObject;
            }
            catch (err) {
                console.log(err);
                return invoiceObject;
            }
        });
    }
    ruleEngineApiCall(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            console.log("ruleengine api call");
            try {
                let self = this;
                const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                const db = mClient.db(env_2.env.dbConfig.dbname);
                if (!util_1.isNullOrUndefined(input.ruleID) && (input.ruleID != "") && !util_1.isNullOrUndefined(input.rulesSetValue) && (input.rulesSetValue != "") && !util_1.isNullOrUndefined(input.doctype) && (input.doctype != "")) {
                    return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                        let datarule = yield scanField.findOne({ isDeleted: false, documentType: input.doctype });
                        if (!util_1.isNullOrUndefined(datarule) && typeof datarule == 'object') {
                            datarule = JSON.parse(JSON.stringify(datarule));
                        }
                        for (let i = 0; i < datarule.fields.length; i++) {
                            if (util_1.isNullOrUndefined(input.rulesSetValue[datarule.fields[i].fieldName])) {
                                input.rulesSetValue[datarule.fields[i].fieldName] = "";
                            }
                        }
                        let token = yield self.createToken(input.userId, input.subscriberId, input.orgId);
                        let headers = {
                            "Authorization": "Bearer " + token,
                            "Content-Type": "application/json",
                            "selectedorgid": input.orgId,
                        };
                        let beforeRuleObj = yield db.collection(input.doctype + "_beforeRule").insertOne(input.rulesSetValue);
                        console.log("BEFORE RULE ---- ENGINE --- OBJ --- >> >>  ", JSON.stringify(input.rulesSetValue), beforeRuleObj);
                        input.rulesSetValue = yield self.accuracyrules(input.rulesSetValue, input.doctype);
                        let beforeRuleObjAcc = yield db.collection(input.doctype + "_accuracyRule").insertOne(input.rulesSetValue);
                        console.log("ACCURACY RULE ---- ENGINE --- OBJ --- >> >>  ", JSON.stringify(input.rulesSetValue), beforeRuleObjAcc);
                        let options = {
                            method: 'POST',
                            url: env_2.env.routes.gibots_api + 'gibots-api/rule/EvaluateRuleSet',
                            headers: headers,
                            body: {
                                rulesSetValue: input.rulesSetValue,
                                id: input.ruleID
                            },
                            json: true
                        };
                        console.warn(" <<< << ------- ---------- ------- CALLING RULE ENGINE API ------- ---------- ------- >>> ");
                        let ruleBody = yield request(options);
                        if (!util_1.isNullOrUndefined(ruleBody) && !util_1.isNullOrUndefined(ruleBody['status']) && ruleBody['status'] == 0) {
                            if (!util_1.isNullOrUndefined(ruleBody['data']) && Object.keys(ruleBody['data']).length == 0) {
                                console.log("<<<<<----------------      ruleBody['data']).length == 0  --------- >>>>>>>> ");
                                output['ruleOutput'] = input.rulesSetValue;
                                resolve({ message: 'rule is not applied', status: 0, data: output });
                            }
                            else {
                                ruleBody['data']['RuleApplied'] = 'YES';
                                let afterRuleObj = yield db.collection(input.doctype + "_afterRule").insertOne(ruleBody['data']);
                                console.log("AFTER RULE ---- ENGINE --- OBJ --- >> >>  ", JSON.stringify(ruleBody['data']), afterRuleObj);
                                output['ruleOutput'] = ruleBody['data'];
                                resolve({ message: 'Rule applied', status: 0, data: output });
                            }
                        }
                        else {
                            output['ruleOutput'] = input.rulesSetValue;
                            resolve({ message: 'rule is not applied', status: 0, data: output });
                        }
                        //return resolve({ message: 'Rule applied', status: 0, data: ruleBody['data'] });
                    }));
                }
                else {
                    return { message: 'Rule is not applied', status: 1, data: output };
                }
            }
            catch (err) {
                // console.log("Error!!! -> " + err);
                this.log.info("rule engine api call failed");
                return { message: err, status: 1, data: err };
            }
        });
    }
    htmlFormatter(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let htmlStr = `${input.htmlStr}`;
                const keyData = JSON.parse(JSON.stringify(input.jsonValue));
                let err = "false";
                Object.keys(keyData).forEach(strKey => {
                    if (!util_1.isNullOrUndefined(strKey)) {
                        if (Array.isArray(keyData[strKey])) {
                            let arrayKeys = Object.keys(keyData[strKey][0]);
                            let formattedKeys = arrayKeys.map(val => `[${val}]`);
                            let firstKeyIndex = htmlStr.indexOf(formattedKeys[0]);
                            if (firstKeyIndex > 0) {
                                const startRowTagIndex = htmlStr.lastIndexOf("<tr>", firstKeyIndex);
                                const endRowTagIndex = htmlStr.indexOf("</tr>", firstKeyIndex);
                                let tableRowBody = htmlStr.substring(startRowTagIndex, endRowTagIndex + 5);
                                let finalResult = "";
                                keyData[strKey].forEach(arrObject => {
                                    let convertedText = tableRowBody;
                                    arrayKeys.forEach(key => {
                                        let searchKey = `[${key}]`;
                                        convertedText = convertedText.replace(searchKey, arrObject[key]);
                                    });
                                    finalResult += convertedText;
                                });
                                htmlStr = htmlStr.replace(tableRowBody, finalResult);
                            }
                            else {
                                console.log("Could not find table key in html String");
                            }
                        }
                        else {
                            let searchKey = `[${strKey}]`;
                            htmlStr = htmlStr.split(searchKey).join(keyData[strKey]);
                        }
                    }
                    else {
                        err = "true";
                    }
                });
                if (err === "false") {
                    output["convertedHtml"] = htmlStr;
                    return { info: 'object converted to html successfully', status: 0, data: output };
                }
                else {
                    return { info: "invalid key", status: 0, data: output };
                }
            }
            catch (e) {
                console.log('Error in fetching details', e);
                return { message: 'Errrr in fetching data', status: 1, data: e };
            }
        });
    }
    updateDocumentXmlTCL(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            this.log.info('<--------- Entered into deleteDocumentInS3Folder Bot ------------->');
            try {
                //let invoiceData = input.invoiceData;
                //let mapping = input.mapping;
                let filePath = input.filePath;
                //let mapping = JSON.parse(JSON.stringify(input.mapping));
                let mapping = !util_1.isNullOrUndefined(input.mapping) && typeof input.mapping == 'string' ? JSON.parse(input.mapping) : input.mapping;
                console.log(mapping);
                let invoiceData = !util_1.isNullOrUndefined(input.invoiceData) && typeof input.invoiceData == 'string' ? JSON.parse(input.invoiceData) : input.invoiceData;
                console.log(invoiceData);
                const AdmZip = require('adm-zip');
                const zip = yield new AdmZip(filePath);
                let xml;
                var zipEntries = yield zip.getEntries();
                // an array of ZipEntry records
                zipEntries.forEach(function (zipEntry) {
                    if (zipEntry.entryName == "word/document.xml") {
                        xml = zipEntry.getData().toString("utf8");
                    }
                });
                let xmlData = xml.toString();
                //console.log(xmlData)
                let result = {};
                result["header"] = xmlData;
                const template = result;
                let masterTemplate = '';
                for (let key in template) {
                    let temp = template[key];
                    //console.log(temp)
                    let map = mapping[key];
                    //console.log(map)
                    let arrayFlag = invoiceData[key] && Array.isArray(invoiceData[key]) ? true : false;
                    //console.log(arrayFlag)
                    if (arrayFlag) {
                        let arrayItems = invoiceData[key];
                        let temp2 = temp;
                        temp = '';
                        for (let i = 0; i < arrayItems.length; i++) {
                            let temp3 = temp2;
                            let item = arrayItems[i];
                            for (let mapKey in map) {
                                if (item[map[mapKey]]) {
                                    //console.log(mapKey)
                                    let regExp = new RegExp(mapKey, "gi");
                                    temp = temp.replace(regExp, invoiceData[map[mapKey]]);
                                }
                            }
                            temp += temp3;
                        }
                    }
                    else {
                        for (let mapKey in map) {
                            if (invoiceData[map[mapKey]]) {
                                let regExp = new RegExp(mapKey, "gi");
                                temp = temp.replace(regExp, invoiceData[map[mapKey]]);
                            }
                        }
                    }
                    masterTemplate += temp;
                }
                //console.log(masterTemplate)
                zipEntries.forEach(function (zipEntry) {
                    if (zipEntry.entryName == "word/document.xml") {
                        zip.updateFile(zipEntry.entryName, masterTemplate);
                        console.log("Pandey");
                        // console.log(zip.readAsText(zipEntry.entryName));
                    }
                });
                let ext = path.extname(filePath);
                let base = path.basename(filePath, ext);
                let zipOutputName = `${base}.zip`;
                yield zip.writeZip(zipOutputName);
                let docPath = path.dirname(filePath) + `/${base}${Math.floor(Math.random() * 11)}.docx`;
                console.log("output doc path", docPath);
                console.log("zip path", zipOutputName);
                yield this.sh(`mv ${zipOutputName} ${docPath}`);
                output['docPath'] = docPath;
                output['filePath'] = "done";
                console.log("Socket triggering to Delete Document from S3");
                return { message: "Socket triggering to Delete Document from folder in S3", status: 0, data: output };
            }
            catch (err) {
                console.error("<----- Error in deleteDocumentInS3Folder BOt ---------->>", err);
                return { message: err, status: 1, data: err };
            }
        });
    }
    callbackEvent(db, id) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("   --->>  ", " --->>> ", id, " ----->>   ");
                let data = yield db.collection('events').findOne({ "_id": ObjectId(id), eventStatus: "Completed" });
                console.log(data, "events");
                if (!util_1.isNullOrUndefined(data) && data !== "" && !util_1.isNullOrUndefined(data["eventStatus"]) && data['eventStatus'] == "Completed") {
                    return { status: "Success" };
                }
                else {
                    let wait = yield delay(1000 * 5);
                    console.log("delay", wait);
                    yield this.callbackEvent(db, id);
                    return { status: "callback" };
                }
            }
            catch (err) {
                console.log(err);
                return { status: "error" };
            }
        });
    }
    groupByExcel(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "excelPath": input.excelPath,
                    "usecase": input.usecase,
                    "key": input.key,
                    "values": input.values,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'groupByExcel',
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Socket triggering for uploadFileViaUtility.");
                return { message: 'Socket triggering for uploadFile Via Utility.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering for uploadFileViaUtility." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    createToken(userId, subscriberId, orgId) {
        userId = userId.toString();
        subscriberId = subscriberId.toString();
        orgId = orgId.toString();
        let token = jwt.encode({
            "permission": [],
            "userId": userId,
            "userType": '',
            // "allPermissions":permissions,
            "subscriberId": subscriberId,
            "userName": '',
            "role": '',
            "type": '',
            "accessKeyId": '',
            "secretAccessKey": '',
            "endpoint": '',
            "signatureVersion": '',
            "region": '',
            "Bucket": '',
            "ACL": '',
            // nbf: (Date.now() / 1000),
            exp: ((Date.now() / 1000) + 5400000)
        }, JWT_SECRET);
        return token;
    }
    oAuthTwo(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let clientOAuth2 = require('client-oauth2');
            try {
                return new Promise((resolve, reject) => {
                    let oauth = new clientOAuth2({
                        clientId: input.clientId,
                        clientSecret: input.clientSecret,
                        accessTokenUri: input.accessTokenUri,
                        scopes: input.scopes
                    });
                    oauth.credentials.getToken()
                        .then(function (user) {
                        // console.log(user)
                        let bearer = "Bearer "; //"Bearer " space after Bearer is left intentionally
                        outPut['accessToken'] = user.accessToken;
                        outPut['bearerAccessToken'] = bearer.concat(user.accessToken);
                        // console.log( outPut['bearerAccessToken'])
                        return resolve({ message: '', status: 0, data: outPut });
                    });
                });
            }
            catch (e) {
                console.log('bot1 Error', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    insertDocToDb(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // const mClient = await MongoClient.connect(env.dbConfig.mongodb_uri);
                // const db = mClient.db(env.dbConfig.dbname);
                const collectionName = input.collectionName;
                const referenceNumber = input.referenceNumber;
                let docData;
                console.log(input.document);
                console.log(typeof input.document);
                if (typeof input.document == "object") {
                    docData = input.document;
                }
                else {
                    docData = JSON.parse(input.document);
                }
                if (!util_1.isNullOrUndefined(referenceNumber) && referenceNumber !== "") {
                    docData['referenceNumber'] = referenceNumber;
                }
                // if (!isNullOrUndefined(input.eventDetail)) {
                docData['eventId'] = ObjectId(input.eventId);
                docData['subscriberId'] = ObjectId(input.subscriberId);
                docData['orgId'] = ObjectId(input.orgId);
                docData['isDeleted'] = false;
                //}
                if (!util_1.isNullOrUndefined(input.timeStamp)) {
                    docData['createdAt'] = new Date();
                    docData['updatedAt'] = new Date();
                }
                const insertDoc = yield db.collection(collectionName).insertMany([docData]);
                if (insertDoc.length > 0) {
                    const savedDoc = yield db.collection(collectionName).findOne(docData);
                    console.log("saved doc------>", savedDoc);
                    output['document'] = savedDoc;
                }
                return { message: 'search key value found.', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "key not found", status: 1, data: err };
            }
        });
    }
    insertDocsToDb(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const collectionName = input.collectionName;
                let documents = [];
                if (Array.isArray(input.document)) {
                    documents = input.document;
                }
                else if (typeof input.document === "string") {
                    documents = JSON.parse(input.document);
                }
                else {
                    documents = [input.document];
                }
                documents = documents.map(doc => {
                    return Object.assign({}, doc, { eventId: ObjectId(input.eventId), subscriberId: ObjectId(input.subscriberId), orgId: ObjectId(input.orgId), isDeleted: false }, (input.timeStamp ? { createdAt: new Date(), updatedAt: new Date() } : {}));
                });
                const batchSize = input.batchSize || 500; // Default batch size is 500
                const ordered = input.ordered || false; // Default ordered is false
                for (let i = 0; i < documents.length; i += batchSize) {
                    const batch = documents.slice(i, i + batchSize);
                    yield db.collection(collectionName).insertMany(batch, { ordered });
                }
                const savedDoc = yield db.collection(collectionName).findOne(documents[0]);
                console.log("saved doc------>", savedDoc);
                output['document'] = savedDoc;
                return { message: 'Documents inserted successfully.', status: 0, data: output };
            }
            catch (err) {
                console.log("Error during batch insertion:", err);
                return { message: "Insertion failed.", status: 1, data: err };
            }
        });
    }
    updateDocsToDb(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const collectionName = input.collectionName;
                let documents = [];
                if (Array.isArray(input.document)) {
                    documents = input.document;
                }
                else if (typeof input.document === "string") {
                    documents = JSON.parse(input.document);
                }
                else {
                    documents = [input.document];
                }
                documents = documents.map(doc => {
                    return Object.assign({}, doc, { eventId: ObjectId(input.eventId), subscriberId: ObjectId(input.subscriberId), orgId: ObjectId(input.orgId), isDeleted: false }, (input.timeStamp ? { updatedAt: new Date() } : {}));
                });
                const batchSize = input.batchSize || 500; // Default batch size is 500
                for (let i = 0; i < documents.length; i += batchSize) {
                    const batch = documents.slice(i, i + batchSize);
                    for (const doc of batch) {
                        if (!input.updateFilter) {
                            throw new Error("updateFilter is required for updates.");
                        }
                        let updateFilter = {};
                        if (typeof input.updateFilter === "string") {
                            updateFilter = { [input.updateFilter]: doc[input.updateFilter] };
                        }
                        else if (typeof input.updateFilter === "object") {
                            updateFilter = Object.keys(input.updateFilter).reduce((acc, key) => {
                                acc[key] = doc[key] || input.updateFilter[key];
                                return acc;
                            }, {});
                        }
                        else {
                            throw new Error("Invalid updateFilter format.");
                        }
                        updateFilter = Object.assign({}, updateFilter, { orgId: ObjectId(input.orgId), subscriberId: ObjectId(input.subscriberId) });
                        const updateOperation = {
                            $set: Object.assign({}, doc, { updatedAt: new Date() }),
                            $setOnInsert: { createdAt: new Date() }
                        };
                        yield db.collection(collectionName).updateOne(updateFilter, updateOperation, { upsert: true });
                    }
                }
                const savedDoc = yield db.collection(collectionName).findOne(documents[0]);
                console.log("Saved document:", savedDoc);
                output['document'] = savedDoc;
                return { message: 'Documents updated successfully.', status: 0, data: output };
            }
            catch (err) {
                console.error("Error during batch update:", err);
                return { message: "Update failed.", status: 1, data: err };
            }
        });
    }
    findDocInDb(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // const mClient = await MongoClient.connect(env.dbConfig.mongodb_uri);
                // const db = mClient.db(env.dbConfig.dbname);
                const collectionName = input.collectionName;
                const fieldName = input.fieldName.split(",");
                const fieldValue = input.fieldValue.split(",");
                let searchObj = {};
                if (fieldName.length != 0) {
                    fieldName.forEach((field, i) => {
                        if (!util_1.isNullOrUndefined(fieldValue[i])) {
                            searchObj[field] = fieldValue[i];
                        }
                        else {
                            searchObj[field] = '';
                        }
                    });
                }
                //searchObj[fieldName] = fieldValue
                let matchedDoc;
                if (!util_1.isNullOrUndefined(searchObj) && Object.keys(searchObj).length > 0) {
                    matchedDoc = yield (db.collection(collectionName)).find(searchObj);
                    matchedDoc = JSON.parse(JSON.stringify(matchedDoc));
                    //matchedDoc = await db.collection(collectionName).find(searchObj).toArray()
                }
                let count = matchedDoc.length;
                if (matchedDoc.length > 0) {
                    output['count'] = count;
                    output['docs'] = matchedDoc;
                    output['doc'] = matchedDoc[0];
                }
                else {
                    output['docs'] = [];
                    output['count'] = count;
                }
                return { message: 'search key value found.', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "key not found", status: 1, data: err };
            }
        });
    }
    updateDocInDb(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                //const mClient = await MongoClient.connect(env.dbConfig.mongodb_uri);
                //const db = mClient.db(env.dbConfig.dbname);
                const collectionName = input.collectionName;
                const fieldName = input.fieldName;
                const fieldValue = input.fieldValue;
                let searchObj = {};
                searchObj[fieldName] = fieldValue;
                let updateValue;
                if (typeof input.updateValue === "string") {
                    updateValue = JSON.parse(input.updateValue);
                }
                else {
                    updateValue = input.updateValue;
                }
                let result = 0;
                if (!util_1.isNullOrUndefined(updateValue) && !util_1.isNullOrUndefined(searchObj) && Object.keys(searchObj).length > 0 && Object.keys(updateValue).length > 0) {
                    if (!util_1.isNullOrUndefined(updateValue['_id'])) {
                        delete updateValue['_id'];
                    }
                    const updated = yield db.collection(collectionName).updateOne(searchObj, { $set: updateValue }, { upsert: true });
                    if (updated.nModified !== 0) {
                        result = 1;
                    }
                }
                if (!util_1.isNullOrUndefined(input.filePath) && input.filePath.length > 0) {
                    output['filePath'] = input.filePath;
                }
                output['result'] = result;
                return { message: 'search key value found.', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "key not found", status: 1, data: err };
            }
        });
    }
    mergeToSingleObject(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                return new Promise((resolve, reject) => {
                    if (input.appendToInput == "false") {
                        if (typeof input.ObjectToAppend == "string") {
                            input.ObjectToAppend = JSON.parse(input.ObjectToAppend);
                        }
                        let newObject = input.ObjectToAppend;
                        delete input.eventId;
                        delete input.userId;
                        delete input.userName;
                        delete input.userType;
                        delete input.subscriberId;
                        delete input.orgId;
                        delete input.ObjectToAppend;
                        delete input.accessControlList;
                        delete input.appendToInput;
                        console.log("input--->", input);
                        for (let child in input) {
                            console.log(child);
                            newObject[child] = input[child];
                        }
                        ;
                        console.log("newObject-->", newObject);
                        //input.ObjectToAppend[input.appendKey] = input.appendValue;
                        outPut['newObject'] = newObject;
                    }
                    else {
                        delete input.eventId;
                        delete input.userId;
                        delete input.userName;
                        delete input.userType;
                        delete input.subscriberId;
                        delete input.orgId;
                        delete input.accessControlList;
                        outPut['newObject'] = input;
                    }
                    return resolve({ message: 'appended successfully', status: 0, data: outPut });
                });
            }
            catch (e) {
                console.log('bot1 Error', e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    sendDataToDB(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            console.log('sendDataToDB-------------- ', typeof input.data);
            try {
                let response;
                let todo = input.todo;
                let data = input.data;
                if (typeof data !== 'object')
                    data = JSON.parse(input.data);
                let collection = input.collection;
                const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                const db = mClient.db(env_2.env.dbConfig.dbname);
                const token = input.eventId;
                if (!util_1.isNullOrUndefined(data)) {
                    if (todo == 'insert') {
                        console.log('aaaaaaaaa', data, "ddddddddd", collection);
                        if (!Array.isArray(data)) {
                            if (!util_1.isNullOrUndefined(data)) {
                                if (data._id)
                                    delete data._id;
                                response = yield db.collection(collection).insert(data);
                            }
                        }
                        else {
                            const country = input.country;
                            console.log('token---------', token);
                            data = data.map(order => { return Object.assign({}, order, { enterprise_code: country, token: token }); });
                            console.log('data -------------- ', data);
                            response = yield db.collection(collection).insert(data);
                            output['token'] = token;
                        }
                        // console.log("ddddddd", mClient, "eeeeeeeeeee", db)
                        // if (!isNullOrUndefined(data)) {
                        //  delete order.type;
                    }
                    else if (todo == 'update') {
                        if (data._id)
                            delete data._id;
                        response = yield db.collection(collection).updateOne({ order_no: data.order_no }, data);
                    }
                    console.log('response', response.result);
                    output['outputBody'] = 'done';
                    console.log('output--------', output);
                    return { message: "Process sucessfully completed", status: 0, data: output };
                    // }
                }
                else {
                    console.log("no data to enter in db");
                    output['token'] = token;
                    output['outputBody'] = 'notDone';
                    console.log('output--------', output);
                    return { message: "no data to enter in db", status: 0, data: output };
                }
                // return { message: "Process sucessfully completed", status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    convertPDFtoPages(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let imagesPathaaray;
                let filePath = input.filePath;
                // let filePath = "/home/user/Videos/inputPdfs/1.pdf"
                this.log.info("In convert pdftopng==============");
                console.log("---------------body---", JSON.stringify(input));
                console.log("filepath---", filePath);
                if ((!util_1.isNullOrUndefined(filePath)) && (filePath !== '')) {
                    let ext = path.extname(filePath);
                    let base = path.basename(filePath);
                    let extension = !util_1.isNullOrUndefined(ext) ? ext : '';
                    if (extension !== '' && base !== '') {
                        if (extension.toLowerCase() === '.pdf') {
                            let name = base.split('.');
                            let path = config.cudapath;
                            //let path = '/home/user/Music/PDFtest/';
                            const pdf = yield mzfs.readFile(filePath);
                            const pages = yield splitPDF(pdf);
                            console.log(pages.length);
                            let imagesPath = [];
                            let counter = 0;
                            if (pages.length <= 1) {
                                let pathName = path + name[0] + ".pdf";
                                yield mzfs.writeFile(pathName, pages[0]);
                                imagesPath.push({ imageFilePath: pathName });
                                console.log("single PDF", imagesPath);
                            }
                            else {
                                pages.forEach((list, index) => {
                                    let imgpath = path + name[0] + '-' + counter + '.pdf';
                                    mzfs.writeFileSync(imgpath, pages[index]);
                                    imagesPath.push({ imageFilePath: imgpath });
                                    counter++;
                                });
                            }
                            let tmp = [];
                            let temp = [];
                            for (let index = 0; index < imagesPath.length; index++) {
                                const element = imagesPath[index];
                                if (fs.existsSync(element.imageFilePath)) {
                                    console.log('file existsfirsttttt!!!');
                                    temp.push(element);
                                }
                                else {
                                    console.log('file not exists!!!!!!!!!!!');
                                    tmp.push(element);
                                }
                            }
                            console.log("tmppp", tmp.length);
                            if (tmp.length != 0) {
                                imagesPath = temp;
                            }
                            else {
                                console.log("--------------file found successfullyyyy");
                            }
                            console.log("imagesPath-------new-", imagesPath);
                            imagesPathaaray = imagesPath;
                            outputParameters['imagesPathArray'] = imagesPathaaray;
                            return ({ message: 'pdf found', status: 0, data: outputParameters });
                        }
                        else {
                            this.log.info("this is a png files-----------------------");
                            let imagesPath = [];
                            imagesPath.push({ imageFilePath: filePath });
                            imagesPathaaray = imagesPath;
                            outputParameters['imagesPathArray'] = imagesPathaaray;
                            console.log("imagesPatharray of png output-", imagesPathaaray);
                            return ({ message: 'not pdf file', status: 0, data: outputParameters });
                            // callback(null, fileData);
                        }
                    }
                    else {
                        // logger.error('File Path Not Found');
                        throw 'File Path Not Found';
                    }
                }
                else {
                    // logger.error('File Path Not Found');
                    throw 'File Path Not Found';
                }
            }
            catch (err) {
                console.log("errrrrrrrrrr", err);
                return { message: "pdf not found .", status: 1, data: err };
            }
        });
    }
    typeOfFile(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let filePath = input.filePath;
                console.log(input.filePath);
                if (!fs.existsSync(input.filePath)) {
                    throw new Error("File not exists..");
                }
                let extension = path.extname(filePath);
                console.log(extension);
                let ispdfreader = false;
                if (/(pdf)/i.test(extension)) {
                    let dataBuffer = fs.readFileSync(filePath);
                    console.log("abc");
                    yield pdf(dataBuffer).then(function (data) {
                        // number of pages
                        console.log(data.numpages, "numpages");
                        // number of rendered pages
                        console.log(data.numrender, "numrender");
                        // PDF info
                        console.log(data.info, "info");
                        // PDF metadata
                        console.log(data.metadata, "metadata");
                        // PDF.js version
                        // check https://mozilla.github.io/pdf.js/getting_started/
                        console.log(data.version, "version");
                        // PDF text
                        let page = Number(data.numpages);
                        page = page * 2;
                        console.log(page + 5, "oh ho");
                        console.log(data.text.length);
                        if (data.text.length < page + 5) {
                            console.log("image pdf.......=======>");
                            extension = ".png";
                            //    console.log(data.text,"sorry");
                            ispdfreader = false;
                        }
                        else {
                            console.log("text pdf.......=======>");
                            //    console.log(data.text,"text");
                            ispdfreader = true;
                        }
                    });
                    console.log("ghi");
                }
                else {
                    console.log("not pdf.......=======>");
                    ispdfreader = false;
                }
                extension = extension.substring(1);
                outputParameters['pdfFilePath'] = filePath;
                outputParameters['ispdf'] = ispdfreader;
                outputParameters['extensions'] = extension;
                this.log.info("type of document found.");
                return { message: 'type of document found', status: 0, data: outputParameters };
            }
            catch (e) {
                outputParameters['pdfFilePath'] = input.filePath;
                outputParameters['ispdf'] = false;
                this.log.error("type of document not found ." + e);
                return { message: "type of document not found .", status: 0, data: outputParameters };
            }
        });
    }
    newTypeOfFile(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const mime = require('mime-types');
                const excelMimeTypes = [
                    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
                    'application/vnd.ms-excel',
                ];
                const pdfMimeType = 'application/pdf';
                const imageMimeTypes = [
                    'image/jpeg',
                    'image/png',
                    'image/gif',
                    'image/bmp',
                    'image/webp',
                    'image/svg+xml',
                    'image/tiff',
                    'image/x-icon',
                ];
                const docxMimeType = ['application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/msword']; // .docx
                let filePath = input.filePath;
                let ispdfreader;
                if (!fs.existsSync(input.filePath)) {
                    throw new Error("File not exists..");
                }
                const fileType = mime.lookup(filePath);
                console.log(input.filePath, fileType);
                if (fileType === pdfMimeType) {
                    let dataBuffer = fs.readFileSync(filePath);
                    yield pdf(dataBuffer).then(function (data) {
                        console.log(data.numpages, "numpages");
                        console.log(data.numrender, "numrender");
                        console.log(data.info, "info");
                        console.log(data.metadata, "metadata");
                        console.log(data.version, "version");
                        let page = Number(data.numpages);
                        page = page * 2;
                        console.log(page + 5, "oh ho");
                        console.log(data.text.length);
                        if (data.text.length < page + 5) {
                            console.log("image pdf.......=======>");
                            ispdfreader = 'Image';
                        }
                        else {
                            console.log("text pdf.......=======>");
                            //    console.log(data.text,"text");
                            ispdfreader = 'Pdf';
                        }
                    });
                }
                else if (docxMimeType.includes(fileType)) {
                    console.log("DOCX.......=======>");
                    ispdfreader = "Docx";
                }
                else if (imageMimeTypes.includes(fileType)) {
                    console.log("Image.......=======>");
                    ispdfreader = "Image";
                }
                else if (excelMimeTypes.includes(fileType)) {
                    console.log("Excel.......=======>");
                    ispdfreader = "Excel";
                }
                else {
                    ispdfreader = "Image";
                }
                outputParameters['pdfFilePath'] = filePath;
                outputParameters['ispdf'] = ispdfreader;
                outputParameters['extensions'] = fileType;
                this.log.info("type of document found.");
                return { message: 'type of document found', status: 0, data: outputParameters };
            }
            catch (e) {
                outputParameters['pdfFilePath'] = input.filePath;
                outputParameters['ispdf'] = "Image";
                this.log.error("type of document not found ." + e);
                return { message: "type of document not found .", status: 0, data: outputParameters };
            }
        });
    }
    fetchImage(body, headerParams) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const self = this;
            try {
                let fileRefNum = body.fileRefNum;
                let PDF_PATH = body.filePath;
                if (util_1.isNullOrUndefined(PDF_PATH)) {
                    let data = yield (db.collection('fileuploadhistories')).findOne({ fileRefNum: fileRefNum }).lean();
                    PDF_PATH = data['filePath'];
                }
                let dObj = {
                    body: body,
                    referNo: headerParams['referNo'],
                    filePath: PDF_PATH,
                    status: "inProgress",
                    subscriberId: ObjectId(headerParams.subscriberId),
                    orgId: ObjectId(headerParams.orgId)
                };
                let temp = yield (db.collection("FetchImageStatus", { timestamps: true })).create(dObj);
                console.log(temp);
                let output = {};
                if (!util_1.isNullOrUndefined(PDF_PATH)) {
                    let data = yield self.convertPdftoPng({ filePath: PDF_PATH }, output, null, null, null);
                    if (data['status'] == 0 && output['imagesPathaaray']) {
                        if (body.fileRefNum) {
                            let re = yield db.collection('fileuploadhistories').updateOne({ fileRefNum: fileRefNum }, { $set: { imagesPath: output['imagesPathaaray'] } });
                            console.log("Updated fileuploadhistories...", re);
                        }
                        let temp = yield (db.collection("FetchImageStatus", { timestamps: true })).updateOne({ referNo: headerParams['referNo'] }, {
                            $set: {
                                status: "completed",
                            }
                        });
                        console.log(temp);
                        output['status'] = 'completed';
                        return { message: 'file found', status: 0, data: output };
                    }
                    else {
                        throw data['err'];
                    }
                }
                else {
                    return { message: 'No file found', status: 1, data: 'No file found' };
                }
            }
            catch (err) {
                let temp = yield (db.collection("FetchImageStatus", { timestamps: true })).updateOne({ referNo: headerParams['referNo'] }, {
                    set: {
                        status: "failed",
                        error: err
                    }
                });
                console.log("convertion failed", err, temp);
                return { message: err, status: 1, data: "Internal Server Error" };
            }
        });
    }
    checkfetchImage(body, headerParams) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("referNo------", body.referNo);
                if (body.referNo) {
                    let temp = yield (db.collection("FetchImageStatus", { timestamps: true })).findOne({ referNo: body.referNo });
                    temp = JSON.parse(JSON.stringify(temp));
                    if (temp.status) {
                        return {
                            message: "ImageGeneration Completed",
                            status: 0,
                            data: {
                                status: temp.status
                            },
                        };
                    }
                    else {
                        throw "Not Found ReferNo";
                    }
                }
                else {
                    return {
                        message: "Invalid input..",
                        status: 1,
                    };
                }
            }
            catch (err) {
                this.log.info("convertion failed", err);
                return { message: err, status: 1, data: err };
            }
        });
    }
    convertPdftoPng(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const self = this;
            try {
                if (!util_1.isNullOrUndefined(input.filePath)) {
                    // using the PDFBox module to extract the images
                    let PDF_PATH = input.filePath;
                    let ext = path.extname(PDF_PATH);
                    let base = path.basename(PDF_PATH);
                    let extension = !util_1.isNullOrUndefined(ext) ? ext : '';
                    if (extension !== '' && base !== '') {
                        if (extension.toLowerCase() === '.pdf' || extension.toLowerCase() === '.tif') {
                            let dpi = input.dpi && !isNaN(Number(input.dpi)) ? Number(input.dpi) : 300;
                            let publicPath = config.cudapath;
                            let inputIObj = {
                                "inputPath": PDF_PATH,
                                "function": "convertPng",
                                "dpi": dpi,
                                "output_png": publicPath,
                                "botOutput": publicPath + `${input.eventId}output.txt`
                            };
                            let parameters = JSON.stringify(JSON.stringify(inputIObj));
                            let res = yield this.sh("java -cp .:json-20190722.jar:pdfbox-2.0.3.jar:fontbox-2.0.3.jar:commons-logging-1.2.jar:json-simple-1.1.1.jar:jbig2-imageio-3.0.0.jar:itextpdf-5.5.13.1.jar:kernel-7.1.12.jar:io-7.1.12.jar:layout-7.1.12.jar:slf4j-api-1.7.30.jar:slf4j-simple-1.7.30.jar:commons-lang3-3.11.jar:bcprov-jdk15on-166.jar NewPdfBox " + parameters);
                            console.log("This is for checking the result---", res, "java -cp .:json-20190722.jar:pdfbox-2.0.3.jar:fontbox-2.0.3.jar:commons-logging-1.2.jar:json-simple-1.1.1.jar:jbig2-imageio-3.0.0.jar:itextpdf-5.5.13.1.jar:kernel-7.1.12.jar:io-7.1.12.jar:layout-7.1.12.jar:slf4j-api-1.7.30.jar:slf4j-simple-1.7.30.jar:commons-lang3-3.11.jar:bcprov-jdk15on-166.jar NewPdfBox " + parameters);
                            if (res['status'] == 1 && !util_1.isNullOrUndefined(res['err']) && !util_1.isNullOrUndefined(res['err']['message']) && res['err']['message'].includes('Command failed')) {
                                console.log("res[status]-in If  --->>", res['status']);
                                output['data'] = 'Seems some issue while reading the PDF';
                                output['curruptFile'] = true;
                            }
                            try {
                                let finalOutput = fs.readFileSync(inputIObj.botOutput, { encoding: 'utf8' });
                                finalOutput = JSON.parse(finalOutput);
                                if (Array.isArray(finalOutput) && finalOutput.length != 0) {
                                    output['imagesPathaaray'] = finalOutput;
                                }
                            }
                            catch (e) {
                                console.log("Error for PDFBox---", e);
                            }
                            console.log('Output after PDFBox-----', output);
                            if (util_1.isNullOrUndefined(output['imagesPathaaray'])) {
                                // pdftoppm conversion if java module not worked
                                let pdftoppm = yield this.convertPdftoImagePdftoppm(input, output, botId, projectId, iterationId);
                                let data = pdftoppm['data'];
                                if (data['imageArr']) {
                                    output['imagesPathaaray'] = JSON.parse(JSON.stringify(data['imageArr']));
                                }
                            }
                            console.log('Output after convertPdftoImagePdftoppm-----', output);
                            if (util_1.isNullOrUndefined(output['imagesPathaaray'])) {
                                // convert imagemagic conversion if pdftoppm module not worked
                                let name = base.split('.');
                                let path = config.path;
                                console.log("text based pdf   ======>");
                                console.time("convert");
                                let execute = yield self.sh('convert  -density 300 -strip -background white -alpha remove ' + PDF_PATH + ' -verbose ' + path + name[0] + '.png');
                                console.timeEnd("convert");
                                if (execute['err']) {
                                    throw execute['err'];
                                }
                                else {
                                    let ssd = execute['stderr'];
                                    if (ssd !== '') {
                                        ssd = ssd.split('\n');
                                        ssd.pop();
                                        ssd = ssd.filter(a => !/(^\*)|(Error)|(Output may be incorrect)/.test(a.trim())); //for handling exceptions for imageMagic
                                    }
                                    let imagesPath = [];
                                    let counter = 0;
                                    console.log("SSDDDDDDDDD LENGHT AJIANKAIUAIA" + ssd.length);
                                    if (ssd.length <= 1) {
                                        imagesPath.push({ imageFilePath: path + name[0] + ".png" });
                                    }
                                    else {
                                        ssd.forEach((list) => {
                                            if (list.trim() !== '') {
                                                let imgpath = path + name[0] + '-' + counter + '.png';
                                                imagesPath.push({ imageFilePath: imgpath });
                                                counter++;
                                            }
                                        });
                                    }
                                    console.log("Converted-------", imagesPath);
                                    output['imagesPathaaray'] = JSON.parse(JSON.stringify(imagesPath));
                                }
                            }
                            console.log('Output after imagemagic-----', output);
                        }
                        else {
                            console.log("this is a png files-----------------------");
                            let publicPath = config.cudapath;
                            yield this.sh("cp " + PDF_PATH + " " + publicPath);
                            let fileName = path.basename(PDF_PATH);
                            let new_filepath = path.join(publicPath, fileName);
                            let imagesPath = [];
                            imagesPath.push({ imageFilePath: new_filepath });
                            output['imagesPathaaray'] = imagesPath;
                            console.log("imagesPatharray of png output-", output['imagesPathaaray']);
                        }
                    }
                    if (output['imagesPathaaray']) {
                        return { message: 'file found', status: 0, data: output };
                    }
                    else {
                        throw "Not generated the Images...";
                    }
                }
                else {
                    return { message: 'No file found', status: 1, data: 'No file found' };
                }
            }
            catch (err) {
                // console.log("Error!!! -> " + err);
                console.log("convertion failed", err);
                return { message: err, status: 1, data: String(err) };
            }
        });
    }
    NthWord(line, splitBy, index) {
        let Splitline = line.split(splitBy);
        if (index == 121 || index == '121') {
            return Splitline[Splitline.length - 1];
        }
        if (index == 420 || index == '420') {
            return Splitline[Splitline.length - 3];
        }
        if (index == 666 || index == '666') {
            return Splitline[Splitline.length - 2];
        }
        if (Splitline.length < index) {
            return 'non';
        }
        return Splitline[index];
    }
    pdfParserJavaInvoice(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let exceptN = input.imageException && [true, 'true'].includes(input.imageException) ? true : false;
            try {
                let self = this;
                let pdfPath = input.PDF_PATH;
                let minArea = !util_1.isNullOrUndefined(input.minArea) ? input.minArea : 0.05;
                let language_identify = input.language_identify;
                let totalArray;
                let pdfParserOutput = [];
                let areaCovered = [];
                console.log("PDF path", pdfPath, "---- TYPE OF -------- >> ", typeof pdfPath);
                return yield new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    //let renamedPATH = PDF_PATH.replace(/[ !@#$%^&*()<>~{}?|]/g, '');
                    //console.log(renamedPATH);
                    //fs.renameSync(PDF_PATH, renamedPATH);
                    let randomNo = Math.floor(Math.random() * 10000);
                    let randomString = randomNo.toString();
                    console.log(randomNo, randomString);
                    let javaJsonFolder = env_2.env.fileConfig.javaJsonFolder; //"../javaJsonFolder/";
                    if (!fs.existsSync(javaJsonFolder)) {
                        fs.mkdirSync(javaJsonFolder);
                    }
                    // let aa = PDF_PATH.lastIndexOf('.')
                    console.info(" < ---- ----- INSIDE PDF_PATH ARRAY INSIDE ARRAY -------- -------- >> ", javaJsonFolder, " ---- INDEX ---");
                    let jsonFileName = pdfPath.substr(pdfPath.lastIndexOf('/') + 1) + ".json";
                    let finalJsonPath = javaJsonFolder + randomString + jsonFileName;
                    //let jsonPath = "../../../../../.." + jsonFileName;
                    //console.log(process.cwd());
                    //let repoRootPath = process.cwd();
                    //let jsonPath = repoRootPath.substring(0, repoRootPath.lastIndexOf('/'));
                    let inputObj = {
                        "finalJsonPath": finalJsonPath,
                        "pdfPath": pdfPath,
                        "isType": false
                    };
                    let parameters = JSON.stringify(JSON.stringify(inputObj));
                    let res = yield self.sh("java -cp .:json-20190722.jar:pdfbox-2.0.3.jar:fontbox-2.0.3.jar:commons-logging-1.2.jar:json-simple-1.1.1.jar:jbig2-imageio-3.0.0.jar:itextpdf-5.5.13.1.jar:kernel-7.1.12.jar:io-7.1.12.jar:layout-7.1.12.jar:slf4j-api-1.7.30.jar:slf4j-simple-1.7.30.jar:commons-lang3-3.11.jar GetPdfData " + parameters);
                    if (!util_1.isNullOrUndefined(res)) {
                        console.log("res[status]---->>", res);
                        if (fs.existsSync(finalJsonPath)) {
                            totalArray = JSON.parse(fs.readFileSync(finalJsonPath, { encoding: 'utf8' }));
                        }
                        else {
                            totalArray = [];
                            console.log("Error while reading JSON file!");
                        }
                        if (totalArray.length == 0) {
                            output['data'] = 'Seems some issue while reading the PDF' + pdfPath;
                            output['output'] = [];
                            output['imageFlow'] = true;
                            if (exceptN) {
                                resolve({ message: res['err'] + pdfPath, status: 0, data: output });
                            }
                            else {
                                resolve({ message: res['err'] + pdfPath, status: 1, data: {} });
                            }
                        }
                    }
                    let rs = yield self.extractImages(totalArray, pdfPath, language_identify);
                    console.log("{ status : ", rs['status'], " }");
                    if (rs['imageArr'] && rs['imageArr'].length > 0) {
                        // rs['imageArray'] = rs['imageArr'];
                    }
                    if (rs['imageArray'] && rs['imageArray'].length > 0) {
                        let chkImageFlow = self.checkPDFIssues(totalArray, rs['imageArray']);
                        if (!util_1.isNullOrUndefined(chkImageFlow['status'])) {
                            output['imageFlow'] = chkImageFlow['imageFlow'];
                        }
                    }
                    output['imageFlow'] = output['imageFlow'] ? output['imageFlow'] : false;
                    let pages = [...new Set(totalArray.map(a => a.pageId))].map(a => Number(a));
                    // for first blank page, data is not coming, so iterating the loop till the last page
                    if (Array.isArray(pages) && !output['imageFlow']) {
                        for (let index = 0, lastPage = Math.max(...pages); index <= lastPage; index++) {
                            let pageNo = index;
                            console.info(" < ---- ----- INSIDE PAGE ARRAY INSIDE ARRAY -------- -------- >> ", pageNo);
                            let finalArray = totalArray.filter(a => a.pageId == pageNo);
                            finalArray = JSON.parse(JSON.stringify(finalArray));
                            finalArray = finalArray.filter(obj => obj.line.trim() != '');
                            //to check whether 5% area of total pdf has been covered with text or not
                            let aObj;
                            let totalArea = finalArray.length > 0 ? (finalArray[0].pageHeight * finalArray[0].pageWidth) : 0;
                            if (totalArea == 0 && finalArray.length == 0) {
                                output['imageFlow'] = true;
                                aObj = {
                                    "tA": totalArea,
                                    "cA": 0
                                };
                            }
                            else {
                                let thresholdArea = totalArea * minArea;
                                let totalN = finalArray.length;
                                let n = 0, sumArea = 0;
                                while (n < totalN) {
                                    sumArea = sumArea + (finalArray[n].width * finalArray[n].fontSize);
                                    n++;
                                }
                                if (!util_1.isNullOrUndefined(rs['imageArr']) && rs['imageArr'].length > 2) {
                                    let count = 0;
                                    for (let i = 0; i < rs['imageArr'].length; i++) {
                                        let element = rs['imageArr'][i];
                                        if (element.includes('/' + index + '_')) {
                                            count = count + 1;
                                        }
                                        if (i == rs['imageArr'].length - 1 && (rs['imageArr'].length / count) == 1) {
                                            output['imageFlow'] = true;
                                        }
                                    }
                                }
                                if (sumArea <= thresholdArea && (index == 0 || !(index == pages.length - 1))) {
                                    let imageExist = false;
                                    if (rs['imageArr'] && rs['imageArr'].length > 0) {
                                        for (let i = 0; i < rs['imageArr'].length; i++) {
                                            let element = rs['imageArr'][i];
                                            if (element.includes('/' + index + '_')) {
                                                imageExist = true;
                                            }
                                        }
                                        if (!imageExist && (util_1.isNullOrUndefined(output['imageFlow']) || !output['imageFlow'])) {
                                            output['imageFlow'] = false;
                                        }
                                        else {
                                            output['imageFlow'] = true;
                                            ;
                                        }
                                    }
                                    else {
                                        output['imageFlow'] = true;
                                        ;
                                    }
                                }
                                aObj = {
                                    "tA": totalArea,
                                    "cA": sumArea
                                };
                            }
                            areaCovered.push(aObj);
                            pdfParserOutput.push(finalArray);
                            self.log.info("pdf read successfully.");
                        }
                        // output['output'] = pdfParserOutput;
                        output['ocr_output'] = pdfParserOutput;
                        output['areaCovered'] = areaCovered;
                        output['imageFlow'] = output['imageFlow'] ? output['imageFlow'] : false;
                        console.info(" < ---- ----- BEFORE PDF_PATH ARRAY INSIDE ARRAY RESOLVE -------- -------- >> ", output['imageFlow'], Object.keys(output), pdfParserOutput.length);
                        resolve({ message: "Process  sucessfully completed", status: 0, data: output });
                    }
                    else if (input.imageException && output['imageFlow']) {
                        console.log("From Image Exception :-", output['imageFlow']);
                        resolve({ message: "Process  sucessfully completed", status: 0, data: output });
                    }
                    else {
                        resolve({ message: "PDF_PATH is NOT in ARRAY", status: 1, data: "PDF_PATH is NOT in ARRAY" });
                    }
                }));
            }
            catch (err) {
                // console.log("Error!!! -> " + err);
                this.log.info("pdf not readed successfully.");
                if (exceptN) {
                    return { message: err, status: 0, data: output };
                }
                else {
                    return { message: err, status: 1, data: err };
                }
            }
        });
    }
    // public async getImages(input, output, botId, projectId, iterationId) {
    //     input.PDF_PATH="/home/user/Videos/inputPdfs/DN 1303 - Emp ID 703.pdf"
    //     console.log("In new pdfParserJava, FileName==" + input.PDF_PATH);
    //     // let TableArray=[];
    //     // let images = await this.extractImages(TableArray,input);
    //     // output['images']=images;
    //     output['path']=input.PDF_PATH;
    //     return { message: "Process  sucessfully completed", status: 0, data: output };
    //     try {
    //     } catch(err){
    //         this.log.info("pdf not readed successfully.");
    //         return { message: err, status: 1, data: err };
    //     }
    // }
    extractImages(finalArray, PDF_PATH, language_identify = 'English') {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // let PDF_PATH=PDF_PATH
                let self = this;
                // let javaJsonFolder = env.fileConfig.javaJsonFolder;   //"../javaJsonFolder/";
                let javaJsonFolder = config.cudapath;
                // let javaJsonFolder= "/var/www/cuda-fs/";
                if (!fs.existsSync(javaJsonFolder)) {
                    fs.mkdirSync(javaJsonFolder);
                }
                let randomNo = Math.floor(Math.random() * 10000);
                let randomString = randomNo.toString();
                let imageFolder = javaJsonFolder + randomString + PDF_PATH.substring(PDF_PATH.lastIndexOf('/') + 1) + "_image/";
                let imageJsonPath = javaJsonFolder + randomString + PDF_PATH.substring(PDF_PATH.lastIndexOf('/') + 1) + "_image.json";
                let inputIObj = {
                    "outputPath": imageJsonPath,
                    "imageFolder": imageFolder,
                    "inputPath": PDF_PATH,
                    "function": "extractImages"
                };
                let parameters = JSON.stringify(JSON.stringify(inputIObj));
                return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    let res = yield this.sh("java -cp .:json-20190722.jar:pdfbox-2.0.3.jar:fontbox-2.0.3.jar:commons-logging-1.2.jar:json-simple-1.1.1.jar:jbig2-imageio-3.0.0.jar:itextpdf-5.5.13.1.jar:kernel-7.1.12.jar:io-7.1.12.jar:layout-7.1.12.jar:slf4j-api-1.7.30.jar:slf4j-simple-1.7.30.jar:commons-lang3-3.11.jar NewPdfBox " + parameters);
                    // let inputIObj = {
                    //     "outputPath": imageJsonPath,
                    //     "imageFolder": imageFolder,
                    //     "inputPath": PDF_PATH,
                    // };
                    if (!util_1.isNullOrUndefined(res)) {
                        console.log("res[status]---->>", res);
                        if (res['status'] == 1 && !util_1.isNullOrUndefined(res['err']) && !util_1.isNullOrUndefined(res['err']['message']) && res['err']['message'].includes('Command failed')) {
                            console.log("res[status]-in If  --->>", JSON.stringify(res));
                            resolve({ message: res['err'] + inputIObj.inputPath, status: 1, data: 'Seems some issue while rxtracting Images the PDF' + inputIObj.inputPath });
                        }
                        let imageArray;
                        if (fs.existsSync(inputIObj.outputPath)) {
                            imageArray = JSON.parse(fs.readFileSync(inputIObj.outputPath, { encoding: 'utf8' }));
                        }
                        else {
                            console.log("IMAGE Error while reading JSON file!");
                        }
                        if (!util_1.isNullOrUndefined(imageArray) && imageArray.length > 0) {
                            let imageArrReq = [], imageArr = [];
                            for (let i = 0; i < imageArray.length; i++) {
                                imageArrReq.push({
                                    "imageFilePath": imageArray[i].location
                                });
                                imageArr.push(imageArray[i].location);
                            }
                            let body = {
                                "input": {
                                    "ImagesPath_Array": imageArrReq,
                                    "language_identify": language_identify ? language_identify : "English",
                                    "rec_model": "paddleocr",
                                    "tesseract_model": "eng",
                                    "iowrite": "False"
                                },
                            };
                            var options = {
                                method: 'POST',
                                url: env_2.env.routes.gibots_ocr + "gibots-ocr/tesseract_ocr",
                                // url: "http://ocri.gibots.com:1443/" + "gibots-ocr/ocr",
                                // url:"http://localhost:3020/"+"gibots-ocr/ocr",
                                // headers: headers,
                                body: body,
                                json: true
                            };
                            console.log("pratik--------", JSON.stringify(options));
                            let response = yield self.remoteApiCall(options);
                            let ocrOutput = response['data'];
                            if (response['data'] && response['status'] == 0 && ocrOutput) {
                                if (ocrOutput.length == imageArr.length) {
                                    for (let i = 0; i < imageArray.length; i++) {
                                        imageArray[i]['ocrObj'] = ocrOutput[i];
                                    }
                                }
                                let indx = 0;
                                for (let i = 0; i < imageArray.length; i++) {
                                    let textAfterImage = finalArray.filter(a => a.pageId == imageArray[i].pageId && a.top >= imageArray[i].yPos && a.lineleft >= imageArray[i].xSF);
                                    textAfterImage.length ? textAfterImage[0]['addOCR'] = true : (finalArray.length ? finalArray[0]['addOCR'] = true : finalArray = [{ 'addOCR': true }]);
                                    for (let j = indx; j < finalArray.length; j++) {
                                        if (imageArray[i].pageId == finalArray[j].pageId && finalArray[j]['addOCR']) {
                                            for (let k = 0; k < imageArray[i]['ocrObj'].length; k++) {
                                                let wordObj = imageArray[i]['ocrObj'][k];
                                                wordObj.leftX = (wordObj.leftX / 4.16666666667);
                                                wordObj.rightX = (wordObj.rightX / 4.16666666667);
                                                wordObj.topY = (wordObj.topY / 4.16666666667);
                                                wordObj.bottomY = (wordObj.bottomY / 4.16666666667);
                                                let obj = {
                                                    "cropboxX": 0,
                                                    "cropboxY": 0,
                                                    "fontSizetf": ((wordObj.bottomY - wordObj.topY)) * 2,
                                                    "line": wordObj.Name,
                                                    "bold": false,
                                                    "pageId": finalArray[j].pageId,
                                                    "pageHeight": finalArray[j].pageHeight,
                                                    "italic": false,
                                                    "YScale": imageArray[i].yScale,
                                                    "pageWidth": finalArray[j].pageWidth,
                                                    "lineright": imageArray[i].xPos + (wordObj.rightX - wordObj.leftX),
                                                    "fontName": "FAAAAH+ArialMT",
                                                    "top": imageArray[i].yPos + wordObj.topY,
                                                    "left": imageArray[i].xPos + wordObj.leftX,
                                                    "width": wordObj.rightX - wordObj.leftX,
                                                    "XScale": imageArray[i].xScale,
                                                    // "Y":103.14105224609375,
                                                    "Height": (wordObj.bottomY - wordObj.topY),
                                                    "fontSize": ((wordObj.bottomY - wordObj.topY)) * 2,
                                                    "text": wordObj.Name,
                                                    "lineleft": imageArray[i].xPos
                                                };
                                                finalArray.splice(j + k, 0, obj);
                                                indx = j + k + 1;
                                                // j=j+k;
                                            }
                                            // flag=true;
                                            break;
                                        }
                                    }
                                    // if(flag){
                                    //     flag=false;
                                    //     break;
                                    // }
                                }
                            }
                            // let flag = false;
                            // console.log(finalArray);
                            resolve({ status: 0, finalArray: finalArray, imageArray: imageArray, imageArr: imageArr });
                            //imageArr is array of imagePaths only
                        }
                        else {
                            resolve({ status: 0, finalArray: finalArray });
                        }
                    }
                    else {
                        resolve({ status: 0, finalArray: finalArray });
                    }
                }));
            }
            catch (e) {
                console.log("Image exception: ", e);
                return false;
            }
        });
    }
    remoteApiCall(options) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            // let self=this;
            return new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                request(options, function (error, response, body) {
                    // console.log(error, response, body)
                    if (error) {
                        // if (error) {
                        //     resolve({ message: "Api Response", status: 1, data: error });
                        // } else if (!isNullOrUndefined(body) && body.status != 0) {
                        //     resolve({ message: "Api Response", status: 2, data: body.err });
                        // }
                        if (error) {
                            resolve({ message: "Api Response", status: 1, data: error });
                        }
                    }
                    else {
                        resolve({ message: "Api Response", status: 0, data: body });
                    }
                });
            }));
        });
    }
    extractJsonValue(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("<==========inside extract json value  ==========>");
                const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                const db = mClient.db(env_2.env.dbConfig.dbname);
                let filterobj = [];
                let finalData = {};
                let data = yield db.collection('scanningfields').findOne({ isDeleted: false, documentType: input.docType });
                data.fields.forEach(element => {
                    if (element.isTable == false && element.fieldName) {
                        finalData[element.fieldName] = '';
                    }
                });
                if (!util_1.isNullOrUndefined(input.jsonContent)) {
                    input.jsonContent.forEach(item => {
                        item['property'] = item.result ? item.result : null;
                        if (!util_1.isNullOrUndefined(item.result) && item.result !== '' && !util_1.isNullOrUndefined(item.show) && item.show == 'true') {
                            filterobj = filterobj.concat(item.finalObj);
                        }
                    });
                    for (let i = 0; i < filterobj.length; i++) {
                        if (filterobj[i]["result"] && filterobj[i]["line"]) {
                            finalData[filterobj[i]["result"]] = filterobj[i]["line"];
                        }
                    }
                    yield db.collection(input.docType).findOneAndUpdate({ referenceNumber: input.fileRef }, { $set: finalData }, { upsert: true });
                    // console.log(inserted_data);
                    // console.log(finalData)
                    let result = yield this.extractCropBoxes(input, outPut, botId, projectId, iterationId);
                    if (result.status == 1) {
                        throw "Error while ExtractingCropBox";
                    }
                    return { message: "success", status: 0, data: finalData };
                }
                else {
                    throw "input data not found";
                }
            }
            catch (e) {
                console.log('Data Not Found Successfully', e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    extractCropBoxes(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("Inside extractCropBoxes....");
                console.log("FileRefNum-----", input.fileRef);
                let data = JSON.parse(JSON.stringify(input.jsonContent));
                let cropBox = [];
                let Keys = data.reduce(function (r, a) {
                    r[a.property] = r[a.property] || [];
                    r[a.property].push(a);
                    return r;
                }, Object.create(null));
                for (let k in Keys) {
                    if (k && k != 'null' && k != 'undefined') {
                        console.log(k, '=>', Keys[k].length);
                        let sameResults = JSON.parse(JSON.stringify(Keys[k]));
                        let obj = {};
                        obj['name'] = k;
                        obj['left'] = Math.min.apply(Math, sameResults.map(a => a.lineleft));
                        obj['right'] = Math.max.apply(Math, sameResults.map(a => a.lineright));
                        obj['top'] = Math.min.apply(Math, sameResults.map(a => a.top));
                        obj['bottom'] = Math.max.apply(Math, sameResults.map(a => a.bottomY));
                        obj['pageId'] = sameResults[0].pageId;
                        cropBox.push(obj);
                    }
                }
                console.log(cropBox);
                if (!util_1.isNullOrUndefined(input.docType) && !util_1.isNullOrUndefined(input.fileRef)) {
                    // let model = await db.collection(input.docType)
                    const mClient = yield MongoClient.connect(env_2.env.dbConfig.mongodb_uri);
                    const db = mClient.db(env_2.env.dbConfig.dbname);
                    let result = yield db.collection(input.docType).findOneAndUpdate({ referenceNumber: input.fileRef }, { $set: { cropBox: cropBox } });
                    console.log("18----->", result);
                }
                return { message: "success", status: 0, data: cropBox };
            }
            catch (e) {
                console.log('extractCropBoxes error : ', e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    insertImagetoPdf(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let PDF_PATH = input.PDF_PATH;
                let image_path = input.imgpath;
                let xcood = input.xcood;
                let ycood = input.ycood;
                let pageNoToInsert = input.pageNo;
                let inputObj = {
                    "pdfPath": PDF_PATH,
                    "imagePath": image_path,
                    "xcood": xcood,
                    "ycood": ycood,
                    "pageno": pageNoToInsert
                };
                let parameters = JSON.stringify(JSON.stringify(inputObj));
                let res = yield this.sh("java -cp .:json-20190722.jar:pdfbox-2.0.3.jar:fontbox-2.0.3.jar:commons-logging-1.2.jar:json-simple-1.1.1.jar:jbig2-imageio-3.0.0.jar:itextpdf-5.5.13.1.jar:kernel-7.1.12.jar:io-7.1.12.jar:layout-7.1.12.jar:slf4j-api-1.7.30.jar:slf4j-simple-1.7.30.jar:commons-lang3-3.11.jar ImageFunction1 " + parameters);
                if (!util_1.isNullOrUndefined(res)) {
                    console.log("res[status]---->>", res);
                    if (res['status'] == 0) {
                        output["finalPath"] = PDF_PATH;
                        return { message: "Process sucessfull completed", status: 0, data: output };
                    }
                    else {
                        return { message: "incomplete", status: 1 };
                    }
                    // return { message: 'pdf readed successfully.', status: 0, data: output };
                }
                return { message: "incomplete", status: 1 };
            }
            catch (err) {
                console.log("Error!!! -> " + err);
                return { message: err, status: 1, data: err };
            }
        });
    }
    convertWordstoLines(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("<==========inside convert words into lines  ==========>");
                let tableArray;
                let finaljsondata = [];
                let output = {};
                let obj;
                let concatName;
                let start;
                let end;
                let bottomy = 0;
                let rightx = 0;
                let midbottomy = 0;
                let midrightx = 0;
                if (!util_1.isNullOrUndefined(input.tableArray)) {
                    tableArray = JSON.parse(input.tableArray);
                }
                if (!util_1.isNullOrUndefined(input.json)) {
                    for (let i = 0; i < input.json.length; i++) {
                        for (let j = 0; j < input.json[i]['lineWithCombineWords'].length; j++) {
                            let filterdata = input.json[i]['lineWithCombineWords'][j];
                            // console.log(filterdata.length)
                            if (!util_1.isNullOrUndefined(tableArray)) {
                                let newdata = filterdata.map(e => e.Name).join(' ');
                                for (let data = 0; data < tableArray.length; data++) {
                                    if (newdata.toLowerCase().search(new RegExp(tableArray[data]['start'])) !== -1) {
                                        start = tableArray[data]['start'];
                                        end = tableArray[data]['end'];
                                        if (filterdata.length > 2) {
                                            let datafilter = 0;
                                            let newfilterdata = JSON.parse(JSON.stringify(filterdata));
                                            for (datafilter = 0; datafilter < newfilterdata.length - 1; datafilter++) {
                                                if (newfilterdata[datafilter + 1]['leftX'] - newfilterdata[datafilter]['rightX'] < 50) {
                                                    filterdata[0]['Name'] = filterdata[0]['Name'] + ' ' + newfilterdata[datafilter + 1]['Name'];
                                                    filterdata[0]['rightX'] = newfilterdata[datafilter + 1]['rightX'];
                                                    filterdata[0]['bottomY'] = newfilterdata[datafilter + 1]['bottomY'];
                                                }
                                                else {
                                                    break;
                                                }
                                            }
                                            datafilter++;
                                            if (datafilter < newfilterdata.length) {
                                                filterdata[1]['Name'] = newfilterdata[datafilter]['Name'];
                                                filterdata[1]['leftX'] = newfilterdata[datafilter]['leftX'];
                                                filterdata[1]['rightX'] = newfilterdata[datafilter]['rightX'];
                                                filterdata[1]['bottomY'] = newfilterdata[datafilter]['bottomY'];
                                                filterdata[1]['topY'] = newfilterdata[datafilter]['topY'];
                                                while (datafilter < newfilterdata.length - 1) {
                                                    filterdata[1]['Name'] = filterdata[1]['Name'] + ' ' + newfilterdata[datafilter + 1]['Name'];
                                                    filterdata[1]['rightX'] = newfilterdata[datafilter + 1]['rightX'];
                                                    datafilter++;
                                                }
                                            }
                                        }
                                        break;
                                    }
                                }
                            }
                            if (filterdata.length == 1) {
                                concatName = filterdata[0]['Name'];
                                bottomy = filterdata[0]['bottomY'];
                                rightx = filterdata[0]['rightX'];
                            }
                            else if (!util_1.isNullOrUndefined(start) && !util_1.isNullOrUndefined(end) && start !== '' && end !== '') {
                                let approxTableMid = filterdata[1]['leftX'];
                                let maxj = j + 10;
                                while (!(input.json[i]['lineWithCombineWords'][j + 1].map(e => e.Name).join(' ').toLowerCase().search(new RegExp(end)) !== -1) && j !== maxj) {
                                    let nextArray = input.json[i]['lineWithCombineWords'][j + 1];
                                    for (let k = 0; k < nextArray.length; k++) {
                                        if (nextArray[k]['leftX'] >= approxTableMid - 100) {
                                            filterdata[1]['Name'] = filterdata[1]['Name'] + ' ' + nextArray[k]['Name'];
                                            if (midbottomy < nextArray[k]['bottomY']) {
                                                midbottomy = nextArray[k]['bottomY'];
                                            }
                                            if (midrightx < nextArray[k]['rightX']) {
                                                midrightx = nextArray[k]['rightX'];
                                            }
                                        }
                                        else {
                                            filterdata[0]['Name'] = filterdata[0]['Name'] + ' ' + nextArray[k]['Name'];
                                            if (bottomy < nextArray[k]['bottomY']) {
                                                bottomy = nextArray[k]['bottomY'];
                                            }
                                            if (rightx < nextArray[k]['rightX']) {
                                                rightx = nextArray[k]['rightX'];
                                            }
                                        }
                                    }
                                    j += 1;
                                }
                                if (midbottomy == 0) {
                                    midbottomy = filterdata[1]['bottomY'];
                                }
                                if (midrightx == 0) {
                                    midrightx = filterdata[1]['rightX'];
                                }
                                obj = {
                                    'line': filterdata[1]['Name'],
                                    'top': filterdata[1]['topY'],
                                    'lineright': midrightx,
                                    'lineleft': filterdata[1]['leftX'],
                                    'fileName': input.json[i]['obj']["fileName"],
                                    'pageHeight': input.json[i]['pageHeight'],
                                    'pageId': i,
                                    'bottomY': midbottomy
                                };
                                finaljsondata.push(obj);
                                concatName = filterdata[0]['Name'];
                                start = '';
                                end = '';
                                midbottomy = 0;
                                midrightx = 0;
                            }
                            else {
                                concatName = '';
                                for (let k = 0; k < filterdata.length; k++) {
                                    concatName = (concatName == '') ? filterdata[k]['Name'] : concatName + ' ' + filterdata[k]['Name'];
                                    bottomy = filterdata[k]['bottomY'];
                                    rightx = filterdata[k]['rightX'];
                                }
                            }
                            obj = {
                                'line': concatName,
                                'top': filterdata[0]['topY'],
                                'lineright': rightx,
                                'lineleft': filterdata[0]['leftX'],
                                'fileName': input.json[i]['obj']["fileName"],
                                'pageHeight': input.json[i]['pageHeight'],
                                'pageId': i,
                                'bottomY': bottomy
                            };
                            finaljsondata.push(obj);
                            bottomy = 0;
                            rightx = 0;
                        }
                    }
                    if (!util_1.isNullOrUndefined(input.filterarr)) {
                        let findandreplace = JSON.parse(input.filterarr);
                        for (let data = 0; data < finaljsondata.length; data++) {
                            for (let item = 0; item < findandreplace.length; item++) {
                                let re = new RegExp(findandreplace[item]['find'], 'g');
                                finaljsondata[data]['line'] = finaljsondata[data]['line'].replace(re, findandreplace[item]['replace']);
                            }
                        }
                    }
                    output["output"] = finaljsondata;
                    return { message: "success", status: 0, data: output };
                }
                else {
                    throw "Data is not Found";
                }
            }
            catch (e) {
                console.log('Data Not Found Successfully', e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    filterEntries(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let pdfData = typeof input['pdfData'] == 'string' ? JSON.parse(input['pdfData']) : input['pdfData'];
                let filteredArray = pdfData.filter(e => e[input['flagName']]);
                let variableList = typeof input['variableNames'] == 'string' ? JSON.parse(input['variableNames']) : input['variableNames'];
                output['jsonEntries'] = [];
                filteredArray.forEach((element, index) => {
                    output['jsonEntries'].push({});
                    for (let i = 0; i < variableList.length; i++) {
                        output['jsonEntries'][index][variableList[i]] = element[variableList[i]];
                    }
                });
                return { status: 0, "message": 'Successfull', data: output };
            }
            catch (e) {
                this.log.error("Error in Filter Entries" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    objectToCsvBot(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const ObjectsToCsv = require('objects-to-csv');
                let jsonObj = typeof input['jsonObj'] == 'string' ? JSON.parse(input['jsonObj']) : input['jsonObj'];
                const csv = new ObjectsToCsv(jsonObj);
                yield csv.toDisk(`${input['csvPath'].substring(0, input['csvPath'].indexOf('.'))}.csv`);
                return { status: 0, "message": 'Successfull', data: output };
            }
            catch (e) {
                this.log.error("Error in writing CSV" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    juta_evaluateRuleSetBot(inputData, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let resp;
                // if (isNullOrUndefined(inputData.pdfData) || inputData.pdfData == "") {
                //     return { status: 1, message: "pdf Data got Null", data: "pdf Data got Null" +" " +"for File" +" " + inputData.file_path };
                // }
                //case1------->take rule from inputData.ruleSet
                if (!util_1.isNullOrUndefined(inputData.preprocessAndEvaluat)) {
                    if (inputData.preprocess === "true") {
                        inputData.preprocess = true;
                    }
                    if (inputData.preprocess === "false") {
                        inputData.preprocess = false;
                    }
                    if (inputData.preprocessAndEvaluat === "true") {
                        inputData.preprocessAndEvaluat = true;
                    }
                    if (inputData.preprocessAndEvaluat === "false") {
                        inputData.preprocessAndEvaluat = false;
                    }
                    if (util_1.isNullOrUndefined(inputData.preFotPreProcess) || inputData.preFotPreProcess === "false") {
                        inputData.preFotPreProcess = false;
                    }
                    if (!util_1.isNullOrUndefined(inputData.preFotPreProcess) && inputData.preFotPreProcess === "true") {
                        inputData.preFotPreProcess = true;
                    }
                    if (util_1.isNullOrUndefined(inputData.afterFotPreProcess) || inputData.afterFotPreProcess === "false") {
                        inputData.afterFotPreProcess = false;
                    }
                    if (!util_1.isNullOrUndefined(inputData.afterFotPreProcess) && inputData.afterFotPreProcess === "true") {
                        inputData.afterFotPreProcess = true;
                    }
                }
                let obj = {};
                if (inputData.preprocess || inputData.preprocessAndEvaluat) { //for preprocess and afetr preprocess bot
                    let id;
                    if ((!util_1.isNullOrUndefined(inputData.preProcessId) && inputData.preProcessId !== "") || (!util_1.isNullOrUndefined(inputData.afterPreprocessId) && inputData.afterPreprocessId !== "")) {
                        if (inputData.preprocess) {
                            id = inputData.preProcessId; //preprocess
                        }
                        if (inputData.preprocessAndEvaluat) {
                            id = inputData.afterPreprocessId; //after preprocess
                        }
                    }
                    else {
                        return { status: 1, message: "Rule Id not found", data: "Rule Id not found" + "for File" + inputData.file_path };
                    }
                    obj = {
                        "id": id,
                        "rulesSetValue": {
                            "preprocess": inputData.preprocess,
                            "preprocessAndEvaluate": inputData.preprocessAndEvaluat,
                            "pdfData": inputData.pdfData,
                            "to": parseInt(inputData.to),
                            "from": parseInt(inputData.from),
                            "file_Name": inputData.file_path,
                            "inputputFilePath": inputData.file_path,
                            "outputFilePath": inputData.outputFilePath
                        }
                    };
                }
                if (!inputData.preprocess && !inputData.preprocessAndEvaluat && inputData.IdentifyRuleSetID.length > 1) { //to find out ruleSet to corresponding pdf
                    // let tempPdfData;
                    // if(typeof inputData.output == "string" && inputData.output == '' && Array.isArray(inputData.pdfData))
                    // {
                    //     tempPdfData = inputData.pdfData;
                    // }
                    // else{
                    //     tempPdfData =
                    // }
                    let output = {};
                    obj = {
                        "id": inputData.IdentifyRuleSetID,
                        "rulesSetValue": {
                            "preprocess": inputData.preprocess,
                            "preprocessAndEvaluate": inputData.preprocessAndEvaluat,
                            "file_Name": inputData.file_Name,
                            "inputputFilePath": inputData.inputputFilePath,
                            "pdfData": inputData.output,
                            "IdentifyRuleSet": true,
                            "to": 5,
                            "from": 5,
                            "preProcessId": "",
                            "afterPreprocessId": "",
                            "preFotPreProcessId": "",
                            "afterFotPreProcessId": ""
                        }
                    };
                    output["output"] = inputData.output;
                    output["FoteNotes"] = !util_1.isNullOrUndefined(inputData.FoteNotes) && inputData.FoteNotes.length > 0 ? inputData.FoteNotes : [];
                    output["file_path"] = inputData.file_path;
                    output["outputFilePath"] = inputData.outputFilePath;
                    output["inputputFilePath"] = inputData.inputputFilePath;
                    output["file_Name"] = inputData.file_Name;
                    //resp = await this.evaluateRuleSet(obj)
                    resp = yield this.evaluateRuleSet(JSON.parse(JSON.stringify(obj)));
                    //    data["preProcessId"]=resp.preProcessId;//replace this by id variable
                    //    data["afterPreprocessId"]=resp.afterPreprocessId;//replace this by id variable
                    if ((!util_1.isNullOrUndefined(resp.preProcessId) && resp.preProcessId !== "") || (!util_1.isNullOrUndefined(resp.afterPreprocessId) && resp.afterPreprocessId !== "")) {
                        output["preProcessId"] = !util_1.isNullOrUndefined(resp.preProcessId) && resp.preProcessId !== "" ? resp.preProcessId : ""; //replace this by id variable
                        output["afterPreprocessId"] = !util_1.isNullOrUndefined(resp.afterPreprocessId) && resp.afterPreprocessId !== "" ? resp.afterPreprocessId : ""; //replace this by id variable
                        output["preFotPreProcessId"] = !util_1.isNullOrUndefined(resp.preFotPreProcessId) && resp.preFotPreProcessId !== "" ? resp.preFotPreProcessId : "";
                        output["afterFotPreProcessId"] = (!util_1.isNullOrUndefined(resp.afterFotPreProcessId) && resp.afterFotPreProcessId !== "") ? resp.afterFotPreProcessId : "";
                        output["concatId"] = (!util_1.isNullOrUndefined(resp.concatId) && resp.concatId !== "") ? resp.concatId : "";
                        // output["preProcessId"] = "5f577e9338fba2177a8f0058";//replace this by id variable
                        // output["afterPreprocessId"] = "5f5b140f07c1dd416a726cdf";//replace this by id variable
                    }
                    else {
                        resp = null;
                        return { status: 1, message: "Can not Identify PDF", data: "Can not Identify PDF" + " " + "for File" + " " + inputData.file_path };
                    }
                    //    data["id"]=resp.preProcessId;//replace this by id variable
                    //    data["file_Name"]=resp.afterPreprocessId
                    return { status: 0, message: "Successfully executed command", data: output };
                }
                resp = yield this.juta_evaluateRuleSet(obj);
                if (!util_1.isNullOrUndefined(resp) && resp.status == 1) {
                    return { status: 1, message: resp.message, data: resp.data + " " + "for File" + " " + inputData.file_path };
                }
                let ipK = Object.keys(inputData);
                let blank = [];
                let fill = [];
                ipK.forEach(b => {
                    if (inputData[b] == "" || util_1.isNullOrUndefined(inputData[b]) || !inputData[b]) {
                        blank.push(b);
                    }
                    else {
                        fill.push(b);
                    }
                });
                if (fill.length > 0) {
                    fill.forEach(t => {
                        output[t] = inputData[t];
                    });
                }
                if (!util_1.isNullOrUndefined(resp) && resp.length > 0) {
                    if (!inputData.preprocessAndEvaluat) {
                        blank.forEach(p => {
                            resp.forEach(element => {
                                if (!util_1.isNullOrUndefined(element[p]) && element[p] !== "" && element[p] && element[p] !== "false") {
                                    output[p] = element[p];
                                }
                            });
                        });
                    }
                }
                // if(inputData.preprocess){
                //     output['pdfData']=resp;
                // }else{
                //     output['pdfData']=resp.data;
                // }
                // let Exclusion_String = '';
                output['pdfData'] = null;
                if (!util_1.isNullOrUndefined(resp) && resp.length > 0 && util_1.isNullOrUndefined(resp.data)) {
                    // Exclusion_String = this.getExclusionString(resp);
                    output['pdfData'] = [];
                    output['pdfData'] = JSON.parse(JSON.stringify(resp));
                }
                else {
                    // Exclusion_String = this.getExclusionString(resp.data);
                    output['pdfData'] = [];
                    output['pdfData'] = JSON.parse(JSON.stringify(resp.data));
                }
                resp = null;
                if (!util_1.isNullOrUndefined(inputData.FoteNotes) && inputData.FoteNotes.length > 0) {
                    let fotObj = {};
                    let fotresp;
                    if (inputData.preFotPreProcess || inputData.afterFotPreProcess) { //for preprocess and afetr preprocess bot
                        let id;
                        if ((!util_1.isNullOrUndefined(inputData.preFotPreProcessId) && inputData.preFotPreProcessId !== "") || (!util_1.isNullOrUndefined(inputData.afterFotPreProcessId) && inputData.afterFotPreProcessId !== "")) {
                            if (inputData.preFotPreProcess) { //preprocessing of fotnote
                                id = inputData.preFotPreProcessId;
                            }
                            if (inputData.afterFotPreProcess) { //after preprocess of fotnote
                                id = inputData.afterFotPreProcessId;
                            }
                        }
                        fotObj = {
                            "id": id,
                            "rulesSetValue": {
                                "preprocess": inputData.preprocess,
                                "preprocessAndEvaluate": inputData.preprocessAndEvaluat,
                                "pdfData": JSON.parse(JSON.stringify(inputData.FoteNotes)),
                                "to": parseInt(inputData.to),
                                "from": parseInt(inputData.from),
                                "file_Name": inputData.file_path,
                                "inputputFilePath": inputData.file_path,
                                "outputFilePath": inputData.outputFilePath
                            }
                        };
                    }
                    fotresp = yield this.juta_evaluateRuleSet(JSON.parse(JSON.stringify(fotObj)));
                    if (!util_1.isNullOrUndefined(fotresp) && fotresp.status == 1) {
                        return { status: 1, message: fotresp.message, data: fotresp.data + " " + "for File" + " " + inputData.file_path };
                    }
                    if (!util_1.isNullOrUndefined(fotresp) && fotresp.length > 0) {
                        if (!inputData.preFotPreProcessId) {
                            blank.forEach(p => {
                                fotresp.forEach(element => {
                                    if (!util_1.isNullOrUndefined(element[p]) && element[p] !== "" && element[p] && element[p] !== "false") {
                                        output[p] = element[p];
                                    }
                                });
                            });
                        }
                    }
                    output['FoteNotes'] = null;
                    if (!util_1.isNullOrUndefined(fotresp) && fotresp.length > 0 && util_1.isNullOrUndefined(fotresp.data)) {
                        // Exclusion_String = this.getExclusionString(resp);
                        output['FoteNotes'] = [];
                        output['FoteNotes'] = JSON.parse(JSON.stringify(fotresp));
                    }
                    else {
                        // Exclusion_String = this.getExclusionString(resp.data);
                        output['FoteNotes'] = [];
                        output['FoteNotes'] = JSON.parse(JSON.stringify(fotresp.data));
                    }
                    fotresp = null;
                }
                delete output['from'];
                // output['outputFilePath']=inputData.outputFilePath
                // if (!isNullOrUndefined(Exclusion_String) && Exclusion_String !== '') {
                //     for (let x = 0; x < output['pdfData'].length; x++) {
                //         output['pdfData'][x]['Exclusion_String'] = Exclusion_String;
                //     }
                // }
                let OutPut = JSON.parse(JSON.stringify(output));
                output = null;
                obj = null;
                return { status: 0, message: "Successfully executed command", data: OutPut };
            }
            catch (e) {
                console.log('errrr------->', e);
                return { info: 'Internal Server Error', status: 1, data: e };
            }
        });
    }
    juta_evaluateRuleSet(input) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let resp;
                const ruleSetObject = yield this.RuleEngineService.getRuleSetObject(input.id, input.name);
                if (!util_1.isNullOrUndefined(input.rulesSetValue)) {
                    if ((!util_1.isNullOrUndefined(input.rulesSetValue.preprocess) && input.rulesSetValue.preprocess) || (!util_1.isNullOrUndefined(input.rulesSetValue.preprocessAndEvaluate) && input.rulesSetValue.preprocessAndEvaluate) || input.rulesSetValue.IdentifyRuleSet) {
                        // if(input.rulesSetValue.preprocessAndEvaluate){
                        // }
                        resp = yield this.juta_EvaluateRulePDF(ruleSetObject.data[0].rulesSet, input.rulesSetValue, input);
                    }
                    else {
                        resp = yield this.juta_EvaluateRule(ruleSetObject.data[0].rulesSet, input.rulesSetValue);
                    }
                    return resp;
                }
                else {
                    let rulesSetValue = {};
                    input.variableList.forEach(element => {
                        rulesSetValue[element.label] = element.value;
                    });
                    resp = yield this.juta_EvaluateRule(ruleSetObject.data[0], rulesSetValue);
                    return resp;
                }
            }
            catch (err) {
                return err;
            }
        });
    }
    juta_EvaluateRulePDF(ruleSet, fields, input) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let c = true;
                let pOutout;
                let strO;
                let keyList1 = Object.keys(fields);
                let isArrayFound = false;
                let pdfData;
                let kk = "";
                let isDataOperation = false;
                let ruleSetCount = 0;
                let expression = {};
                for (const k of keyList1) {
                    kk = k;
                    if (Array.isArray(fields[kk])) {
                        isArrayFound = true;
                        pdfData = fields[k];
                        // if(pdfData.length>4000){
                        // pdfData=pdfData.slice(0,500)
                        // }
                    }
                }
                if (!isArrayFound) {
                    return "Invalid input Data";
                }
                if (fields.preprocessAndEvaluate) {
                    let inputData = {
                        pdfData: pdfData,
                        rulesSet: ruleSet,
                        file_path: fields.file_Name,
                        outputFilePath: fields.outputFilePath
                    };
                    return this.evaluateRulesAndSplitPDF(inputData);
                }
                else {
                    let index = -1;
                    let compVal;
                    let Val;
                    let finelObj = {};
                    let Expresult;
                    pdfData[pdfData.length - 1]['lastPage'] = true;
                    let k = Object.keys(pdfData[0]);
                    let lastObj = pdfData[pdfData.length - 1];
                    lastObj['pageIds'] = lastObj['pageId'];
                    // console.log("----------Total PDF lines------------------------------"+pdfData.length);
                    for (let increment = 0; increment <= pdfData.length - 1; increment++) {
                        pdfData[increment]["inputputFilePath"] = input.rulesSetValue.inputputFilePath;
                        // console.log("Executing for line------------------>"+increment+"--"+pdfData[increment].line);
                        for (const i of Object.keys(finelObj)) {
                            pdfData[increment][i] = finelObj[i];
                        }
                        if (increment == pdfData.length - 1) {
                            // console.log("near to lastobj")
                            pdfData[increment]['lastPage'] = true;
                        }
                        index = index + 1;
                        isDataOperation = false;
                        ruleSetCount = 0;
                        let keyList = Object.keys(pdfData[increment]);
                        for (const myrules of ruleSet) {
                            ruleSetCount = ruleSetCount + 1;
                            for (let i = 0; i < myrules.rules.length; i++) {
                                let matchCriteriaCount = 0;
                                let totalCriteria = 0;
                                totalCriteria = myrules.rules[i].rule.criteria.length;
                                let criteriaIncrementCount = 0;
                                for (const criteria of myrules.rules[i].rule.criteria) {
                                    criteriaIncrementCount = criteriaIncrementCount + 1;
                                    if (criteria.value !== "") {
                                        if (index >= fields.from && index < pdfData.length - fields.to) {
                                            if (criteria.value.includes("isNullOrUndefined")) {
                                                let newobj = {};
                                                for (const newfield of Object.keys(pdfData[increment])) {
                                                    newobj[newfield] = pdfData[increment][newfield];
                                                }
                                                newobj['pdfData'] = JSON.stringify(pdfData.slice(index - fields.from, index + fields.to));
                                                newobj['index'] = index;
                                                newobj['currentIndex'] = fields.from;
                                                expression = {
                                                    Expression: criteria.value,
                                                    value: newobj
                                                };
                                            }
                                            else {
                                                expression = {
                                                    Expression: criteria.value,
                                                    value: { pdfData: JSON.stringify(pdfData.slice(index - fields.from, index + fields.to)), index: index, currentIndex: fields.from }
                                                };
                                            }
                                        }
                                        else {
                                            if (criteria.value.includes("isNullOrUndefined")) {
                                                let newobj = {};
                                                for (const newfield of Object.keys(pdfData[increment])) {
                                                    newobj[newfield] = pdfData[increment][newfield];
                                                }
                                                newobj['pdfData'] = JSON.stringify(pdfData.slice(0, index + fields.to));
                                                newobj['index'] = index;
                                                newobj['currentIndex'] = index;
                                                expression = {
                                                    Expression: criteria.value,
                                                    value: newobj
                                                };
                                            }
                                            else {
                                                expression = {
                                                    Expression: criteria.value,
                                                    value: { pdfData: JSON.stringify(pdfData.slice(0, index + fields.to)), index: index, currentIndex: index }
                                                };
                                            }
                                        }
                                        Val = yield this.juta_evaluateExpression(expression);
                                        let self = this;
                                        let isOutOfField = false;
                                        if (keyList.indexOf(criteria.field) == -1) {
                                            if (index >= 10 && index < pdfData.length - 10) {
                                                if (criteria.field.includes("isNullOrUndefined")) {
                                                    let newobj = {};
                                                    for (const newfield of Object.keys(pdfData[increment])) {
                                                        newobj[newfield] = pdfData[increment][newfield];
                                                    }
                                                    newobj['pdfData'] = JSON.stringify(pdfData.slice(index - fields.from, index + fields.to));
                                                    newobj['index'] = index;
                                                    newobj['currentIndex'] = fields.from;
                                                    expression = {
                                                        Expression: criteria.field,
                                                        value: newobj
                                                    };
                                                }
                                                else {
                                                    expression = {
                                                        Expression: criteria.field,
                                                        value: { pdfData: JSON.stringify(pdfData.slice(index - fields.from, index + fields.to)), index: index, currentIndex: fields.from }
                                                    };
                                                }
                                            }
                                            else {
                                                if (criteria.field.includes("isNullOrUndefined")) {
                                                    let newobj = {};
                                                    for (const newfield of Object.keys(pdfData[increment])) {
                                                        newobj[newfield] = pdfData[increment][newfield];
                                                    }
                                                    newobj['pdfData'] = JSON.stringify(pdfData.slice(index - fields.from, index + fields.to));
                                                    newobj['index'] = index;
                                                    newobj['currentIndex'] = index;
                                                    expression = {
                                                        Expression: criteria.field,
                                                        value: newobj
                                                    };
                                                }
                                                else {
                                                    expression = {
                                                        Expression: criteria.field,
                                                        value: { pdfData: JSON.stringify(pdfData.slice(0, index + fields.to)), index: index, currentIndex: index }
                                                    };
                                                }
                                            }
                                            compVal = yield this.juta_evaluateExpression(expression);
                                            isOutOfField = true;
                                        }
                                        if (Val == "true") {
                                            Val = true;
                                        }
                                        if (Val == "false") {
                                            Val = false;
                                        }
                                        if (compVal == "true") {
                                            compVal = true;
                                        }
                                        if (compVal == "false") {
                                            compVal = false;
                                        }
                                        if (!isNaN(compVal)) {
                                            compVal = Number(compVal);
                                        }
                                        if (!isNaN(Val)) {
                                            Val = Number(Val);
                                        }
                                        if (self.operators[criteria.operator](compVal, Val)) {
                                            matchCriteriaCount++;
                                        }
                                        if (isOutOfField) {
                                            delete pdfData[increment][criteria.field];
                                        }
                                        if (matchCriteriaCount != criteriaIncrementCount) {
                                            break;
                                        }
                                    }
                                    else {
                                        totalCriteria = totalCriteria - 1;
                                    }
                                }
                                if (matchCriteriaCount == totalCriteria) {
                                    for (const result of myrules.rules[i].rule.result) {
                                        // let result
                                        // let re = {}
                                        if (!util_1.isNullOrUndefined(result) && result !== "") {
                                            if (result.value.indexOf('push') > -1) {
                                                // result = '';
                                                let splitR = result.value.split('.');
                                                const regex = /^\s*(\w+)\s*\((.*)\)/gm;
                                                const str = splitR[1];
                                                let m;
                                                let key;
                                                while ((m = regex.exec(str)) !== null) {
                                                    if (m.index === regex.lastIndex) {
                                                        regex.lastIndex++;
                                                    }
                                                    m.forEach((match, groupIndex) => {
                                                        console.log(`Found match, group ${groupIndex}: ${match}`);
                                                        if (groupIndex == 1) {
                                                        }
                                                        else if (groupIndex == 2) {
                                                            key = match;
                                                        }
                                                    });
                                                }
                                                if (util_1.isNullOrUndefined(finelObj[splitR[0]])) {
                                                    finelObj[splitR[0]] = pdfData[increment][key];
                                                }
                                                else {
                                                    finelObj[splitR[0]] = finelObj[splitR[0]] + '-' + pdfData[increment][key];
                                                }
                                            }
                                            if (result.field == "exit") {
                                                return pdfData;
                                            }
                                            let tagexpression;
                                            let tagExpresult;
                                            if (result.value !== "") {
                                                if (index >= 10 && index < pdfData.length - 10) {
                                                    let data123 = pdfData.slice(index - fields.from, index + fields.to);
                                                    data123;
                                                    expression = {
                                                        Expression: result.value,
                                                        // value: {pdfData:JSON.stringify(pdfData.slice(index-10, index+10)),index:index,currentIndex:0}
                                                        value: { pdfData: JSON.stringify(pdfData.slice(index - fields.from, index + fields.to)), index: index, currentIndex: fields.from }
                                                    };
                                                    if (result.field == 'line') {
                                                        tagexpression = {
                                                            Expression: result.value.replace(/line/g, 'tagline'),
                                                            // value: {pdfData:JSON.stringify(pdfData.slice(index-10, index+10)),index:index,currentIndex:0}
                                                            value: { pdfData: JSON.stringify(pdfData.slice(index - fields.from, index + fields.to)), index: index, currentIndex: fields.from }
                                                        };
                                                    }
                                                }
                                                else {
                                                    let data123 = pdfData.slice(0, index + fields.to);
                                                    data123;
                                                    expression = {
                                                        Expression: result.value,
                                                        value: { pdfData: JSON.stringify(pdfData.slice(0, index + fields.to)), index: index, currentIndex: index }
                                                    };
                                                    if (result.field == 'line') {
                                                        tagexpression = {
                                                            Expression: result.value.replace(/line/g, 'tagline'),
                                                            value: { pdfData: JSON.stringify(pdfData.slice(0, index + fields.to)), index: index, currentIndex: index }
                                                        };
                                                    }
                                                }
                                                if (result.field === "dataOperation") {
                                                    yield pdfData.splice(index + 1, 1);
                                                    // pdfData = await this.evaluateExpression(expression)
                                                    // pdfData=pdfData.slice(0,index+1).concat(pdfData.slice(index+2,pdfData.length))
                                                    isDataOperation = true;
                                                }
                                                else if (result.field === "sort" && c == true) {
                                                    let a = [];
                                                    let val = result.value;
                                                    for (let t = 0; t < pdfData.length; t++) {
                                                        if (!util_1.isNullOrUndefined(pdfData[t].content_page) && (pdfData[t].content_page == true || pdfData[t].content_page == "true")) {
                                                            a.push(pdfData[t]);
                                                            pdfData[t] = ({ p: "r" });
                                                            if (!util_1.isNullOrUndefined(pdfData[t].content_page) && (pdfData[t].content_page == false || pdfData[t].content_page == "false")) {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    a.sort((a, b) => a.line.substring(a.line.indexOf(val) + val.length + 1, a.line.lastIndexOf('(') - 1) - b.line.substring(b.line.indexOf(val) + val.length + 1, b.line.lastIndexOf('(') - 1));
                                                    for (let o = 0; o < a.length; o++) {
                                                        if (!util_1.isNullOrUndefined(a[o].line) && a[o].line !== "" && !util_1.isNullOrUndefined(a[o + 1]) && !util_1.isNullOrUndefined(a[o + 1].line) && a[o + 1].line !== "") {
                                                            let g = a[o].line.substring(a[o].line.indexOf(val) + val.length + 1, a[o].line.lastIndexOf('(') - 1);
                                                            let h = a[o + 1].line.substring(a[o + 1].line.indexOf(val) + val.length + 1, a[o + 1].line.lastIndexOf('(') - 1);
                                                            if (!util_1.isNullOrUndefined(a[o + 1]) && g[g.length - 1] == h[h.length - 1]) {
                                                                let c = (a[o].line.match(/,/g) || []).length;
                                                                let m = (a[o + 1].line.match(/,/g) || []).length;
                                                                if (c > m) {
                                                                    a.splice(o, 1);
                                                                }
                                                                else {
                                                                    a.splice(o + 1, 1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                    let index = 0;
                                                    for (let q = 0; q < pdfData.length; q++) {
                                                        if (!util_1.isNullOrUndefined(pdfData[q].p) && pdfData[q].p == 'r') {
                                                            // index = p;
                                                            // break;
                                                            if (!util_1.isNullOrUndefined(a[index]) && a[index] !== "") {
                                                                pdfData[q] = a[index];
                                                                index++;
                                                            }
                                                        }
                                                        // if(isNullOrUndefined(pdfData[q]) || pdfData[q] == "undefined" || (!isNullOrUndefined(pdfData[q].p) && pdfData[q].p =='r')){
                                                        //     pdfData.splice(q, 1);
                                                        // }
                                                    }
                                                    c = false;
                                                }
                                                else if (result.field === "sortNR" && c == true) {
                                                    let a = [];
                                                    let val = result.value;
                                                    let startOfContent = -1;
                                                    let endOfContent = 0;
                                                    for (let t = 0; t < pdfData.length; t++) {
                                                        if (!util_1.isNullOrUndefined(pdfData[t].content_page) && (pdfData[t].content_page == true || pdfData[t].content_page == "true")) {
                                                            if (startOfContent == -1) {
                                                                startOfContent = t;
                                                            }
                                                            else {
                                                                endOfContent++;
                                                            }
                                                            if (pdfData[t].line.substring(pdfData[t].line.lastIndexOf(val)).includes('(') == true) {
                                                                if (pdfData[t].line.substring(pdfData[t].line.lastIndexOf(val)).split(' ').length <= 2) {
                                                                    pdfData[t].line = pdfData[t].line.substring(0, pdfData[t].line.lastIndexOf('(')) + ' ' + pdfData[t].line.substring(pdfData[t].line.lastIndexOf('('));
                                                                }
                                                                pdfData[t]['pageStart'] = pdfData[t].line.substring(pdfData[t].line.lastIndexOf(val) + val.length + 1, pdfData[t].line.lastIndexOf('(') - 1);
                                                                a.push(pdfData[t]);
                                                                pdfData[t] = ({ p: "r" });
                                                            }
                                                            else {
                                                                pdfData[t].line = pdfData[t].line + " (";
                                                                pdfData[t]['pageStart'] = pdfData[t].line.substring(pdfData[t].line.lastIndexOf(val) + val.length + 1, pdfData[t].line.lastIndexOf('(') - 1);
                                                                a.push(pdfData[t]);
                                                                pdfData[t] = ({ p: "r" });
                                                            }
                                                            if (!util_1.isNullOrUndefined(pdfData[t].content_page) && (pdfData[t].content_page == false || pdfData[t].content_page == "false")) {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    let d = [];
                                                    for (let r = 0; r < a.length; r++) {
                                                        if (!util_1.isNullOrUndefined(a[r]['line']) && a[r]['line'] !== "") {
                                                            let f = a[r]['line'].substring(a[r]['line'].lastIndexOf(val) + val.length + 1, a[r]['line'].lastIndexOf('(') - 1);
                                                            if (Number(f)) {
                                                                d.push(a[r]);
                                                            }
                                                        }
                                                    }
                                                    a = d;
                                                    a.sort((a, b) => a.line.substring(a.line.lastIndexOf(val) + val.length + 1, a.line.lastIndexOf('(') - 1) - b.line.substring(b.line.lastIndexOf(val) + val.length + 1, b.line.lastIndexOf('(') - 1));
                                                    let l = a.length;
                                                    for (let o = 0; o < l; o++) {
                                                        if (!util_1.isNullOrUndefined(a[o]) && a[o] !== "" && !util_1.isNullOrUndefined(a[o].line) && a[o].line !== "" && !util_1.isNullOrUndefined(a[o + 1]) && a[o + 1] !== "" && !util_1.isNullOrUndefined(a[o + 1].line) && a[o + 1].line !== "") {
                                                            // let g = a[o].line.substring(a[o].line.indexOf(val) + val.length+1, a[o].line.lastIndexOf('(') - 1);
                                                            // let h = a[o + 1].line.substring(a[o + 1].line.indexOf(val) + val.length+1, a[o + 1].line.lastIndexOf('(') - 1)
                                                            let g = a[o].pageStart;
                                                            let h = a[o + 1].pageStart;
                                                            if (isNaN(g)) {
                                                                a.splice(o, 1);
                                                                o--;
                                                                continue;
                                                            }
                                                            if (!util_1.isNullOrUndefined(a[o + 1]) && !util_1.isNullOrUndefined(a[o + 1].line) && g == h) {
                                                                let c = (a[o].line.match(/,/g) || []).length;
                                                                let m = (a[o + 1].line.match(/,/g) || []).length;
                                                                if (c > m) {
                                                                    a.splice(o, 1);
                                                                }
                                                                else {
                                                                    a.splice(o + 1, 1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                    pdfData.splice(startOfContent, endOfContent);
                                                    // let index = 0
                                                    for (let q = 0; q < a.length; q++) {
                                                        pdfData.splice(startOfContent, 0, a[q]);
                                                        startOfContent++;
                                                    }
                                                    c = false;
                                                }
                                                else if (result.field === "Cases_Reported" && c == true) {
                                                    // checkTo(pdfData, matchKey) {
                                                    // let pageid = 'none';
                                                    // if(!matchKey.includes("No.")){matchKey="No. "+matchKey}
                                                    // if (!isNaN(matchKey)) { matchKey = "No. " + matchKey }
                                                    // pdfData.filter((re) => {
                                                    //     if (re.content_page == "false" && re.line.includes(result.value)) {
                                                    //         if (re.lineNumber <= 3) {
                                                    //             pageid = re.pageId;
                                                    //         } else {
                                                    //             pageid = re.pageId + 1;
                                                    //         }
                                                    //     }
                                                    // })
                                                    // return pageid;
                                                    let a = [];
                                                    for (let r = 0; r < pdfData.length; r++) {
                                                        // let k = "p" + r;
                                                        if (!util_1.isNullOrUndefined(pdfData[r].content_page) && (pdfData[r].content_page == "true" || pdfData[r].content_page == true) && pdfData[r].content_page !== "false") {
                                                            if (!pdfData[r].line.toUpperCase().includes('CASES REPORTED') && !pdfData[r].line.toUpperCase().includes("BOTSWANA LAW REPORTS")) {
                                                                a.push(pdfData[r]);
                                                                pdfData[r] = ({ p: "r" });
                                                            }
                                                            //  else {
                                                            //     pdfData[r] = ({ p: "r" })
                                                            // }
                                                        }
                                                    }
                                                    a.sort((a, b) => a.line.split(' ')[a.line.split(' ').length - 1] - b.line.split(' ')[b.line.split(' ').length - 1]);
                                                    let index = 0;
                                                    for (let o = 0; o < a.length; o++) {
                                                        if (!util_1.isNullOrUndefined(a[o].line) && a[o].line !== "" && !util_1.isNullOrUndefined(a[o + 1]) && !util_1.isNullOrUndefined(a[o + 1].line) && a[o + 1].line !== "") {
                                                            let g = a[o].line.split(' ');
                                                            let h = a[o + 1].line.split(' ');
                                                            if (!util_1.isNullOrUndefined(a[o + 1]) && g[g.length - 1] == h[h.length - 1]) {
                                                                let c = (a[o].line.match(/,/g) || []).length;
                                                                let m = (a[o + 1].line.match(/,/g) || []).length;
                                                                if (c > m) {
                                                                    a.splice(o, 1);
                                                                }
                                                                else {
                                                                    a.splice(o + 1, 1);
                                                                }
                                                            }
                                                        }
                                                    }
                                                    // let d = [];
                                                    let court = ['CIRCUIT COURT', 'COURT OF APPEAL', 'INDUSTRIAL COURT', 'HIGH COURT'];
                                                    let occurrence = 0;
                                                    for (let d = 0; d < a.length; d++) {
                                                        if (!util_1.isNullOrUndefined(a[d].content_page) && a[d].content_page) {
                                                            // if (!a[d].line.toUpperCase().includes('CASES REPORTED') && !a[d].line.toUpperCase().includes("BOTSWANA LAW REPORTS")) {
                                                            let j = a[d].line.split(' ')[a[d].line.split(' ').length - 1];
                                                            if (!isNaN(j)) {
                                                                let i = a[d].line.indexOf(". .");
                                                                if (i !== -1 || i !== '-1') {
                                                                    let s = a[d].line.substring(0, i);
                                                                    if (!util_1.isNullOrUndefined(s) && s !== '') {
                                                                        s = s.replace(', (IC)', '');
                                                                        s = s.replace(', (CC)', '');
                                                                        s = s.replace(', (CA)', '');
                                                                        s = s.replace(', (HC)', '');
                                                                        s = s.trim();
                                                                        let id = 0;
                                                                        for (let f = 0; f < pdfData.length; f++) {
                                                                            if (id !== pdfData[f].pageId) {
                                                                                occurrence = 0;
                                                                                id = pdfData[f].pageId;
                                                                            }
                                                                            if (!util_1.isNullOrUndefined(pdfData[f].line) && pdfData[f].line[0].toUpperCase() == pdfData[f].line[0] && pdfData[f].line[1] == ' ') {
                                                                                pdfData[f].line = pdfData[f].line.substring(2, pdfData[f].line.length);
                                                                            }
                                                                            else if (!util_1.isNullOrUndefined(pdfData[f].line) && pdfData[f].line[pdfData[f].line.length - 1].toUpperCase() == pdfData[f].line[pdfData[f].line.length - 1] && pdfData[f].line[pdfData[f].line.length - 1] == ' ') {
                                                                                pdfData[f].line = pdfData[f].line.substring(0, pdfData[f].line.length - 2);
                                                                            }
                                                                            // pdfData[f]['occurrence'] = 1
                                                                            if (!util_1.isNullOrUndefined(pdfData[f].line) && pdfData[f].line.length > 6 && s.toUpperCase().trim() == pdfData[f].line.toUpperCase().trim()) { // && pdfData[f].bold == true   s.toUpperCase().includes(pdfData[f].line.toUpperCase().trim())
                                                                                occurrence += 1;
                                                                                for (let c = 0; c < court.length; c++) {
                                                                                    if ((!util_1.isNullOrUndefined(pdfData[f + 1].line) && pdfData[f + 1].line.includes(court[c])) || (!util_1.isNullOrUndefined(pdfData[f + 2].line) && pdfData[f + 2].line.includes(court[c])) || (!util_1.isNullOrUndefined(pdfData[f + 3].line) && pdfData[f + 3].line.includes(court[c])) || (!util_1.isNullOrUndefined(pdfData[f + 4].line) && pdfData[f + 4].line.includes(court[c])) || (!util_1.isNullOrUndefined(pdfData[f + 5].line) && pdfData[f + 5].line.includes(court[c])) || (!util_1.isNullOrUndefined(pdfData[f + 6].line) && pdfData[f + 6].line.includes(court[c]))) {
                                                                                        a[d]['splitId'] = pdfData[f].pageId;
                                                                                        a[d]['occurrence'] = occurrence;
                                                                                        a[d]['splitText'] = s;
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            // }
                                                        }
                                                    }
                                                    for (let q = 0; q < pdfData.length; q++) {
                                                        if (!util_1.isNullOrUndefined(pdfData[q].p) && pdfData[q].p == 'r') {
                                                            // index = p;
                                                            // break;
                                                            if (!util_1.isNullOrUndefined(a[index]) && a[index] !== "") {
                                                                pdfData[q] = a[index];
                                                                index++;
                                                            }
                                                        }
                                                        // if(isNullOrUndefined(pdfData[q]) || pdfData[q] == "undefined" || (!isNullOrUndefined(pdfData[q].p) && pdfData[q].p =='r')){
                                                        //     pdfData.splice(q, 1);
                                                        // }
                                                    }
                                                    // for(let w=index;w<pdfData.length;w++){
                                                    // }
                                                    result.value = "SortDone";
                                                    c = false;
                                                    // }
                                                }
                                                else if (result.field === "CILSA" && c == true) {
                                                    for (let d = 0; d < pdfData.length; d++) {
                                                        if (!util_1.isNullOrUndefined(pdfData[d].content_page) && (pdfData[d].content_page == "true" || pdfData[d].content_page == true) && !util_1.isNullOrUndefined(pdfData[d].line)) {
                                                            let no = pdfData[d].line.replace(/[^0-9]/g, '');
                                                            if (!util_1.isNullOrUndefined(no) && no !== "") {
                                                                let index = pdfData[d].line.indexOf(no);
                                                                if (pdfData[d].line[index - 1] == " " && pdfData[d].line[index + no.toString().length] == " ") {
                                                                    pdfData[d]['splitId'] = no;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    c = false;
                                                }
                                                else if (result.field.includes('+') || result.field.includes('-')) {
                                                    // result.field = result.field.split("[").join("");
                                                    // result.field = result.field.split("]").join("");
                                                    let expressionIndexing = {
                                                        Expression: result.field,
                                                        value: pdfData[increment]
                                                    };
                                                    //expressionIndexing["value"]["pdfData"] = JSON.stringify(pdfData)
                                                    expressionIndexing["value"]["index"] = increment;
                                                    let indexIn = yield this.juta_evaluateExpression(expressionIndexing);
                                                    let expression = {
                                                        Expression: result.value,
                                                        value: { pdfData: JSON.stringify(pdfData), index: index }
                                                    };
                                                    let tagexpression = {
                                                        Expression: result.value.replace(/line/g, 'tagline'),
                                                        value: { pdfData: JSON.stringify(pdfData), index: index }
                                                    };
                                                    for (const newfield of Object.keys(pdfData[increment])) {
                                                        if (newfield !== 'line') {
                                                            expression.value[newfield] = pdfData[increment][newfield];
                                                        }
                                                    }
                                                    if (!isNaN(indexIn) && indexIn < pdfData.length) {
                                                        let evalExpr = yield this.juta_evaluateExpression(expression);
                                                        let tagevalExpr = yield this.juta_evaluateExpression(tagexpression);
                                                        pdfData[indexIn][result.operator] = evalExpr;
                                                        pdfData[indexIn]['tagline'] = tagevalExpr;
                                                    }
                                                }
                                                else {
                                                    Expresult = yield this.juta_evaluateExpression(expression);
                                                    if (result.field == 'line') {
                                                        tagExpresult = yield this.juta_evaluateExpression(tagexpression);
                                                    }
                                                    // obj[result.field] = Expresult;
                                                    if (!k.includes(result.field)) {
                                                        finelObj[result.field] = Expresult;
                                                    }
                                                    if (result.field.trim() == "idFound") {
                                                        //---- Krishna ----
                                                        let splitId = Expresult.split(',');
                                                        let idObj = {};
                                                        if (!(!(splitId.length % 2))) {
                                                            idObj = {
                                                                "preProcessId": util_1.isNullOrUndefined(splitId[0]) ? "" : splitId[0],
                                                                "afterPreprocessId": util_1.isNullOrUndefined(splitId[1]) ? "" : splitId[1],
                                                                "preFotPreProcessId": util_1.isNullOrUndefined(splitId[2]) ? "" : splitId[2],
                                                                "afterFotPreProcessId": util_1.isNullOrUndefined(splitId[3]) ? "" : splitId[3],
                                                                "concatId": util_1.isNullOrUndefined(splitId[splitId.length - 1]) ? "" : splitId[splitId.length - 1]
                                                            };
                                                        }
                                                        else {
                                                            idObj = {
                                                                "preProcessId": util_1.isNullOrUndefined(splitId[0]) ? "" : splitId[0],
                                                                "afterPreprocessId": util_1.isNullOrUndefined(splitId[1]) ? "" : splitId[1],
                                                                "preFotPreProcessId": util_1.isNullOrUndefined(splitId[2]) ? "" : splitId[2],
                                                                "afterFotPreProcessId": util_1.isNullOrUndefined(splitId[3]) ? "" : splitId[3],
                                                            };
                                                        }
                                                        return idObj;
                                                    }
                                                    if (result.field == "exitnow" && (Expresult == 'true' || Expresult == true)) {
                                                        return pdfData;
                                                    }
                                                    if (pdfData[index][result.field] === undefined) {
                                                        finelObj[result.field] = Expresult;
                                                        // re[result.field] = Expresult;
                                                    }
                                                    pdfData[index][result.field] = Expresult;
                                                    if (result.field == 'line') {
                                                        pdfData[index]['tagline'] = tagExpresult;
                                                    }
                                                    //   pdfData[index][result.field] = Expresult
                                                    if (isNaN(Expresult)) {
                                                        if (!util_1.isNullOrUndefined(Expresult) && Expresult !== "" && ((Expresult.indexOf('is not defined') > -1 && Expresult.indexOf('pageIds') == -1) || Expresult.indexOf("Invalid regular expression flags") > -1)) {
                                                            pdfData[index][result.field] = result.value;
                                                            // obj[result.field] = result.value;
                                                            const regex = /^\s*(\w+)\s*\((.*)\)/gm;
                                                            const str = pdfData[index]['function'];
                                                            let m;
                                                            let functionName;
                                                            let args = [];
                                                            while ((m = regex.exec(str)) !== null) {
                                                                if (m.index === regex.lastIndex) {
                                                                    regex.lastIndex++;
                                                                }
                                                                m.forEach((match, groupIndex) => {
                                                                    console.log(`Found match, group ${groupIndex}: ${match}`);
                                                                    if (groupIndex == 1) {
                                                                        functionName = match;
                                                                    }
                                                                    else if (groupIndex == 2) {
                                                                        if (match.indexOf(',') > -1) {
                                                                            args = match.split(',');
                                                                        }
                                                                        else {
                                                                            args.push(match);
                                                                        }
                                                                    }
                                                                });
                                                            }
                                                            let replacedFilePath = "";
                                                            if (!util_1.isNullOrUndefined(input) && !util_1.isNullOrUndefined(input.rulesSetValue.file_Name) && input.rulesSetValue.file_Name !== "") {
                                                                replacedFilePath = input.rulesSetValue.file_Name; //.split('_').join('@');
                                                            }
                                                            // let replacedoutputFilePath = "";
                                                            // if (!isNullOrUndefined(input['file_Name'])) {
                                                            //     replacedoutputFilePath = fields.outputFilePath + input['file_Name'].split('_').join('@');
                                                            // } else {
                                                            //     replacedoutputFilePath = fields.outputFilePath.split('_').join('@');
                                                            // }
                                                            if (!util_1.isNullOrUndefined(replacedFilePath) && replacedFilePath !== "") {
                                                                let inputObj = {
                                                                    "function": functionName,
                                                                    // "inputPath": inputData.file_path,
                                                                    "inputPath": replacedFilePath,
                                                                    // "inputPath":"/home/user/Desktop/InputPdf/juta1.pdf",
                                                                    //    "outputPath": inputData.outputFilePath + input['file_Name'],
                                                                    //    "outputPath": fields.outputFilePath + fields.file_Name.substring(fields.file_Name.lastIndexOf('/')+1),
                                                                    "outputPath": replacedFilePath,
                                                                    // "outputPath":"/home/user/Desktop/OutputPdf/juta.pdf",
                                                                    "text": pdfData[index].text,
                                                                    "nextText": pdfData[index].nextText
                                                                };
                                                                if (!util_1.isNullOrUndefined(args) && args.length > 0) {
                                                                    for (let l = 0; l < args.length; l++) {
                                                                        let evalObjVal = {
                                                                            "Expression": args[l],
                                                                            "value": pdfData[index],
                                                                        };
                                                                        console.log('parameters@@@@@@@@@@@@@@@@@@', evalObjVal);
                                                                        if (isNaN(pdfData[index][args[l]])) {
                                                                            if (!util_1.isNullOrUndefined(pdfData[index][args[l]]) && pdfData[index][args[l]].indexOf('-') > -1) {
                                                                                // inputObj['input' + l] = pdfData[index][args[l]]
                                                                                inputObj['input' + l] = Array.from(new Set(pdfData[index][args[l]].split('-'))).toString().replace(/[,]/g, '-');
                                                                            }
                                                                            else {
                                                                                let result = yield this.juta_evaluateExpression(evalObjVal);
                                                                                result = result.toString();
                                                                                if (isNaN(result.replace(/\s/g, ''))) {
                                                                                    // inputObj['input' + l] = lastObj['pageIds'] + 1;
                                                                                    inputObj['input' + l] = strO;
                                                                                    inputObj['lastPage'] = "true";
                                                                                    // if (result.indexOf('-') > -1) {
                                                                                    //     inputObj['input' + l] = input[args[l]];
                                                                                    // }
                                                                                }
                                                                                else {
                                                                                    // inputObj['input' + l] = result.replace(/\s/g, '');
                                                                                    inputObj['input' + l] = strO;
                                                                                    inputObj['lastPage'] = "false";
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                // inputObj['input1']=input[args[0]];
                                                                let parameters = "";
                                                                let res;
                                                                if (config.pythonFunctions.indexOf(functionName) > -1) {
                                                                    console.log('Inside python function%%%%%%%%%%%%%%%%');
                                                                    if (pdfData[pdfData.length - 1].pageId < 1500) {
                                                                        let path = fields.file_Name;
                                                                        res = yield this.sh("sudo python3 juta.py " + path + " " + functionName + "  ");
                                                                        console.log("res --->>>", res);
                                                                        if (res.status === 0) {
                                                                            pOutout = JSON.parse(res.output);
                                                                            if (Array.isArray(pOutout)) {
                                                                                strO = "";
                                                                                for (let x = 0; x < pOutout.length; x++) {
                                                                                    if (x == 0) {
                                                                                        strO = pOutout[x];
                                                                                    }
                                                                                    else {
                                                                                        strO = strO + '-' + pOutout[x];
                                                                                    }
                                                                                }
                                                                                finelObj['pageIds'] = strO;
                                                                                // inputObj['function'] = 'deletePage'
                                                                                // inputObj['input0'] = strO;
                                                                                // parameters = JSON.stringify(JSON.stringify(inputObj))
                                                                                // res = await this.sh("java -cp .:json-20190722.jar:pdfbox-2.0.3.jar:fontbox-2.0.3.jar:commons-logging-1.2.jar:json-simple-1.1.1.jar:bcmail-jdk15on-166.jar:bcpkix-jdk15on-166.jar:bcprov-jdk15on-166.jar  NewPdfBox " + parameters);
                                                                                // console.log("res --->>>", res);
                                                                                // if (res.status === 1) {
                                                                                //     //throw res.err;
                                                                                // }
                                                                                // output['pageIds']=strO
                                                                            }
                                                                        }
                                                                    }
                                                                    console.log('End python function%%%%%%%%%%%%%%%%');
                                                                }
                                                                else {
                                                                    if (!util_1.isNullOrUndefined(functionName) && functionName == "fullCropPDF") {
                                                                        if (!util_1.isNullOrUndefined(pdfData[index].crop) && pdfData[index].crop !== "undefined" && pdfData[index].crop !== "") {
                                                                            inputObj['input0'] = pdfData[index].crop;
                                                                        }
                                                                        // else if (!inputObj.inputPath.toLowerCase().includes("report")) {
                                                                        //     inputObj.function = "cropPoint";
                                                                        //     parameters = JSON.stringify(JSON.stringify(inputObj))
                                                                        //     let resp = await this.sh("java -cp .:json-20190722.jar:pdfbox-2.0.3.jar:fontbox-2.0.3.jar:commons-logging-1.2.jar:json-simple-1.1.1.jar:bcmail-jdk15on-166.jar:bcpkix-jdk15on-166.jar:bcprov-jdk15on-166.jar  NewPdfBox " + parameters);
                                                                        //     if (!isNullOrUndefined(resp) && resp['status'] == 0) {
                                                                        //         let res = JSON.parse(resp['output']);
                                                                        //         let k
                                                                        //         k = Object.keys(res);
                                                                        //         if (k.includes('cmX') || k.includes('cmY')) {
                                                                        //             k.forEach((k) => {
                                                                        //                 if (k !== "cmX" && k !== "cmY") {
                                                                        //                     if (k[1] == "X") {
                                                                        //                         res[k] = res[k] + res["cmX"]
                                                                        //                     } else if (k[1] == "Y") {
                                                                        //                         res[k] = res[k] + res["cmY"]
                                                                        //                     }
                                                                        //                 }
                                                                        //             })
                                                                        //         }
                                                                        //         let result = [];
                                                                        //         k.sort((a, b) => a.replace(/^\D+/g, '') - b.replace(/^\D+/g, ''));
                                                                        //         let s = k
                                                                        //         for (let r = 0; r < s.length; r++) {
                                                                        //             if (s[r].includes('w')) {
                                                                        //                 let obj = {};
                                                                        //                 for (let f = 0; f < 5; f++) {
                                                                        //                     if (!isNullOrUndefined(obj[s[r + f]]) && obj[s[r + f]] !== "") {
                                                                        //                         obj[s[r + f].substring(0, s[r + f].indexOf(s[r + f].replace(/^\D+/g, '')))] = res[s[r + f]];
                                                                        //                     }
                                                                        //                 }
                                                                        //                 result.push(obj);
                                                                        //                 r = r + 4
                                                                        //             } else {
                                                                        //                 let obj = {};
                                                                        //                 for (let g = 0; g < 4; g++) {
                                                                        //                     if (!isNullOrUndefined(obj) && !isNullOrUndefined(s[r + g])) {
                                                                        //                         obj[s[r + g].substring(0, s[r + g].indexOf(s[r + g].replace(/^\D+/g, '')))] = res[s[r + g]];
                                                                        //                     }
                                                                        //                 }
                                                                        //                 result.push(obj);
                                                                        //                 r = r + 3
                                                                        //             }
                                                                        //         }
                                                                        //         result.forEach((o) => {
                                                                        //             if (o.w > 2) {
                                                                        //                 o.mY = o.lY - o.w;
                                                                        //                 o.mX = o.lX;
                                                                        //                 o['flag'] = "Vertical"
                                                                        //             }
                                                                        //             if (o.mY == o.lY) {
                                                                        //                 o['flag'] = "Horizontal"
                                                                        //             }
                                                                        //         })
                                                                        //         let minX = 999999
                                                                        //         let maxY = 0
                                                                        //         let maxX = 0
                                                                        //         let minY = 999999
                                                                        //         result.forEach((w) => {
                                                                        //             if (w.flag == "Vertical") {
                                                                        //                 if (maxX < w.mX) {
                                                                        //                     maxX = w.mX
                                                                        //                 } else if (minX > w.mX) {
                                                                        //                     minX = w.mX;
                                                                        //                 }
                                                                        //             }
                                                                        //             if (w.flag == "Horizontal") {
                                                                        //                 if (maxY < w.mY) {
                                                                        //                     maxY = w.mY;
                                                                        //                 }
                                                                        //                 else if (minY > w.mY) {
                                                                        //                     minY = w.mY;
                                                                        //                 }
                                                                        //             }
                                                                        //         })
                                                                        //         console.log("minx", minX, "maxy", maxY, "maxX", maxX, "minY", minY);
                                                                        //         inputObj['input0'] = minX + "@" + maxX + "@" + maxY + "@" + minY;
                                                                        //     }
                                                                        //     console.log("Res-->>", res);
                                                                        // }
                                                                        else if (inputObj.inputPath.toLowerCase().includes("report")) {
                                                                            inputObj['input1'] = "0";
                                                                            let res1 = yield this.sh("sudo python3 juta.py " + replacedFilePath + " " + "fullCropPDF" + "  ");
                                                                            if (res1['status'] == 1 && !util_1.isNullOrUndefined(res1['err']) && !util_1.isNullOrUndefined(res1['err']['message']) && res1['err']['message'].includes('Command failed')) {
                                                                                console.log("error in finding Crop points");
                                                                            }
                                                                            else {
                                                                                inputObj['input0'] = res1['output'].substring(0, res1['output'].length - 1);
                                                                                console.log(res1);
                                                                            }
                                                                            inputObj.function = "fullCropPDF";
                                                                            parameters = JSON.stringify(JSON.stringify(inputObj));
                                                                            res = yield this.sh("java -cp .:json-20190722.jar:pdfbox-2.0.3.jar:fontbox-2.0.3.jar:commons-logging-1.2.jar:json-simple-1.1.1.jar:bcmail-jdk15on-166.jar:bcpkix-jdk15on-166.jar:bcprov-jdk15on-166.jar:commons-lang3-3.11.jar  NewPdfBox " + parameters);
                                                                            let r = this.sh("sudo chown -R " + env_2.env.fileConfig.fileUser + ":" + env_2.env.fileConfig.fileUser + " " + inputObj.outputPath);
                                                                            console.log("res --->>>", res, r);
                                                                            if (res.status === 1) {
                                                                                //throw res.err;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (ruleSetCount == ruleSet.length && isDataOperation == true) {
                                increment = increment - 1;
                                index = index - 1;
                            }
                        }
                    }
                    return pdfData;
                }
            }
            catch (error) {
                return error;
            }
        });
    }
    juta_EvaluateRule(ruleSet, fields) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let keyList = Object.keys(fields);
                let finalResult = {};
                // ruleSet.forEach(myrules => {
                for (const myrules of ruleSet) {
                    for (let i = 0; i < myrules.rules.length; i++) {
                        let matchCriteriaCount = 0;
                        let totalCriteria = 0;
                        totalCriteria = myrules.rules[i].rule.criteria.length;
                        // myrules.rules[i].rule.criteria.forEach( criteria => {
                        for (const criteria of myrules.rules[i].rule.criteria) {
                            if (criteria.value !== "") {
                                let expression = {
                                    Expression: criteria.value,
                                    value: fields
                                };
                                let val = yield this.juta_evaluateExpression(expression);
                                let self = this;
                                let isOutOfField = false;
                                if (keyList.indexOf(criteria.field) == -1) {
                                    expression = {
                                        Expression: criteria.field,
                                        value: fields
                                    };
                                    fields[criteria.field] = yield this.juta_evaluateExpression(expression);
                                    isOutOfField = true;
                                }
                                if (val == "true") {
                                    val = true;
                                }
                                if (val == "false") {
                                    val = false;
                                }
                                if (fields[criteria.field] == "true") {
                                    fields[criteria.field] = true;
                                }
                                if (fields[criteria.field] == "false") {
                                    fields[criteria.field] = false;
                                }
                                if (self.operators[criteria.operator](fields[criteria.field], val)) {
                                    matchCriteriaCount++;
                                }
                                if (isOutOfField) {
                                    delete fields[criteria.field];
                                }
                            }
                            else {
                                totalCriteria = totalCriteria - 1;
                            }
                        }
                        if (matchCriteriaCount == totalCriteria) {
                            //     myrules.rules[i].rule.result.forEach( result=>{
                            //     if(result.value!==""){
                            //             let expression={
                            //             Expression:result.value,
                            //             value:fields
                            //              }
                            //              finalResult[result.field]= await this.evaluateExpression(expression)
                            //     }
                            // })
                            for (const result of myrules.rules[i].rule.result) {
                                if (result.value !== "") {
                                    let expression = {
                                        Expression: result.value,
                                        value: fields
                                    };
                                    finalResult[result.field] = yield this.juta_evaluateExpression(expression);
                                }
                            }
                            i = myrules.rules.length;
                            for (let key in finalResult) {
                                if (fields.hasOwnProperty(key)) {
                                    if (Array.isArray(finalResult[key])) {
                                        fields[key] = finalResult[key];
                                    }
                                    else {
                                        fields[key] = finalResult[key].toString();
                                    }
                                }
                            }
                        }
                    }
                }
                // for (let key in finalResult) {
                //     if (fields.hasOwnProperty(key)) {
                //         fields[key]=finalResult[key]
                //         // console.log(key + " -> " + p[key]);
                //     }
                // }
                return fields;
            }
            catch (error) {
                return error;
            }
        });
    }
    juta_evaluateExpression(expression) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let result;
                let MyExpression = expression.Expression;
                MyExpression = expression.Expression.replace("this.", "");
                //Register Newly Created function here
                // let j = 0;
                let myNewFunction = ["isNullOrUndefined", "!isNullOrUndefined", "tostring", "split", "evaluateOrganization", 'evaluateBranch', 'lookUp', 'lookUpCount', 'fuzzylookUp', "avg", "median", "mean", "sum", "count", "range", "isDate", "date", "digitLengthNew", "digitLength", "includeAnyOf", "alternateData", "noticeExclusion", "getData", "getContentEnd", "createCustomTable", "replaceAll", "convertToTitleCase", "NthWord", "roman_to_Int", "isRoman", "firstCharUpperCase"];
                let splitrCharacter = ["(", ")", ",", "+", "-", "/", "*", "%", ".", "[", "]", "{", "}", "^", "?", ":", "=", "|", "||", "&", ">", "<"];
                let operator = [":", "?", "+", "-", "/", "*", ">", "<", "!", ">=", "<=", "%", "==", "===", "^", "|", "&", "(", ")", ".length"];
                let firstString = "";
                let i = 0;
                let addColumn = 0;
                let currentString = "";
                let secondString = "";
                let tempFirstString = "";
                let isCotesFound = false;
                let executebleStatement = false;
                while (i < MyExpression.length) {
                    currentString = "";
                    while (splitrCharacter.indexOf(MyExpression.charAt(i)) == -1 && i < MyExpression.length) {
                        currentString = currentString + MyExpression.charAt(i);
                        i++;
                    }
                    // if (currentString == "dateFormat") {
                    //     let date = MyExpression.substring(i + 2, MyExpression.indexOf(",") - 1)
                    //     let dataValue = expression.value[date]
                    //     let outPut = await this.dateFormat(dataValue, MyExpression.substring(MyExpression.indexOf(",") + 2, MyExpression.length))
                    //     return outPut;
                    // }
                    if (currentString == "isNullOrUndefined") {
                        let data = MyExpression.substring(MyExpression.indexOf("(") + 1, MyExpression.indexOf(")"));
                        return this.isNullOrUndefined(data, expression.value);
                    }
                    if (currentString == "innerLookUP") { //innerLookUP(invoiceItems,tappoline,['PO_Quantity','PO_Number'],['PO_UOM','PO_Quantity'])",
                        let ind1 = MyExpression.indexOf(",") + 1;
                        let ind2 = MyExpression.indexOf("]") + 1;
                        let tableName = MyExpression.substring(ind1, MyExpression.indexOf("[") - 1);
                        let data = MyExpression.substring(i + 1, ind1 - 1);
                        let match = MyExpression.substring(MyExpression.indexOf("["), MyExpression.indexOf("]") + 1);
                        // let x=MyExpression.indexOf(MyExpression.indexOf("]")+1,"]");
                        // x
                        let val = MyExpression.substring(ind2 + 1, MyExpression.split("]", 2).join("]").length + 1);
                        // let project = MyExpression.substring(ind2+1,MyExpression.indexOf(")"))
                        // let projectArry = MyExpression.split(",")
                        // let project= projectArry[projectArry.length-1]
                        let project = MyExpression.substring(MyExpression.split("]", 2).join("]").length + 2, MyExpression.indexOf(")"));
                        let dataValue = expression.value[data];
                        let outPut = yield this.innerLookUP(dataValue, tableName, match, val, project, expression.value);
                        return outPut;
                    }
                    if (currentString == "") {
                        i++;
                    }
                    if (!this.findMe(currentString, myNewFunction) && currentString !== "") { //if expression and inbuild function
                        addColumn = 0;
                        i = i - currentString.length;
                        if (util_1.isNullOrUndefined(expression.value[currentString]) || expression.value[currentString].toString().includes("[native code]")) { //if value of the current string undefined or is not a native function
                            let myStr = currentString;
                            let cotes = "\'";
                            let temp = myStr.split(cotes).join("");
                            cotes = "\"";
                            temp = myStr.split(cotes).join("");
                            if (!util_1.isNullOrUndefined(temp) && isNaN(Number(temp)) === false) {
                                if (currentString.trim().length > 0) {
                                    firstString = MyExpression.substring(0, i) + currentString;
                                    isCotesFound = true;
                                }
                                else {
                                    firstString = MyExpression.substring(0, i) + "";
                                }
                            }
                            else {
                                firstString = MyExpression.substring(0, i) + currentString;
                            }
                        }
                        else {
                            if (!util_1.isNullOrUndefined(expression.value[currentString]) && isNaN(expression.value[currentString]) === false) { //if variable name is numeric
                                firstString = MyExpression.substring(0, i) + expression.value[currentString];
                            }
                            else {
                                if (!util_1.isNullOrUndefined(expression.value[currentString]) && isNaN(Number(expression.value[currentString])) === false) { //if variable value is numeric
                                    tempFirstString = firstString;
                                    firstString = MyExpression.substring(0, i) + expression.value[currentString];
                                    addColumn = 0;
                                    if (MyExpression[tempFirstString.length + 2] === "." || MyExpression[i + currentString.length]) {
                                        firstString = MyExpression.substring(0, i) + '"' + expression.value[currentString] + '"';
                                        addColumn = 2;
                                    }
                                    else {
                                        if (MyExpression[currentString.length] === ".") {
                                            firstString = '"' + firstString + '"';
                                            addColumn = 2;
                                        }
                                    }
                                }
                                else {
                                    if (!util_1.isNullOrUndefined(expression.value[currentString]) && expression.value[currentString].charAt(expression.value[currentString].length - 1) !== ']') {
                                        firstString = MyExpression.substring(0, i) + '"' + expression.value[currentString] + '"'; //if variable value is string
                                        addColumn = 2;
                                    }
                                    else {
                                        firstString = MyExpression.substring(0, i) + expression.value[currentString]; //if variable value is string
                                        addColumn = 0;
                                    }
                                }
                            }
                        }
                        if (isCotesFound) { //remove this if else if successfully tested
                            i = i + currentString.length;
                            //i = i + temp.length;
                        }
                        else {
                            i = i + currentString.length;
                        }
                        secondString = MyExpression.substring(i);
                        i++;
                        // if(secondString[0]==="."){
                        //     firstString='"'+firstString+'"'
                        //     i=i+2;
                        //     }
                        MyExpression = firstString + secondString;
                        if (!util_1.isNullOrUndefined(expression.value[currentString]) && expression.value[currentString].toString().includes("[native code]") == false) {
                            if (!isNaN(expression.value[currentString])) {
                                let numberLength = expression.value[currentString].toString().length;
                                i = i + numberLength - currentString.length + addColumn;
                            }
                            else {
                                i = i + expression.value[currentString].length - currentString.length + addColumn;
                            }
                        }
                    }
                    else {
                        if (currentString !== "") {
                            i = i - currentString.length - 1;
                            if (MyExpression.charAt(i + 1) === '!') { //to handle not operator for the custome function
                                firstString = MyExpression.substring(0, i + 1) + "!this.";
                                secondString = MyExpression.substring(i + 2);
                                i = i + 6 + currentString.length + 1;
                            }
                            else {
                                firstString = MyExpression.substring(0, i + 1) + "this.";
                                secondString = MyExpression.substring(i + 1);
                                i = i + 5 + currentString.length + 1;
                            }
                            MyExpression = firstString + secondString;
                        }
                    }
                }
                operator.forEach(op => {
                    if (!executebleStatement) {
                        if (MyExpression.includes(op)) {
                            executebleStatement = true;
                        }
                    }
                });
                if (executebleStatement) {
                    MyExpression = firstString + secondString;
                    // MyExpression=MyExpression.replace("this.","")
                    // result = new Function("return " + MyExpression)()
                    if (!MyExpression.includes("this.")) {
                        result = yield new Function("return " + MyExpression)();
                    }
                    else {
                        result = !util_1.isNullOrUndefined(MyExpression) ? yield eval(MyExpression) : MyExpression;
                    }
                }
                else {
                    MyExpression = MyExpression.replace('"', '');
                    MyExpression = MyExpression.replace(/"([^"]*)$/, '$1');
                    result = MyExpression;
                }
                if (typeof result === "object" && !util_1.isNullOrUndefined(expression.value['isObject'])) {
                    return JSON.stringify(result);
                }
                return result;
            }
            catch (err) {
                console.log("error", err);
                return err.message;
            }
        });
    }
    syncUpCollections(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const mClient = yield MongoClient.connect(input.mongoString);
            const db = mClient.db(input.mongoString.split('/')[input.mongoString.split('/').length - 1]);
            try {
                let dumpCollections = JSON.parse(input.collections);
                if (!util_1.isNullOrUndefined(input.from)) {
                    if (input.from == "local") {
                        let promArr = [];
                        for (let col of dumpCollections) {
                            promArr.push(db.collection(col).find({ "synced": { $ne: true } }));
                        }
                        let resA = yield Promise.all(promArr);
                        for (let i = 0; i < dumpCollections.length; i++) {
                            let Res = resA[i];
                            let finalRes = [];
                            for (let s of Res) {
                                finalRes.push(db.collection(dumpCollections[i]).update({ _id: ObjectId(String(s._id)) }, { $set: s }, { upsert: true }));
                                finalRes.push(db.collection(dumpCollections[i]).findOneAndUpdate({ _id: ObjectId(String(s._id)) }, { $set: { "synced": true } }));
                            }
                            let res2 = yield Promise.all(finalRes);
                            console.log("Total Updated--->", res2.length);
                        }
                    }
                    return { status: 0, "message": 'File read successfull', data: output };
                }
                mClient.close();
                throw "No Input";
            }
            catch (e) {
                mClient.close();
                this.log.error("Error in Socket triggering for read file utility." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    getAllFiles(dirPath, arrayOfFiles) {
        const self = this;
        let files = fs.readdirSync(dirPath);
        arrayOfFiles = arrayOfFiles || [];
        files.forEach(function (file) {
            if (fs.statSync(dirPath + "/" + file).isDirectory()) {
                arrayOfFiles = self.getAllFiles(dirPath + "/" + file, arrayOfFiles);
            }
            else {
                arrayOfFiles.push(dirPath + "/" + file);
            }
        });
        return arrayOfFiles;
    }
    moveFromTo(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let src = input.from;
                let dest = input.to;
                if (!fs.existsSync(dest)) {
                    fs.mkdirSync(dest, { recursive: true });
                }
                console.log("Moving file from ---", src, " ---- ", dest);
                let res = yield this.sh("mv " + src + " " + dest);
                console.log(res);
                outputParameters['outputBody'] = "cleaned.";
                this.log.info("Files Moved---");
                return { message: "server folder cleaned.", status: 0, data: outputParameters };
            }
            catch (e) {
                this.log.error("Error while moving file ---" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    createWDforTrainingSetUp(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const self = this;
            try {
                this.log.info("read files from folder.");
                if (!util_1.isNullOrUndefined(input) && !util_1.isNullOrUndefined(input.filePath) && !util_1.isNullOrUndefined(input.wD)) {
                    const AdmZip = require("adm-zip");
                    let dirname = input.filePath.substr(input.filePath.lastIndexOf('/') + 1).replace('_training.zip', '');
                    let zipPath = `${dirname}_training.zip`;
                    let unzipPath = input.wD.replace(/(\/)$/, '') + `/${dirname}/PDF/`;
                    let subId = dirname.split('_')[0];
                    let orgId = dirname.split('_')[1];
                    let csvPath = `${subId}_${orgId}_historicalData.csv`;
                    if (fs.existsSync(unzipPath)) {
                        fs.rmdirSync(unzipPath, { recursive: true });
                    }
                    fs.mkdirSync(unzipPath, { recursive: true });
                    let trashDir = input.wD.replace(/(\/)$/, '') + '/' + 'Processed/';
                    if (!fs.existsSync(trashDir)) {
                        fs.mkdirSync(trashDir, { recursive: true });
                    }
                    let tempDir = trashDir + 'temp/';
                    if (fs.existsSync(tempDir)) {
                        fs.rmdirSync(tempDir, { recursive: true });
                    }
                    fs.mkdirSync(tempDir, { recursive: true });
                    console.log('Unzipping...');
                    let zip = new AdmZip(input.filePath);
                    zip.extractAllTo(tempDir, true);
                    let files = self.getAllFiles(tempDir, []);
                    console.log('moving csv file.....');
                    let oldPath = `${tempDir}${csvPath}`;
                    let newPath = `${unzipPath.replace(/(PDF|PDF\/)$/, '')}${csvPath}`;
                    const cPath = newPath;
                    console.log(oldPath, newPath);
                    fs.renameSync(oldPath, newPath);
                    // let files = fs.readdirSync(unzipPath);
                    if (files.length == 0) {
                        throw "Please, Add files in Directory...";
                    }
                    console.log("From User--->", files);
                    let finalFile = [];
                    let count = 0;
                    for (let file of files) {
                        if (!/(.pdf|.jpg|.jpeg|.png|.tiff)$/.test(file)) {
                            // fs.unlinkSync(unzipPath + '/' + file);
                        }
                        else {
                            let ext = file.substr(file.lastIndexOf('.') + 1) !== file ? file.substr(file.lastIndexOf('.') + 1) : '';
                            let f = `${subId}_${orgId}_${count++}.${ext}`;
                            console.log("Renaming the file--->", file, " ", f);
                            fs.renameSync(file, unzipPath + '/' + f);
                            finalFile.push(f);
                        }
                    }
                    console.log("Final-->", finalFile);
                    let obj = {};
                    obj['subId'] = ObjectId(subId);
                    obj['orgId'] = ObjectId(orgId);
                    obj['uFiles'] = finalFile.map(a => ({ 'fName': unzipPath + '/' + a, 'trained': false }));
                    obj['filesCount'] = obj['uFiles'].length;
                    if (finalFile.length == 0) {
                        output['next'] = false;
                    }
                    else {
                        output['next'] = true;
                    }
                    let res = yield Promise.all([(db.collection('historicalData')).update({ subId: obj['subId'], orgId: obj['orgId'] }, { $set: obj }, { upsert: true }), (db.collection('subscribers')).findById(obj['subId'])]);
                    res = JSON.parse(JSON.stringify(res));
                    if (res && res[1] && res[1].name) {
                        output['subName'] = res[1].name;
                    }
                    console.log(res);
                    console.log("Moving zip file ....");
                    oldPath = input.filePath;
                    newPath = `${trashDir.replace(/(\/)$/, '')}/${zipPath}`;
                    console.log(oldPath, newPath);
                    fs.renameSync(oldPath, newPath);
                    output['trainingCsv'] = cPath;
                    output['trainingFiles'] = unzipPath;
                    output['sId'] = subId;
                    output['oId'] = orgId;
                    return { status: 0, "message": 'File read successfull', data: output };
                }
                else {
                    output['filePath'] = null;
                    return { status: 1, "message": 'directoryPath is not found', data: output };
                }
            }
            catch (e) {
                this.log.error("Error in createWD " + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    combinedLinestoPdfData(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            // const self = this;
            try {
                let fieldName = input.fieldToCopy;
                fieldName = fieldName && fieldName !== '' ? fieldName : 'lineWithCombineWordsNew';
                for (let page = 0, len = input.combineLines.length; page < len; page++) {
                    input.combineLines[page][fieldName].filter(a => a.filter(x => x.pageNo = page));
                }
                if (input.combineLines && Array.isArray(input.combineLines)) {
                    let pdfData = [];
                    if (["true", true].includes(input.lineConcat)) {
                        for (let rObj of input.combineLines) {
                            for (let lines of rObj[fieldName]) {
                                if (lines.length > 1) {
                                    let name = lines.map(a => a.Name).join(" ");
                                    lines[0].Name = name;
                                    lines[0].rightX = lines[lines.length - 1].rightX;
                                    pdfData.push(JSON.parse(JSON.stringify(lines[0])));
                                }
                                else if (lines.length) {
                                    pdfData.push(JSON.parse(JSON.stringify(lines[0])));
                                }
                            }
                        }
                    }
                    else {
                        let lineWithCombineWords = [];
                        input.combineLines.filter(a => lineWithCombineWords = lineWithCombineWords.concat(a[fieldName]));
                        lineWithCombineWords.filter(a => pdfData = pdfData.concat(a));
                    }
                    output['pdfData'] = pdfData;
                    return { message: "server folder cleaned.", status: 0, data: output };
                }
                else {
                    throw { message: "Unknown input" };
                }
            }
            catch (e) {
                this.log.error("Error in createWD " + JSON.stringify(e));
                return { message: e, status: 1, data: e };
            }
        });
    }
    splitPdfData(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            // const self = this;
            try {
                let combineLines = input.combineLines;
                let cPages = input.cPages;
                let ePages = input.ePages;
                let fileRefNum = input.ref_no;
                cPages = cPages.map(a => Number(a));
                ePages = ePages.map(a => Number(a));
                if (combineLines && cPages && ePages) {
                    let cData = [];
                    let eData = [];
                    let cImages = [];
                    let eImages = [];
                    for (let i = 0; i < combineLines.length; i++) {
                        if (cPages.includes(i)) {
                            cData.push(combineLines[i]);
                        }
                        if (ePages.includes(i)) {
                            eData.push(combineLines[i]);
                        }
                    }
                    if (fileRefNum) {
                        let fileD = yield (db.collection('fileuploadhistories')).findOne({ fileRefNum: fileRefNum }).lean();
                        let newImagePath = [];
                        if (fileD && fileD['imagesPath'] && Array.isArray(fileD['imagesPath'])) {
                            for (let i = 0; i < fileD['imagesPath'].length; i++) {
                                if (cPages.includes(i)) {
                                    cImages.push(fileD['imagesPath'][i]);
                                    newImagePath.push(fileD['imagesPath'][i]);
                                }
                                else if (ePages.includes(i)) {
                                    eImages.push(fileD['imagesPath'][i]);
                                    newImagePath.push(fileD['imagesPath'][i]);
                                }
                            }
                            let res = yield (db.collection('fileuploadhistories')).findOneAndUpdate({ fileRefNum: fileRefNum }, { $set: { imagesPath: JSON.parse(JSON.stringify(newImagePath)) } }, { upsert: true });
                            console.log("Res---", res, fileD['imagesPath'], newImagePath);
                        }
                    }
                    output['cData'] = cData;
                    output['eData'] = eData;
                    output['cImages'] = cImages;
                    output['eImages'] = eImages;
                    output['isCheque'] = cPages.length > 0 ? true : false;
                    return { message: "Data splitted", status: 0, data: output };
                }
                else {
                    throw { message: "Unknown input" };
                }
            }
            catch (e) {
                this.log.error("Error in createWD " + JSON.stringify(e));
                return { message: e, status: 1, data: e };
            }
        });
    }
    insertDummyDocumentTrainings(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // to Display in TrainingComponenet
                let dTobj = {
                    userId: ObjectId(input.userId),
                    orgId: ObjectId(input.orgId),
                    documentType: input.docType,
                    "isDeleted": false,
                    subscriberId: ObjectId(input.subscriberId),
                    documentCsvData: []
                };
                let fileData = yield (db.collection("fileuploadhistories")).findOne({ fileRefNum: input.fileRefNum }).lean();
                let uObj = {
                    documentType: input.docType
                };
                if (fileData.imagesPath && fileData.imagesPath.length == 0) {
                    uObj['imagesPath'] = [{ imageFilePath: fileData['filePath'] }];
                }
                yield (db.collection("fileuploadhistories")).updateOne({ fileRefNum: input.fileRefNum }, { $set: uObj });
                let res = yield (db.collection("documenttrainings")).update({ fileRefNum: input.fileRefNum }, { $set: dTobj }, { upsert: true });
                console.log("res---------->", res);
                return { message: "Data splitted", status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error in createWD " + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    insertTable(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const self = this;
            try {
                let tableObject = input.tableObject;
                let fileRefNum = input.ref_no;
                let docType = input.docType;
                let ruleId = input.ruleId;
                // let tables = tableObject.map(a=>a.additionalInfoTable);
                console.log("length ---", tableObject.length);
                let lineItems = [];
                for (let table of tableObject) {
                    if (table.additionalInfoTable && Array.isArray(table.additionalInfoTable)) {
                        for (let item of table.additionalInfoTable) {
                            if (item.lineItems && Array.isArray(item.lineItems)) {
                                let obj = JSON.parse(JSON.stringify(item));
                                delete obj['lineItems'];
                                for (let l of item.lineItems) {
                                    let obj2 = JSON.parse(JSON.stringify(l));
                                    let finalObj = Object.assign({}, obj, obj2);
                                    lineItems.push(finalObj);
                                }
                            }
                        }
                    }
                }
                console.log("lineitems----", lineItems.length);
                let headerData = yield (db.collection(docType)).findOne({ referenceNumber: fileRefNum });
                headerData = JSON.parse(JSON.stringify(headerData));
                let ruleObj = {
                    id: ruleId,
                    rulesSetValue: {
                        invoiceItems: lineItems
                    }
                };
                if (!util_1.isNullOrUndefined(headerData) && Object.keys(headerData).length != 0) {
                    ruleObj.rulesSetValue = Object.assign({}, ruleObj.rulesSetValue, headerData);
                }
                let ruleRes = yield self.evaluateRuleSet(ruleObj);
                // console.log(ruleRes.invoiceItems);
                let invoiceItems = ruleRes.invoiceItems;
                let res = yield (db.collection(docType)).findOneAndUpdate({ referenceNumber: fileRefNum }, { $set: { invoiceItems: JSON.parse(JSON.stringify(invoiceItems)) } }, { upsert: true });
                console.log("res----", res);
                output["lineItems"] = invoiceItems;
                output["document"] = ruleRes;
                return { message: "Data splitted", status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error in createWD " + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    formatandSaveJson(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // to Display in TrainingComponenet
                let inputFieldName = input.fieldNames == '' ? [] : input.fieldNames.split(',');
                let attributeName = input.attributeNames == '' ? [] : input.attributeNames.split(',');
                let tableFieldName = input.tableFieldName == '' ? [] : input.tableFieldName.split(',');
                let tableAttributeName = input.tableAttributeName == '' ? [] : input.tableAttributeName.split(',');
                let inputJSON = typeof input.inputJSON == 'string' ? JSON.parse(input.inputJSON) : input.inputJSON;
                let headerFileName = input.headerFileName == '' ? 'header.json' : input.headerFileName;
                let tableFileName = input.tableFileName == '' ? 'table.json' : input.tableFileName;
                //let seperateJson = input.seperate;
                let finalHeaders = {};
                let path = input.savePath == '' ? config.cudapath : input.savePath;
                let referenceNo = input.inputJSON && input.inputJSON['referenceNumber'] ? input.inputJSON['referenceNumber'] : '';
                let finalTableData = [];
                if (!util_1.isNullOrUndefined(inputFieldName) && !util_1.isNullOrUndefined(attributeName) && inputFieldName.length === attributeName.length && !util_1.isNullOrUndefined(input.inputJSON)) {
                    finalHeaders = inputFieldName.reduce((final, el, i) => {
                        if (!util_1.isNullOrUndefined(inputJSON[el])) {
                            final[attributeName[i]] = inputJSON[el];
                        }
                        return final;
                    }, {});
                }
                if (!util_1.isNullOrUndefined(tableFieldName) && !util_1.isNullOrUndefined(tableAttributeName) && tableFieldName.length != 0 && tableFieldName.length == tableAttributeName.length && inputJSON.invoiceItems && inputJSON.invoiceItems.length > 0) {
                    for (let i = 0; i < inputJSON.invoiceItems.length; i++) {
                        let obj = {};
                        for (let j = 0; j < tableAttributeName.length; j++) {
                            if (!util_1.isNullOrUndefined(inputJSON.invoiceItems[i][tableFieldName[j]])) {
                                obj[tableAttributeName[j]] = inputJSON.invoiceItems[i][tableFieldName[j]];
                            }
                        }
                        finalTableData.push(obj);
                    }
                }
                if (headerFileName != '' && finalHeaders) {
                    let fileName = path + referenceNo + headerFileName;
                    fs.writeFileSync(fileName, JSON.stringify(finalHeaders));
                }
                if (tableFileName != '' && finalTableData.length > 0) {
                    let tablefilePath = path + referenceNo + tableFileName;
                    fs.writeFileSync(tablefilePath, JSON.stringify(finalTableData));
                }
                output['headerData'] = finalHeaders;
                output['tableData'] = finalTableData;
                return { message: "Data formated and saved", status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error in formating " + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    updateSubsOrg(files, mongodb_uri) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const mClient = yield MongoClient.connect(mongodb_uri);
            try {
                let sub = [];
                let org = [];
                for (let f of files) {
                    let spl = f.split('_');
                    if (spl.length == 3) {
                        sub.push(spl[0]);
                        org.push(spl[1]);
                    }
                }
                sub = sub.map(a => ObjectId(a));
                org = org.map(a => ObjectId(a));
                const db = mClient.db(mongodb_uri.split('/')[mongodb_uri.split('/').length - 1]);
                let res = yield Promise.all([db.collection('subscribers').find({ _id: { $in: sub } }).toArray(), db.collection('organisations').find({ _id: { $in: org } }).toArray(), db.collection('users').find({ subscriberId: { $in: sub } }).toArray()]);
                let subD = res[0];
                let orgD = res[1];
                let userD = res[2];
                let finalRes = [];
                for (let s of subD) {
                    finalRes.push((db.collection('subscribers')).findOneAndUpdate({ _id: ObjectId(String(s._id)) }, { $set: s }, { upsert: true }));
                }
                for (let s of orgD) {
                    finalRes.push((db.collection('organisations')).findOneAndUpdate({ _id: ObjectId(String(s._id)) }, { $set: s }, { upsert: true }));
                }
                for (let s of userD) {
                    finalRes.push((db.collection('users')).findOneAndUpdate({ _id: ObjectId(String(s._id)) }, { $set: s }, { upsert: true }));
                }
                let res2 = yield Promise.all(finalRes);
                console.log(res2.length);
                mClient.close();
                return { status: 0 };
            }
            catch (e) {
                mClient.close();
                this.log.error("Error in Socket triggering for read file utility." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    checkForSameValue(input, output, botId, projectId, iterationId) {
        try {
            let ruleSetObj, key1, key2, matchKey, objField1, objField2, objField3;
            console.log("inside checkfor same value", JSON.stringify(input));
            var poArray = [];
            var GRNError = [];
            var POError = [];
            var poNumError = [];
            if (!util_1.isNullOrUndefined(input.key2) && (input.key2 != "") && !util_1.isNullOrUndefined(input.key1) && (input.key1 != "") && !util_1.isNullOrUndefined(input.matchKey) && (input.matchKey != "")) {
                key1 = input.key1; //EX159
                key2 = input.key2; //EX160
                matchKey = input.matchKey; //Item_PO_Number
            }
            if (!util_1.isNullOrUndefined(input.field1) && (input.field1 != "")) {
                objField1 = input.field1;
            }
            if (!util_1.isNullOrUndefined(input.field2) && (input.field2 != "")) {
                objField2 = input.field2;
            }
            if (!util_1.isNullOrUndefined(input.field3) && (input.field3 != "")) {
                objField3 = input.field3;
            }
            return new Promise(function (resolve, reject) {
                if (!util_1.isNullOrUndefined(input.inputObj) && (input.inputObj != "")) {
                    ruleSetObj = typeof input.inputObj == 'string' ? JSON.parse(input.inputObj) : input.inputObj;
                    console.log("input object", ruleSetObj);
                    for (let i = 0; i < ruleSetObj['invoiceItems'].length; i++) {
                        let element = ruleSetObj['invoiceItems'][i];
                        for (let key in element) {
                            if (key == matchKey) {
                                poArray.push(element[key]);
                            }
                        }
                    }
                    if (poArray.every(val => val === poArray[0])) {
                        console.log("inside same");
                        for (let i = 0; i < ruleSetObj['invoiceItems'].length; i++) {
                            let ele = ruleSetObj['invoiceItems'][i];
                            for (let index in ele) {
                                if ((index == "error") && (Array.isArray(ele[index])) && ele[index].length != 0) {
                                    let error = ele[index];
                                    console.log("inside same error loop", error);
                                    error.forEach(element => {
                                        let reg = new RegExp(key1, "ig");
                                        let reg1 = new RegExp(key2, "ig");
                                        console.log("element", element, reg1, reg1.test(element));
                                        console.log("element objField2", element[objField2], reg1.test(element[objField2]));
                                        console.log("element objField2", element[objField3], reg1.test(element[objField3]));
                                        if (reg.test(element)) {
                                            GRNError.push(element);
                                            console.log("GRN error first if", GRNError);
                                        }
                                        else if (reg.test(element[objField1])) {
                                            GRNError.push(element);
                                            console.log("GRN error second if", GRNError);
                                        }
                                        if (reg1.test(element)) {
                                            POError.push(element);
                                            console.log("PO error first if", POError);
                                        }
                                        else if (reg1.test(element[objField2])) {
                                            POError.push(element);
                                            console.log("PO error second if", POError);
                                        }
                                        else if (reg1.test(element[objField3])) {
                                            POError.push(element);
                                            console.log("PO error third if", POError);
                                        }
                                    });
                                }
                            }
                        }
                        output["PO_Number"] = ruleSetObj['invoiceItems'][0]['Item_PO_Number'];
                        // if (ruleSetObj['invoiceItems'][0]["PO_OWNER_EMAIL"] != "") {
                        //     output["PO_OWNER_EMAIL"] = ruleSetObj['invoiceItems'][0]["PO_OWNER_EMAIL"];
                        // } else
                        if (ruleSetObj['invoiceItems'][0]["PR_OWNER_EMAIL"] != "") {
                            output["PO_OWNER_EMAIL"] = ruleSetObj['invoiceItems'][0]["PR_OWNER_EMAIL"];
                        }
                        output["GRNError"] = GRNError;
                        output["POError"] = POError;
                        output["same"] = "true";
                    }
                    else {
                        console.log("inside different");
                        for (let i = 0; i < ruleSetObj['invoiceItems'].length; i++) {
                            let ele = ruleSetObj['invoiceItems'][i];
                            for (let index in ele) {
                                if ((index == "error") && (Array.isArray(ele[index])) && ele[index].length != 0) {
                                    let error = ele[index];
                                    error.forEach(element => {
                                        let reg1 = new RegExp(key2, "ig");
                                        if (reg1.test(element)) {
                                            POError.push(element);
                                            poNumError.push(element["Item_PO_Number"]);
                                            console.log("inside first if", POError, poNumError);
                                        }
                                        else if (reg1.test(element[objField2])) {
                                            POError.push(element);
                                            console.log("inside second if", POError, poNumError);
                                        }
                                        else if (reg1.test(element[objField3])) {
                                            POError.push(element);
                                            console.log("inside third if", POError, poNumError);
                                        }
                                    });
                                }
                            }
                        }
                        output["same"] = "false";
                        output["PO_Number"] = poNumError.join(",");
                        output["POError"] = POError;
                    }
                    output['POErrorlength'] = POError.length > 0 ? "true" : "false";
                    output['GRNErrorlength'] = GRNError.length > 0 ? "true" : "false";
                    resolve({ message: "Details found sucessfully", status: 0, data: output });
                }
                else {
                    resolve({ message: "Details not found sucessfully", status: 1, data: output });
                }
            });
        }
        catch (e) {
            this.log.error("Failed getting input " + e);
            return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
        }
    }
    update_fileuploadHistories(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("for update_fileuploadHistories");
                // console.log("body-----", JSON.stringify(req.body));
                let imagesPathaaray = input.imagesPathaaray;
                //let imagesPathaaray = input.outputArray;
                let fileRefNum = input.fileRefNum;
                let documentType = input.documentType;
                // const MongoClient = require('mongodb').MongoClient;
                // let mClient = await MongoClient.connect(env.dbConfig.mongodb_uri);
                // let db = await mClient.db(env.dbConfig.dbname);
                console.log("18----->", JSON.stringify(imagesPathaaray));
                yield fileUploadHistory.findOneAndUpdate({ fileRefNum: fileRefNum }, { $set: { imagesPath: imagesPathaaray, documentType: documentType } }, { upsert: true });
                let outputData = { "imagesPathaaray_op": imagesPathaaray, "uplodeStatus": true, 'statusCode': '200' };
                return { message: 'data saved successfully.', status: 0, data: outputData };
            }
            catch (err) {
                console.log('Failed in file upload history - ' + err);
                return { message: 'Erro occured...', status: 0, data: {} };
            }
        });
    }
    documentdetailEx(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let resObj = {};
                if (!util_1.isNullOrUndefined(input.docType) && !util_1.isNullOrUndefined(input.result) && !util_1.isNullOrUndefined(input.fileRefNum)) {
                    let docData = yield (db.collection(input.docType)).findOne({ referenceNumber: input.fileRefNum }).lean();
                    docData = JSON.parse(JSON.stringify(docData));
                    if (util_1.isNullOrUndefined(docData)) {
                        let data = yield (db.collection('scanningfields')).findOne({ isDeleted: false, documentType: input.docType });
                        data = JSON.parse(JSON.stringify(data));
                        data.fields.forEach(element => {
                            if (element.isTable == false && element.show == true && element.fieldName) {
                                resObj[element.fieldName] = '';
                            }
                        });
                    }
                    let cropBox = [];
                    let dObj = {
                        "LEFT_bottomY": null,
                        "LEFT_rightX": null,
                        "LEFT_topY": null,
                        "LEFT_leftX": null,
                        "LEFT_Name": "",
                        "TOP_bottomY": null,
                        "TOP_rightX": null,
                        "TOP_topY": null,
                        "TOP_leftX": null,
                        "TOP_Name": null,
                        "property": "",
                        "lineNumber": 0,
                        "pageNo": 0,
                        "Property": "",
                        "bottomY": 0,
                        "rightX": 0,
                        "topY": 0,
                        "leftX": 0,
                        "Name": "",
                    };
                    for (let obj of input.result) {
                        if (obj['property'] && obj['text']) {
                            resObj[obj['property']] = obj['text'];
                        }
                        if (obj['left'] && obj['right'] && obj['top'] && obj['bottom'] && !util_1.isNullOrUndefined(obj['pageId'])) {
                            let cropObj = JSON.parse(JSON.stringify(dObj));
                            cropObj['property'] = obj['property'];
                            cropObj['Property'] = obj['property'];
                            cropObj['Name'] = obj['text'];
                            cropObj['leftX'] = obj['left'];
                            cropObj['rightX'] = obj['right'];
                            cropObj['topY'] = obj['top'];
                            cropObj['bottomY'] = obj['bottom'];
                            cropObj['pageNo'] = obj['pageId'];
                            cropBox.push(JSON.parse(JSON.stringify(cropObj)));
                        }
                    }
                    resObj['cropBox'] = cropBox;
                    let res = yield (db.collection(input.docType)).update({ referenceNumber: input.fileRefNum }, { $set: resObj }, { upsert: true });
                    console.log("Updating the extracted details...", res);
                    // to Display in TrainingComponenet
                    let dTobj = {
                        userId: ObjectId(input.userId),
                        orgId: ObjectId(input.orgId),
                        documentType: input.docType,
                        "isDeleted": false,
                        subscriberId: ObjectId(input.subscriberId),
                        documentCsvData: cropBox
                    };
                    res = yield (db.collection("documenttrainings")).update({ fileRefNum: input.fileRefNum }, { $set: dTobj }, { upsert: true });
                    console.log(res);
                    let outputData = {};
                    outputData['invData'] = resObj;
                    return { message: 'data saved successfully.', status: 0, data: outputData };
                }
                else {
                    throw "DocType not found";
                }
            }
            catch (e) {
                console.log('Failed in documentdetailEx - ' + e);
                return { message: 'Erro occured...', status: 0, data: {} };
            }
        });
    }
    matchByKeyword(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let nearBy = Array.isArray(input.nearBy) ? input.nearBy : JSON.parse(input.nearBy);
                if (!util_1.isNullOrUndefined(input.ruleObj)) {
                    let objArr = input.ruleObj;
                    let gotKey;
                    let raws = [];
                    for (let obj of objArr) {
                        let matches = [];
                        if (gotKey) {
                            break;
                        }
                        obj.raw = obj.raw.filter(a => a.Name);
                        let strs = obj.raw.map(a => a.Name.toLowerCase());
                        raws = raws.concat(obj.raw);
                        for (let keyword of nearBy) {
                            let bM = stringSimilarity.findBestMatch(keyword.toLowerCase(), strs);
                            delete bM['ratings'];
                            matches.push(JSON.parse(JSON.stringify(bM)));
                        }
                        console.log(matches);
                        matches.sort((a, b) => b.bestMatch.rating - a.bestMatch.rating);
                        for (let index = 0; index < matches.length; index++) {
                            let Bm = matches[index];
                            if (input.matchLength) {
                                for (let i = Bm.bestMatchIndex + 1; i < Bm.bestMatchIndex + 9; i++) {
                                    if (strs[i] && strs[i].length == input.matchLength && !isNaN(strs[i])) {
                                        gotKey = strs[i];
                                        break;
                                    }
                                }
                                if (gotKey) {
                                    break;
                                }
                                if (Bm.bestMatchIndex > 5) {
                                    for (let i = Bm.bestMatchIndex - 5; i < Bm.bestMatchIndex + 6; i++) {
                                        if (strs[i] && strs[i].length == input.matchLength && !isNaN(strs[i])) {
                                            gotKey = strs[i];
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    let resObj = {};
                    let docData = yield (db.collection(input.docType)).findOne({ referenceNumber: input.fileRefNum }).lean();
                    docData = JSON.parse(JSON.stringify(docData));
                    if (util_1.isNullOrUndefined(docData)) {
                        let data = yield (db.collection('scanningfields')).findOne({ isDeleted: false, documentType: input.docType });
                        data = JSON.parse(JSON.stringify(data));
                        data.fields.forEach(element => {
                            if (element.isTable == false && element.fieldName) {
                                resObj[element.fieldName] = '';
                            }
                        });
                    }
                    console.log("------gotKeys---", gotKey);
                    if (gotKey && input.keyName) {
                        resObj[input.keyName] = gotKey;
                        let res = yield (db.collection(input.docType)).update({ referenceNumber: input.fileRefNum }, { $set: resObj }, { upsert: true });
                        console.log(res);
                    }
                    else {
                        let res = yield (db.collection(input.docType)).update({ referenceNumber: input.fileRefNum }, { $set: resObj }, { upsert: true });
                        console.log(res);
                    }
                    let dTobj = {
                        userId: ObjectId(input.userId),
                        orgId: ObjectId(input.orgId),
                        documentType: input.docType,
                        "isDeleted": false,
                        subscriberId: ObjectId(input.subscriberId),
                        documentCsvData: raws
                    };
                    let res = yield (db.collection("documenttrainings")).update({ fileRefNum: input.fileRefNum }, { $set: dTobj }, { upsert: true });
                    console.log(res);
                    let outputData = { 'gotKey': gotKey };
                    return { message: 'data saved successfully.', status: 0, data: outputData };
                }
                else {
                    throw "No Input..";
                }
            }
            catch (e) {
                console.log('Failed in matchByKeyword - ' + e);
                return { message: 'Erro occured...', status: 0, data: {} };
            }
        });
    }
    preTraining(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let resObj = {};
                let template = {};
                let jsoncsv = [];
                let fileRefNum = input.fileRefNum;
                let filePath = input.filePath;
                let trainingProperties = JSON.parse(input.trainingProperties);
                let csvProperties = JSON.parse(input.csvProperties);
                let keywords = JSON.parse(input.nearbyKeywords);
                let orderMatch = JSON.parse(input.directMach);
                let checkMatch = JSON.parse(input.checkMatch);
                let correctMatch = JSON.parse(input.correctMatch);
                let pData = {};
                pData['dT'] = input.docType;
                pData['fR'] = fileRefNum;
                pData['fP'] = filePath;
                if (input.sId)
                    pData['sId'] = ObjectId(input.sId);
                if (input.oId)
                    pData['oId'] = ObjectId(input.oId);
                pData['csvP'] = input.historicalData;
                if (!util_1.isNullOrUndefined(input.docType)) {
                    // let data = await db.collection('scanningfields').findOne({ isDeleted: false, documentType: input.docType });
                    let data = yield (db.collection('scanningfields')).findOne({ isDeleted: false, documentType: input.docType });
                    data = JSON.parse(JSON.stringify(data));
                    data.fields.forEach(element => {
                        if (element.isTable == false && element.fieldName) {
                            resObj[element.fieldName] = '';
                            template[element.fieldName] = '';
                        }
                    });
                }
                console.log("*FileRefNum :", fileRefNum);
                let filename = filePath.substring(filePath.lastIndexOf('/') + 1);
                console.log("*file ----->:>:>:", filename);
                let historicalContent = fs.readFileSync(input.historicalData, { encoding: 'utf8' });
                let historicalDataCsv = JSON.parse(historicalContent);
                var matchjson = null;
                let documetCsvData = yield (db.collection("documenttrainings")).find({ fileRefNum: input.fileRefNum });
                documetCsvData = JSON.parse(JSON.stringify(documetCsvData));
                let ar = [];
                documetCsvData.map(a => ar = ar.concat(a.documentCsvData));
                for (let i = 0, ct = ar.length; i < ct; i++) {
                    ar[i]['cName'] = ar[i]['Name'];
                    let j = i;
                    while (j < ct - 1 && ar[j + 1].leftX > ar[j].rightX && ar[j + 1].leftX - ar[j].rightX < 25 && Math.abs(ar[j + 1].topY - ar[j].topY) < 5) {
                        ar[i]['cName'] = ar[i]['cName'] + ' ' + ar[j + 1]['Name'];
                        ar[j + 1]['cName'] = ar[j + 1]['Name'];
                        j++;
                    }
                    i = j--;
                }
                historicalDataCsv.forEach((data, index) => {
                    if (data["File Name"] == filename) {
                        console.log('Matched Data :', JSON.stringify(data));
                        matchjson = historicalDataCsv[index];
                    }
                });
                if (util_1.isNullOrUndefined(matchjson)) {
                    console.log("Cheking with properties....");
                    let res = this.matchCSVData(ar, historicalDataCsv, orderMatch, checkMatch);
                    if (!util_1.isNullOrUndefined(res.match) && !util_1.isNullOrUndefined(res.csvData)) {
                        matchjson = res.match;
                        // historicalDataCsv = res.csvData;
                        // historicalDataCsv = historicalDataCsv.filter(a => [null, undefined].includes(a.mapped));
                        // if ((input.historicalData)) {
                        //     fs.writeFileSync(input.historicalData, JSON.stringify(historicalDataCsv))
                        // }
                    }
                }
                let obj = {};
                if (!util_1.isNullOrUndefined(matchjson)) {
                    if (trainingProperties.length == csvProperties.length) {
                        let keys = trainingProperties.length;
                        for (let i = 0; i < keys; i++) {
                            obj[trainingProperties[i]] = matchjson[csvProperties[i]];
                        }
                    }
                    console.log("Mapping--->", obj);
                }
                if (Object.keys(obj).length > 0 && !util_1.isNullOrUndefined(input.fileRefNum)) {
                    console.log("Updating the doument...");
                    pData['matchFound'] = true;
                    pData['historicalData'] = JSON.parse(JSON.stringify(obj));
                    pData['mlData'] = [];
                    pData['autoTrain'] = [];
                    for (let i = 0; i < documetCsvData.length; i++) {
                        jsoncsv = Array.isArray(documetCsvData[i]['documentCsvData']) ? JSON.parse(JSON.stringify(documetCsvData[i]['documentCsvData'])) : JSON.parse(JSON.stringify(jsoncsv));
                        let FilePath = documetCsvData[i]['filePath'];
                        let ResOBJ = JSON.parse(JSON.stringify(template));
                        let mlPred = ar.filter(a => a.Property !== "undefined");
                        mlPred.filter(a => a.property = a.Property);
                        let mlPredKeys = mlPred.map(a => a.Property);
                        pData['mlData'] = pData['mlData'].concat(mlPred);
                        console.log("*ImagePath :", FilePath);
                        console.log("historicalDataCsv--->", historicalDataCsv.length);
                        console.log("jsoncsv--->", jsoncsv.length);
                        if (!util_1.isNullOrUndefined(obj) && jsoncsv.length > 0) {
                            var exceptionFlag = false;
                            for (const item in obj) {
                                let mlP = mlPred.filter(a => a.Property == item);
                                let mlValue = mlP.map(a => a.Name).join('').trim();
                                console.log("key : ", item, "--- value : ", obj[item], " ----mlP---", mlValue);
                                if (mlP.length > 0 && mlValue !== '' && !util_1.isNullOrUndefined(obj[item])) {
                                    if (correctMatch.includes(item)) {
                                        if (mlValue == obj[item].trim() || (Number(mlValue) && Number(obj[item].trim()) && Math.abs(Number(mlValue) - Number(obj[item].trim())) < 1)) {
                                            continue;
                                        }
                                        else if (mlValue.includes(obj[item].trim())) {
                                            let temp = mlValue;
                                            let c = mlP.length - 1;
                                            while (c < 0) {
                                                if (mlValue.replace(mlP[c], '').includes(obj[item].trim())) {
                                                    mlP[c].Property = 'undefined';
                                                    mlValue = mlValue.replace(mlP[c], '');
                                                }
                                                c--;
                                            }
                                            if (temp !== mlValue) {
                                                continue;
                                            }
                                        }
                                    }
                                    else if (mlValue && item.toLowerCase().includes('date') && !util_1.isNullOrUndefined(obj[item])) {
                                        let check = this.isEqualDate(mlValue, obj[item]);
                                        if (check) {
                                            continue;
                                        }
                                    }
                                }
                                let count = 0;
                                let indices = [], multiIndexes = [];
                                let propertyMatch = false;
                                let keys = keywords[item];
                                if (!util_1.isNullOrUndefined(obj[item])) {
                                    jsoncsv.forEach((val, index) => {
                                        val["index"] = index;
                                    });
                                    // jsoncsv.forEach((val, index) =>
                                    for (let index = 0; index < jsoncsv.length; index++) { //iterating over csv json
                                        let val = jsoncsv[index];
                                        if (val["Name"] == obj[item]) { //matching field value without any regex
                                            count++;
                                            indices.push(index);
                                        }
                                        else if (val["cName"] && val["cName"].length > 10 && stringSimilarity.compareTwoStrings(val["cName"].toLowerCase(), obj[item].toLowerCase()) > 0.8) {
                                            let j = index;
                                            while (j < jsoncsv.length - 1 && val["cName"].includes(jsoncsv[j]["Name"].trim())) {
                                                multiIndexes.push(j);
                                                j++;
                                            }
                                            propertyMatch = true;
                                        }
                                        else if ((/[\d,]+/.test(obj[item])) && (count == 0)) { //checking it is number or not
                                            //console.log(/[\d~,]+/.test(val["Name"]),"--", val["Name"]);
                                            if (/[\d~,]+/.test(val["Name"])) { //checking it is amount with , or ~
                                                var temp = null;
                                                var temp1 = null;
                                                if (val["Name"].search(',') >= 0) { //check for , in amount
                                                    temp1 = val["Name"].replace(",", "");
                                                    if (obj[item] == temp1) {
                                                        count++;
                                                        indices.push(index);
                                                    }
                                                    else {
                                                        if (temp1.search('-') >= 0) { //check for - in amount
                                                            temp1 = temp1.replace("-", "");
                                                            if (Number(obj[item]) == temp1) {
                                                                count++;
                                                                indices.push(index);
                                                            }
                                                        }
                                                    }
                                                }
                                                else if (val["Name"].search('~') >= 0) { //checking for ~
                                                    temp = val["Name"].replace("~", "");
                                                    if (obj[item] == temp) {
                                                        count++;
                                                        indices.push(index);
                                                    }
                                                    else {
                                                        console.log("In else", temp);
                                                        temp = temp.replace("/", "");
                                                        console.log(temp, obj[item]);
                                                        //console.log(obj[item], obj[item].length);
                                                        if (temp == Number(obj[item])) { //checking for /
                                                            console.log(temp, obj[item]);
                                                            count++;
                                                            indices.push(index);
                                                        }
                                                    }
                                                }
                                                else if (val["Name"].includes(obj[item])) {
                                                    console.log(/[\d~,]+/.test(val["Name"]), "--------", val["Name"]); //check for string included in field value
                                                    count++;
                                                    indices.push(index);
                                                }
                                                else if (item.toLowerCase().includes('date') && /^(0?[1-9]|[12][0-9]|3[01])[\/\-](0?[1-9]|1[012])[\/\-]\d{4}$/.test(obj[item])) { //check for object is date
                                                    // console.log("Date Condition", obj[item], '----', val["Name"]);
                                                    const months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
                                                    var datestring = obj[item];
                                                    d = datestring.split("/");
                                                    var x = d[1] + "/" + d[0] + "/" + d[2]; //converting into MM/DD/YYYY format
                                                    var d = new Date(x);
                                                    let current_datetime = new Date(x);
                                                    console.log(current_datetime);
                                                    let formatted_date = current_datetime.getDate() + " " + months[current_datetime.getMonth()] + " " + current_datetime.getFullYear();
                                                    console.log(formatted_date);
                                                    let dateCheck = this.isEqualDate(val["Name"], obj[item]);
                                                    if (val["Name"] == formatted_date) { //checking for matching date
                                                        count++;
                                                        indices.push(index);
                                                    }
                                                    else if (dateCheck) {
                                                        count++;
                                                        indices.push(index);
                                                    }
                                                }
                                                else {
                                                    if (obj[item].search(',') >= 0 && /(\d+\s,|,\s\d+)/.test(obj[item])) {
                                                        obj[item] = obj[item].replace(" ", "");
                                                        let str = obj[item].split(",");
                                                        if (val["Name"].includes(str[0])) {
                                                            console.log(val["Name"]);
                                                        }
                                                    }
                                                }
                                            }
                                            else if (!isNaN(new Date(val["Name"] + ' ' + val["RIGHT_Name"]).getDate()) && index + 1 < jsoncsv.length) {
                                                let dateCheck = this.isEqualDate(val["Name"] + ' ' + jsoncsv[index + 1]["Name"], obj[item]);
                                                if (dateCheck) {
                                                    propertyMatch = true;
                                                    multiIndexes.push(index);
                                                    multiIndexes.push(index + 1);
                                                }
                                            }
                                        }
                                        else if (val["Name"] != "" && (obj[item].toLowerCase().includes(val["Name"].toLowerCase()) || (obj[item] != "" && stringSimilarity.compareTwoStrings(val["Name"], obj[item].split(' ')[0]) > 0.8))) {
                                            let indexes = [];
                                            let text = val["Name"];
                                            let dummyText = obj[item].toLowerCase().includes(jsoncsv[index]["Name"].toLowerCase()) ? obj[item].toLowerCase().replace(jsoncsv[index]["Name"].toLowerCase(), "") : obj[item].split(' ').slice(1).join(' ');
                                            indexes.push(index);
                                            index++;
                                            while (index < jsoncsv.length && (dummyText.toLowerCase().includes(jsoncsv[index]["Name"].toLowerCase()) || (dummyText != "" && stringSimilarity.compareTwoStrings(jsoncsv[index]["Name"].toLowerCase().trim(), dummyText.split(' ')[0].trim()) > 0.8))) {
                                                text = text + ' ' + jsoncsv[index]['Name'];
                                                indexes.push(index);
                                                index++;
                                                dummyText = dummyText.toLowerCase().includes(jsoncsv[index]["Name"].toLowerCase()) ? dummyText.toLowerCase().replace(jsoncsv[index]["Name"].toLowerCase(), "") : dummyText.split(' ').slice(1).join(' ');
                                                if (text.length + jsoncsv[index]['Name'].length > obj[item].length)
                                                    break;
                                            }
                                            if (stringSimilarity.compareTwoStrings(text, obj[item]) > 0.8) {
                                                propertyMatch = true;
                                                multiIndexes = indexes.concat(multiIndexes);
                                            }
                                        }
                                        // else if(!isNaN(new Date(val["Name"] +' '+ val["RIGHT_Name"]).getDate()) && index+1 < jsoncsv.length)
                                        // {
                                        //     let dateCheck = this.isEqualDate(val["Name"] +' '+ jsoncsv[index+1]["Name"], obj[item]);
                                        //      if (dateCheck) {
                                        //         propertyMatch = true;
                                        //         multiIndexes.push(index);
                                        //         multiIndexes.push(index+1)
                                        //     }
                                        // }
                                        // });
                                    }
                                }
                                if (count == 1) { //single match
                                    console.log(".......property match......", count);
                                    jsoncsv[indices[0]]["property"] = item;
                                    pData['autoTrain'].push(jsoncsv[indices[0]]);
                                    mlP.filter(a => a.Property = "undefined");
                                    mlP.filter(a => a.property = "undefined");
                                    console.log(jsoncsv[indices[0]]["Name"] + "====>>>>" + jsoncsv[indices[0]]["property"]);
                                }
                                else {
                                    if ((count > 1) || (count == 0)) { //no match or mutliple matches
                                        exceptionFlag = true;
                                        if (!propertyMatch) {
                                            for (let index = 0; index < indices.length; index++) {
                                                let i = indices[index];
                                                let lowerCaseK = keys ? keys.map(a => a.toLowerCase()) : keys;
                                                if (!util_1.isNullOrUndefined(lowerCaseK)) {
                                                    if ((jsoncsv[i]['TOP_Name'] && lowerCaseK.indexOf(jsoncsv[i]['TOP_Name'].toLowerCase()) > -1) || (jsoncsv[i]['TOP_Name'] && lowerCaseK.filter(a => a.includes(jsoncsv[i]['LEFT_Name'].toLowerCase()) || jsoncsv[i]['LEFT_Name'].toLowerCase().includes(a)).length > 0) || (jsoncsv[i]['LEFT_Name'] && lowerCaseK.indexOf(jsoncsv[i]['LEFT_Name'].toLowerCase()) > -1) || (jsoncsv[i]['LEFT_Name'] && lowerCaseK.filter(a => a.includes(jsoncsv[i]['LEFT_Name'].toLowerCase()) || jsoncsv[i]['LEFT_Name'].toLowerCase().includes(a)).length > 0)) {
                                                        console.log(".......Direct match with nearby keywords......", count);
                                                        jsoncsv[i]["property"] = item;
                                                        mlP.filter(a => a.Property = "undefined");
                                                        mlP.filter(a => a.property = "undefined");
                                                        pData['autoTrain'].push(jsoncsv[i]);
                                                        console.log(jsoncsv[i]["Name"] + "====>>>>" + jsoncsv[i]["property"]);
                                                        break;
                                                    }
                                                    let top_NameFuzz = stringSimilarity.findBestMatch(jsoncsv[i]['TOP_Name'].toLowerCase(), lowerCaseK);
                                                    let left_NameFuzz = stringSimilarity.findBestMatch(jsoncsv[i]['LEFT_Name'].toLowerCase(), lowerCaseK);
                                                    if ((top_NameFuzz.bestMatch && top_NameFuzz.bestMatch.rating && top_NameFuzz.bestMatch.rating > 0.75) || (left_NameFuzz.bestMatch && left_NameFuzz.bestMatch.rating && left_NameFuzz.bestMatch.rating > 0.75)) {
                                                        console.log(".......Fuzzy match with nearby keywords......", count);
                                                        jsoncsv[i]["property"] = item;
                                                        mlP.filter(a => a.Property = "undefined");
                                                        mlP.filter(a => a.property = "undefined");
                                                        pData['autoTrain'].push(jsoncsv[i]);
                                                        console.log(jsoncsv[i]["Name"] + "====>>>>" + jsoncsv[i]["property"]);
                                                        break;
                                                    }
                                                }
                                                console.log("Not Matched ====>" + jsoncsv[i]["Name"] + "====>>>>" + jsoncsv[i]["property"]);
                                            }
                                        }
                                        else {
                                            mlP.filter(a => a.property = "undefined");
                                            mlP.filter(a => a.Property = "undefined");
                                            multiIndexes.forEach(i => {
                                                jsoncsv[i]["property"] = item;
                                                jsoncsv[i]["Property"] = item;
                                                pData['autoTrain'].push(jsoncsv[i]);
                                                console.log(jsoncsv[i]["Name"] + "====>>>>" + jsoncsv[i]["property"]);
                                            });
                                            //updating the ML data
                                        }
                                    }
                                }
                                console.log("exception", exceptionFlag);
                            }
                            outputParameters['jsonCsv'] = jsoncsv;
                            outputParameters['fileRefNum'] = fileRefNum;
                            outputParameters["pretrainedStatus"] = !exceptionFlag;
                            let Keys = Object.keys(obj);
                            let mappedProperties = [...new Set(jsoncsv.filter(a => Keys.indexOf(a.property) > -1 || mlPredKeys.indexOf(a.property) > -1).map(a => a.property))];
                            console.log(" Total Properties Applied : ", mappedProperties.length, " Keys : ", Keys.length);
                            let trainingPrediction = (mappedProperties.length / Object.keys(obj).length) * 100;
                            // Updating the documetTrainings
                            if (!util_1.isNullOrUndefined(input.fileRefNum)) {
                                console.log("Updating the doument training...");
                                yield (db.collection("documenttrainings")).update({ fileRefNum: input.fileRefNum, filePath: FilePath }, { $set: { 'documentCsvData': jsoncsv, 'pretrainedStatus': !exceptionFlag, 'autoTraining': trainingPrediction } });
                            }
                            // Updating the documentType
                            for (let i = 0; i < mappedProperties.length; i++) {
                                if (mappedProperties[i] && mappedProperties[i]) {
                                    resObj[mappedProperties[i]] = jsoncsv.filter(a => a.property == mappedProperties[i]).map(a => a.Name).join(' ').trim();
                                }
                                ResOBJ[mappedProperties[i]] = resObj[mappedProperties[i]];
                                delete obj[mappedProperties[i]];
                            }
                        }
                        // if (!isNullOrUndefined(input.fileRefNum) && !isNullOrUndefined(input.docType)) {
                        //     console.log("Updating the docType Pages...", JSON.stringify(ResOBJ))
                        //     await (db.collection(input.docType + '_Pages')).update({ referenceNumber: input.fileRefNum, filePath: FilePath }, { $set: ResOBJ }, { upsert: true })
                        // }
                    }
                }
                else {
                    pData['matchFound'] = false;
                    let mlPred = ar.filter(a => a.Property !== "undefined");
                    mlPred.filter(a => a.property = a.Property);
                    let mlPredKeys = mlPred.map(a => a.Property);
                    let mappedProperties = [...new Set(mlPred.filter(a => mlPredKeys.indexOf(a.property) > -1).map(a => a.property))];
                    for (let i = 0; i < mappedProperties.length; i++) {
                        if (mappedProperties[i] && mappedProperties[i]) {
                            resObj[mappedProperties[i]] = mlPred.filter(a => a.property == mappedProperties[i]).map(a => a.Name).join(' ').trim();
                        }
                    }
                    console.log("-------Match not found------");
                    if (!util_1.isNullOrUndefined(input.fileRefNum)) {
                        console.log("Updating the doument...");
                        yield (db.collection("documenttrainings")).update({ fileRefNum: input.fileRefNum }, { $set: { 'pretrainedStatus': false, 'autoTraining': 0, 'trainingException': 'FileName not matched with HistoricalData' } });
                    }
                }
                if (input.sId && input.oId) {
                    resObj['orgId'] = input.oId;
                    resObj['subscriberId'] = input.sId;
                }
                resObj["tally_status"] = "Inserted";
                if (matchjson) {
                    for (let key in resObj) {
                        if (matchjson[key] && (util_1.isNullOrUndefined(resObj[key]) || resObj[key] == '')) {
                            resObj[key] = matchjson[key];
                        }
                    }
                }
                if (!util_1.isNullOrUndefined(input.fileRefNum) && !util_1.isNullOrUndefined(input.docType)) {
                    console.log("Updating the docType...", JSON.stringify(resObj));
                    yield (db.collection(input.docType)).update({ referenceNumber: input.fileRefNum }, { $set: resObj }, { upsert: true });
                    yield (db.collection(input.docType + '_pretraining')).update({ fP: input.fileRefNum }, { $set: pData }, { upsert: true });
                }
                return { message: 'CSV read successfully.', status: 0, data: outputParameters };
            }
            catch (e) {
                this.log.error("Error in reading csv file" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    matchCSVData(arr, csvData, uniqueKeys, checkKeys) {
        try {
            // let arr = [];
            // data.map(a => arr = arr.concat(a.documentCsvData));
            let tempData = csvData;
            // matching the primary keys with strick checking
            for (let pro of uniqueKeys) {
                console.log("Property--->", pro);
                let mObj = csvData.filter(a => a[pro] && a[pro] !== '').filter(a => arr.filter(d => (d.Name.toLowerCase() == a[pro].toLowerCase()) || stringSimilarity.compareTwoStrings(d.Name.toLowerCase(), a[pro].toLowerCase()) > 0.8).length > 0);
                if (mObj.length == 1) {
                    mObj[0]['mapped'] = true;
                    return { match: mObj[0], csvData: csvData };
                }
                else {
                    let ML = arr.filter(a => a.Property == "Invoice_Number").map(a => a.Name).join(' ');
                    let sObj = mObj.filter(a => stringSimilarity.compareTwoStrings(a[pro].toLowerCase(), ML.toLowerCase()) > 0.8);
                    if (sObj.length == 1) {
                        sObj[0]['mapped'] = true;
                        return { match: sObj[0], csvData: csvData };
                    }
                }
                if (mObj.length > 0) {
                    tempData = csvData;
                }
            }
            for (let line of tempData) {
                let tC = 0, mC = 0;
                for (let key of checkKeys) {
                    if (!util_1.isNullOrUndefined(line[key]) && line[key] != '') {
                        tC++;
                        let F = [];
                        if (!isNaN(line[key])) {
                            F = arr.filter(a => Number(a.Name) == Number(line[key]));
                        }
                        let E = arr.filter(d => stringSimilarity.compareTwoStrings(d.Name.toLowerCase(), line[key].toLowerCase()) > 0.8);
                        let D = arr.filter(d => stringSimilarity.compareTwoStrings(d.cName.toLowerCase(), line[key].toLowerCase()) > 0.8);
                        if (D.length > 0 || E.length > 0 || F.length > 0) {
                            mC++;
                        }
                    }
                }
                console.log("Total count---->", tC, "  Matched Count---->", mC);
                if ((mC / tC) * 100 > 70) {
                    line['mapped'] = true;
                    return { match: line, csvData: csvData };
                }
            }
            return {};
        }
        catch (e) {
            console.log("From matchCSVData -", e);
            return {};
        }
    }
    saveTemplateTraining(input, output, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            /*Rule for save document level training*/
            try {
                let refNo = input.refNo;
                let docType = input.docType;
                let obj = {
                    isDeleted: false,
                    userId: input.userId,
                    subscriberId: input.subscriberId,
                    orgId: input.orgId
                };
                let filePath = input.filePath;
                output['templateTraining'] = true;
                let documentT = yield (db.collection('documenttrainings')).find({ fileRefNum: refNo, documentType: docType });
                documentT = JSON.parse(JSON.stringify(documentT));
                let finalDocumentOCR = [];
                let dcD = documentT && documentT[0] && documentT[0]['documentCsvData'] ? documentT[0]['documentCsvData'] : [];
                documentT.map(a => finalDocumentOCR = finalDocumentOCR.concat(a['documentCsvData']));
                finalDocumentOCR.filter(a => util_1.isNullOrUndefined(a.Property) || a.Property == '').map(a => a.Property = a.property);
                let fdq = [];
                let ancKey = [];
                let newfinalDocumentOCR = [];
                let documentOCR = JSON.parse(JSON.stringify(finalDocumentOCR));
                for (let i = 0; i < finalDocumentOCR.length; i++) {
                    let firstObj = finalDocumentOCR[i];
                    if (util_1.isNullOrUndefined(firstObj['marked'])) {
                        for (let j = i + 1; j < documentOCR.length - 1; j++) {
                            let nextObj = finalDocumentOCR[j];
                            if (firstObj.Property == nextObj.Property) {
                                if (nextObj.topY < firstObj.topY) {
                                    firstObj.topY = nextObj.topY;
                                }
                                if (nextObj.leftX < firstObj.leftX) {
                                    firstObj.leftX = nextObj.leftX;
                                }
                                if (nextObj.rightX > firstObj.rightX) {
                                    firstObj.rightX = nextObj.rightX;
                                }
                                if (nextObj.bottomY > firstObj.bottomY) {
                                    firstObj.bottomY = nextObj.bottomY;
                                }
                                if (nextObj.leftX < firstObj.leftX && nextObj.rightX < firstObj.leftX) {
                                    firstObj.Name = nextObj.Name + " " + firstObj.Name;
                                }
                                else {
                                    firstObj.Name = firstObj.Name + " " + nextObj.Name;
                                }
                                nextObj['marked'] = true;
                            }
                        }
                    }
                }
                for (let i = 0; i < finalDocumentOCR.length; i++) {
                    let firstObj = finalDocumentOCR[i];
                    if (util_1.isNullOrUndefined(firstObj['marked'])) {
                        newfinalDocumentOCR.push(firstObj);
                    }
                }
                for (let i = 0; i < newfinalDocumentOCR.length; i++) {
                    let field = newfinalDocumentOCR[i];
                    let tempObj = {};
                    let ackObj = {};
                    if (field.Property == "Vendor_Name") {
                        obj['vendorName'] = field.Name;
                        ackObj['field'] = field.Property;
                        ackObj['leftX'] = field['leftX'];
                        ackObj['rightX'] = field['rightX'];
                        ackObj['bottomY'] = field['bottomY'];
                        ackObj['topY'] = field['topY'];
                        ackObj['Name'] = !util_1.isNullOrUndefined(field['Name']) ? field['Name'] : '';
                        ackObj['LEFT_Name'] = !util_1.isNullOrUndefined(field['LEFT_Name']) ? field['LEFT_Name'] : '';
                        ackObj['LEFT_topY'] = field['LEFT_topY'];
                        ackObj['LEFT_bottomY'] = field['LEFT_bottomY'];
                        ackObj['LEFT_rightX'] = field['LEFT_rightX'];
                        ackObj['LEFT_leftX'] = field['LEFT_leftX'];
                        ackObj['TOP_Name'] = !util_1.isNullOrUndefined(field['TOP_Name']) ? field['TOP_Name'] : '';
                        ackObj['TOP_topY'] = field['TOP_topY'];
                        ackObj['TOP_bottomY'] = field['TOP_bottomY'];
                        ackObj['TOP_rightX'] = field['TOP_rightX'];
                        ackObj['TOP_leftX'] = field['TOP_leftX'];
                        ackObj['pageNo'] = field['pageNo'];
                        ancKey.push(ackObj);
                    }
                    if (field.Property != "undefined") {
                        tempObj['field'] = field.Property;
                        tempObj['leftX'] = field['leftX'];
                        tempObj['rightX'] = field['rightX'];
                        tempObj['bottomY'] = field['bottomY'];
                        tempObj['topY'] = field['topY'];
                        tempObj['Name'] = !util_1.isNullOrUndefined(field['Name']) ? field['Name'] : '';
                        tempObj['LEFT_Name'] = !util_1.isNullOrUndefined(field['LEFT_Name']) ? field['LEFT_Name'] : '';
                        tempObj['LEFT_topY'] = field['LEFT_topY'];
                        tempObj['LEFT_bottomY'] = field['LEFT_bottomY'];
                        tempObj['LEFT_rightX'] = field['LEFT_rightX'];
                        tempObj['LEFT_leftX'] = field['LEFT_leftX'];
                        tempObj['TOP_Name'] = !util_1.isNullOrUndefined(field['TOP_Name']) ? field['TOP_Name'] : '';
                        tempObj['TOP_topY'] = field['TOP_topY'];
                        tempObj['TOP_bottomY'] = field['TOP_bottomY'];
                        tempObj['TOP_rightX'] = field['TOP_rightX'];
                        tempObj['TOP_leftX'] = field['TOP_leftX'];
                        tempObj['pageNo'] = field['pageNo'];
                        fdq.push(tempObj);
                    }
                    if (field.Property == "Vendor_GSTIN") {
                        obj['gstin'] = field.Name;
                    }
                }
                obj['fdq'] = fdq;
                obj['ancKey'] = ancKey;
                obj['doc_bottomY'] = dcD ? dcD[dcD.length - 1].bottomY : '';
                obj['doc_topY'] = dcD ? dcD[0].topY : '';
                // let templateTrainingObj = new templateTrainingData(obj);
                // console.log("before saved !!!!!!!!!!!!!!!!!!!!!!!!!!!", JSON.stringify(obj))
                if (util_1.isNullOrUndefined(obj['vendorName'])) {
                    output['templateTraining'] = false;
                }
                if (!util_1.isNullOrUndefined(obj['gstin'])) {
                    let data = yield (db.collection('templatetrainings')).find({ gstin: obj['gstin'], orgId: ObjectId(input.orgId), subscriberId: ObjectId(input.subscriberId) });
                    if (data.length > 0) {
                        let D = yield (db.collection('templatetrainings')).findOneAndUpdate({ gstin: obj['gstin'], orgId: ObjectId(input.orgId), subscriberId: ObjectId(input.subscriberId), isDeleted: false }, {
                            $set: {
                                isDeleted: obj.isDeleted, gstin: obj['gstin'], vendorName: obj['vendorName'],
                                ancKey: obj['ancKey'], fdq: obj['fdq'],
                                subscriberId: ObjectId(input['sId']), orgId: ObjectId(input['oId']),
                                imageHeight: input.imageHeight, imageWidth: input.imageWidth, doc_bottomY: obj['doc_bottomY'],
                                doc_topY: obj['doc_topY'], synced: false, filePath: filePath
                            }
                        }, { new: true, upsert: true });
                        console.log(D);
                    }
                    else {
                        let D = yield (db.collection('templatetrainings')).findOneAndUpdate({ vendorName: obj['vendorName'], orgId: ObjectId(input['oId']), subscriberId: ObjectId(input['sId']), isDeleted: false }, {
                            $set: {
                                isDeleted: obj.isDeleted, gstin: obj['gstin'], vendorName: obj['vendorName'],
                                ancKey: obj['ancKey'], fdq: obj['fdq'],
                                subscriberId: ObjectId(input['sId']), orgId: ObjectId(input['oId']),
                                imageHeight: input.imageHeight, imageWidth: input.imageWidth, doc_bottomY: obj['doc_bottomY'],
                                doc_topY: obj['doc_topY'], synced: false, filePath: filePath
                            }
                        }, { new: true, upsert: true });
                        console.log(D);
                    }
                }
                else if (!util_1.isNullOrUndefined(obj['vendorName'])) {
                    let D = yield (db.collection('templatetrainings')).findOneAndUpdate({ vendorName: obj['vendorName'], orgId: ObjectId(input['oId']), subscriberId: ObjectId(input['sId']), isDeleted: false }, {
                        $set: {
                            isDeleted: obj.isDeleted, gstin: obj['gstin'], vendorName: obj['vendorName'],
                            ancKey: obj['ancKey'], fdq: obj['fdq'],
                            subscriberId: ObjectId(input['sId']), orgId: ObjectId(input['oId']),
                            imageHeight: input.imageHeight, imageWidth: input.imageWidth, doc_bottomY: obj['doc_bottomY'],
                            doc_topY: obj['doc_topY'], synced: false, filePath: filePath
                        }
                    }, { new: true, upsert: true });
                    console.log(D);
                }
                else {
                    output['templateTraining'] = false;
                }
                if (input['oId'] && input['sId'] && input['filePath']) {
                    let res = yield (db.collection("historicalData")).update({ orgId: ObjectId(input['oId']), subId: ObjectId(input['sId']), "uFiles": { $elemMatch: { "fName": input['filePath'] } } }, { $set: { 'uFiles.$.trained': true } });
                    console.log("Updated historicalData collection....", res);
                }
                // adding subscriberId and orgId to fileuploadhistories for templateTraining
                if (input['oId'] && input['sId'] && input['refNo']) {
                    let user = yield (db.collection("users")).findOne({ subscriberId: ObjectId(input['sId']) });
                    let userId = JSON.parse(JSON.stringify(user))['_id'];
                    let res = yield Promise.all([(db.collection("fileuploadhistories")).update({ fileRefNum: input['refNo'] }, { $set: { subscriberId: ObjectId(input['sId']), orgId: ObjectId(input['oId']), userId: ObjectId(userId) } }), (db.collection("filequeues")).update({ fileRefNum: input['refNo'] }, { $set: { subscriberId: ObjectId(input['sId']), orgId: ObjectId(input['oId']), userId: ObjectId(userId) } })]);
                    console.log("Updated historicalData collection....", res);
                }
                return { message: 'data saved successfully.', status: 0, data: output };
            }
            catch (err) {
                console.log('Failed for save document training data - ' + err);
                return { message: 'data saved successfully.', status: 1, data: err };
            }
        });
    }
    gstInFormatter(inputText, matchObj) {
        if (typeof inputText == 'string') {
            inputText = inputText.replace(/[^\da-zA-Z]/gi, '');
            let textArr = /[A-Za-z0-9]{15}/.exec(inputText);
            let text = '';
            if (textArr) {
                text = textArr[0];
            }
            else {
                return inputText;
            }
            if (text.length == 15 && typeof matchObj == 'object') {
                let split1 = text.substring(0, 2);
                let split2 = text.substring(2, 7);
                let split3 = text.substring(7, 11);
                let split4 = text.substring(11, 12);
                let split5 = text.substring(12, 13);
                let split6 = 'Z';
                let split7 = text.substring(14);
                const forText = (text) => {
                    Object.values(matchObj).forEach((el, i) => {
                        let elem = el.toString();
                        let reg = new RegExp(elem, 'ig');
                        let value = Object.keys(matchObj)[i];
                        text = text.replace(reg, value);
                    });
                    return text;
                };
                const forNumber = (text) => {
                    Object.keys(matchObj).forEach((el, i) => {
                        let reg = new RegExp(el, 'ig');
                        let value = Object.values(matchObj)[i];
                        text = text.replace(reg, value);
                    });
                    return text;
                };
                split1 = forNumber(split1);
                split2 = forText(split2);
                split3 = forNumber(split3);
                split4 = forText(split4);
                const res = split1 + split2 + split3 + split4 + split5 + split6 + split7;
                return res;
            }
            else {
                return inputText;
            }
        }
        else {
            return inputText;
        }
    }
    convertDateNew(date, format) {
        if (/-/.test(date)) {
            let splitDate = date.split("-");
            if (splitDate.length == 3) {
                if (splitDate[0].length <= 2 && splitDate[1].length <= 2) {
                    if (Number(splitDate[1]) > Number(splitDate[0]) && Number(splitDate[1]) > 12) {
                        date = `${splitDate[1]}-${splitDate[0]}-${splitDate[2]}`;
                    }
                }
            }
        }
        let dateDay = moment(date, 'DD/MM/YYYY').date();
        let dateMonth = moment(date, 'DD/MM/YYYY').month();
        let dateYear = moment(date, 'DD/MM/YYYY').year();
        dateMonth = moment().month(dateMonth).format('MMM');
        if (dateDay && dateMonth && dateYear) {
            return `${dateMonth} ${dateDay}, ${dateYear}`;
        }
        else {
            return moment(date).format(format);
        }
    }
    //function to get userdata fields
    getUserDetails(id, field, field2) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const userData = yield User_1.UserModel.findById(id);
                if (!util_1.isNullOrUndefined(field2)) {
                    return userData[field][field2];
                }
                else {
                    console.log("result ", userData[field]);
                    return userData[field];
                }
            }
            catch (e) {
                console.log("Invalid id ", e);
                return e;
            }
        });
    }
    identifyGroup(arrayData, valueSelected, resultType) {
        try {
            let result = {};
            if (!util_1.isNullOrUndefined(valueSelected) && !util_1.isNullOrUndefined(arrayData) && Array.isArray(arrayData) && arrayData.length > 0) {
                let objData = arrayData[0];
                //console.log("----------------", objData)
                if (typeof valueSelected == "string") {
                    if (objData['Direct Expenses'].includes(valueSelected)) {
                        result['group'] = 'Direct Expenses';
                    }
                    else if (objData['Indirect Expenses'].includes(valueSelected)) {
                        result['group'] = 'Indirect Expenses';
                    }
                    else if (objData['Purchase Accounts'].includes(valueSelected)) {
                        result['group'] = 'Purchase Accounts';
                    }
                    else if (objData['Fixed Assets'].includes(valueSelected)) {
                        result['group'] = 'Fixed Assets';
                    }
                }
                //console.log("result", result)
                if (result['group']) {
                    result['present'] = true;
                }
                else {
                    result['present'] = false;
                    result['group'] = '';
                }
                return result[resultType];
            }
            else {
                return false;
            }
        }
        catch (error) {
            return error["message"];
        }
    }
    getStateinIndia(place) {
        const stateDetails = [{ "State": "Andhra Pradesh", "TIN": 37, "State Code": "AD" }, { "State": "Arunachal Pradesh", "TIN": 12, "State Code": "AR" }, { "State": "Assam", "TIN": 18, "State Code": "AS" }, { "State": "Bihar", "TIN": 10, "State Code": "BR" }, { "State": "Chattisgarh", "TIN": 22, "State Code": "CG" }, { "State": "Delhi", "TIN": 7, "State Code": "DL" }, { "State": "Goa", "TIN": 30, "State Code": "GA" }, { "State": "Gujarat", "TIN": 24, "State Code": "GJ" }, { "State": "Haryana", "TIN": 6, "State Code": "HR" }, { "State": "Himachal Pradesh", "TIN": 2, "State Code": "HP" }, { "State": "Jammu and Kashmir", "TIN": 1, "State Code": "JK" }, { "State": "Jharkhand", "TIN": 20, "State Code": "JH" }, { "State": "Karnataka", "TIN": 29, "State Code": "KA" }, { "State": "Kerala", "TIN": 32, "State Code": "KL" }, { "State": "Lakshadweep Islands", "TIN": 31, "State Code": "LD" }, { "State": "Madhya Pradesh", "TIN": 23, "State Code": "MP" }, { "State": "Maharashtra", "TIN": 27, "State Code": "MH" }, { "State": "Manipur", "TIN": 14, "State Code": "MN" }, { "State": "Meghalaya", "TIN": 17, "State Code": "ML" }, { "State": "Mizoram", "TIN": 15, "State Code": "MZ" }, { "State": "Nagaland", "TIN": 13, "State Code": "NL" }, { "State": "Odisha", "TIN": 21, "State Code": "OD" }, { "State": "Pondicherry", "TIN": 34, "State Code": "PY" }, { "State": "Punjab", "TIN": 3, "State Code": "PB" }, { "State": "Rajasthan", "TIN": 8, "State Code": "RJ" }, { "State": "Sikkim", "TIN": 11, "State Code": "SK" }, { "State": "Tamil Nadu", "TIN": 33, "State Code": "TN" }, { "State": "Telangana", "TIN": 36, "State Code": "TS" }, { "State": "Tripura", "TIN": 16, "State Code": "TR" }, { "State": "Uttar Pradesh", "TIN": 9, "State Code": "UP" }, { "State": "Uttarakhand", "TIN": 5, "State Code": "UK" }, { "State": "West Bengal", "TIN": 19, "State Code": "WB" }, { "State": "Andaman and Nicobar Islands", "TIN": 35, "State Code": "AN" }, { "State": "Chandigarh", "TIN": 4, "State Code": "CH" }, { "State": "Dadra & Nagar Haveli and Daman & Diu", "TIN": 26, "State Code": "DNHDD" }, { "State": "Ladakh", "TIN": 38, "State Code": "LA" }, { "State": "Other Territory", "TIN": 97, "State Code": "OT" }];
        let resultState = '';
        place = String(place);
        place = place.replace(/[^\da-zA-Z]/gi, '');
        if (!util_1.isNullOrUndefined(place)) {
            stateDetails.forEach(el => {
                let state = el.State.replace(/[^\da-zA-Z]/gi, '').toUpperCase();
                if (new RegExp(state, 'i').test(place)) {
                    resultState = el.State.toUpperCase();
                }
                else if (String(el.TIN) == place) {
                    resultState = el.State.toUpperCase();
                }
                else if (el['State Code'] == place) {
                    resultState = el.State.toUpperCase();
                }
            });
            if (resultState != '') {
                return resultState;
            }
            else {
                return '';
            }
        }
        else {
            return '';
        }
    }
    getStateinIndiabyAddr(place) {
        const stateDetails = [{ "State": "Andhra Pradesh", "TIN": 37, "State Code": "AD" }, { "State": "Arunachal Pradesh", "TIN": 12, "State Code": "AR" }, { "State": "Assam", "TIN": 18, "State Code": "AS" }, { "State": "Bihar", "TIN": 10, "State Code": "BR" }, { "State": "Chattisgarh", "TIN": 22, "State Code": "CG" }, { "State": "Delhi", "TIN": 7, "State Code": "DL" }, { "State": "Goa", "TIN": 30, "State Code": "GA" }, { "State": "Gujarat", "TIN": 24, "State Code": "GJ" }, { "State": "Haryana", "TIN": 6, "State Code": "HR" }, { "State": "Himachal Pradesh", "TIN": 2, "State Code": "HP" }, { "State": "Jammu and Kashmir", "TIN": 1, "State Code": "JK" }, { "State": "Jharkhand", "TIN": 20, "State Code": "JH" }, { "State": "Karnataka", "TIN": 29, "State Code": "KA" }, { "State": "Kerala", "TIN": 32, "State Code": "KL" }, { "State": "Lakshadweep Islands", "TIN": 31, "State Code": "LD" }, { "State": "Madhya Pradesh", "TIN": 23, "State Code": "MP" }, { "State": "Maharashtra", "TIN": 27, "State Code": "MH" }, { "State": "Manipur", "TIN": 14, "State Code": "MN" }, { "State": "Meghalaya", "TIN": 17, "State Code": "ML" }, { "State": "Mizoram", "TIN": 15, "State Code": "MZ" }, { "State": "Nagaland", "TIN": 13, "State Code": "NL" }, { "State": "Odisha", "TIN": 21, "State Code": "OD" }, { "State": "Pondicherry", "TIN": 34, "State Code": "PY" }, { "State": "Punjab", "TIN": 3, "State Code": "PB" }, { "State": "Rajasthan", "TIN": 8, "State Code": "RJ" }, { "State": "Sikkim", "TIN": 11, "State Code": "SK" }, { "State": "Tamil Nadu", "TIN": 33, "State Code": "TN" }, { "State": "Telangana", "TIN": 36, "State Code": "TS" }, { "State": "Tripura", "TIN": 16, "State Code": "TR" }, { "State": "Uttar Pradesh", "TIN": 9, "State Code": "UP" }, { "State": "Uttarakhand", "TIN": 5, "State Code": "UK" }, { "State": "West Bengal", "TIN": 19, "State Code": "WB" }, { "State": "Andaman and Nicobar Islands", "TIN": 35, "State Code": "AN" }, { "State": "Chandigarh", "TIN": 4, "State Code": "CH" }, { "State": "Dadra & Nagar Haveli and Daman & Diu", "TIN": 26, "State Code": "DNHDD" }, { "State": "Ladakh", "TIN": 38, "State Code": "LA" }, { "State": "Other Territory", "TIN": 97, "State Code": "OT" }];
        if ((place) && typeof place == 'string' && place.length > 0) {
            let res = [];
            let pincode = place.match(/\d{6}/);
            if (pincode) {
                let pincodeIndex = pincode.index;
                let totalLength = place.length;
                let minLength = Math.round(totalLength / 10 * 4);
                if (pincodeIndex > minLength) {
                    let stateCode = pincode[0].substring(0, 2);
                    const pincodeDets = [{ "stateNo": "11", "state": "Delhi" }, { "stateNo": "12|13", "state": "Haryana" }, { "stateNo": "14|15|16", "state": "Punjab" }, { "stateNo": "17", "state": "Himachal Pradesh" }, { "stateNo": "18|19", "state": "Jammu and Kashmir" }, { "stateNo": "30|31|32|33|34", "state": "Rajasthan" }, { "stateNo": "36|37|38|39", "state": "Gujarat" }, { "stateNo": "40|41|42|43|44", "state": "Maharashtra" }, { "stateNo": "56|57|58|59", "state": "Karnataka" }, { "stateNo": "60|61|62|63|64", "state": "Tamil Nadu" }, { "stateNo": "67|68|69", "state": "Kerala" }, { "stateNo": "70|71|72|73|74", "state": "West Bengal" }, { "stateNo": "75|76|77", "state": "Odisha" }, { "stateNo": "78", "state": "Assam" }];
                    let stateDets = pincodeDets.find(el => {
                        let reg = new RegExp(el.stateNo);
                        return reg.test(stateCode);
                    });
                    if (stateDets) {
                        return stateDets.state.toUpperCase();
                    }
                }
            }
            stateDetails.forEach(el => {
                let stateName = el.State;
                let statecode = el['State Code'];
                let regex = new RegExp(`${stateName}|${statecode}`, 'ig');
                if (regex.test(place)) {
                    let match = place.match(regex);
                    let obj = {
                        "state": stateName,
                        "match": match[0],
                        "index": place.indexOf(match[0])
                    };
                    res.push(obj);
                }
            });
            if (pincode && res.length > 0) {
                let index = place.indexOf(pincode[0]);
                const closest = res.reduce((a, b) => {
                    return Math.abs(b.index - index) < Math.abs(a.index - index) ? b : a;
                });
                return closest.state.toUpperCase();
            }
            else {
                return '';
            }
        }
        else {
            return '';
        }
    }
    stringCompare(str1, str2, matchPercent) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let stringSimilarity = require("string-similarity");
                if (typeof str1 == 'string' && typeof str2 == 'string') {
                    str1 = str1.replace(/\W/g, "-");
                    str2 = str2.replace(/\W/g, "-");
                    let score = stringSimilarity.compareTwoStrings(str1, str2);
                    console.log(score);
                    if (score >= matchPercent / 100) {
                        return 'yes';
                    }
                    else {
                        return 'no';
                    }
                }
                else {
                    return '';
                }
            }
            catch (e) {
                return '';
            }
        });
    }
    getOrgData(orgId, fields) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            if (!util_1.isNullOrUndefined(orgId) && orgId.length > 0) {
                let orgData = yield this.OrganizationService.findOneById(orgId);
                let orgDataRes = JSON.parse(JSON.stringify(orgData.data));
                if (Array.isArray(fields) && orgDataRes) {
                    if (fields.length > 0) {
                        let obj = {};
                        fields.forEach(el => {
                            if (orgDataRes[el] || orgDataRes[el] === false) {
                                obj[el] = orgDataRes[el];
                            }
                            else {
                                obj[el] = '';
                            }
                        });
                        let res = JSON.stringify(obj);
                        res = res.replace(/"/g, "'");
                        return res;
                    }
                }
                if (!util_1.isNullOrUndefined(orgData) && orgDataRes) {
                    return JSON.stringify(orgDataRes);
                }
                else {
                    return '';
                }
            }
            else {
                return '';
            }
        });
    }
    checkFinancialYear(invdate) {
        if (!util_1.isNullOrUndefined(invdate)) {
            let currentYear = new Date().getFullYear();
            let currentMonth = new Date().getMonth();
            if (currentMonth < 3) {
                currentYear = currentYear - 1;
            }
            let startFinancialYear = new Date(`01-Apr-${currentYear}`);
            startFinancialYear = new Date(startFinancialYear.getTime() + 19800000);
            let endFinancialYear = new Date(`31-Mar-${currentYear + 1}`);
            endFinancialYear = new Date(endFinancialYear.getTime() + 19800000);
            if (/\w{1,2}-\w{3}-\w{4}/gm.test(invdate)) {
                let invDateRes = new Date(invdate);
                invDateRes = new Date(invDateRes.getTime() + 19800000);
                if (!/invalid/.test(invDateRes.toString())) {
                    if (startFinancialYear <= invDateRes && invDateRes <= endFinancialYear) {
                        return 'yes';
                    }
                    else {
                        return 'no';
                    }
                }
                else {
                    return '';
                }
            }
            else {
                return '';
            }
        }
        else {
            return '';
        }
    }
    getOrgAddress(orgData, singleField = '') {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            if (!util_1.isNullOrUndefined(orgData)) {
                let orgDataRes = orgData;
                if (typeof orgDataRes == 'string') {
                    orgDataRes = orgDataRes.replace(/'/g, '"');
                    orgDataRes = JSON.parse(orgDataRes);
                }
                if (orgData) {
                    if (singleField != '') {
                        if (orgDataRes['primaryAddress'][singleField]) {
                            return orgDataRes['primaryAddress'][singleField];
                        }
                        else if (orgDataRes[singleField] == true || orgDataRes[singleField] === false) {
                            return orgDataRes[singleField];
                        }
                        else {
                            return 'yes';
                        }
                    }
                    let building = (!util_1.isNullOrUndefined(orgDataRes['primaryAddress']['building']) && orgDataRes['primaryAddress']['building'] != '') ? orgDataRes['primaryAddress']['building'] + ", " : "";
                    let street = (!util_1.isNullOrUndefined(orgDataRes['primaryAddress']['street']) && orgDataRes['primaryAddress']['street'] != '') ? orgDataRes['primaryAddress']['street'] + ", " : "";
                    let area = (!util_1.isNullOrUndefined(orgDataRes['primaryAddress']['area']) && orgDataRes['primaryAddress']['area'] != '') ? orgDataRes['primaryAddress']['area'] + ", " : "";
                    let city = (!util_1.isNullOrUndefined(orgDataRes['primaryAddress']['city']) && orgDataRes['primaryAddress']['city'] != '') ? orgDataRes['primaryAddress']['city'] + ", " : "";
                    let state = (!util_1.isNullOrUndefined(orgDataRes['primaryAddress']['state']) && orgDataRes['primaryAddress']['state'] != '') ? orgDataRes['primaryAddress']['state'] + ", " : "";
                    let countryName = (!util_1.isNullOrUndefined(orgDataRes['primaryAddress']['countryName']) && orgDataRes['primaryAddress']['countryName'] != '') ? orgDataRes['primaryAddress']['countryName'] : "";
                    let addr = building + street + area + city + state + countryName;
                    return addr;
                }
                else {
                    return '';
                }
            }
            else {
                return '';
            }
        });
    }
    orderStringMatch(dataArr, fieldValue) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let stringSimilarity = require("string-similarity");
                let res = dataArr.reduce((final, el) => {
                    let obj = {};
                    obj['value'] = el['value'];
                    obj['label'] = el['label'];
                    obj['score'] = stringSimilarity.compareTwoStrings(el['value'], fieldValue);
                    final.push(obj);
                    return final;
                }, []);
                let orderedList = res.sort((a, b) => b['score'] - a['score']);
                orderedList = orderedList.map(el => ({ 'label': el['label'], 'value': el['value'] }));
                console.log(orderedList);
                return JSON.stringify(orderedList);
            }
            catch (err) {
                console.log(" RRR ERRR ", err);
                return dataArr;
            }
        });
    }
    fuzzyMatchStr(dataArr, fieldName, fieldValue, datafield) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let stringSimilarity = require("string-similarity");
                let fieldNameToSearch = fieldName.split(",");
                let fieldValueToSearch = fieldValue.split(",");
                console.log("-------", fieldNameToSearch, fieldValueToSearch);
                if (dataArr && Array.isArray(dataArr)) {
                    if (dataArr.length > 0) {
                        if (fieldNameToSearch.length == fieldValueToSearch.length) {
                            for (let i = 0; i < fieldNameToSearch.length; i++) {
                                let value = fieldValueToSearch[i];
                                const match = dataArr.reduce((final, el) => {
                                    let dataField = datafield.split(",");
                                    let matchValue = stringSimilarity.compareTwoStrings(el[dataField[i]], value);
                                    console.log(el[dataField[i]], value, matchValue);
                                    if (matchValue > 0.85) {
                                        final.push(el);
                                    }
                                    return final;
                                }, []);
                                if (match.length > 0) {
                                    return JSON.stringify(match);
                                }
                            }
                        }
                    }
                }
                return JSON.stringify([]);
            }
            catch (err) {
                console.log(" RRR ERRR ", err);
                return null;
            }
        });
    }
    sortItems(arrayData, key, value, searchField, resultField, allData = []) {
        try {
            // console.log(JSON.stringify(arrayData), value, key)
            const filterNewData = () => {
                let formatLedgerData = arrayData.map(el => el['value']);
                if (allData.length != 0 && Array.isArray(allData)) {
                    let filterHistoricalData = allData.filter(el => {
                        return !(el[searchField] != '' && formatLedgerData.includes(el[searchField]));
                    });
                    filterHistoricalData = filterHistoricalData.map(el => ({ 'label': el[searchField], 'value': el[searchField] }));
                    if (filterHistoricalData.length > 0) {
                        arrayData = [...arrayData, ...filterHistoricalData];
                        arrayData = arrayData.reduce((final, el) => {
                            if (final.filter(item => item['label'] == el['label']).length == 0 && el['label'] != '' && !util_1.isNullOrUndefined(el['label'])) {
                                final.push(el);
                            }
                            return final;
                        }, []);
                    }
                }
                return arrayData;
            };
            if (value.length > 0) {
                let searchVal = value[value.length - 1][searchField];
                let check = "no";
                let objValue = "";
                let result = {};
                if (!util_1.isNullOrUndefined(searchVal)) {
                    if (arrayData.length > 0) {
                        let matchObj = arrayData.filter(el => {
                            if (el[key] == searchVal) {
                                // el["selected"] = "yes"
                                check = "yes";
                                objValue = el["value"];
                            }
                            return el;
                        });
                        if (check == "no" && searchVal != '') {
                            check = "yes";
                            objValue = searchVal;
                            arrayData = arrayData.concat({ 'label': searchVal, 'value': searchVal });
                        }
                        arrayData = filterNewData();
                        result['ledgers'] = arrayData;
                        result["check"] = check;
                        result["final"] = matchObj;
                        result["value"] = objValue;
                    }
                    else {
                        if (searchVal != '') {
                            arrayData = filterNewData();
                            result["check"] = "yes";
                            result["value"] = searchVal;
                            result['ledgers'] = arrayData;
                        }
                        else {
                            result['ledgers'] = arrayData;
                        }
                    }
                }
                return result[resultField] ? result[resultField] : [];
            }
            else {
                arrayData = filterNewData();
                let result = {};
                result['ledgers'] = arrayData;
                return result[resultField] ? result[resultField] : [];
            }
        }
        catch (error) {
            return error["message"];
        }
    }
    getInvoiceCountPerOrg(data) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!util_1.isNullOrUndefined(data['orgId'])) {
                    if (Array.isArray(data["orgId"])) {
                        const InvoiceDetails = yield (db.collection('Invoice_Document')).find({ orgId: { "$in": data['orgId'] } });
                        const InvoiceDetailsOfOrg = JSON.parse(JSON.stringify(InvoiceDetails));
                        //console.log(JSON.stringify(InvoiceDetailsOfOrg))
                        const finalResult = data['orgId'].reduce((final, el) => {
                            let filterInvoice = InvoiceDetailsOfOrg.filter(doc => doc.orgId == el).length;
                            let res = {};
                            res['orgId'] = el;
                            res['Invoice_Count'] = filterInvoice;
                            if (filterInvoice > 0) {
                                res['invCheck'] = true;
                            }
                            else {
                                res['invCheck'] = false;
                            }
                            final.push(res);
                            return final;
                        }, []);
                        return finalResult;
                    }
                }
            }
            catch (error) {
                console.log(error);
                return [];
            }
        });
    }
    getTallyDetailsFromServer(orgId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!util_1.isNullOrUndefined(orgId)) {
                    const tallyLedgerDetails = yield (db.collection('TallyMasters')).find({ orgId: orgId });
                    const tallyData = JSON.parse(JSON.stringify(tallyLedgerDetails));
                    if (tallyData.length > 0) {
                        return tallyData;
                    }
                    else {
                        return {};
                    }
                }
                else {
                    return 'orgId empty';
                }
            }
            catch (error) {
                return null;
            }
        });
    }
    updateTallyDetails(data) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!util_1.isNullOrUndefined(data['orgId'])) {
                    if (!util_1.isNullOrUndefined(data['_id'])) {
                        delete data['_id'];
                    }
                    console.log({ orgId: data["orgId"] }, data, { upsert: true }, { new: true });
                    const tallyLedgerDetails = yield (db.collection('TallyMasters')).updateOne({ orgId: data["orgId"] }, data, { upsert: true });
                    this.OrganizationService.updateisSyncTally(data["orgId"]);
                    if (tallyLedgerDetails.nModified !== 0) {
                        return 'Success';
                    }
                    else {
                        return 'Not Modified';
                    }
                }
                else {
                    return 'orgId empty';
                }
            }
            catch (error) {
                console.log(error);
                return null;
            }
        });
    }
    getTallyDetails(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'getTallyDetails',
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("names of excel files are changed.");
                return { message: 'names of excel files are changed.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to change names of excel files." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    converIsoDate(date) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            if (!util_1.isNullOrUndefined(date)) {
                date = new Date(date);
                date.setHours(date.getHours() + 5);
                date.setMinutes(date.getMinutes() + 30);
                return date;
            }
        });
    }
    assignToApprover(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let updateValue = !util_1.isNullOrUndefined(input.updateValue) ? typeof input.updateValue == 'string' && input.updateValue.search(/[\{[\]]/g) != -1 ? JSON.parse(input.updateValue) : input.updateValue : input.updateValue;
                let eventId = !util_1.isNullOrUndefined(input.eventId) && input.eventId != '' ? input.eventId : input.eventId;
                let botId = !util_1.isNullOrUndefined(input.botId) && input.botId != '' ? typeof input.botId == 'string' ? Number(input.botId) : input.botId : input.botId;
                let position = !util_1.isNullOrUndefined(input.position) && input.position != '' ? typeof input.position == 'string' ? Number(input.position) : input.position : input.position;
                let isPush = typeof input.isPush == 'string' ? JSON.parse(input.isPush) : input.isPush;
                let searchObj = {};
                let newUpdateValue = {};
                searchObj['eventId'] = ObjectId(eventId);
                searchObj['botId'] = botId;
                if (!util_1.isNullOrUndefined(updateValue) && updateValue != '' && !util_1.isNullOrUndefined(position) && position != '' && !util_1.isNullOrUndefined(isPush) && isPush == false && !util_1.isNullOrUndefined(eventId) && eventId != '' && !util_1.isNullOrUndefined(botId) && botId != '') {
                    if (!Array.isArray(updateValue)) {
                        for (let obj in updateValue) {
                            let key = "assignToList." + position + "." + obj;
                            if (obj == 'date' || obj == 'startDate') {
                                let d = yield this.converIsoDate(new Date());
                                newUpdateValue[key] = d;
                            }
                            else if (obj == 'assignedToId') {
                                newUpdateValue[key] = typeof updateValue['assignedToId'] == 'string' ? ObjectId(updateValue['assignedToId']) : updateValue['assignedToId'];
                            }
                            else {
                                newUpdateValue[key] = updateValue[obj];
                            }
                        }
                        const updated = yield (db.collection('eventstatuses')).update(searchObj, { $set: newUpdateValue });
                        if (updated.nModified == 1) {
                            output['result'] = updated.nModified;
                            return { message: 'Data  assignApprover Successfully', status: 0, data: output };
                        }
                    }
                }
                else if (!util_1.isNullOrUndefined(updateValue) && updateValue != '' && !util_1.isNullOrUndefined(isPush) && isPush == true && !util_1.isNullOrUndefined(eventId) && eventId != '' && !util_1.isNullOrUndefined(botId) && botId != '') {
                    if (Array.isArray(updateValue)) {
                        for (let obj of updateValue) {
                            let d = yield this.converIsoDate(new Date());
                            obj['assignedToId'] = typeof obj['assignedToId'] == 'string' ? ObjectId(obj['assignedToId']) : obj['assignedToId'];
                            obj['date'] = d;
                            obj['startDate'] = d;
                        }
                    }
                    else {
                        let d = yield this.converIsoDate(new Date());
                        updateValue['assignedToId'] = typeof updateValue['assignedToId'] == 'string' ? ObjectId(updateValue['assignedToId']) : updateValue['assignedToId'];
                        updateValue['date'] = d;
                        updateValue['startDate'] = d;
                    }
                    let d = Object.create(null);
                    if (!util_1.isNullOrUndefined(position) && position !== "") {
                        if (!Array.isArray(updateValue)) {
                            updateValue = [updateValue];
                        }
                        d = { "assignToList": { "$each": updateValue, '$position': position } };
                    }
                    else {
                        if (!Array.isArray(updateValue)) {
                            updateValue = [updateValue];
                        }
                        d = { "assignToList": { "$each": updateValue } };
                    }
                    const updated = yield (db.collection('eventstatuses')).update(searchObj, { $set: {}, $push: d });
                    if (updated.nModified == 1) {
                        output['result'] = updated.nModified;
                        return { message: 'Data  assignApprover Successfully', status: 0, data: output };
                    }
                }
                return { message: 'Data  Not assignApprover ', status: 1, data: output };
            }
            catch (e) {
                this.log.error("Data  assign Approver Failed" + e);
                return { message: 'Data  assignApprover Failed', status: 1, data: e };
            }
        });
    }
    DumpDataInCollection(input, outputParameters, botId, projectId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("all inputs are", input);
                var mysort = { "_id": -1 };
                let Poll_NO;
                let Pole_Longitude;
                let Pole_Latitude;
                let Total_Connection;
                let Actual_Connection;
                let Customer_Latiude;
                let Customer_Longitude;
                let Doc_type = input.Doc_type;
                let FileRefNO = input.FileRefNO;
                let db_name = input.db_name;
                let server_uri = input.server_uri;
                let project_name = input.project_name;
                console.log('aa gya');
                const mClient = yield MongoClient.connect(server_uri);
                const db = yield mClient.db(db_name);
                let result = yield db.collection("events").find({ "projectName": project_name }).sort(mysort).limit(1).toArray();
                let ab = result;
                ab = ab[0].additionalInfoVar;
                console.log("result========================", ab);
                Poll_NO = ab.Poll_NO;
                Pole_Longitude = ab.Pole_Longitude;
                Pole_Latitude = ab.Pole_Latitude;
                Total_Connection = ab.Total_Connection;
                Actual_Connection = ab.Actual_Connection;
                Customer_Latiude = ab.Customer_Latiude;
                Customer_Longitude = ab.Customer_Longitude;
                console.log("==================////////////////========", Poll_NO, Pole_Longitude, Pole_Latitude, Total_Connection, Actual_Connection, Customer_Latiude, Customer_Longitude);
                yield db.collection(Doc_type).findOneAndUpdate({ "referenceNumber": FileRefNO }, { $set: { Poll_NO: Poll_NO, Pole_Longitude: Pole_Longitude, Pole_Latitude: Pole_Latitude, Total_Connection: Total_Connection, Actual_Connection: Actual_Connection, Customer_Latiude: Customer_Latiude, Customer_Longitude: Customer_Longitude } }, { upsert: true });
                return { message: 'Data updated in database', status: 0, data: outputParameters };
            }
            catch (e) {
                this.log.error("Error in creating collection." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    dynamicDocumentIdentification(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                if (util_1.isNullOrUndefined(input.filePath))
                    throw new Error("filePath is required");
                if (util_1.isNullOrUndefined(input.documentType))
                    throw new Error("documentType is required");
                if (util_1.isNullOrUndefined(input.refNumber))
                    throw new Error("refNumber is required");
                let filePath = input.filePath;
                let documentType = input.documentType;
                const data = fs.readFileSync(filePath, 'utf8');
                console.log('File content:', data);
                let prompt = `
                You are an expert in document classification. Your task is to analyze OCR-extracted text from an uploaded document and determine its exact document type.  

                ### **Instructions:**  
                1. You will receive **OCR-extracted text** from a document.  
                2. You will also receive a **list of   document types** that this document must belong to.  
                3. Your goal is to **identify the correct document type** by analyzing the text and matching it with relevant keywords, phrases, or unique identifiers associated with each document type.  

                ### **Steps to Follow:**  
                1. **Extract relevant keywords** from each document type in the provided list and use them for classification.  
                2. **Analyze the given OCR text** and compare it against these keywords to determine the best match.  
                3. **Ensure accurate classification** by checking multiple characteristics such as document structure, key fields, and domain-specific terminology.  
                4. **Return a structured JSON output** with:  
                - The identified **document type**.  
                - The **keywords used** for classification.  

                ### **Input Data:**  
                #### **OCR Text:**  
                ${data}  

                #### **Possible Document Types(Strictly give the output(document type) from the below list only.):**  
                ${documentType}  

                ### **Expected Output Format:**  
                Return the response in the following JSON format:  
                json
                {
                "output": {"document_type": "Detected Document Type"}
                
                }
                
            `;
                let response = yield this.callopenAI(prompt, input.subscriberId, input.orgId, 'Dynamic Document Classification');
                console.log(response.document_type);
                yield db.collection("fileuploadhistories").findOneAndUpdate({ fileRefNum: input.refNumber }, { $set: { documentType: response.document_type } });
                output['document_type'] = response.document_type;
                output['response'] = response;
                return { "message": "dynamicDocumentIdentification found", status: 0, data: output };
            }
            catch (e) {
                console.error("Error inside dynamicDocumentSplitter ", e);
                return { "message": "dynamicDocumentIdentification not found", status: 1, data: e };
            }
        });
    }
    fleetComplaince(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("Inside the fleetComplaince+++++++++++++++++++++++", input);
                console.log("iterationId   ", iterationId);
                if (!input.documentType)
                    throw new Error("Document Type is required");
                console.log("documentType   ", input.documentType);
                let documentType = typeof input.documentType === 'string' ? JSON.parse(input.documentType) : input.documentType;
                documentType = documentType[iterationId];
                let expiry_date;
                let documents;
                let matchObj;
                let value = input.expiry_date;
                if (!isNaN(value) && typeof Number(value) === 'number' && value != '') {
                    console.log("It's a number!");
                    expiry_date = new Date();
                    value = Number(value);
                    expiry_date.setDate(expiry_date.getDate() + value);
                    matchObj = {
                        formattedDate: { $lte: expiry_date, $gt: new Date() },
                        isDeleted: { $nin: [true, "true"] }
                    };
                }
                else if (!util_1.isNullOrUndefined(value) && value != '') {
                    console.log("It's a Date.");
                    expiry_date = new Date(value);
                    matchObj = {
                        formattedDate: { $lte: expiry_date, $gt: new Date() },
                        isDeleted: { $nin: [true, "true"] }
                    };
                }
                else {
                    console.log("It's not a number.");
                    expiry_date = new Date();
                    matchObj = {
                        formattedDate: { $lte: expiry_date },
                        isDeleted: { $nin: [true, "true"] }
                    };
                }
                console.log("documentType       ", documentType);
                console.log("expiry_date    ", expiry_date);
                //documents = await (db.collection(documentType).find(matchObj).lean());
                documents = yield db.collection(documentType).aggregate([
                    { $match: matchObj },
                    { $sort: { _id: -1 } },
                    { $group: {
                            _id: "$Vechicle_Number",
                            latestDocument: { $first: "$$ROOT" }
                        } },
                    { $replaceRoot: { newRoot: "$latestDocument" } } // Flatten the output
                ]);
                console.log("   documents   ", documents);
                output['documents'] = documents;
                output['documentCount'] = documents.length;
                return { message: 'Documents Fetched', status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error in fleetComplaince Function." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    fleetHistory(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("Inside the fleetHistory+++++++++++++++++++++++", input);
                console.log("iterationId   ", iterationId);
                if (!input.olfRefNo)
                    throw new Error("olfRefNo is required");
                if (!input.newRefNo)
                    throw new Error("newRefNo is required");
                if (!input.documentType)
                    throw new Error("documentType is required");
                let documentType = input.documentType;
                let olfRefNo = input.olfRefNo;
                let newRefNo = input.newRefNo;
                let oldDocument = yield db.collection(documentType).findOne({ referenceNumber: olfRefNo }).lean();
                let newDocument = yield db.collection(documentType).findOneAndUpdate({ referenceNumber: newRefNo }, { isDeleted: true }).lean();
                let dmsDocument = yield db.collection('documents').findOne({ fileRefNum: olfRefNo }, { versions: 1 }).lean();
                if (!util_1.isNullOrUndefined(dmsDocument)) {
                    let versions = dmsDocument.versions;
                    let ver = {
                        "createdAt": new Date(),
                        "updatedAt": new Date(),
                        "path": newDocument.filePath,
                        "isServer": true,
                        "versionNumber": versions.length,
                        "_id": ObjectId()
                    };
                    versions.unshift(ver);
                    yield db.collection('documents').updateOne({ fileRefNum: olfRefNo }, { $set: { versions: versions } });
                }
                let history = oldDocument.history ? oldDocument.history : [];
                let referenceNumber = oldDocument.referenceNumber;
                delete oldDocument._id;
                delete newDocument._id;
                delete newDocument.isDeleted;
                delete oldDocument.history;
                history.push(oldDocument);
                let newObj = Object.assign({}, newDocument, { history: history, referenceNumber });
                console.log(newObj);
                let result = yield db.collection(documentType).replaceOne({ referenceNumber: referenceNumber }, newObj);
                console.log("resul  t    ", result);
                return { message: 'Documents Fetched', status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error in fleetComplaince Function." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    dmsVersioning(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("Inside the dmsVersioning+++++++++++++++++++++++", input);
                console.log("iterationId   ", iterationId);
                let filePath = input.filePath;
                let refNo = input.refNo;
                let dmsDocument = yield db.collection('documents').findOne({ fileRefNum: refNo }, { versions: 1 }).lean();
                if (!util_1.isNullOrUndefined(dmsDocument)) {
                    let versions = dmsDocument.versions;
                    let ver = {
                        "createdAt": new Date(),
                        "updatedAt": new Date(),
                        "path": filePath,
                        "isServer": true,
                        "versionNumber": versions.length,
                        "_id": ObjectId()
                    };
                    versions.unshift(ver);
                    yield db.collection('documents').updateOne({ fileRefNum: refNo }, { $set: { versions: versions } });
                }
                return { message: 'Versioned the file', status: 0, data: outPut };
            }
            catch (e) {
                this.log.error("Error in fleetComplaince Function." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    sendPOCWAMsg(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let data1 = {};
                data1['functionName'] = "sendPOCWAMsg",
                    data1['input'] = input;
                let token = yield this.createToken(input.userId, input.subscriberId, input.orgId);
                const urloptions = {
                    method: 'POST',
                    url: "https://dev.aiqod.com:843/gibots-api/bots/botCommonFunction",
                    headers: {
                        "Authorization": "Bearer " + token,
                        "Content-Type": "application/json",
                        "selectedorgid": input.orgId,
                    },
                    body: data1,
                    json: true
                };
                const res = yield request(urloptions);
                console.log('res   ', res);
                return { message: '', status: 0, data: res };
            }
            catch (e) {
                console.log('bot2 Error', e);
                return { message: '', status: 1, data: e };
            }
        });
    }

pdfConverter_BKP(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
		console.log("GOAT  ",input)
                const util = require('util');
                const fs = require('fs/promises');
                const exec = util.promisify(require('child_process').exec);
                const ExcelJS = require('exceljs123');
                let filePath;
                if ([true, "true"].includes(input.isArray)) {
                    if (typeof input.filePath === "string") {
                        input.filePath = JSON.parse(input.filePath);
                    }
                    filePath = input.filePath[iterationId];
                }
                else {
                    filePath = input.filePath;
                }
                let extractedFilePath = filePath.substring(0, filePath.lastIndexOf('/'));
                let fileName = filePath.substring(filePath.lastIndexOf('/') + 1, filePath.indexOf('.'));
                let ext = filePath.substring(filePath.lastIndexOf('.') + 1, filePath.length);
                if (!(ext == 'xls' || ext == 'xlsx' || ext == 'docx' || ext == 'doc')) {
                    console.info("Input file is not a excel file");
			if ([true, "true"].includes(input.isArray)) {
                 	   output['filePathArr'] = input.filePath;
			}
			output['newFilePath'] = filePath;
                    return { message: "Not a excel File", status: 0, data: output };
                }
                if (ext === 'xls') {
                    const command = `libreoffice --headless --convert-to xlsx "${filePath}" --outdir "${extractedFilePath}"`;
                    const response = yield exec(command);
                    console.log(response);
                    yield fs.unlink(filePath);
                    filePath = `${extractedFilePath}/${fileName}.xlsx`;
                    console.log(filePath);
                }
                yield delay(5000);
                // Configuring the workbook and the worksheet
                const workbook = new ExcelJS.Workbook();
                yield workbook.xlsx.readFile(filePath);
                workbook.eachSheet((worksheet, sheetId) => {
                    const totalRows = worksheet.rowCount;
                    const totalColumns = worksheet.columnCount;
                    // Apply wrapText to the entire range of the worksheet
                    if (totalColumns !== 0 || totalRows !== 0)
                        worksheet.getCell(`A1:${worksheet.getColumn(totalColumns).letter}${totalRows}`).alignment = { wrapText: true };
                    // Set page layout properties
                    worksheet.pageSetup.orientation = 'landscape'; // or 'portrait'  'landscape'
                    worksheet.pageSetup.paperSize = 9; // 9 is for A4; refer to documentation for other sizes
                    worksheet.pageSetup.fitToPage = true; // Enable fit to page
                    worksheet.pageSetup.fitToWidth = 1; // Fit content to 1 page width
                    worksheet.pageSetup.fitToHeight = 0; // Fit content to 1 page height
                    worksheet.pageSetup.pageOrder = 'overThenDown';
                });
                //Save the workbook to a file
                yield workbook.xlsx.writeFile(filePath);
                console.log("++++++++++ configured the excel +++++++++++");
                console.log("in the pdf conversion block");
                const command = `libreoffice --headless --convert-to pdf "${filePath}" --outdir "${extractedFilePath}"`;
                yield exec(command);
                yield fs.unlink(filePath);
                filePath = `${extractedFilePath}/${fileName}.pdf`;
                console.log(`File converted to pdf successfully`, filePath);
                if ([true, "true"].includes(input.isArray)) {
                    input.filePath[iterationId] = filePath;
                    output['filePathArr'] = input.filePath;
                }
                output['newFilePath'] = filePath;
                return { message: "Succesfully converted t1he file.", status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error while converting file ---" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    pdfConverter(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const util = require('util');
                const fs = require('fs/promises');
                const exec = util.promisify(require('child_process').exec);
                const ExcelJS = require('exceljs123');
                let filePath;
		console.log("Input ", input);
		console.log("iterationId ",iterationId)
		console.log("CHECKing [true, 'true'].includes(input.isArray ",[true, 'true'].includes(input.isArray) )
		console.log("typeof input.filePath === 'string'  ", typeof input.filePath === "string")
                 console.info("1", input.filePath)

                if ([true, "true"].includes(input.isArray)) {
                    if (typeof input.filePath === "string") {
                        input.filePath = JSON.parse(input.filePath);
			console.log("filePath ", input.filePath)
                    }
                    filePath = input.filePath[iterationId];
			console.log("filePath 1", input.filePath)

                }
                else {
                    filePath = input.filePath;
                }
		console.info("2",filePath)

                let extractedFilePath = filePath.substring(0, filePath.lastIndexOf('/'));
                let fileName = filePath.substring(filePath.lastIndexOf('/') + 1, filePath.lastIndexOf('.'));
                let ext = filePath.substring(filePath.lastIndexOf('.') + 1, filePath.length);
                if (!(ext == 'xls' || ext == 'xlsx')) {
                    console.info("Input file is not a excel file");
                    output['filePathArr'] = input.filePath;
                    return { message: "Not a excel File", status: 0, data: output };
                }
		console.info("3")

                if (ext === 'xls') {
                    const command = `libreoffice --headless --convert-to xlsx "${filePath}" --outdir "${extractedFilePath}"`;
                    const response = yield exec(command);
                    console.log(response);
                    yield fs.unlink(filePath);
                    filePath = `${extractedFilePath}/${fileName}.xlsx`;
                    console.log(filePath);
                }
		console.log("4")
                yield delay(5000);
                // Configuring the workbook and the worksheet
                const workbook = new ExcelJS.Workbook();
                yield workbook.xlsx.readFile(filePath);
                workbook.eachSheet((worksheet, sheetId) => {
                    const totalRows = worksheet.rowCount;
                    const totalColumns = worksheet.columnCount;
                    // Apply wrapText to the entire range of the worksheet
                    if (totalColumns !== 0 && totalRows !== 0)
                        worksheet.getCell(`A1:${worksheet.getColumn(totalColumns).letter}${totalRows}`).alignment = { wrapText: true };
                    // Set page layout properties
                    worksheet.pageSetup.orientation = 'landscape'; // or 'portrait'  'landscape'
                    worksheet.pageSetup.paperSize = 9; // 9 is for A4; refer to documentation for other sizes
                    worksheet.pageSetup.fitToPage = true; // Enable fit to page
                    worksheet.pageSetup.fitToWidth = 1; // Fit content to 1 page width
                    worksheet.pageSetup.fitToHeight = 0; // Fit content to 1 page height
                    worksheet.pageSetup.pageOrder = 'overThenDown';
                });
                //Save the workbook to a file
                yield workbook.xlsx.writeFile(filePath);
                console.log("++++++++++ configured the excel +++++++++++");
                console.log("in the pdf conversion block");
                const command = `libreoffice --headless --convert-to pdf "${filePath}" --outdir "${extractedFilePath}"`;
                yield exec(command);
                yield fs.unlink(filePath);
                filePath = `${extractedFilePath}/${fileName}.pdf`;
                console.log(`File converted to pdf successfully`, filePath);
                if ([true, "true"].includes(input.isArray)) {
                    input.filePath[iterationId] = filePath;
                    output['filePathArr'] = input.filePath;
                }
                output['newFilePath'] = filePath;
                return { message: "Succesfully converted t1he file.", status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error while converting file ---" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    extractedFieldsToTxt(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                this.log.info("inside the extractedFieldsToTxt function+__________+++++++++++++++__****");
                if (input.doctype == '' || util_1.isNullOrUndefined(input.doctype))
                    throw new Error("doctype is required");
                if (input.refnum == '' || util_1.isNullOrUndefined(input.refnum))
                    throw new Error("doctype is required");
                const fs = require('fs').promises;
                let doctype = input.doctype;
                let refnum = input.refnum;
                let scanningDoc = yield db.collection('scanningfields').findOne({ documentType: doctype }).lean();
                if (util_1.isNullOrUndefined(scanningDoc)) {
                    throw new Error("scanningDoc not found");
                }
		function ensureFields(required, input) {
  const result = { ...input };
  for (const key in required) {
    if (!(key in result)) {
      result[key] = "";
    }
  }
  return result;
}

                let fields = scanningDoc.fields;
                if (util_1.isNullOrUndefined(fields || fields.length == 0))
                    throw new Error("fields not found");
                let headerFields = [];
                headerFields = fields
                    .filter(el => el.isTable === false)
                    .map(el => el.fieldName);
                headerFields.push("multiTable");
                headerFields.push("filePath");
                let projectionFields = headerFields.reduce((acc, field) => {
                    acc[field] = 1;
                    return acc;
                }, {});
			console.log("projected fields ",projectionFields)
                projectionFields['_id'] = 0;
                let doc = yield db.collection(doctype).findOne({ referenceNumber: refnum }, projectionFields).lean();
                //console.log('first  ', doc);
                let tempFilePath = doc.filePath.substring(doc.filePath.indexOf("_") + 1);
                //delete doc.filePath
		//doc = ensureFields(projectionFields,doc)
		console.log('first  ', doc);
		delete doc.filePath

		const jsonString = JSON.stringify(doc, null, 2);
                let outputFilePath = config.cudapath + refnum + "_" + tempFilePath + '_json.txt';
                yield fs.writeFile(outputFilePath, jsonString);
                console.log('JSON saved to output.txt ', outputFilePath);
                output['txtfilePath'] = outputFilePath;
                return { message: "Succesfully converted t1he file.", status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error while extractedFieldsToTxt file ---" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    monitoringEmail(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.info("inside the monitoring email function");
                const Imap = require('imap');
                let temp = `${input.username}_${input.projectId}`;
                if (this.monitorInstances.has(temp)) {
                    console.log(`Monitoring already active for ${temp} ${input.projectName}`);
                    const imap1 = this.monitorInstances.get(temp);
                    if (imap1) {
                        imap1.end();
                        this.monitorInstances.delete(temp);
                        console.log(`Monitoring stopped for ${temp}  ${input.projectName}`);
                        console.log(`previous IMAP is ended. Now starting a new IMAP Monitoring ${temp}  ${input.projectName}`);
                    }
                    else {
                        console.log(`No monitoring active for ${input.username}`);
                    }
                }
                console.log("first");
                const imapConfig = {
                    user: input.username,
                    password: input.password,
                    host: 'imap.gmail.com',
                    port: 993,
                    tls: true,
                    authTimeout: 40000,
                    tlsOptions: {
                        rejectUnauthorized: false,
                    },
                };
                const imap = new Imap(imapConfig);
                imap.connect();
                this.monitorInstances.set(input.username, temp);
                console.log("third");
                imap.once('ready', () => {
                    imap.openBox('INBOX', false, (err, box) => {
                        if (err)
                            throw err;
                        console.log('Monitoring for new emails...' + input.projectName);
                        imap.on('mail', () => {
                            let searchCriteria;
                            if (!util_1.isNullOrUndefined(input.subject)) {
                                searchCriteria = ['UNSEEN', ['SINCE', input.date /* */], ['SUBJECT', input.subject]];
                            }
                            else {
                                searchCriteria = ['UNSEEN', ['SINCE', input.date /* */]];
                            }
                            console.log("outside");
                            imap.search(searchCriteria, (err, results) => {
                                if (err)
                                    throw err;
                                if (!results || results.length === 0)
                                    return;
                                console.log("create Task");
                                this.createTask(input, {}, botId, projectId, iterationId);
                                console.log("+++++________It is working fine*********+++++");
                            });
                        });
                    });
                });
                imap.once('error', (err) => {
                    console.error(err);
                });
                imap.once('end', () => {
                    console.log('Connection ended.');
                });
                setTimeout(() => {
                    imap.end();
                    this.monitorInstances.delete(temp);
                }, input.time);
                return { info: 'success', status: 0, data: output };
            }
            catch (error) {
                return { info: 'Failed', status: 1, data: [] };
            }
        });
    }
    createTask(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const botRequest = require("request-promise");
            try {
                console.info(" ---- INPUT ---- ", input);
                let self = this;
                let preData, currentTaskTitle = '';
                let Qs = yield Promise.all([
                    event_1.event.findOne({ _id: ObjectId(input.eventId) }).lean(),
                    event_1.event.findOne({ parentEventId: ObjectId(input.eventId), "iterationId": iterationId }).sort({ _id: -1 }).lean()
                ]);
                if (Qs.length > 0 && Qs[0]['taskTitle']) {
                    currentTaskTitle = Qs[0]['taskTitle'] + ' -> ';
                }
                if (input.eventId && input.waitForExecution && Qs.length == 2) {
                    preData = Qs[1];
                    if (preData && preData['eventStatus'] && !util_1.isNullOrUndefined(Qs[0]['inProgressBotId'])) {
                        if (preData['eventStatus'] == "Completed") {
                            // output = preData.additionalInfoVar;
                            output['outputData'] = preData.additionalInfoVar;
                            let updateDoc = yield event_1.event.update({ "_id": ObjectId(input.eventId) }, { inProgressBotId: null });
                            console.log(updateDoc);
                            return { info: 'success', status: 0, data: output };
                        }
                        else {
                            output['waitForExecution'] = true;
                            return { info: 'success', status: 0, data: output };
                        }
                    }
                }
                let token = yield self.createToken(input.userId, input.subscriberId, input.orgId);
                console.info(" --- AFTER TOKEN CREATION ----");
                const count = yield event_1.event.find({
                    projectId: ObjectId(input.projectId), isDeleted: false,
                    subscriberId: ObjectId(input.subscriberId), orgId: ObjectId(input.orgId)
                }).count();
                console.info("-- AFTER COUNT EXTRACTION ---- ");
                // input.projectName = "Gazette quality check",
                // input.projectId = "5f941791ee0201f88e523b0c";
                let date = new Date();
                let dateConcate = date.getFullYear().toString() + (date.getMonth() + 1).toString() + date.getDate().toString();
                // let id = Math.round(new Date().getTime() + (Math.random() * 100));
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                console.info(" -- BEFORE ADD TASK OPTIONS ---- ");
                let options = {
                    "method": 'POST',
                    "url": env_2.env.routes.gibots_orch + "gibots-orch/event/add/task",
                    "body": {
                        'additionalInfo': [],
                        'customerId': "5b8fd401b3930517f134c569",
                        'projectId': input.projectId,
                        'projectName': input.projectName,
                        'taskDesc': "",
                        'taskTemplateName': null,
                        'taskTitle': currentTaskTitle + dateConcate + '_' + input.projectName.substring(0, 1) + '_' + count,
                        'token': input.projectName.substring(0, 1) + '_' + count,
                        'username': input.userName,
                        'isBot': true
                    },
                    "headers": {
                        'authorization': 'Bearer ' + token,
                        'Content-Type': "application/json",
                        "selectedorgid": input.orgId,
                        "selectedgstin": "123456789876543"
                    },
                    json: true
                };
                let botResult = yield botRequest(options);
                console.info(" -- AFTER CREATION TASK ---- ");
                if (botResult.status == 0) {
                    const parentEvent = yield event_1.event.findById(input.eventId);
                    const newEvent = yield event_1.event.findById(botResult.data._id);
                    let variableMapping;
                    try {
                        variableMapping = JSON.parse(input.variableMapping);
                    }
                    catch (e) {
                        variableMapping = null;
                    }
                    let newObj = newEvent;
                    if (!util_1.isNullOrUndefined(input.taskName)) {
                        const taskName = input.taskName.split(",");
                        let taskValue = {};
                        taskName.forEach(item => {
                            if (!util_1.isNullOrUndefined(parentEvent['additionalInfoVar'][item])) {
                                taskValue[item] = parentEvent['additionalInfoVar'][item];
                            }
                        });
                        let newVariable;
                        taskName.forEach(item => {
                            newVariable = newEvent['variableList'].map(el => {
                                if (el.name === item) {
                                    el.value = taskValue[item];
                                }
                                return el;
                            });
                        });
                        newObj['variableList'] = newVariable;
                        taskName.forEach(item => {
                            newObj['additionalInfoVar'][item] = taskValue[item];
                        });
                    }
                    if (variableMapping && typeof variableMapping == 'object') {
                        let taskValue = {};
                        for (let item in variableMapping) {
                            if (!util_1.isNullOrUndefined(parentEvent['additionalInfoVar'][variableMapping[item]])) {
                                taskValue[item] = parentEvent['additionalInfoVar'][variableMapping[item]];
                            }
                        }
                        let newVariable;
                        for (let item in variableMapping) {
                            newVariable = newEvent['variableList'].map(el => {
                                if (el.name === item) {
                                    el.value = taskValue[item];
                                }
                                return el;
                            });
                        }
                        newEvent['variableList'] = newVariable;
                    }
                    newObj['parentEventId'] = input.eventId;
                    newObj['iterationId'] = iterationId;
                    const updateDoc = yield event_1.event.update({ "_id": ObjectId(newEvent._id) }, newObj);
                    const updateEs = yield eventStatus_1.eventStatus.update({ "eventId": ObjectId(newEvent._id) }, { parentEventId: input.eventId });
                    console.log(updateDoc, updateEs);
                    output["taskId"] = botResult.data._id;
                    output["processId"] = botResult.data.processId;
                    output["projectId"] = botResult.data.projectId;
                    output["filesList"] = input.filesList;
                    let chatURL = "";
                    let chatSocket = io.connect(chatURL, {
                        secure: true, 'reconnection': true, 'reconnectionDelay': 60000,
                        'reconnectionDelayMax': 60000,
                        'reconnectionAttempts': 'Infinity', transports: ['polling']
                    });
                    let excuteOptions = {
                        "method": 'POST',
                        "url": env_2.env.routes.gibots_orch + "gibots-orch/orchestrator/executeProject",
                        "body": {
                            "from": "join_event",
                            'projectId': input.projectId,
                            "eventId": botResult.data._id
                        },
                        "headers": {
                            'authorization': 'Bearer ' + token,
                            'Content-Type': "application/json",
                            "selectedorgid": input.orgId,
                            "selectedgstin": "123456789876543"
                        },
                        json: true
                    };
                    // let processcount = !isNullOrUndefined(input.processcount) && input.processcount !== '' ? input.processcount : 3;
                    // let processinprogresscount = await event.find({ parentEventId: ObjectId(input.eventId), projectId: ObjectId(input.projectId), eventStatus: { $in: ["InProgress", "inprogress"] } }).count()
                    // let botExcute;
                    // if (processinprogresscount < processcount) {
                    //     await chatSocket.emit('join_event', excuteOptions["body"]);
                    //     botExcute = await botRequest(excuteOptions);
                    // } else {
                    //     return { info: 'success', status: 0, data: output };
                    // }
                    let botExcute;
                    if (!util_1.isNullOrUndefined(input.bulkUpload) && (input.bulkUpload == true || input.bulkUpload == "true")) {
                        let processcount = !util_1.isNullOrUndefined(input.processcount) && input.processcount !== '' ? input.processcount : 3;
                        let processinprogresscount = yield event_1.event.find({ projectId: ObjectId(input.projectId), eventStatus: { $in: ["InProgress", "inprogress"] } }).count(); //parentEventId: ObjectId(input.eventId),
                        if (processinprogresscount < processcount) {
                            yield chatSocket.emit('join_event', excuteOptions["body"]);
                            botExcute = yield botRequest(excuteOptions);
                            return { info: 'success', status: 0, data: output };
                        }
                        else {
                            return { info: 'success', status: 0, data: output };
                        }
                    }
                    yield chatSocket.emit('join_event', excuteOptions["body"]);
                    botExcute = yield botRequest(excuteOptions);
                    if (input.waitForExecution && ["true", true].includes(input.waitForExecution)) {
                        let updateDoc = yield event_1.event.update({ "_id": ObjectId(input.eventId) }, { inProgressBotId: botId });
                        output['waitForExecution'] = true;
                        console.log(updateDoc);
                    }
                    if (botExcute.status == 0) {
                        return { info: 'success', status: 0, data: output };
                    }
                    else {
                        return { info: 'success', status: 1, data: output };
                    }
                }
                else {
                    return { info: 'success', status: 1, data: output };
                }
            }
            catch (e) {
                console.log('errrr------->', e);
                return { info: 'Internal Server Error', status: 1, data: e };
            }
        });
    }
    triggerProcesswithVariables(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const botRequest = require("request-promise");
            try {
                console.info(" ---- INPUT ---- ", input);
                let additionalInfo = input.additionalInfo;
                input.orgId = input.orgId;
                const count = yield event_1.event.find({
                    projectId: ObjectId(input.projectId), isDeleted: false,
                    subscriberId: ObjectId(input.subscriberId),
                }).count();
                console.info("-- AFTER COUNT EXTRACTION ---- ");
                let date = new Date();
                let dateConcate = date.getFullYear().toString() + (date.getMonth() + 1).toString() + date.getDate().toString();
                let token = yield this.createToken(input.userId, input.subscriberId, input.orgId);
                console.info(" --- AFTER TOKEN CREATION ----");
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                console.info(" -- BEFORE ADD TASK OPTIONS ---- ");
                let options = {
                    "method": 'POST',
                    "url": env_2.env.routes.gibots_orch + "event/add/task",
                    "body": {
                        'additionalInfo': [],
                        'customerId': "5b8fd401b3930517f134c569",
                        'projectId': input.projectId,
                        'projectName': input.projectName,
                        'taskDesc': "",
                        'taskTemplateName': null,
                        'taskTitle': dateConcate + '_' + input.projectName.substring(0, 1) + '_' + count,
                        'token': input.projectName.substring(0, 1) + '_' + count,
                        'username': input.userName,
                        'isBot': true
                    },
                    "headers": {
                        'authorization': 'Bearer ' + token,
                        'Content-Type': "application/json",
                        "selectedorgid": input.orgId,
                        "selectedgstin": "123456789876543"
                    },
                    json: true
                };
                let botResult = yield botRequest(options);
                console.info(" -- AFTER CREATION TASK ---- ", botResult);
                if (botResult.status == 0) {
                    const newEvent = yield event_1.event.findById(botResult.data._id);
                    let newObj = JSON.parse(JSON.stringify(newEvent));
                    let newVariable;
                    let taskVar = Object.keys(additionalInfo);
                    taskVar.forEach(item => {
                        newVariable = newEvent['variableList'].map(el => {
                            if (el.name === item) {
                                el.value = additionalInfo[item];
                            }
                            return el;
                        });
                    });
                    newObj['variableList'] = newVariable;
                    taskVar.forEach(item => {
                        newObj['additionalInfoVar'][item] = additionalInfo[item];
                    });
                    const updateDoc = yield event_1.event.update({ "_id": ObjectId(newEvent._id) }, newObj);
                    console.log(updateDoc);
                    output["taskId"] = botResult.data._id;
                    output["processId"] = botResult.data.processId;
                    output["projectId"] = botResult.data.projectId;
                    let excuteOptions = {
                        "method": 'POST',
                        "url": env_2.env.routes.gibots_orch + "orchestrator/executeProject",
                        "body": {
                            "from": "join_event",
                            'projectId': input.projectId,
                            "eventId": botResult.data._id
                        },
                        "headers": {
                            'authorization': 'Bearer ' + token,
                            'Content-Type': "application/json",
                            "selectedorgid": input.orgId,
                            "selectedgstin": "123456789876543"
                        },
                        json: true
                    };
                    console.log("Executing API-------", options);
                    let botExcute;
                    botExcute = yield botRequest(excuteOptions);
                    if (botExcute.status == 0) {
                        return { info: 'success', status: 0, data: botExcute };
                    }
                    else {
                        return { info: 'success', status: 1, data: output };
                    }
                }
                else {
                    return { info: 'success', status: 1, data: output };
                }
            }
            catch (e) {
                console.log('errrr------->', e);
                return { info: 'Internal Server Error', status: 1, data: e };
            }
        });
    }
    updateEventStatus(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                ////////////////////////////////////////////////////////////////
                const InvoiceDetails = yield (db.collection('Invoice_Document')).findOne({ referenceNumber: input.referenceNumber });
                let InvoiceDetailsParsed = JSON.parse(JSON.stringify(InvoiceDetails));
                ///////////////////////////////////////////////////////////////
                let taskD = yield event_1.event.findOne({ 'additionalInfoVar.ref_no': input.referenceNumber, projectId: ObjectId("623d891574eeea38268bc8d6") });
                let task = JSON.parse(JSON.stringify(taskD));
                for (let index = 0; index < task.variableList.length; index++) {
                    const element = task.variableList[index];
                    if (element['name'] == 'Invoice_Status') {
                        element['value'] = "Inserted";
                    }
                    if (element['name'] == 'Invoice_Date') {
                        element['value'] = InvoiceDetailsParsed['Invoice_Date'];
                    }
                    if (element['name'] == 'Vendor_Name') {
                        element['value'] = InvoiceDetailsParsed['Vendor_Name'];
                    }
                    if (element['name'] == 'Invoice_Total') {
                        element['value'] = InvoiceDetailsParsed['Invoice_Total'];
                    }
                }
                yield event_1.event.updateOne({ '_id': ObjectId(task._id) }, {
                    $set: {
                        eventStatus: 'Completed', 'additionalInfoVar.Invoice_Status': "Inserted",
                        'additionalInfoVar.Invoice_Date': InvoiceDetailsParsed['Invoice_Date'], 'additionalInfoVar.Vendor_Name': InvoiceDetailsParsed['Vendor_Name'],
                        'additionalInfoVar.Invoice_Total': InvoiceDetailsParsed['Invoice_Total'], 'additionalInfoVar.Invoice_Number': InvoiceDetailsParsed['Invoice_Number'], variableList: task.variableList
                    }
                });
                let eventStatusD = yield eventStatus_1.eventStatus.find({ $or: [{ eventId: task._id }, { parentEventId: task._id }, { eventId: task._id }], isDeleted: false, orchestratorStatus: "inProgress", projectId: ObjectId(task.projectId) });
                for (let index = 0; index < eventStatusD.length; index++) {
                    const element = eventStatusD[index];
                    for (const itemInner of element['assignToList']) {
                        itemInner.orchestratorStatus = "Complete";
                    }
                    let queryCurrentBotD = { $or: [{ eventId: task._id }, { parentEventId: task._id }, { eventId: task._id }], isDeleted: false, botId: element['botId'], projectId: ObjectId(task.projectId) };
                    yield eventStatus_1.eventStatus.updateOne(queryCurrentBotD, { $set: { 'assignToList': element['assignToList'], orchestratorStatus: "Complete", completeTime: new Date() } });
                    let queryCurrentBotDEnd = { $or: [{ eventId: task._id }, { parentEventId: task._id }, { eventId: task._id }], isDeleted: false, isEnd: true, projectId: ObjectId(task.projectId) };
                    yield eventStatus_1.eventStatus.updateOne(queryCurrentBotDEnd, { $set: { orchestratorStatus: "Complete", completeTime: new Date() } });
                }
                return { message: 'updated succesfully.', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "something went wrong", status: 1, data: err };
            }
        });
    }
    uploadfilesFromLocal(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const crypto = require('crypto');
                let algorithm = config.crypto.Alogo;
                let key = config.crypto.key;
                let IV = config.crypto.IV;
                let sObj = {
                    host: input.host,
                    port: input.port,
                    username: input.username,
                    password: input.password,
                };
                let cipher = crypto.createCipheriv(algorithm, key, IV);
                let encrypted = cipher.update(JSON.stringify(sObj), 'utf8', 'base64');
                encrypted += cipher.final('base64');
                let orgD = yield (db.collection('organisations')).findById(input.orgId).lean();
                orgD = JSON.parse(JSON.stringify(orgD));
                let obj = {
                    "src": input.srcLocation,
                    "dest": input.destLocation,
                    "serverCred": encrypted,
                    'orgId': input.orgId,
                    'orgName': orgD.name,
                    'subscriberId': input.subscriberId,
                    'userId': input.userId,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'uploadfilesFromLocal',
                    "accessControlList": input.accessControlList
                };
                console.log('input--->', obj);
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("xmlfile is at given folder path.");
                return { message: 'xmlfile is at given folder path.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("Error in Socket triggering to give excel file path." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    fetch_ledger_tally_categorywise_new(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "ledgers": input.ledgers,
                    "costcentres": input.costcentres,
                    //"XML": input.XML,
                    //"data": input.data,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'fetch_ledger_tally_categorywise_new',
                    "orgName": input.orgName,
                    // "userId": input.userId,
                    //"accessControlList": input.accessControlList
                    "accessControlList": input.accessControlList
                };
                console.log(obj);
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Ledger id fetched from tally.");
                return { message: 'Ledger id fetched from tally.', status: 0, data: obj };
            }
            catch (e) {
                this.log.error("There is error" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    apiBot(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let method = input.method.toUpperCase();
                let url = input.url;
                let rawHeader = input.headers;
                let body;
                let headers;
                if (!util_1.isNullOrUndefined(input.headers) && (input.headers != "")) {
                    if (typeof rawHeader === "string") {
                        headers = JSON.parse(rawHeader);
                    }
                    else {
                        headers = rawHeader;
                    }
                    // console.log(headers)
                }
                if (!util_1.isNullOrUndefined(input.body) && (input.body != "")) {
                    body = JSON.parse(input.body);
                }
                if ((!util_1.isNullOrUndefined(input.headerKey) && (input.headerKey != ""))) {
                    if ((!util_1.isNullOrUndefined(input.headerValue) && (input.headerValue != ""))) {
                        headers[input.headerKey] = input.headerValue;
                    }
                }
                let options = {
                    method: method,
                    url: url,
                    headers: headers,
                    body: body,
                    json: true
                };
                // console.log(options)
                // console.log(JSON.stringify(options))
                let resp;
                function doRequest() {
                    return new Promise(function (resolve, reject) {
                        request(options, function (error, res, body) {
                            // console.log("ERROR", error)
                            // console.log("RES.statusCode", res.statusCode)
                            if (error || res.statusCode != 200) {
                                // reject(error)
                                abc(error);
                            }
                            resolve(res);
                        });
                    });
                }
                function main() {
                    return tslib_2.__awaiter(this, void 0, void 0, function* () {
                        resp = yield doRequest();
                        Promise.resolve();
                    });
                }
                yield main();
                outputParameters['response'] = resp.statusCode;
                // console.log(outputParameters['response']);
                let re = /\s*([^{:|^,:]+):/g;
                let objToString;
                if (!util_1.isNullOrUndefined(resp.body)) {
                    objToString = JSON.stringify(resp.body);
                }
                let m;
                do {
                    m = re.exec(objToString);
                    if (m) {
                        objToString = objToString.replace(m[0], m[0].replace(/\./g, '_'));
                    }
                } while (m);
                objToString = JSON.parse(objToString);
                if (input.outputKey != "") {
                    outputParameters['outputBody'] = objToString[input.outputKey];
                    // console.log(outputParameters['outputBody']);
                    // console.log(resp.body[input.outputKey]);
                }
                else {
                    outputParameters['outputBody'] = objToString;
                }
                function abc(error) {
                    this.log.error("api is not working error occured check input parameters.");
                    return { message: "error while running request check input parameters", status: 1, data: error };
                }
                if (resp.statusCode == 200) {
                    outputParameters['error'] = 'null';
                    // console.log(outputParameters['error'])
                    this.log.info("api is working.");
                    return { message: 'api working.', status: 0, data: outputParameters };
                }
                else {
                    outputParameters['error'] = resp;
                    this.log.error("api is not working");
                    return { message: "api is not working", status: 1, data: outputParameters };
                }
            }
            catch (e) {
                this.log.error("Error in api information." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    keywordSearchBot(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            //parsedData is the line by line pdf parser output
            let jsonlinebyline = input.jsonFile;
            let bagsOfMatchWords = Object.keys(JSON.parse(input.BagOfMapWords));
            let bagsOfMatchKeysValue = Object.values(JSON.parse(input.BagOfMapWords));
            let isMatchKey = [];
            let totalValue = 0;
            jsonlinebyline.forEach((ele, i) => {
                bagsOfMatchWords.forEach((row, k) => {
                    let regex = new RegExp(row, 'ig');
                    if (regex.test(ele.text)) {
                        if (!util_1.isNullOrUndefined(isMatchKey) && isMatchKey.length > 0 && isMatchKey.indexOf(row) > -1) {
                            console.log(row);
                        }
                        else {
                            isMatchKey.push(row);
                        }
                        if (Array.isArray(bagsOfMatchKeysValue[k])) {
                            if (/[\d]/ig.test(ele.text)) {
                                if ((!util_1.isNullOrUndefined(/([\d,]+)/gm.exec(jsonlinebyline[i + 1].text)) && /([\d,]+)/gm.exec(jsonlinebyline[i + 1].text) != null && totalValue !== Number(/([\d,]+)/gm.exec(jsonlinebyline[i + 1].text)[0].replace(/\,/g, ""))) || (!util_1.isNullOrUndefined(/([\d,]+)/gm.exec(ele.text)) && /([\d,]+)/gm.exec(ele.text) !== null && totalValue !== Number(/([\d,]+)/gm.exec(ele.text)[0].replace(/\,/g, "")))) {
                                    if (!util_1.isNullOrUndefined(/([\d,]+)/gm.exec(jsonlinebyline[i + 1].text)) && totalValue < Number(/([\d,]+)/gm.exec(jsonlinebyline[i + 1].text)[0].replace(/\,/g, ""))) {
                                        totalValue = Number(/([\d,]+)/gm.exec(jsonlinebyline[i + 1].text)[0].replace(/\,/g, ""));
                                    }
                                    else {
                                        if (totalValue < Number(/([\d,]+)/gm.exec(ele.text)[0].replace(/\,/g, ""))) {
                                            totalValue = Number(/([\d,]+)/gm.exec(ele.text)[0].replace(/\,/g, ""));
                                        }
                                        else {
                                            totalValue = /([\d,]+)/gm.test(ele.text) && !util_1.isNullOrUndefined(/([\d,]+)/gm.exec(jsonlinebyline[i + 1].text)) ? totalValue + Number(/([\d,]+)/gm.exec(ele.text)[0].replace(/\,/g, "")) + Number(/([\d,]+)/gm.exec(jsonlinebyline[i + 1].text)[0].replace(/\,/g, "")) : totalValue + Number(/([\d,]+)/gm.exec(ele.text)[0].replace(/\,/g, ""));
                                            totalValue = !/([\d,]+)/gm.test(ele.text) && ele.text.includes(row) && !util_1.isNullOrUndefined(/([\d,]+)/gm.exec(jsonlinebyline[i + 1].text)) ? totalValue + Number(/([\d,]+)/gm.exec(jsonlinebyline[i + 1].text)[0].replace(/\,/g, "")) : totalValue;
                                        }
                                    }
                                }
                            }
                        }
                    }
                });
            });
            console.log(totalValue);
            console.log(isMatchKey);
            if (isMatchKey.length > 1) {
                output["result"] = "Exception";
                output["value"] = "NA";
            }
            else {
                if (isMatchKey.length > 0) {
                    if (totalValue > 5000000) {
                        output["result"] = bagsOfMatchKeysValue[bagsOfMatchWords.indexOf(isMatchKey[0])][0];
                        output["value"] = isMatchKey[0];
                    }
                    else if ((totalValue != 0) && (totalValue < 5000000)) {
                        output["result"] = bagsOfMatchKeysValue[bagsOfMatchWords.indexOf(isMatchKey[0])][1];
                        output["value"] = isMatchKey[0];
                    }
                    else {
                        if (!Array.isArray(bagsOfMatchKeysValue[bagsOfMatchWords.indexOf(isMatchKey[0])]) && !util_1.isNullOrUndefined(bagsOfMatchKeysValue[bagsOfMatchWords.indexOf(isMatchKey[0])])) {
                            output["result"] = bagsOfMatchKeysValue[bagsOfMatchWords.indexOf(isMatchKey[0])];
                            output["value"] = isMatchKey[0];
                        }
                        else {
                            output["result"] = "Default",
                                output["value"] = "NA";
                        }
                    }
                }
                else {
                    if (isMatchKey.length == 0) {
                        output["result"] = "Default",
                            output["value"] = "NA";
                    }
                    return { info: 'keyword does not exists', status: 1, data: output };
                }
            }
            return { info: 'keyword exists', status: 0, data: output };
        });
    }
    //////////////////////////////////////////////////////////////////////////////////////////
    getKeyValue(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log(input, "anubhavinput");
                let filePath = input.filePath;
                let imagePath = [];
                imagePath.push({ imageFilePath: filePath });
                outputParameters['imageFilePath'] = imagePath;
                this.log.info("key value done.");
                return { message: 'key value done.', status: 0, data: outputParameters };
            }
            catch (e) {
                this.log.error("Error." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    invoiceMapper(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log("inside invoice mapper", JSON.stringify(input));
                let blankPath = [];
                if (!util_1.isNullOrUndefined(input.blankPath) && input.blankPath != "") {
                    blankPath.push(input.blankPath);
                    console.log("blankpath ==============", input.blankPath, "////////", blankPath);
                }
                //let blankPath = ["/home/gibots/ExcelPDF/excelinvoice.pdf"];
                if (!util_1.isNullOrUndefined(input.jsonArray) && !util_1.isNullOrUndefined(input.filePathArray) && !util_1.isNullOrUndefined(input.mapKey)) {
                    if (input.filePathArray.length > 0) {
                        let fileExists = false;
                        input.filePathArray.forEach(element => {
                            let fileArray = element.split("/");
                            let invoiceNo = fileArray[fileArray.length - 1].split("_");
                            console.log("invoice number", invoiceNo[0]);
                            console.log("---json array---invoice num-----", input.jsonArray[iterationId][input.mapKey]);
                            if (invoiceNo[0] == input.jsonArray[iterationId][input.mapKey]) {
                                let temp = [];
                                fileExists = true;
                                temp.push(element);
                                outputParameters['invoiceFilePath'] = JSON.stringify(temp);
                                outputParameters['invoiceObject'] = input.jsonArray[iterationId];
                            }
                        });
                        if (!fileExists) {
                            outputParameters['invoiceFilePath'] = JSON.stringify(blankPath);
                            outputParameters['invoiceObject'] = input.jsonArray[iterationId];
                        }
                    }
                    else {
                        outputParameters['invoiceFilePath'] = JSON.stringify(blankPath);
                        outputParameters['invoiceObject'] = input.jsonArray[iterationId];
                    }
                }
                console.log("///////-- filepath --//////", outputParameters);
                return ({ message: 'type of invoice found', status: 0, data: outputParameters });
            }
            catch (e) {
                this.log.error("type of invoice found with filepath ." + e);
                return { message: "type of invoice not found with filepath .", status: 1, data: e };
            }
        });
    }
    customPathExtensionfilter(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let extension;
                outputParameters["filePathArray"] = [];
                if (!util_1.isNullOrUndefined(input.filterArray) && (!util_1.isNullOrUndefined(input.extension)) && (input.filterArray.length > 0) && (input.extension !== "")) {
                    input.filterArray.forEach(element => {
                        extension = path.extname(element);
                        if (input.extension == extension) {
                            outputParameters["filePathArray"].push(element);
                            outputParameters["filepathArraylength"] = outputParameters.filePathArray.length > 1 ? 'true' : 'false';
                        }
                    });
                }
                else {
                    outputParameters["filepathArraylength"] = false;
                }
                console.log("custom path extension filter", outputParameters);
                return ({ message: 'type of extension found', status: 0, data: outputParameters });
            }
            catch (e) {
                this.log.error("type of extension not found ." + e);
                return { message: "type of extension not found .", status: 1, data: e };
            }
        });
    }
    wordParser(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let filePath = input.filePath;
                let arrayOutput = [];
                return new Promise((resolve, reject) => {
                    parser(filePath, function (resultList) {
                        let lineStr = "";
                        for (let i = 0; i < resultList.length; i++) {
                            lineStr += resultList[i];
                            arrayOutput.push({ 'line': resultList[i] });
                        }
                        outputParameters['lineString'] = lineStr;
                        outputParameters['lineArray'] = arrayOutput;
                        resolve({ message: 'word file readed successfully.', status: 0, data: outputParameters });
                    });
                });
            }
            catch (e) {
                this.log.error("Error in reading word file." + e);
                return { message: "Error in reading word file.", status: 1, data: e };
            }
        });
    }
    pdfParserJavaInvoicePageWise(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            console.log("In new pdfParserJava, FileName==" + input.PDF_PATH);
            try {
                // let arr=[{imageFilePath:input.PDF_PATH}];
                // input.PDF_PATH=arr;
                let PDF_PATH1 = [];
                let self = this;
                if (!util_1.isNullOrUndefined(input.PDF_PATH) && typeof input.PDF_PATH == 'string') {
                    PDF_PATH1 = JSON.parse(input.PDF_PATH);
                }
                else {
                    PDF_PATH1 = input.PDF_PATH;
                }
                let pdfParserOutput = [];
                console.log("PDF path", PDF_PATH1, "---- TYPE OF -------- >> ", typeof PDF_PATH1);
                return yield new Promise((resolve, reject) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    if (Array.isArray(PDF_PATH1)) {
                        console.info(" < ---- ----- INSIDE PDF_PATH ARRAY BEFORE ARRAY -------- -------- >> ");
                        for (let index = 0; index < PDF_PATH1.length; index++) {
                            let PDF_PATH = PDF_PATH1[index]['imageFilePath'];
                            console.info(" < ---- ----- INSIDE PDF_PATH ARRAY INSIDE ARRAY -------- -------- >> ", PDF_PATH, " ---- INDEX ---", index);
                            //let renamedPATH = PDF_PATH.replace(/[ !@#$%^&*()<>~{}?|]/g, '');
                            //console.log(renamedPATH);
                            //fs.renameSync(PDF_PATH, renamedPATH);
                            let randomNo = Math.floor(Math.random() * 10000);
                            let randomString = randomNo.toString();
                            console.log(randomNo, randomString);
                            let javaJsonFolder = env_2.env.fileConfig.javaJsonFolder; //"../javaJsonFolder/";
                            if (!fs.existsSync(javaJsonFolder)) {
                                fs.mkdirSync(javaJsonFolder);
                            }
                            console.log(javaJsonFolder);
                            // let aa = PDF_PATH.lastIndexOf('.')
                            console.info(" < ---- ----- INSIDE PDF_PATH ARRAY INSIDE ARRAY -------- -------- >> ", javaJsonFolder, " ---- INDEX ---", index);
                            let jsonFileName = PDF_PATH.substring(PDF_PATH.lastIndexOf('/') + 1) + ".json";
                            let finalJsonPath = javaJsonFolder + randomString + jsonFileName;
                            console.log(jsonFileName);
                            console.log(finalJsonPath);
                            //let jsonPath = "../../../../../.." + jsonFileName;
                            //console.log(process.cwd());
                            //let repoRootPath = process.cwd();
                            //let jsonPath = repoRootPath.substring(0, repoRootPath.lastIndexOf('/'));
                            let inputObj = {
                                "finalJsonPath": finalJsonPath,
                                "pdfPath": PDF_PATH,
                                "isType": ""
                            };
                            let parameters = JSON.stringify(JSON.stringify(inputObj));
                            let res = yield self.sh("java -cp .:json-20190722.jar:pdfbox-2.0.3.jar:fontbox-2.0.3.jar:commons-logging-1.2.jar:json-simple-1.1.1.jar:jbig2-imageio-3.0.0.jar:itextpdf-5.5.13.1.jar:kernel-7.1.12.jar:io-7.1.12.jar:layout-7.1.12.jar:slf4j-api-1.7.30.jar:slf4j-simple-1.7.30.jar:commons-lang3-3.11.jar GetPdfData " + parameters);
                            if (!util_1.isNullOrUndefined(res)) {
                                console.log("res[status]---->>", res);
                                if (res['status'] == 1 && !util_1.isNullOrUndefined(res['err']) && !util_1.isNullOrUndefined(res['err']['message']) && res['err']['message'].includes('Command failed')) {
                                    console.log("res[status]-in If  --->>", res['status']);
                                    yield self.sleep(120000);
                                    res = yield self.sh("java -cp .:json-20190722.jar:pdfbox-2.0.3.jar:fontbox-2.0.3.jar:commons-logging-1.2.jar:json-simple-1.1.1.jar:jbig2-imageio-3.0.0.jar:itextpdf-5.5.13.1.jar:kernel-7.1.12.jar:io-7.1.12.jar:layout-7.1.12.jar:slf4j-api-1.7.30.jar:slf4j-simple-1.7.30.jar:commons-lang3-3.11.jar GetPdfData " + parameters);
                                    if (res['status'] == 1 && !util_1.isNullOrUndefined(res['err']) && !util_1.isNullOrUndefined(res['err']['message']) && res['err']['message'].includes('Command failed')) {
                                        output['data'] = JSON.stringify(res) + 'Seems some issue while reading the PDF' + PDF_PATH;
                                        output['curruptFile'] = true;
                                        resolve({ message: res['err'] + PDF_PATH, status: 1, data: output });
                                    }
                                }
                                let finalArray;
                                if (fs.existsSync(finalJsonPath)) {
                                    finalArray = JSON.parse(fs.readFileSync(finalJsonPath, { encoding: 'utf8' }));
                                }
                                else {
                                    console.log("Error while reading JSON file!");
                                }
                                finalArray = finalArray.filter(obj => obj.line.trim() != '');
                                let rs = yield self.extractImages(finalArray, PDF_PATH);
                                console.info(" < ---- ----- INSIDE PDF_PATH ARRAY INSIDE ARRAY -------- -------- >> ", rs, " ---- INDEX ---", index);
                                if (rs['status'] == 1) {
                                    // resolve({ message: rs['err'] + PDF_PATH, status: 1, data: rs['data'] });
                                }
                                pdfParserOutput.push(finalArray);
                                // console.log("output-->", index, finalArray);
                                //output['output'] = finalArray;
                                //resolve({ message: "Process  sucessfully completed", status: 0, data: output });
                                self.log.info("pdf read successfully.");
                                // return { message: 'pdf readed successfully.', status: 0, data: output };
                            }
                        }
                        output['output'] = pdfParserOutput;
                        console.info(" < ---- ----- BEFORE PDF_PATH ARRAY INSIDE ARRAY RESOLVE -------- -------- >> ", output);
                        resolve({ message: "Process  sucessfully completed", status: 0, data: output });
                    }
                    else {
                        resolve({ message: "PDF_PATH is NOT in ARRAY", status: 1, data: "PDF_PATH is NOT in ARRAY" });
                    }
                }));
            }
            catch (err) {
                // console.log("Error!!! -> " + err);
                this.log.info("pdf not readed successfully.");
                return { message: err, status: 1, data: err };
            }
        });
    }
    sleep(ms) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                setTimeout(resolve, ms);
            });
        });
    }
    // public async getImages(input, output, botId, projectId, iterationId) {
    //     input.PDF_PATH="/home/user/Videos/inputPdfs/DN 1303 - Emp ID 703.pdf"
    //     console.log("In new pdfParserJava, FileName==" + input.PDF_PATH);
    //     // let TableArray=[];
    //     // let images = await this.extractImages(TableArray,input);
    //     // output['images']=images;
    //     output['path']=input.PDF_PATH;
    //     return { message: "Process  sucessfully completed", status: 0, data: output };
    //     try {
    //     } catch(err){
    //         this.log.info("pdf not readed successfully.");
    //         return { message: err, status: 1, data: err };
    //     }
    // }
    checkPDFIssues(finalArray, imageArray) {
        try {
            let fullImage = false;
            if (finalArray.length > 0) {
                let pageWidth = finalArray[0].pageWidth * 4.1666666;
                let pageHeight = finalArray[0].pageHeight * 4.1666666;
                let npWidth = finalArray[0].pageWidth;
                let npHeight = finalArray[0].pageHeight;
                for (let i = 0, limg = imageArray.length; i < limg; i++) {
                    if (Math.abs(imageArray[i].height - pageHeight) < 10 && Math.abs(imageArray[i].width - pageWidth) < 10) {
                        fullImage = true;
                        break;
                    }
                    if (Math.abs(imageArray[i].yScale - npHeight) < 10 && Math.abs(imageArray[i].xScale - npWidth) < 10) {
                        fullImage = true;
                        break;
                    }
                }
                if (fullImage) {
                    return { status: 0, imageFlow: true };
                }
                else {
                    return { status: 1, imageFlow: false };
                }
            }
            else {
                return { status: 0, imageFlow: true };
            }
        }
        catch (e) {
            console.log("checkPDFIssues exception: ", e);
            return { status: 1, imageFlow: false };
        }
    }
    splitterBot(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                for (let i = 0; i < input.splitConfig.length; i++) {
                    let ele = input.splitConfig[i];
                    // console.log("hiiii",ele);
                    for (let index = 0; index < ele.startWords.length; index++) {
                        let element = ele.startWords[index];
                        ele.startWords[index] = element.replace(/[^a-z]/gi, '');
                    }
                    for (let index = 0; index < ele.endWords.length; index++) {
                        let element = ele.endWords[index];
                        ele.endWords[index] = element.replace(/[^a-z]/gi, '');
                    }
                }
                let splitData = [];
                for (let i = 0; i < input.data.length; i++) {
                    let element = input.data[i];
                    let startFound = false;
                    let endFound = false;
                    for (let j = 0; j < element['lineWithCombineWords'].length; j++) {
                        let line = element['lineWithCombineWords'][j];
                        for (let k = 0; k < line.length; k++) {
                            let lineObj = JSON.parse(JSON.stringify(line[k]));
                            lineObj['Name'] = lineObj['Name'].replace(/[^a-z]/gi, '');
                            for (let l = 0; l < input.splitConfig.length; l++) {
                                let ele = input.splitConfig[l];
                                if (ele.startWords.indexOf(lineObj['Name'].toLowerCase()) > -1) {
                                    startFound = true;
                                }
                                if (ele.endWords.indexOf(lineObj['Name'].toLowerCase()) > -1 && startFound) {
                                    endFound = true;
                                }
                                if (startFound && endFound) {
                                    // console.log(lineObj,"--",i);
                                    let obj = {
                                        docType: ele.docType,
                                        filepath: element['obj']['filePath'],
                                        pageNo: i
                                    };
                                    splitData.push(obj);
                                    // outputParameters['splitData'].push(obj);
                                    startFound = false;
                                    endFound = false;
                                }
                            }
                        }
                    }
                }
                outputParameters['splitData'] = splitData;
                outputParameters['data'] = input.data;
                this.log.info("Files Moved---");
                return { message: "server folder cleaned.", status: 0, data: outputParameters };
            }
            catch (e) {
                this.log.error("Error while moving file ---" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    filterBot(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let pageNumbers = [];
                for (let index = 0; index < input.splitData.length; index++) {
                    let element = input.splitData[index];
                    pageNumbers.push(element.pageNo);
                }
                if (input.splitData.length > 0) {
                    input.data = input.data.filter((row, i) => {
                        if (pageNumbers.indexOf(i) > -1) {
                            return row;
                        }
                    });
                }
                outputParameters['data'] = input.data;
                this.log.info("Files Moved---");
                return { message: "server folder cleaned.", status: 0, data: outputParameters };
            }
            catch (e) {
                this.log.error("Error while moving file ---" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    extractReceiptInfo(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // let receiptData = {};
                let poArr = [];
                let receiptArr = [];
                let po_no, receipt_no;
                for (let i = 0; i < input.data.length; i++) {
                    let element = input.data[i];
                    for (let j = 0; j < element['lineWithCombineWords'].length; j++) {
                        let line = element['lineWithCombineWords'][j];
                        for (let k = 0; k < line.length; k++) {
                            let lineObj = JSON.parse(JSON.stringify(line[k]));
                            lineObj['Name'] = lineObj['Name'].replace(/[^a-z]/gi, '');
                            if (["receiptno", "receipt"].indexOf(lineObj['Name'].toLocaleLowerCase()) > -1) {
                                if (line[k + 1]) {
                                    receipt_no = line[k + 1]['Name'];
                                    receipt_no = line[k + 1]['Name'].replace(/[^0-9]/gi, '');
                                }
                                else {
                                    if (j > 0 && element['lineWithCombineWords'][j - 1][element['lineWithCombineWords'][j - 1].length - 1] && /^\d+$/.test(element['lineWithCombineWords'][j - 1][element['lineWithCombineWords'][j - 1].length - 1]['Name'])) {
                                        receipt_no = element['lineWithCombineWords'][j - 1][element['lineWithCombineWords'][j - 1].length - 1]['Name'];
                                    }
                                }
                                if (receipt_no != "") {
                                    receiptArr.push(receipt_no);
                                }
                            }
                            if (lineObj['Name'].toLocaleLowerCase() == "pono" || /po/.test(lineObj['Name'].toLocaleLowerCase()) || /pono/.test(lineObj['Name'].toLocaleLowerCase()) || /pno/.test(lineObj['Name'].toLocaleLowerCase())) {
                                if (/\d$/.test(line[k]['Name'])) {
                                    po_no = line[k]['Name'].replace(/[^0-9]/gi, '');
                                    if (/^0/.test(po_no)) {
                                        po_no = po_no.substring(1);
                                    }
                                }
                                else if (line[k + 1]) {
                                    po_no = line[k + 1]['Name'].replace(/[^0-9]/gi, '');
                                }
                                if (/\d/.test(po_no)) {
                                    poArr.push(po_no);
                                }
                            }
                        }
                    }
                }
                // outputParameters['receiptData'] = receiptData;
                outputParameters['poArr'] = poArr;
                outputParameters['receiptArr'] = receiptArr;
                return { message: "server folder cleaned.", status: 0, data: outputParameters };
            }
            catch (e) {
                this.log.error("Error while moving file ---" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    threeWayReconciliationN(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let po = [], inv = [], rc = [];
                let masterReconciliation = [];
                this.log.info('Inside prepare reconciliation');
                let docType = input.docType;
                let invRef = input.inv_ref_no;
                let poRef = input.poArr;
                let receiptRef = input.receiptArr;
                let matchKey = input.matchKey ? input.matchKey : "Description";
                let rateKey = input.rateKey ? input.rateKey : "Rate";
                let qtyKey = input.qtyKey ? input.qtyKey : "Quantity";
                let amtKey = input.amtKey ? input.amtKey : "Amount";
                console.log("Input ---", input, matchKey, rateKey, qtyKey, amtKey);
                let invoiceData = yield (db.collection(docType)).findOne({ referenceNumber: invRef }).lean();
                // let poData = await (db.collection(docType)).findOne({ referenceNumber: poRef }).lean();
                let receiptData = {
                    receiptNumber: "",
                    invoiceItems: []
                };
                let poData = {
                    poNumber: "",
                    invoiceItems: []
                };
                let receiptDataDB = yield (db.collection('receiptinfos')).find({ "receiptNumber": { $in: receiptRef } }).lean();
                let poDataDB = yield (db.collection('poinfos')).find({ "poNumber": { $in: poRef } }).lean();
                if (!util_1.isNullOrUndefined(receiptDataDB) && receiptDataDB.length > 0) {
                    for (let index = 0; index < receiptDataDB.length; index++) {
                        let invoiceItems = receiptDataDB[index]['invoiceItems'];
                        for (let j = 0; j < invoiceItems.length; j++) {
                            invoiceItems[j]['receiptNumber'] = receiptDataDB[index]['receiptNumber'];
                            if (invoiceItems[j]['UOM'] && invoiceItems[j]['UOM'].toLowerCase() == "thousands") {
                                invoiceItems[j]['Quantity'] = String(Number(invoiceItems[j]['Quantity']) * 1000);
                            }
                        }
                    }
                    for (let index = 0; index < receiptDataDB.length; index++) {
                        let element = receiptDataDB[index];
                        receiptData['invoiceItems'] = receiptData['invoiceItems'].concat(element['invoiceItems']);
                        receiptData['receiptNumber'] = receiptData['receiptNumber'] + " , " + element['receiptNumber'];
                    }
                }
                if (!util_1.isNullOrUndefined(poDataDB) && poDataDB.length > 0) {
                    for (let index = 0; index < poDataDB.length; index++) {
                        let invoiceItems = poDataDB[index]['invoiceItems'];
                        for (let j = 0; j < invoiceItems.length; j++) {
                            if (invoiceItems[j]['UOM'] && invoiceItems[j]['UOM'].toLowerCase() == "thousands") {
                                invoiceItems[j]['Quantity'] = String(Number(invoiceItems[j]['Quantity']) * 1000);
                            }
                        }
                    }
                    for (let index = 0; index < poDataDB.length; index++) {
                        let element = poDataDB[index];
                        poData['invoiceItems'] = poData['invoiceItems'].concat(element['invoiceItems']);
                        poData['poNumber'] = element['poNumber'];
                    }
                }
                console.log("poInvNumData", poData);
                let invNo = invoiceData.Invoice_Number;
                let poNo = poData['poNumber'];
                let receiptNo = receiptData['receiptNumber'];
                console.log("Invoice No---", invNo, " PO No-----", poNo, "receipt no", receiptNo);
                po = JSON.parse(JSON.stringify(poData['invoiceItems']));
                inv = JSON.parse(JSON.stringify(invoiceData['invoiceItems']));
                rc = JSON.parse(JSON.stringify(receiptData['invoiceItems']));
                let tempInv = JSON.parse(JSON.stringify(invoiceData['invoiceItems']));
                let tempPo = JSON.parse(JSON.stringify(poData['invoiceItems']));
                // let DcData = await (db.collection(docType)).findOne({ isGrn: true, Invoice_Number: invNo }).lean();
                let rObj = {};
                rc.forEach((element) => {
                    let data = {};
                    let invRec = tempInv.find((invRow) => {
                        return element[matchKey].toLowerCase().trim() == invRow[matchKey].toLowerCase().trim() || element[matchKey].toLowerCase().trim().includes(invRow[matchKey].toLowerCase().trim()) || invRow[matchKey].toLowerCase().trim().includes(element[matchKey].toLowerCase().trim());
                    });
                    if (util_1.isNullOrUndefined(invRec) && element[matchKey] && tempInv.length) {
                        let mats = tempInv.map(a => a[matchKey].toLowerCase());
                        let match = stringSimilarity.findBestMatch(element[matchKey].toLowerCase(), mats);
                        console.log(`---------match -------`, element[matchKey].toLowerCase(), '------------', match);
                        if (match && match.ratings && match.ratings.length > 1) {
                            for (let i = 0; i < match.ratings.length; i++) {
                                let ele = match.ratings[i];
                                for (let j = 0; j < tempInv.length; j++) {
                                    let eleInner = tempInv[j];
                                    if (eleInner[matchKey].toLowerCase() == ele['target']) {
                                        if (element['Quantity'].replace(/[^0-9]/gi, '') == eleInner['Quantity'].replace(/[^0-9]/gi, '')) {
                                            match.bestMatchIndex = j;
                                        }
                                    }
                                }
                            }
                        }
                        console.log(`---------after match -------`, '------------', match);
                        if (!util_1.isNullOrUndefined(match.bestMatchIndex)) {
                            invRec = tempInv[match.bestMatchIndex];
                            tempInv.splice(match.bestMatchIndex, 1);
                        }
                    }
                    else {
                        tempInv = tempInv.filter(invRow => !(element[matchKey].toLowerCase().trim() == invRow[matchKey].toLowerCase().trim() || element[matchKey].toLowerCase().trim().includes(invRow[matchKey].toLowerCase().trim()) || invRow[matchKey].toLowerCase().trim().includes(element[matchKey].toLowerCase().trim())));
                    }
                    data['poNum'] = poData.poNumber;
                    data['invNum'] = invoiceData.Invoice_Number;
                    data['devNum'] = receiptNo;
                    data['receiptNumber'] = element['receiptNumber'];
                    rObj['poNum'] = poData.poNumber;
                    rObj['invNum'] = invoiceData.Invoice_Number;
                    rObj['devNum'] = receiptNo;
                    element[qtyKey] = element[qtyKey] ? element[qtyKey].replace(/,/g, '') : '';
                    element[rateKey] = element[rateKey] ? element[rateKey].replace(/,/g, '') : '';
                    element[amtKey] = element[amtKey] ? element[amtKey].replace(/,/g, '') : '';
                    if (invRec) {
                        data['productName'] = element[matchKey];
                        data['rproductName'] = invRec[matchKey];
                        data['rproductNameFlag'] = false;
                        inv = _.without(inv, _.findWhere(inv, { productName: invRec[matchKey] }));
                        element[qtyKey] = element[qtyKey] ? element[qtyKey].replace(/,/g, '') : '';
                        invRec[qtyKey] = invRec[qtyKey] ? invRec[qtyKey].replace(/,/g, '') : '';
                        element[rateKey] = element[rateKey] ? element[rateKey].replace(/,/g, '') : '';
                        invRec[rateKey] = invRec[rateKey] ? invRec[rateKey].replace(/,/g, '') : '';
                        element[amtKey] = element[amtKey] ? element[amtKey].replace(/,/g, '') : '';
                        invRec[amtKey] = invRec[amtKey] ? invRec[amtKey].replace(/,/g, '') : '';
                        if (element[qtyKey] == invRec[qtyKey] || (!isNaN(element[qtyKey]) && String(parseFloat(element[qtyKey])) == String(parseFloat(invRec[qtyKey])))) {
                            data['rqty'] = invRec[qtyKey];
                            data['qty'] = element[qtyKey];
                            data['rqtyFlag'] = false;
                        }
                        else {
                            data['rqty'] = invRec[qtyKey];
                            data['qty'] = element[qtyKey];
                            data['rqtyFlag'] = true;
                        }
                        if (element[rateKey] == invRec[rateKey] || (!isNaN(element[rateKey]) && String(parseFloat(element[rateKey])) == String(parseFloat(invRec[rateKey])))) {
                            data['rrate'] = invRec[rateKey];
                            data['rate'] = element[rateKey];
                            data['rrateFlag'] = false;
                        }
                        else {
                            data['rrate'] = invRec[rateKey];
                            data['rate'] = element[rateKey];
                            data['rrateFlag'] = true;
                        }
                        if (element[amtKey] == invRec[amtKey] || (!isNaN(element[amtKey]) && String(parseFloat(element[amtKey])) == String(parseFloat(invRec[amtKey])))) {
                            data['ritemAmt'] = invRec[amtKey];
                            data['itemAmt'] = element[amtKey];
                            data['ritemAmtFlag'] = false;
                        }
                        else {
                            data['ritemAmt'] = invRec[amtKey];
                            data['itemAmt'] = element[amtKey];
                            data['ritemAmtFlag'] = true;
                        }
                    }
                    else {
                        data['productName'] = element[matchKey];
                        data['rproductName'] = element[matchKey];
                        data['rproductNameFlag'] = true;
                        data['qty'] = element[qtyKey];
                        data['rqty'] = '';
                        data['rqtyFlag'] = true;
                        data['rate'] = element[rateKey];
                        data['rrate'] = '';
                        data['rrateFlag'] = true;
                        data['itemAmt'] = element[amtKey];
                        data['ritemAmt'] = '';
                        data['ritemAmtFlag'] = true;
                    }
                    let poRec = tempPo.find((invRow) => {
                        return element[matchKey].toLowerCase().trim() == invRow[matchKey].toLowerCase().trim() || element[matchKey].toLowerCase().trim().includes(invRow[matchKey].toLowerCase().trim()) || invRow[matchKey].toLowerCase().trim().includes(element[matchKey].toLowerCase().trim());
                    });
                    if (util_1.isNullOrUndefined(poRec) && element[matchKey] && tempPo.length) {
                        let mats = tempPo.map(a => a[matchKey].toLowerCase());
                        let match = stringSimilarity.findBestMatch(element[matchKey].toLowerCase(), mats);
                        console.log(`---------match -------`, element[matchKey].toLowerCase(), '------------', match);
                        if (match && match.ratings && match.ratings.length > 1) {
                            for (let i = 0; i < match.ratings.length; i++) {
                                let ele = match.ratings[i];
                                for (let j = 0; j < tempPo.length; j++) {
                                    let eleInner = tempPo[j];
                                    if (eleInner[matchKey].toLowerCase() == ele['target']) {
                                        if (element['Quantity'].replace(/[^0-9]/gi, '') == eleInner['Quantity'].replace(/[^0-9]/gi, '')) {
                                            match.bestMatchIndex = j;
                                        }
                                    }
                                }
                            }
                        }
                        if (!util_1.isNullOrUndefined(match.bestMatchIndex)) {
                            poRec = tempPo[match.bestMatchIndex];
                            tempPo.splice(match.bestMatchIndex, 1);
                        }
                    }
                    else {
                        tempPo = tempPo.filter((invRow) => !(element[matchKey].toLowerCase().trim() == invRow[matchKey].toLowerCase().trim() || element[matchKey].toLowerCase().trim().includes(invRow[matchKey].toLowerCase().trim()) || invRow[matchKey].toLowerCase().trim().includes(element[matchKey].toLowerCase().trim())));
                    }
                    if (poRec) {
                        data['poProductName'] = poRec[matchKey];
                        data['poProductNameFlag'] = false;
                        po = _.without(po, _.findWhere(po, { productName: poRec[matchKey] }));
                        element[qtyKey] = element[qtyKey] ? element[qtyKey].replace(/,/g, '') : '';
                        poRec[qtyKey] = poRec[qtyKey] ? poRec[qtyKey].replace(/,/g, '') : '';
                        element[rateKey] = element[rateKey] ? element[rateKey].replace(/,/g, '') : '';
                        poRec[rateKey] = poRec[rateKey] ? poRec[rateKey].replace(/,/g, '') : '';
                        element[amtKey] = element[amtKey] ? element[amtKey].replace(/,/g, '') : '';
                        poRec[amtKey] = poRec[amtKey] ? poRec[amtKey].replace(/,/g, '') : '';
                        if (element[qtyKey] == poRec[qtyKey] || (!isNaN(element[qtyKey]) && String(parseFloat(element[qtyKey])) == String(parseFloat(poRec[qtyKey])))) {
                            data['poQty'] = poRec[qtyKey];
                            data['poQtyFlag'] = false;
                        }
                        else {
                            data['poQty'] = poRec[qtyKey];
                            data['poQtyFlag'] = true;
                        }
                        if (element[rateKey] == poRec[rateKey] || (!isNaN(element[rateKey]) && String(parseFloat(element[rateKey])) == String(parseFloat(poRec[rateKey])))) {
                            data['poRate'] = poRec[rateKey];
                            data['poRateFlag'] = false;
                        }
                        else {
                            data['poRate'] = poRec[rateKey];
                            data['poRateFlag'] = true;
                        }
                        if (element[amtKey] == poRec[amtKey] || (!isNaN(element[amtKey]) && String(parseFloat(element[amtKey])) == String(parseFloat(poRec[amtKey])))) {
                            data['poItemAmt'] = poRec[amtKey];
                            data['poItemAmtFlag'] = false;
                        }
                        else {
                            data['poItemAmt'] = poRec[amtKey];
                            data['poItemAmtFlag'] = true;
                        }
                    }
                    else {
                        data['poProductName'] = poRec[matchKey];
                        data['poProductNameFlag'] = true;
                        data['poQty'] = '';
                        data['poQtyFlag'] = true;
                        data['poRate'] = '';
                        data['poRateFlag'] = true;
                        data['poItemAmt'] = '';
                        data['poItemAmtFlag'] = true;
                    }
                    masterReconciliation.push(JSON.parse(JSON.stringify(data)));
                });
                let tempTable = JSON.parse(JSON.stringify(tempInv));
                tempPo.forEach((list) => {
                    let data = rObj;
                    let info = tempTable.find((res) => {
                        return list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase());
                    });
                    if (util_1.isNullOrUndefined(info) && list[matchKey] && tempTable.length) {
                        let mats = tempTable.map(a => a[matchKey].toLowerCase());
                        let match = stringSimilarity.findBestMatch(list[matchKey].toLowerCase(), mats);
                        console.log(`---------match -------`, list[matchKey].toLowerCase(), '------------', match);
                        if (match && match.ratings && match.ratings.length > 1) {
                            for (let i = 0; i < match.ratings.length; i++) {
                                let ele = match.ratings[i];
                                for (let j = 0; j < tempTable.length; j++) {
                                    let eleInner = tempTable[j];
                                    if (eleInner[matchKey].toLowerCase() == ele['target']) {
                                        if (list['Quantity'].replace(/[^0-9]/gi, '') == eleInner['Quantity'].replace(/[^0-9]/gi, '')) {
                                            match.bestMatchIndex = j;
                                        }
                                    }
                                }
                            }
                        }
                        if (!util_1.isNullOrUndefined(match.bestMatchIndex)) {
                            info = tempTable[match.bestMatchIndex];
                            tempTable.splice(match.bestMatchIndex, 1);
                        }
                    }
                    else {
                        tempTable = tempTable.filter(res => !(list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase())));
                    }
                    list[qtyKey] = list[qtyKey] ? list[qtyKey].replace(/,/g, '') : '';
                    list[rateKey] = list[rateKey] ? list[rateKey].replace(/,/g, '') : '';
                    list[amtKey] = list[amtKey] ? list[amtKey].replace(/,/g, '') : '';
                    if (info) {
                        data['productName'] = list[matchKey];
                        data['rproductName'] = info[matchKey];
                        data['rproductNameFlag'] = false;
                        tempInv = _.without(tempInv, _.findWhere(tempInv, { productName: info[matchKey] }));
                        list[qtyKey] = list[qtyKey] ? list[qtyKey].replace(/,/g, '') : '';
                        info[qtyKey] = info[qtyKey] ? info[qtyKey].replace(/,/g, '') : '';
                        list[rateKey] = list[rateKey] ? list[rateKey].replace(/,/g, '') : '';
                        info[rateKey] = info[rateKey] ? info[rateKey].replace(/,/g, '') : '';
                        list[amtKey] = list[amtKey] ? list[amtKey].replace(/,/g, '') : '';
                        info[amtKey] = info[amtKey] ? info[amtKey].replace(/,/g, '') : '';
                        data['qty'] = '';
                        data['rqty'] = '';
                        data['rqtyFlag'] = true;
                        data['rate'] = '';
                        data['rrate'] = '';
                        data['rrateFlag'] = true;
                        data['itemAmt'] = '';
                        data['ritemAmt'] = '';
                        data['ritemAmtFlag'] = true;
                        if (list[qtyKey] == info[qtyKey] || (!isNaN(list[qtyKey]) && String(parseFloat(list[qtyKey])) == String(parseFloat(info[qtyKey])))) {
                            data['rqty'] = info[qtyKey];
                            data['poQty'] = list[qtyKey];
                            data['rqtyFlag'] = false;
                        }
                        else {
                            data['rqty'] = info[qtyKey];
                            data['poQty'] = list[qtyKey];
                            data['rqtyFlag'] = true;
                        }
                        if (list[rateKey] == info[rateKey] || (!isNaN(list[rateKey]) && String(parseFloat(list[rateKey])) == String(parseFloat(info[rateKey])))) {
                            data['rrate'] = info[rateKey];
                            data['poRate'] = list[rateKey];
                            data['poRateFlag'] = false;
                        }
                        else {
                            data['rrate'] = info[rateKey];
                            data['poRate'] = list[rateKey];
                            data['poRateFlag'] = true;
                        }
                        if (list[amtKey] == info[amtKey] || (!isNaN(list[amtKey]) && String(parseFloat(list[amtKey])) == String(parseFloat(info[amtKey])))) {
                            data['ritemAmt'] = info[amtKey];
                            data['poItemAmt'] = list[amtKey];
                            data['poItemAmtFlag'] = false;
                        }
                        else {
                            data['ritemAmt'] = info[amtKey];
                            data['poItemAmt'] = list[amtKey];
                            data['poItemAmtFlag'] = true;
                        }
                    }
                    else {
                        data['productName'] = list[matchKey];
                        data['rproductName'] = list[matchKey];
                        data['rproductNameFlag'] = true;
                        data['qty'] = '';
                        data['rqty'] = '';
                        data['rqtyFlag'] = true;
                        data['rate'] = '';
                        data['rrate'] = '';
                        data['rrateFlag'] = true;
                        data['itemAmt'] = '';
                        data['ritemAmt'] = '';
                        data['ritemAmtFlag'] = true;
                        data['poProductName'] = list[matchKey];
                        data['poProductNameFlag'] = true;
                        data['poQty'] = list[qtyKey];
                        data['poQtyFlag'] = true;
                        data['poRate'] = list[rateKey];
                        data['poRateFlag'] = true;
                        data['poItemAmt'] = list[amtKey];
                        data['poItemAmtFlag'] = true;
                    }
                    masterReconciliation.push(JSON.parse(JSON.stringify(data)));
                });
                tempTable.forEach((list) => {
                    let data = rObj;
                    data['productName'] = list[matchKey];
                    data['rproductName'] = list[matchKey];
                    data['rproductNameFlag'] = true;
                    data['qty'] = '';
                    data['rqty'] = list[qtyKey];
                    data['rqtyFlag'] = true;
                    data['rate'] = '';
                    data['rrate'] = list[rateKey];
                    data['rrateFlag'] = true;
                    data['itemAmt'] = '';
                    data['ritemAmt'] = list[amtKey];
                    data['ritemAmtFlag'] = true;
                    data['poProductName'] = list[matchKey];
                    data['poProductNameFlag'] = true;
                    data['poQty'] = '';
                    data['poQtyFlag'] = true;
                    data['poRate'] = '';
                    data['poRateFlag'] = true;
                    data['poItemAmt'] = '';
                    data['poItemAmtFlag'] = true;
                    masterReconciliation.push(JSON.parse(JSON.stringify(data)));
                });
                output['outputData'] = JSON.stringify(masterReconciliation);
                return { info: 'Reconciliation Prepare success', status: 0, data: output };
            }
            catch (err) {
                this.log.error('Failed inside prepare reconciliation - ' + err);
                return { info: 'Failed inside prepare reconciliation', status: 1, data: [] };
            }
        });
    }
    twoWayReConciliationN(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let masterInvdata = [];
                let pOrder = [];
                let invData = [];
                let docType = input.docType;
                let invRef = input.inv_ref_no;
                let poRef = input.po_no;
                let matchKey = input.matchKey ? input.matchKey : "Description";
                let rateKey = input.rateKey ? input.rateKey : "Rate";
                let qtyKey = input.qtyKey ? input.qtyKey : "Quantity";
                let amtKey = input.amtKey ? input.amtKey : "Amount";
                console.log("Input ---", input, matchKey, rateKey, qtyKey, amtKey);
                if (!util_1.isNullOrUndefined(invRef) && invRef !== "" && !util_1.isNullOrUndefined(poRef) && poRef !== "") {
                    let invNumData = yield (db.collection(docType)).findOne({ referenceNumber: invRef }).lean();
                    // let poInvNumData = await (db.collection(docType)).findOne({ referenceNumber: poRef }).lean();
                    let poDataDB = yield (db.collection('poinfos')).find({ "poNumber": { $in: poRef } }).lean();
                    let poInvNumData = {
                        poNumber: "",
                        invoiceItems: []
                    };
                    if (!util_1.isNullOrUndefined(poDataDB) && poDataDB.length > 0) {
                        for (let index = 0; index < poDataDB.length; index++) {
                            let invoiceItems = poDataDB[index]['invoiceItems'];
                            for (let j = 0; j < invoiceItems.length; j++) {
                                if (invoiceItems[j]['UOM'] && invoiceItems[j]['UOM'].toLowerCase() == "thousands") {
                                    invoiceItems[j]['Quantity'] = String(Number(invoiceItems[j]['Quantity']) * 1000);
                                }
                            }
                        }
                        for (let index = 0; index < poDataDB.length; index++) {
                            let element = poDataDB[index];
                            poInvNumData['invoiceItems'] = poInvNumData['invoiceItems'].concat(element['invoiceItems']);
                            poInvNumData['poNumber'] = element['poNumber'];
                        }
                    }
                    console.log("poInvNumData", poInvNumData);
                    pOrder = JSON.parse(JSON.stringify(poInvNumData['invoiceItems']));
                    invData = JSON.parse(JSON.stringify(invNumData['invoiceItems']));
                    let tempTable = JSON.parse(JSON.stringify(invNumData['invoiceItems']));
                    let tempPo = JSON.parse(JSON.stringify(poInvNumData['invoiceItems']));
                    let rObj = {};
                    if (pOrder.length == invData.length || pOrder.length < invData.length) {
                        pOrder.forEach((list) => {
                            let data = {};
                            let info = tempTable.find((res) => {
                                return list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase());
                            });
                            if (util_1.isNullOrUndefined(info) && list[matchKey] && tempTable.length) {
                                let mats = tempTable.map(a => a[matchKey].toLowerCase());
                                let match = stringSimilarity.findBestMatch(list[matchKey].toLowerCase(), mats);
                                console.log(`---------match -------`, list[matchKey].toLowerCase(), '------------', match);
                                if (match && match.ratings && match.ratings.length > 1) {
                                    for (let i = 0; i < match.ratings.length; i++) {
                                        let ele = match.ratings[i];
                                        for (let j = 0; j < tempTable.length; j++) {
                                            let eleInner = tempTable[j];
                                            if (eleInner[matchKey].toLowerCase() == ele['target']) {
                                                if (list['Quantity'].replace(/[^0-9]/gi, '') == eleInner['Quantity'].replace(/[^0-9]/gi, '')) {
                                                    match.bestMatchIndex = j;
                                                }
                                            }
                                        }
                                    }
                                }
                                if (!util_1.isNullOrUndefined(match.bestMatchIndex)) {
                                    info = tempTable[match.bestMatchIndex];
                                    tempTable.splice(match.bestMatchIndex, 1);
                                }
                            }
                            else {
                                tempTable = tempTable.filter(res => !(list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase())));
                            }
                            data['poNum'] = poInvNumData.poNumber;
                            data['invNum'] = invNumData.Invoice_Number;
                            rObj['poNum'] = poInvNumData.poNumber;
                            rObj['invNum'] = invNumData.Invoice_Number;
                            list[qtyKey] = list[qtyKey] ? list[qtyKey].replace(/,/g, '') : '';
                            list[rateKey] = list[rateKey] ? list[rateKey].replace(/,/g, '') : '';
                            list[amtKey] = list[amtKey] ? list[amtKey].replace(/,/g, '') : '';
                            if (info) {
                                data['rproductName'] = info[matchKey];
                                data['productName'] = info[matchKey];
                                data['poProductName'] = list[matchKey];
                                data['poProductNameFlag'] = false;
                                invData = _.without(invData, _.findWhere(invData, { productName: info[matchKey] }));
                                info[qtyKey] = info[qtyKey] ? info[qtyKey].replace(/,/g, '') : '';
                                info[rateKey] = info[rateKey] ? info[rateKey].replace(/,/g, '') : '';
                                info[amtKey] = info[amtKey] ? info[amtKey].replace(/,/g, '') : '';
                                if (list[qtyKey] == info[qtyKey] || (!isNaN(list[qtyKey]) && String(parseFloat(list[qtyKey])) == String(parseFloat(info[qtyKey])))) {
                                    data['rqty'] = info[qtyKey];
                                    data['poQty'] = list[qtyKey];
                                    data['poQtyFlag'] = false;
                                }
                                else {
                                    data['rqty'] = info[qtyKey];
                                    data['poQty'] = list[qtyKey];
                                    data['poQtyFlag'] = true;
                                }
                                if (list[rateKey] == info[rateKey] || (!isNaN(list[rateKey]) && String(parseFloat(list[rateKey])) == String(parseFloat(info[rateKey])))) {
                                    data['rrate'] = info[rateKey];
                                    data['poRate'] = list[rateKey];
                                    data['poRateFlag'] = false;
                                }
                                else {
                                    data['rrate'] = info[rateKey];
                                    data['poRate'] = list[rateKey];
                                    data['poRateFlag'] = true;
                                }
                                if (list[amtKey] == info[amtKey] || (!isNaN(list[amtKey]) && String(parseFloat(list[amtKey])) == String(parseFloat(info[amtKey])))) {
                                    data['ritemAmt'] = info[amtKey];
                                    data['poItemAmt'] = list[amtKey];
                                    data['poItemAmtFlag'] = false;
                                }
                                else {
                                    data['ritemAmt'] = info[amtKey];
                                    data['poItemAmt'] = list[amtKey];
                                    data['poItemAmtFlag'] = true;
                                }
                            }
                            else {
                                data['rproductName'] = list[matchKey];
                                data['productName'] = list[matchKey];
                                data['poProductName'] = list[matchKey];
                                data['poProductNameFlag'] = true;
                                data['rqty'] = '';
                                data['poQty'] = list[qtyKey];
                                data['poQtyFlag'] = true;
                                data['rrate'] = '';
                                data['poRate'] = list[rateKey];
                                data['poRateFlag'] = true;
                                data['ritemAmt'] = '';
                                data['poItemAmt'] = list[amtKey];
                                data['poItemAmtFlag'] = true;
                            }
                            masterInvdata.push(JSON.parse(JSON.stringify(data)));
                        });
                        tempTable.forEach((list) => {
                            let data = rObj;
                            data['rproductName'] = list[matchKey];
                            data['productName'] = list[matchKey];
                            data['poProductName'] = list[matchKey];
                            data['poProductNameFlag'] = true;
                            data['rqty'] = list[qtyKey];
                            data['poQty'] = '';
                            data['poQtyFlag'] = true;
                            data['rrate'] = list[rateKey];
                            data['poRate'] = '';
                            data['poRateFlag'] = true;
                            data['ritemAmt'] = list[amtKey];
                            data['poItemAmt'] = '';
                            data['poItemAmtFlag'] = true;
                            masterInvdata.push(JSON.parse(JSON.stringify(data)));
                        });
                    }
                    else {
                        invData.forEach((list) => {
                            let data = {};
                            let info = tempPo.find((res) => {
                                return list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase());
                            });
                            if (util_1.isNullOrUndefined(info) && list[matchKey] && tempPo.length) {
                                let mats = tempPo.map(a => a[matchKey].toLowerCase());
                                let match = stringSimilarity.findBestMatch(list[matchKey].toLowerCase(), mats);
                                console.log(`---------match -------`, list[matchKey].toLowerCase(), '------------', match);
                                if (match && match.ratings && match.ratings.length > 1) {
                                    for (let i = 0; i < match.ratings.length; i++) {
                                        let ele = match.ratings[i];
                                        for (let j = 0; j < tempPo.length; j++) {
                                            let eleInner = tempPo[j];
                                            if (eleInner[matchKey].toLowerCase() == ele['target']) {
                                                if (list['Quantity'].replace(/[^0-9]/gi, '') == eleInner['Quantity'].replace(/[^0-9]/gi, '')) {
                                                    match.bestMatchIndex = j;
                                                }
                                            }
                                        }
                                    }
                                }
                                if (!util_1.isNullOrUndefined(match.bestMatchIndex)) {
                                    info = tempPo[match.bestMatchIndex];
                                    tempPo.splice(match.bestMatchIndex, 1);
                                }
                            }
                            else {
                                tempPo = tempPo.filter(res => !(list[matchKey].toLowerCase().trim() == res[matchKey].toLowerCase().trim() || list[matchKey].toLowerCase().includes(res[matchKey].toLowerCase()) || res[matchKey].toLowerCase().includes(list[matchKey].toLowerCase())));
                            }
                            data['poNum'] = poInvNumData.poNumber;
                            data['invNum'] = invNumData.Invoice_Number;
                            rObj['poNum'] = poInvNumData.poNumber;
                            rObj['invNum'] = invNumData.Invoice_Number;
                            list[qtyKey] = list[qtyKey] ? list[qtyKey].replace(/,/g, '') : '';
                            list[rateKey] = list[rateKey] ? list[rateKey].replace(/,/g, '') : '';
                            list[amtKey] = list[amtKey] ? list[amtKey].replace(/,/g, '') : '';
                            if (info) {
                                let t1 = info ? JSON.parse(JSON.stringify(info)) : info;
                                let t2 = list ? JSON.parse(JSON.stringify(list)) : list;
                                info = t2;
                                list = t1;
                                data['rproductName'] = info[matchKey];
                                data['productName'] = info[matchKey];
                                data['poProductName'] = list[matchKey];
                                data['poProductNameFlag'] = false;
                                invData = _.without(invData, _.findWhere(invData, { productName: info[matchKey] }));
                                info[qtyKey] = info[qtyKey] ? info[qtyKey].replace(/,/g, '') : '';
                                info[rateKey] = info[rateKey] ? info[rateKey].replace(/,/g, '') : '';
                                info[amtKey] = info[amtKey] ? info[amtKey].replace(/,/g, '') : '';
                                list[qtyKey] = list[qtyKey] ? list[qtyKey].replace(/,/g, '') : '';
                                list[rateKey] = list[rateKey] ? list[rateKey].replace(/,/g, '') : '';
                                list[amtKey] = list[amtKey] ? list[amtKey].replace(/,/g, '') : '';
                                if (list[qtyKey] == info[qtyKey] || (!isNaN(list[qtyKey]) && String(parseFloat(list[qtyKey])) == String(parseFloat(info[qtyKey])))) {
                                    data['rqty'] = info[qtyKey];
                                    data['poQty'] = list[qtyKey];
                                    data['poQtyFlag'] = false;
                                }
                                else {
                                    data['rqty'] = info[qtyKey];
                                    data['poQty'] = list[qtyKey];
                                    data['poQtyFlag'] = true;
                                }
                                if (list[rateKey] == info[rateKey] || (!isNaN(list[rateKey]) && String(parseFloat(list[rateKey])) == String(parseFloat(info[rateKey])))) {
                                    data['rrate'] = info[rateKey];
                                    data['poRate'] = list[rateKey];
                                    data['poRateFlag'] = false;
                                }
                                else {
                                    data['rrate'] = info[rateKey];
                                    data['poRate'] = list[rateKey];
                                    data['poRateFlag'] = true;
                                }
                                if (list[amtKey] == info[amtKey] || (!isNaN(list[amtKey]) && String(parseFloat(list[amtKey])) == String(parseFloat(info[amtKey])))) {
                                    data['ritemAmt'] = info[amtKey];
                                    data['poItemAmt'] = list[amtKey];
                                    data['poItemAmtFlag'] = false;
                                }
                                else {
                                    data['ritemAmt'] = info[amtKey];
                                    data['poItemAmt'] = list[amtKey];
                                    data['poItemAmtFlag'] = true;
                                }
                            }
                            else {
                                data['rproductName'] = list[matchKey];
                                data['productName'] = list[matchKey];
                                data['poProductName'] = list[matchKey];
                                data['poProductNameFlag'] = true;
                                data['rqty'] = list[qtyKey];
                                data['poQty'] = '';
                                data['poQtyFlag'] = true;
                                data['rrate'] = list[rateKey];
                                data['poRate'] = '';
                                data['poRateFlag'] = true;
                                data['ritemAmt'] = list[amtKey];
                                data['poItemAmt'] = '';
                                data['poItemAmtFlag'] = true;
                            }
                            masterInvdata.push(JSON.parse(JSON.stringify(data)));
                        });
                        tempPo.forEach((list) => {
                            let data = rObj;
                            data['rproductName'] = list[matchKey];
                            data['productName'] = list[matchKey];
                            data['poProductName'] = list[matchKey];
                            data['poProductNameFlag'] = true;
                            data['rqty'] = '';
                            data['poQty'] = list[qtyKey];
                            data['poQtyFlag'] = true;
                            data['rrate'] = '';
                            data['poRate'] = list[rateKey];
                            data['poRateFlag'] = true;
                            data['ritemAmt'] = '';
                            data['poItemAmt'] = list[amtKey];
                            data['poItemAmtFlag'] = true;
                            masterInvdata.push(JSON.parse(JSON.stringify(data)));
                        });
                    }
                    // invData.forEach((list) => {
                    //     let data = {};
                    //     data['poNum'] = poInvNumData.Invoice_Number;
                    //     data['invNum'] = invNumData.Invoice_Number;
                    //     data['rproductName'] = list[matchKey];
                    //     data['productName'] = list[matchKey];
                    //     data['poProductName'] = '';
                    //     data['poProductNameFlag'] = true;
                    //     data['rqty'] = list[qtyKey];
                    //     data['poQty'] = '';
                    //     data['rqtyFlag'] = true;
                    //     data['rrate'] = list[rateKey];
                    //     data['poRate'] = '';
                    //     data['poRateFlag'] = true;
                    //     data['ritemAmt'] = list[amtKey];
                    //     data['poItemAmt'] = '';
                    //     data['poItemAmtFlag'] = true;
                    //     masterInvdata.push(data);
                    // });
                    output['outputData'] = JSON.stringify(masterInvdata);
                    yield (db.collection("TwoWayRecon")).create(masterInvdata[0]);
                    return { message: 'Data Found Sucessfull', status: 0, data: output };
                }
                else {
                    return { message: 'Please Give Pan Number', status: 1, data: output };
                }
            }
            catch (e) {
                this.log.error("Error in Finding User Data" + e);
                return {
                    message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' +
                        projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']'
                };
            }
        });
    }
    fetchReceiptInfoFromDB(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let receiptData = yield (db.collection('receiptinfos')).findOne({ "receiptNumber": input["receiptData"]['Receipt No'] });
                let poData = yield (db.collection('poinfos')).findOne({ "poNumber": input["receiptData"]['Po No'] });
                outputParameters['receiptDataDB'] = receiptData;
                outputParameters['poDataDB'] = poData;
                return { message: "server folder cleaned.", status: 0, data: outputParameters };
            }
            catch (e) {
                this.log.error("Error while moving file ---" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    powerbiAPI(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let self = this;
                let docType = input.docType;
                let refNo = input.refNo;
                let url = input.url;
                let scanFields = yield (db.collection('scanningfields')).findOne({ documentType: docType }).lean();
                scanFields = JSON.parse(JSON.stringify(scanFields));
                let lineItemsFields = scanFields.defaultInvoiceItems;
                let sizeKeys = scanFields.sizeKeys;
                //for new requirement of innohat for sizeArray
                let headerFields = scanFields.fields.filter(a => a.show).map(a => a.fieldName);
                let invData = yield (db.collection(docType)).findOne({ referenceNumber: refNo }, {}).lean();
                let invfile = yield (db.collection("fileuploadhistories")).findOne({ "fileRefNum": refNo }, { "fileName": 1 }).lean();
                let finalData = {};
                finalData['fileName'] = invfile['fileName'];
                finalData['referenceNumber'] = refNo;
                for (let field of headerFields) {
                    finalData[field] = invData[field] ? invData[field] : '';
                }
                finalData['invoiceItems'] = [];
                for (let item of invData['invoiceItems']) {
                    let QtySize = {};
                    let subTableEntries = [];
                    for (let field of Object.keys(item)) {
                        if (sizeKeys.includes(field)) {
                            QtySize[field] = item[field] ? item[field] : '';
                            delete item[field];
                        }
                    }
                    //for new requirement of innohat for subtable
                    const subTable = item['subTable'] || [];
                    for (let subTableItem of subTable) {
                        let subTableEntry = Object.assign({}, QtySize, subTableItem);
                        subTableEntries.push(subTableEntry);
                    }
                    delete item['subTable'];
                    item['QtySize'] = Object.assign({}, QtySize, subTableEntries[0]);
                    for (let field of lineItemsFields) {
                        item[field] = item[field] ? item[field] : '';
                    }
                    finalData['invoiceItems'].push(item);
                }
                let options = {
                    'method': 'POST',
                    'url': url,
                    'headers': {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(finalData)
                };
                let response = yield self.remoteApiCall(options);
                console.log(response);
                return { message: "server folder cleaned.", status: 0, data: outputParameters };
            }
            catch (e) {
                this.log.error("Error while moving file ---" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    updateDocType(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let refNo = input.fileRefNum;
                let newDocType = input.docType;
                let tableObj = input.tableObj && Array.isArray(input.tableObj) ? input.tableObj : [];
                let updateDocTrain = input.updateDT ? input.updateDT : false;
                if (!util_1.isNullOrUndefined(refNo) && refNo !== '' && !util_1.isNullOrUndefined(newDocType) && newDocType !== '') {
                    let res = yield (db.collection("fileuploadhistories")).updateOne({ "fileRefNum": refNo }, { $set: { "documentType": newDocType } });
                    console.log("res---", res);
                    res = yield (db.collection("filequeues")).updateOne({ "fileRefNum": refNo }, { $set: { "documentType": newDocType } });
                    console.log("res---", res);
                    for (let i = 0; i < tableObj.length; i++) {
                        if (tableObj[i]['obj']) {
                            tableObj[i]['obj']["documentType"] = newDocType;
                            console.log(tableObj[i]['obj']);
                        }
                    }
                    if (updateDocTrain) {
                        let cropBox = [];
                        tableObj.map(a => cropBox = cropBox.concat(a.raw));
                        let dTobj = {
                            userId: ObjectId(input.userId),
                            orgId: ObjectId(input.orgId),
                            documentType: input.docType,
                            "isDeleted": false,
                            subscriberId: ObjectId(input.subscriberId),
                            documentCsvData: cropBox
                        };
                        console.log("DocumentCsv Data--------", cropBox.length);
                        res = yield (db.collection("documenttrainings")).update({ fileRefNum: input.fileRefNum }, { $set: dTobj }, { upsert: true });
                        console.log("updated doctraiings----", res);
                    }
                    outputParameters['newTableObj'] = tableObj;
                    return { message: "server folder cleaned.", status: 0, data: outputParameters };
                }
                else {
                    throw "fileRefNum or docType not found";
                }
            }
            catch (e) {
                this.log.error("Error updateDocType in  ---" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    saveInDocumentType(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let ruleObj = input.ruleObj ? input.ruleObj : [];
                let docType = input.docType;
                let fileRefNum = input.fileRefNum ? input.fileRefNum : `${Date.now()}`;
                let invObj = input.invObj ? input.invObj : {};
                let invItems = input.invoiceItems ? input.invoiceItems : [];
                if (!util_1.isNullOrUndefined(ruleObj) && Array.isArray(ruleObj) && !util_1.isNullOrUndefined(fileRefNum) && !util_1.isNullOrUndefined(docType)) {
                    let invoiceItems = ruleObj.length && ruleObj[0]["newTable"] ? ruleObj[0]["newTable"] : [];
                    console.log(invoiceItems.length);
                    if (invoiceItems.length == 0) {
                        invoiceItems = invItems;
                    }
                    let scanFields = yield (db.collection('scanningfields')).findOne({ documentType: docType }).lean();
                    scanFields = JSON.parse(JSON.stringify(scanFields));
                    let dbInvObj = yield (db.collection(docType)).findOne({ referenceNumber: fileRefNum }).lean();
                    dbInvObj = dbInvObj ? dbInvObj : {};
                    let finalObj = {};
                    scanFields.fields.forEach(elment => {
                        finalObj[elment['fieldName']] = invObj[elment['fieldName']] ? invObj[elment['fieldName']] : (dbInvObj[elment['fieldName']] ? dbInvObj[elment['fieldName']] : '');
                    });
                    finalObj['docType'] = docType;
                    if (invoiceItems.length) {
                        let newInvoiceItems = [];
                        for (let s of invoiceItems) {
                            let obj = {};
                            for (let key in s) {
                                let newKey = key.trim().replace(/[\.\s]/g, '_').replace(/^_|_$/g, '');
                                obj[newKey] = s[key];
                            }
                            newInvoiceItems.push(JSON.parse(JSON.stringify(obj)));
                        }
                        finalObj['invoiceItems'] = newInvoiceItems;
                    }
                    finalObj['orgId'] = String(input.orgId);
                    ruleObj.filter(a => a.invoiceObject = finalObj);
                    let invfile = yield (db.collection(docType)).update({ referenceNumber: fileRefNum }, { $set: finalObj }, { upsert: true });
                    console.log(invfile);
                    outputParameters['invObj'] = finalObj;
                    outputParameters['ruleObj'] = ruleObj;
                    return { message: "server folder cleaned.", status: 0, data: outputParameters };
                }
                else {
                    throw "fileRefNum or docType not found";
                }
            }
            catch (e) {
                this.log.error("Error updateDocType in  ---" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    barCodeDataSaveInDocumentType(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let barData = input.barCodeData;
                let imgArr = input.imgArr ? input.imgArr : [];
                if (Array.isArray(barData)) {
                    // to find the pages with barcode present
                    let pageWithBarcode = [...new Set(barData.filter(a => a.data.trim() !== '').map(a => a.pageNo))].map(a => Number(a));
                    if (pageWithBarcode.length != 0) {
                        pageWithBarcode.push(imgArr.length);
                    }
                    else {
                        throw "BarCode data not proper";
                    }
                    barData = barData.filter(a => a.data.trim() !== '');
                    try {
                        let width = Math.max(...barData.map(a => a.rect.width));
                        let height = Math.max(...barData.map(a => a.rect.height));
                        barData = barData.filter(a => a.rect.width == width || a.rect.height == height);
                    }
                    catch (e) {
                        console.log("Err barcode ------------", e);
                    }
                    let splitPdfs = {};
                    let splitString = [];
                    let firstPage, lastPage;
                    for (let i = 0; i < barData.length; i++) {
                        lastPage = barData[i];
                        if (firstPage && lastPage && firstPage.data != lastPage.data && firstPage.pageNo != lastPage.pageNo) {
                            splitString.push(`${firstPage.pageNo + 1}_${lastPage.pageNo}`);
                            firstPage = undefined;
                        }
                        firstPage = firstPage || barData[i];
                    }
                    if (firstPage && lastPage) {
                        splitString.push(`${firstPage.pageNo + 1}_${imgArr.length > lastPage.pageNo ? imgArr.length : lastPage.pageNo + 1}`);
                    }
                    console.log(pageWithBarcode, splitString, barData.map(a => a.data.trim()));
                    outputParameters['mergePdf'] = splitPdfs;
                    outputParameters['splitString'] = splitString.join(',');
                    return { message: "server folder cleaned.", status: 0, data: outputParameters };
                }
                else {
                    throw "No Barcode Data";
                }
            }
            catch (e) {
                this.log.error("Error updateDocType in  ---" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    splitPdfpageWise(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let filePath = input.filePath;
                let splitString = input.splitString;
                let dirPath = input.dirPath ? input.dirPath : config.cudapath;
                dirPath = dirPath.replace(/(\/)$/, '') + '/' + Date.now();
                console.log("Creating -----", dirPath);
                fs.mkdirSync(dirPath);
                console.log('DirPath----', dirPath);
                let inputIObj = {
                    inputPath: filePath,
                    outputFolder: dirPath,
                    splitOn: splitString,
                    function: "splitPdfByPageNumber",
                };
                let parameters = JSON.stringify(JSON.stringify(inputIObj));
                console.log("java -cp .:json-20190722.jar:pdfbox-2.0.3.jar:fontbox-2.0.3.jar:commons-logging-1.2.jar:json-simple-1.1.1.jar:jbig2-imageio-3.0.0.jar:itextpdf-5.5.13.1.jar:kernel-7.1.12.jar:io-7.1.12.jar:layout-7.1.12.jar:slf4j-api-1.7.30.jar:slf4j-simple-1.7.30.jar:commons-lang3-3.11.jar NewPdfBox " +
                    parameters);
                let res = yield this.sh("java -cp .:json-20190722.jar:pdfbox-2.0.3.jar:fontbox-2.0.3.jar:commons-logging-1.2.jar:json-simple-1.1.1.jar:jbig2-imageio-3.0.0.jar:itextpdf-5.5.13.1.jar:kernel-7.1.12.jar:io-7.1.12.jar:layout-7.1.12.jar:slf4j-api-1.7.30.jar:slf4j-simple-1.7.30.jar:commons-lang3-3.11.jar NewPdfBox " +
                    parameters);
                let mergedPdfs = [];
                let files = fs.readdirSync(dirPath);
                for (const file of files) {
                    let fP = path.join(dirPath, file);
                    mergedPdfs.push(fP);
                }
                console.log(res, splitString.split(','), mergedPdfs);
                if (mergedPdfs.length == splitString.split(',').length) {
                    console.log("mergedPdfs--->", mergedPdfs);
                    outputParameters['dirPath'] = dirPath;
                    outputParameters['filePaths'] = mergedPdfs;
                    return { message: "PDFs merged", status: 0, data: outputParameters };
                }
                else {
                    throw "Some issue while merging";
                }
            }
            catch (e) {
                this.log.error("Error mergpdfs in ---" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    mergeImagesToPdf(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let objMapping = input.mergePDFObj;
                let dirPath = input.dirPath ? input.dirPath : config.cudapath;
                dirPath = dirPath.replace(/(\/)$/, '') + '/' + Date.now();
                console.log("Creating -----", dirPath);
                fs.mkdirSync(dirPath);
                // creating the dynamic directoreis bcoz in DelphiPOC have to iterate this Dir in next flow
                console.log('DirPath----', dirPath);
                let prmArr = [];
                let mergedPdfs = [];
                for (let file in objMapping) {
                    let fileName = `${dirPath}/${file}`;
                    let filePaths = objMapping[file].map(a => a['imageFilePath']);
                    let inputIObj = {
                        "fileArray": filePaths,
                        "outputFilePath": fileName
                    };
                    mergedPdfs.push(fileName);
                    let data = this.imagesToPdf(inputIObj, {}, '', '', '');
                    prmArr.push(data);
                }
                let reso = yield Promise.all(prmArr);
                if (reso.filter(a => a.status == 0).length == mergedPdfs.length) {
                    console.log("=====>", reso);
                    console.log("mergedPdfs--->", mergedPdfs);
                    outputParameters['dirPath'] = dirPath;
                    outputParameters['filePaths'] = mergedPdfs;
                    return { message: "PDFs merged", status: 0, data: outputParameters };
                }
                else {
                    throw "Some issue while merging";
                }
            }
            catch (e) {
                this.log.error("Error mergpdfs in ---" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    ruleEngineBot(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let fileRefNum = input.refNo;
                let docType = input.docType;
                let ruleId = input.ruleId;
                let rulesSetValue = yield (db.collection(docType)).findOne({ referenceNumber: fileRefNum }).lean();
                delete rulesSetValue['_id'];
                let keys = Object.keys(rulesSetValue);
                for (let key of keys) {
                    if (Array.isArray(rulesSetValue[key]) && key !== "invoiceItems") {
                        delete rulesSetValue[key];
                    }
                }
                if (util_1.isNullOrUndefined(ruleId) || ruleId == '') {
                    let scanD = yield (db.collection('scanningfields')).findOne({ documentType: docType }).lean();
                    ruleId = String(scanD.ruleId);
                }
                let invfile = yield (db.collection(docType + '_cons_before')).update({ referenceNumber: fileRefNum }, { $set: rulesSetValue }, { upsert: true });
                console.log("Applying rules-----", ruleId);
                let obj = {
                    id: ruleId,
                    rulesSetValue: rulesSetValue
                };
                let res = yield this.evaluateRuleSet(obj);
                console.log("res----", res);
                invfile = yield (db.collection(docType)).update({ referenceNumber: fileRefNum }, { $set: res }, { upsert: true });
                console.log("Updated in documentType---", invfile);
                outputParameters['ruleSetValue'] = res;
                outputParameters['invoiceItems'] = res['invoiceItems'];
                for (let key in res) {
                    outputParameters[key] = res[key];
                }
                return { message: "RuleSet Applied", status: 0, data: outputParameters };
            }
            catch (e) {
                this.log.error("Error updateDocType in  ---" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    templateWriteExcelusingXLSX(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const workbook = XLSX.readFile(input.templateXlsx);
                const worksheet = workbook.Sheets[input.sheetName];
                let matchHeaderRow = input.matchHeaderRow;
                let matchHeader = input.matchHeader;
                let mapping = typeof input.mapping == "string" ? JSON.parse(input.mapping) : input.mapping;
                let data = input.data;
                let matchValue = input.matchValue ? input.matchValue : null;
                if (matchValue) {
                    for (let obj of data) {
                        if (!obj[matchHeader]) {
                            obj[matchHeader] = matchValue;
                        }
                    }
                }
                let matchHeaders = data.map(a => a[matchHeader]);
                for (let key in worksheet) {
                    if (key.endsWith(matchHeaderRow) && /[^\d]/.test(key.replace(matchHeaderRow, '')) && worksheet[key]['w'] && matchHeaders.includes(worksheet[key]['w'])) {
                        let match = matchHeaders[matchHeaders.indexOf(worksheet[key]['w'])];
                        let dAtA = data.filter(a => a[matchHeader] == match)[0];
                        let col = key.replace(matchHeaderRow, '');
                        console.log("====>", match, "====>", dAtA, col);
                        for (let nkey in mapping) {
                            let k = col + nkey;
                            console.log(k);
                            if (!worksheet[k]) {
                                worksheet[k] = {};
                            }
                            worksheet[k]['t'] = 'n';
                            worksheet[k]['v'] = !Number.isNaN(parseFloat(dAtA[mapping[nkey]])) ? parseFloat(dAtA[mapping[nkey]]) : '';
                            worksheet[k]['w'] = dAtA[mapping[nkey]];
                        }
                    }
                }
                XLSX.writeFile(workbook, input.writeXlsx);
                outputParameters['outputPath'] = input.writeXlsx;
                return { message: "Excel Written", status: 0, data: outputParameters };
            }
            catch (ex) {
                console.log("Error in excel writing---", ex);
                return { message: ex, status: 1, data: ex };
            }
        });
    }
    templateWriteExcel(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                //Bcoz exceljs with latest version was not compatible with out typescript so using this approach
                // this js file is maintained in scripts folder of src => excelll.js
                // But keep this file in another seperate node project where exceljs@3 or greater and luxon should be installed
                // and assign that js file path in config.excelllPath
                let str = input.writeXlsx;
                input.writeXlsx = str.substr(0, str.lastIndexOf('/') + 1) + Date.now() + '_' + str.substr(str.lastIndexOf('/') + 1);
                let daTa = yield this.sh(`node ${config.excelllPath} '${JSON.stringify(input)}'`);
                console.log(daTa);
                outputParameters['outputPath'] = input.writeXlsx;
                return { message: "Excel Written", status: 0, data: outputParameters };
                //template from where have to copy
                let sourceWorkbook = new Excel.Workbook();
                sourceWorkbook = yield sourceWorkbook.xlsx.readFile(input.templateXlsx);
                const sourceWorksheet = sourceWorkbook.getWorksheet(input.sheetName);
                fs.copyFileSync(input.templateXlsx, input.writeXlsx);
                //first copy the path
                //Path where to add new Entry
                let targetWorkbook = new Excel.Workbook();
                targetWorkbook = yield targetWorkbook.xlsx.readFile(input.writeXlsx);
                const targetWorksheet = targetWorkbook.getWorksheet(input.sheetName);
                let matchHeaderRow = input.matchHeaderRow;
                let matchHeader = input.matchHeader;
                let mapping = typeof input.mapping == "string" ? JSON.parse(input.mapping) : input.mapping;
                let data = input.data;
                let matchValue = input.matchValue ? input.matchValue : null;
                let newData = {};
                if (matchValue) {
                    for (let obj of data) {
                        if (!obj[matchHeader]) {
                            obj[matchHeader] = matchValue;
                        }
                    }
                }
                // let matchHeaders = data.map(a => a[matchHeader]);
                sourceWorksheet.eachRow({ includeEmpty: false }, function (row, rowNumber) {
                    var targetRow = targetWorksheet.getRow(rowNumber);
                    if (rowNumber == matchHeaderRow) {
                        let rowString = targetRow._cells.map(a => {
                            let str;
                            if (/(dd\.)|(yy)/.test(a.style.numFmt)) {
                                let format = a.style.numFmt == "dd.mm.yyyy" ? "dd.MM.yyyy" : a.style.numFmt;
                                const date = DateTime.fromJSDate(new Date(a._value.model.value));
                                const formattedDate = date.toFormat(format);
                                console.log(a.style.numFmt, format, formattedDate);
                                str = formattedDate;
                            }
                            else
                                str = a._value.model.value;
                            return str;
                        });
                        for (let obj of data) {
                            if (rowString.indexOf(obj[matchHeader]) != -1) {
                                newData[rowString.indexOf(obj[matchHeader])] = obj;
                            }
                        }
                        console.log(newData);
                    }
                    if (mapping[rowNumber]) {
                        console.log("Row Number----", mapping[rowNumber]);
                        row.eachCell({ includeEmpty: true }, function (cell, cellNumber) {
                            if (newData[cellNumber]) {
                                targetRow.getCell(cellNumber).value = newData[cellNumber][mapping[rowNumber]];
                                console.log("row---", cellNumber, "---value--", newData[cellNumber][mapping[rowNumber]]);
                            }
                            else {
                                targetRow.getCell(cellNumber).value = cell.value;
                            }
                        });
                    }
                    else {
                        row.eachCell({ includeEmpty: false }, function (cell, cellNumber) {
                            targetRow.getCell(cellNumber).value = cell.value;
                        });
                    }
                    row.commit();
                });
                yield targetWorkbook.xlsx.writeFile(input.writeXlsx);
                outputParameters['outputPath'] = input.writeXlsx;
                return { message: "Excel Written", status: 0, data: outputParameters };
            }
            catch (ex) {
                console.log("Error in excel writing---", ex);
                return { message: ex, status: 1, data: ex };
            }
        });
    }
    convertPdftoImagePdftoppm(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let filePath = input.filePath;
                let rValue = input.rValue ? input.rValue : 300;
                let ext = input.ext ? input.ext : 'jpeg';
                let fileName = filePath.split('/')[filePath.split('/').length - 1];
                let outputDir = config.cudapath;
                console.log("filePath-------", filePath);
                console.log("fileName-------", fileName);
                let outFile = outputDir + fileName.replace(/(\.pdf)$/, '').replace(/[\s\(\)]/g, '');
                let cmd = `pdftoppm -${ext} -r ${rValue} '${filePath}' ${outFile}`;
                //pdftoppm -jpeg  /home/user/Downloads/subcon_po_invoice.pdf ss
                let res = yield this.sh(cmd);
                console.log("Cmd----", cmd, res);
                let imgArr = [];
                let cnt = 1;
                let flag = false;
                // Gives output in name-1.jpg format for pdf length < 10
                do {
                    let newFile = `${outFile}-${String(1).padStart(cnt, '0')}.jpg`;
                    console.log(newFile);
                    if (fs.existsSync(newFile)) {
                        flag = true;
                        break;
                    }
                    cnt++;
                } while (true && cnt < 50);
                if (flag) {
                    let page = 1;
                    do {
                        let newFile = `${outFile}-${String(page).padStart(cnt, '0')}.jpg`;
                        console.log(newFile);
                        if (!fs.existsSync(newFile)) {
                            break;
                        }
                        page++;
                        imgArr.push({
                            imageFilePath: newFile
                        });
                    } while (true);
                }
                if (imgArr.length == 0) {
                    throw "No Images extracted thorugh pdftoppm";
                }
                outputParameters['imageArr'] = imgArr;
                console.log(outputParameters);
                return { message: "Excel Written", status: 0, data: outputParameters };
            }
            catch (ex) {
                console.log("Error while creating images ---", ex);
                return { message: ex, status: 1, data: ex };
            }
        });
    }
    imagesToPdf(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let filePaths = input.fileArray;
                let outputFilePath = input.outputFilePath;
                console.log("filePaths-------", filePaths);
                console.log("fileName-------", outputFilePath);
                let cmd = `convert ${filePaths.join(' ')}  ${outputFilePath}`;
                let res = yield this.sh(cmd);
                console.log("Cmd----", cmd, res);
                if (fs.existsSync(outputFilePath)) {
                    outputParameters['outputFilePath'] = outputFilePath;
                    return { message: "Files converted ", status: 0, data: outputParameters };
                }
                else {
                    throw "File Not Created";
                }
            }
            catch (ex) {
                console.log("Error while creating images ---", ex);
                return { message: ex, status: 1, data: ex };
            }
        });
    }
    downloadfilesFromServer(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const client = yield Client({
                    host: input.host,
                    port: input.port,
                    username: input.username,
                    password: input.password,
                });
                input.localPath = `${input.localPath.replace(/(\/)$/, '')}/${input.serverPath.split('/')[input.serverPath.split('/').length - 1]}`;
                console.log("Server Path----", input.serverPath, "-----Local Path------", input.localPath);
                yield client.downloadFile(input.serverPath, input.localPath);
                output['localPath'] = input.localPath;
                return { message: 'ServerPath is at given folder path.', status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error while doing scp" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    unzipFileToDir(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let zip = new AdmZip(input.zipPath);
                zip.extractAllTo(input.destDir, true);
                output['localPath'] = input.destDir;
                return { message: 'ServerPath is at given folder path.', status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error while doing scp" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    checkEventsWithparentEventsIdBot(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let currentEventId = input.eventId;
                let matchObj = {};
                for (let i = 1; i < 10; i++) {
                    if (!util_1.isNullOrUndefined(input['fieldMatch' + i]) && !util_1.isNullOrUndefined(input['valueMatch' + i]) && input['fieldMatch' + i].trim() != '') {
                        matchObj[input['fieldMatch' + i]] = input['valueMatch' + i];
                    }
                }
                if (input.fieldMatch && input.valueMatch) {
                    try {
                        matchObj[input.fieldMatch] = ObjectId(input.valueMatch);
                    }
                    catch (e) {
                        matchObj[input.fieldMatch] = input.valueMatch;
                    }
                }
                else {
                    let data = yield (db.collection('events')).findOne({ _id: ObjectId(currentEventId) }, { parentEventId: 1 });
                    data = JSON.parse(JSON.stringify(data));
                    matchObj = { parentEventId: ObjectId(data.parentEventId) };
                }
                console.log("Match Obj-------", matchObj);
                let eventsC = yield (db.collection('events')).find(matchObj, { eventStatus: 1 });
                eventsC = JSON.parse(JSON.stringify(eventsC));
                let completedCount = eventsC.filter(a => a.eventStatus == "Completed").length;
                if (completedCount >= eventsC.length - 1) {
                    outputParameters['nextflow'] = true;
                }
                else {
                    outputParameters['nextflow'] = false;
                    let res = yield (db.collection('events')).updateOne({ _id: ObjectId(currentEventId) }, { $set: { eventStatus: 'Completed' } });
                    console.log("ressss---->", res);
                }
                outputParameters['EventsCount'] = JSON.stringify(eventsC.length);
                outputParameters['completedCount'] = JSON.stringify(completedCount);
                console.log("outputParameters ------------", eventsC.map(a => a.eventStatus), outputParameters);
                return { message: '', status: 0, data: outputParameters };
            }
            catch (ex) {
                return { message: '', status: 1, data: ex };
            }
        });
    }
    checkEventsWithparentEventsIdBot1(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let currentEventId = input.eventId;
                let matchObj;
                if (input.fieldMatch && input.valueMatch) {
                    matchObj = {};
                    try {
                        matchObj[input.fieldMatch] = ObjectId(input.valueMatch);
                    }
                    catch (e) {
                        matchObj[input.fieldMatch] = input.valueMatch;
                    }
                }
                else {
                    let data = yield (db.collection('events')).findOne({ _id: ObjectId(currentEventId) }, { parentEventId: 1, additionalInfoVar: 1 });
                    data = JSON.parse(JSON.stringify(data));
                    matchObj = { parentEventId: ObjectId(data.parentEventId) };
                }
                console.log("Match Obj-------", matchObj);
                let eventsC = yield (db.collection('events')).find(matchObj);
                eventsC = JSON.parse(JSON.stringify(eventsC));
                let completedCount = eventsC.filter(a => a.eventStatus == "Completed").length;
                if (completedCount >= eventsC.length - 1) {
                    outputParameters['nextflow'] = true;
                }
                else {
                    outputParameters['nextflow'] = false;
                    let res = yield (db.collection('events')).updateOne({ _id: ObjectId(currentEventId) }, { $set: { eventStatus: 'Completed' } });
                    console.log("ressss---->", res);
                }
                console.log("outputParameters ------------", eventsC.map(a => a.eventStatus), outputParameters);
                return { message: '', status: 0, data: outputParameters };
            }
            catch (ex) {
                return { message: '', status: 1, data: ex };
            }
        });
    }
    matrixReconcilation(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let currentEventId = input.eventId;
                //         let reconcileFields = { 'Employee_Document' : {
                //             fields : ['Company_Name','Candidate_Name','Employee_Code','Candidate_DOJ','Candidate_DOR','Candidate_Designation','Candidate_Salary']
                //            },
                //        'Education_Document' : {
                //             fields :
                //             ['Candidate_Name','Register_Number','University_Name','College_Name','Name_Of_Degree',
                //    'Year_Of_Passing','Class_Obtained']
                //        }
                //            }
                let reconcileFields = input.reconcileFields && typeof input.reconcileFields == "object" ? input.reconcileFields : JSON.parse(input.reconcileFields);
                let data = yield (db.collection('events')).findOne({ _id: ObjectId(currentEventId) }, { parentEventId: 1 });
                data = JSON.parse(JSON.stringify(data));
                if (!data) {
                    throw "Event is not present";
                }
                let eventsC = yield (db.collection('events')).find({ parentEventId: ObjectId(data.parentEventId) });
                eventsC = JSON.parse(JSON.stringify(eventsC));
                let allRefs = eventsC.map(a => ({ refNo: a['additionalInfoVar']['ref_no'], docType: a['additionalInfoVar']['doc_type'] }));
                let prmArr = [];
                for (let obj of allRefs) {
                    prmArr.push((db.collection(obj['docType'])).findOne({ referenceNumber: obj['refNo'] }));
                }
                let resArr = yield Promise.all(prmArr);
                resArr = JSON.parse(JSON.stringify(resArr));
                resArr = resArr.reduce((final, obj) => {
                    final[obj['documentType']] = obj;
                    return final;
                }, {});
                // console.log(resArr);
                let Candidate_Name;
                let Company_Name;
                let csvArr = [];
                let demoObj = {
                    'Candidate Details': '',
                    'Value': '',
                    'QC Verification': '',
                    'TP Verification': '',
                    'QC Value': '',
                    'TP Value': ''
                };
                let BGVstatus = true;
                for (let docType in reconcileFields) {
                    let curData = resArr[docType];
                    let qcData = resArr['QC_Report'];
                    let tpData = resArr['TP_Report'];
                    for (let field of reconcileFields[docType]['fields']) {
                        let csvObj = JSON.parse(JSON.stringify(demoObj));
                        csvObj['Candidate Details'] = field;
                        csvObj['QC Value'] = qcData[field];
                        csvObj['TP Value'] = tpData[field];
                        csvObj['Value'] = curData[field];
                        if (field == 'Candidate_Name') {
                            Candidate_Name = curData[field] ? curData[field] : '';
                            Candidate_Name = qcData[field] ? qcData[field] : '';
                            Candidate_Name = tpData[field] ? tpData[field] : '';
                        }
                        else if (field == 'Company_Name') {
                            Company_Name = curData[field] ? curData[field] : '';
                            Company_Name = qcData[field] ? qcData[field] : '';
                            Company_Name = tpData[field] ? tpData[field] : '';
                        }
                        curData[field] = curData[field] ? curData[field] : '';
                        qcData[field] = qcData[field] ? qcData[field] : '';
                        tpData[field] = tpData[field] ? tpData[field] : '';
                        console.log(curData[field], qcData[field], tpData[field]);
                        let qcSimilarity = stringSimilarity.compareTwoStrings(String(curData[field]).toLowerCase(), String(qcData[field]).toLowerCase());
                        console.log(qcSimilarity);
                        let tpSimilarity = stringSimilarity.compareTwoStrings(String(curData[field]).toLowerCase(), String(tpData[field]).toLowerCase());
                        console.log(tpSimilarity);
                        if (util_1.isNullOrUndefined(qcData[field]) || qcData[field] == '') {
                            csvObj['QC Verification'] = 'NA';
                        }
                        else if (curData[field] == qcData[field] || qcSimilarity > 0.7) {
                            csvObj['QC Verification'] = 'Positive';
                        }
                        else {
                            csvObj['QC Verification'] = 'Negative';
                            BGVstatus = false;
                        }
                        if (util_1.isNullOrUndefined(tpData[field]) || tpData[field] == '') {
                            csvObj['TP Verification'] = 'NA';
                        }
                        else if (curData[field] == tpData[field] || tpSimilarity > 0.7) {
                            csvObj['TP Verification'] = 'Positive';
                        }
                        else {
                            csvObj['TP Verification'] = 'Negative';
                            BGVstatus = false;
                        }
                        for (let elm in csvObj) {
                            if (util_1.isNullOrUndefined(csvObj[elm])) {
                                csvObj[elm] = '';
                            }
                        }
                        csvArr.push(JSON.parse(JSON.stringify(csvObj)));
                    }
                }
                console.log(csvArr);
                const { Parser } = require('json2csv');
                const json2csvParser = new Parser();
                const csv = yield json2csvParser.parse(csvArr);
                const filepath = config.cudapath;
                const filename = `${Date.now()}_BGV.csv`;
                let fileStored = filepath + "/" + filename;
                // console.log("-------->,", csv)
                if (!util_1.isNullOrUndefined(filepath) && !util_1.isNullOrUndefined(csv)) {
                    fs.writeFileSync(fileStored, csv);
                }
                outputParameters['csvData'] = csvArr;
                outputParameters['csvPath'] = fileStored;
                // console.log("outputParameters ------------",allRefs, data,outputParameters)
                let obj = {
                    status: "Completed",
                    BGVstatus: BGVstatus ? "Successful" : "Unsuccessful"
                };
                if (Candidate_Name) {
                    obj['Candidate_Name'] = Candidate_Name;
                }
                if (Company_Name) {
                    obj['Company_Name'] = Company_Name;
                }
                let rD = yield (db.collection('BGV_Records', { timestamps: true })).update({ eventId: ObjectId(data.parentEventId) }, {
                    $set: obj
                }, { upsert: true });
                console.log("---------->", rD);
                return { message: '', status: 0, data: outputParameters };
            }
            catch (ex) {
                console.log("Error in reconcilation for BGV--", ex);
                return { message: '', status: 1, data: ex };
            }
        });
    }
    xlsxtojson(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let filePath = input.xlsxPath;
                let sName = input.sheetName ? input.sheetName : null;
                const workbook = XLSX.readFile(filePath);
                const sheetNameToUse = sName || workbook.SheetNames[0];
                const sheet = workbook.Sheets[sheetNameToUse];
                if (!sheet) {
                    throw new Error(`Sheet not found: ${sheetNameToUse}`);
                }
                const sheetData = XLSX.utils.sheet_to_json(sheet, {
                    header: 1,
                    blankrows: false,
                });
                if (sheetData.length === 0) {
                    throw new Error("Sheet is empty");
                }
                const headers = sheetData[0].map(header => header.trim());
                const validHeaders = headers.filter(header => header !== "");
                const jsonData = sheetData.slice(1).map(row => {
                    const rowObject = {};
                    validHeaders.forEach((header, colIndex) => {
                        rowObject[header] = row[colIndex] ? row[colIndex].toString().trim() : "";
                    });
                    return rowObject;
                }).filter(row => Object.values(row).some(value => value !== ""));
                console.log("jsonData length===>", jsonData.length);
                outputParameters['jsonData'] = jsonData;
                return { message: '', status: 0, data: outputParameters };
            }
            catch (ex) {
                console.log("Error in xlsxtojson--", ex);
                return { message: '', status: 1, data: ex };
            }
        });
    }
    csvToJson(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let filePath = input.csvPath;
                let delimiter = input.delimiter ? input.delimiter : ',';
                // Resolve the CSV file path
                const csvFilePath = path.resolve(filePath);
                // Check if the file exists
                if (!fs.existsSync(csvFilePath)) {
                    throw new Error("File not found");
                }
                const csv = require('csvtojson');
                // Use csvtojson to convert the CSV content to JSON
                const jsonData = yield csv({
                    delimiter: delimiter,
                    quote: '"',
                    trim: true // Trim fields for leading/trailing spaces
                }).fromFile(csvFilePath);
                console.log("jsonData length ===>", jsonData.length);
                // Add the parsed JSON to the output parameters
                outputParameters['jsonData'] = jsonData;
                outputParameters['jsonLength'] = jsonData.length;
                // Return success status with parsed JSON data
                return { message: '', status: 0, data: outputParameters };
            }
            catch (ex) {
                console.log("Error in csvtojson--", ex);
                return { message: '', status: 1, data: ex };
            }
        });
    }
    bulkUploadHelper(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const { inputArray, column_names, db_names, subscriberId, orgId } = input;
                const formatPhoneNumber = (number) => {
                    let cleanedNumber = number.replace(/[^0-9]/g, '');
                    if (cleanedNumber.length === 10) {
                        //cleanedNumber = '91' + cleanedNumber;
                    }
                    else if (cleanedNumber.startsWith('91') && cleanedNumber.length > 10) {
                    }
                    else {
                        cleanedNumber = cleanedNumber.replace(/^(\d{2})/, '');
                    }
                    return cleanedNumber;
                };
                const existingRecords = yield db.collection('leads').find({
                    $and: [
                        { subscriberId: subscriberId },
                        { orgId: orgId },
                        {
                            $or: [
                                { 'phoneNumber': { $in: inputArray.map(item => item['Phone Number']) } },
                                { 'emailAddress': { $in: inputArray.map(item => item['Email Address']) } }
                            ]
                        }
                    ]
                }).lean();
                const existingMobiles = existingRecords.map(record => record.phoneNumber);
                const existingEmails = existingRecords.map(record => record.emailAddress);
                const result = inputArray.filter(item => !existingMobiles.includes(formatPhoneNumber(item['Phone Number'])) && !existingEmails.includes(item['Email Address']));
                const formattedResult = result.map(item => {
                    if (item && item['Phone Number']) {
                        item['Phone Number'] = formatPhoneNumber(item['Phone Number']);
                    }
                    return item;
                });
                const columnNames = column_names.split(',').map(name => name.trim());
                const dbNames = db_names.split(',').map(name => name.trim());
                if (columnNames.length !== dbNames.length) {
                    throw new Error("columnNames and dbNames must have the same length");
                }
                const keyMapping = columnNames.reduce((acc, columnName, index) => {
                    acc[columnName] = dbNames[index];
                    return acc;
                }, {});
                const the_array = formattedResult.map(obj => {
                    return Object.keys(obj).reduce((newObj, key) => {
                        const newKey = keyMapping[key] || key;
                        newObj[newKey] = obj[key];
                        return newObj;
                    }, {});
                });
                outputParameters['outputArray'] = the_array;
                outputParameters['arrayLength'] = formattedResult.length;
                return { message: '', status: 0, data: outputParameters };
            }
            catch (ex) {
                console.log("Error in bulkUploadHelper", ex);
                return { message: '', status: 1, data: ex };
            }
        });
    }
    bulkUploader(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const { inputArray, globalObj, collection, subscriberId, orgId } = input;
                let uniqueArray = inputArray;
                if (!util_1.isNullOrUndefined(globalObj) && !util_1.isNullOrUndefined(collection)) {
                    const columns = globalObj.fieldArray;
                    const filter = globalObj.fieldKeyName;
                    const dbRes = yield db.collection(collection).find({ [filter]: { $in: columns }, subscriberId, orgId }).lean();
                    const result = dbRes.map(item => ({
                        socialMediaLink: item.socialMediaLink || null,
                        BusinessDevelopmentRepresentative: item.BusinessDevelopmentRepresentative || null,
                        ProductsInterest: item.ProductsInterest || null,
                        LeadSource: item.LeadSource || null,
                        InterestLevel: item.InterestLevel || null,
                        primaryContact: item.primaryContact || null,
                        departmentName: item.departmentName || null,
                        mailingAddress: item.mailingAddress || null,
                        mobile: item.mobile || null,
                        jobTitle: item.jobTitle || null,
                        name: item.name || null,
                        isSubscribed: true,
                        isDeleted: false,
                        companyId: item.companyId || null,
                        email: item.email || null,
                        eventId: item.eventId || null,
                        subscriberId: item.subscriberId || null,
                        orgId: item.orgId || null,
                        Industry: item.Industry || null,
                        companyName: item.companyName || null,
                        companyType: item.companyType || null,
                        companyInformation: item.companyInformation || null,
                        companyWebsite: item.companyWebsite || null,
                        leadCategory: item.leadCategory || null,
                        leadSubCategory: item.leadSubCategory || null,
                        noOfEmps: item.noOfEmps || null,
                        Revenue: item.Revenue || null
                    }));
                    const finalArray = [...inputArray, ...result];
                    const getUniqueKey = (item, fields) => {
                        return fields.map(field => item[field]).join('-');
                    };
                    const fieldsToCompare = ['email', 'mobile'];
                    uniqueArray = [...new Map(finalArray.map(item => {
                            const key = getUniqueKey(item, fieldsToCompare);
                            return [key, item];
                        })).values()];
                }
                const isValidEmail = (email) => {
                    if (email === null || email === "") {
                        return true;
                    }
                    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                    return emailRegex.test(email);
                };
                const filterValidEmails = (array) => {
                    return array.filter(item => isValidEmail(item['email']));
                };
                const newInputArray = filterValidEmails(uniqueArray);
                const outputArray = newInputArray.map(item => ({ 'socialMediaLink': item.socialMediaLink || null, 'BusinessDevelopmentRepresentative': item.BusinessDevelopmentRepresentative || null, 'ProductsInterest': item.ProductsInterest || null, 'LeadSource': item.LeadSource || null, 'InterestLevel': item.InterestLevel || null, 'primaryContact': item.primaryContact || null, 'departmentName': item.departmentName || null, 'mailingAddress': item.mailingAddress || null, 'phoneNumber': item.mobile || null, 'jobTitle': item.jobTitle || null, 'contactName': item.name || null, 'isSubscribed': true, 'isDeleted': false, 'companyId': item.companyId || null, 'emailAddress': item.email || null, 'eventId': item.eventId || null, 'subscriberId': item.subscriberId || null, 'orgId': item.orgId || null }));
                const output_detailed = newInputArray.map(item => ({ 'socialMediaLink': item.socialMediaLink || null, 'BusinessDevelopmentRepresentative': item.BusinessDevelopmentRepresentative || null, 'ProductsInterest': item.ProductsInterest || null, 'LeadSource': item.LeadSource || null, 'InterestLevel': item.InterestLevel || null, 'primaryContact': item.primaryContact || null, 'departmentName': item.departmentName || null, 'mailingAddress': item.mailingAddress || null, 'phoneNumber': item.mobile || null, 'jobTitle': item.jobTitle || null, 'contactName': item.name || null, 'isSubscribed': true, 'isDeleted': false, 'companyId': item.companyId || null, 'emailAddress': item.email || null, 'eventId': item.eventId || null, 'subscriberId': item.subscriberId || null, 'orgId': item.orgId || null, 'Industry': item.Industry || null, 'companyName': item.companyName || null, 'companyType': item.companyType || null, 'companyInformation': item.companyInformation || null, 'companyWebsite': item.companyWebsite || null, 'leadCategory': item.leadCategory || null, 'leadSubCategory': item.leadSubCategory || null, 'noOfEmps': item.noOfEmps || null, 'Revenue': item.Revenue || null }));
                // Step 1: Define the default structure
                const defaultTemplate = {
                    isMaster: false,
                    companyName: 'N/A',
                    Industry: 'N/A',
                    noOfEmps: null,
                    Revenue: null,
                    companyWebsite: 'N/A',
                    companyInformation: 'N/A',
                    leadCategory: 'N/A',
                    leadSubCategory: 'N/A',
                    enterpriseInfo: 'N/A',
                    companyType: 'N/A',
                    isDeleted: false
                };
                const additionalFields = {
                    eventId: input.eventId,
                    subscriberId: input.subscriberId,
                    orgId: input.orgId,
                    timeStamp: true // Used to conditionally add createdAt and updatedAt
                };
                // Process input array
                const updatedArray = output_detailed.map(input => {
                    // Start with the default template and merge with input data
                    let docData = Object.assign({}, defaultTemplate, {
                        companyName: input.companyName || 'N/A',
                        Industry: input.Industry || 'N/A',
                        noOfEmps: input.noOfEmps || null,
                        Revenue: input.Revenue || null,
                        leadCategory: input.leadCategory || 'N/A',
                        leadSubCategory: input.leadSubCategory || 'N/A',
                        companyType: input.companyType || 'N/A',
                        companyInformation: input.companyInformation || 'N/A',
                        companyWebsite: input.companyWebsite || 'N/A'
                    });
                    // Add additional fields
                    docData.eventId = ObjectId(additionalFields.eventId);
                    docData.subscriberId = ObjectId(additionalFields.subscriberId);
                    docData.orgId = ObjectId(additionalFields.orgId);
                    docData.isDeleted = false;
                    // Conditionally add createdAt and updatedAt
                    if (additionalFields.timeStamp) {
                        docData.createdAt = new Date();
                        docData.updatedAt = new Date();
                    }
                    return docData;
                });
                let saved_leads = 0;
                for (let i = 0; i < updatedArray.length; i++) {
                    const enterprise_doc = updatedArray[i];
                    const lead_doc = outputArray[i];
                    const savedDoc = yield db.collection('enterprisedetails').insertMany([enterprise_doc]);
                    const newDoc = Object.assign({}, lead_doc, { 'companyId': ObjectId(savedDoc[0]['_id']), 'subscriberId': ObjectId(input.subscriberId), 'orgId': ObjectId(input.orgId) });
                    const savedLeadDoc = yield db.collection('leads').insertMany([newDoc]);
                    if (!util_1.isNullOrUndefined(savedLeadDoc)) {
                        saved_leads += 1;
                    }
                }
                outputParameters['total_inserted'] = saved_leads;
                return { message: '', status: 0, data: outputParameters };
            }
            catch (e) {
                console.log("Error in bulkUploader", e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    mergeArrays(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const { inputArray, globalObj, collection, subscriberId, orgId } = input;
                let uniqueArray = [];
                if (!util_1.isNullOrUndefined(inputArray) && !util_1.isNullOrUndefined(globalObj) && !util_1.isNullOrUndefined(collection)) {
                    const columns = globalObj.fieldArray;
                    const filter = globalObj.fieldKeyName;
                    const dbRes = yield db.collection(collection).find({ [filter]: { $in: columns }, subscriberId: ObjectId(subscriberId), orgId: ObjectId(orgId) }).lean();
                    const result = dbRes.map(item => ({
                        phoneNumber: item.phoneNumber || null,
                        emailAddress: item.emailAddress || null,
                        eventId: item.eventId || null,
                        subscriberId: item.subscriberId || null,
                        orgId: item.orgId || null,
                    }));
                    const finalArray = [...inputArray, ...result];
                    const getUniqueKey = (item, fields) => {
                        return fields.map(field => item[field]).join('-');
                    };
                    const fieldsToCompare = ['emailAddress', 'phoneNumber'];
                    uniqueArray = [...new Map(finalArray.map(item => {
                            const key = getUniqueKey(item, fieldsToCompare);
                            return [key, item];
                        })).values()];
                }
                outputParameters['output_array'] = uniqueArray;
                return { message: '', status: 0, data: outputParameters };
            }
            catch (e) {
                console.log("Error in merge array", e);
                return { message: '', status: 1, data: e };
            }
        });
    }
    tableExtractionfromMailBody(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            let dummyPath = `${config.path.replace(/(\/)$/, '')}/dummy${Date.now()}.json`;
            try {
                // let htmlbody = input.htmlbody;
                let docType = input.docType;
                // const parsedHTML = this.parseHTMLFromEmail(htmlbody);
                // const tableData = this.extractTableDataFromHTML(parsedHTML);
                fs.writeFileSync(dummyPath, JSON.stringify(input));
                let daTa = yield this.sh(`node ${config.tableParseFromHtml} '${dummyPath}'`);
                console.log(daTa);
                let tableData = JSON.parse(daTa['output']);
                let tableStart;
                if (docType) {
                    let scanD = yield (db.collection('scanningfields')).findOne({ documentType: docType }).lean();
                    scanD = JSON.parse(JSON.stringify(scanD));
                    tableStart = scanD.tableStart;
                }
                let tableObj = [];
                if (tableData.headers && tableData.headers.length == 1) {
                    if (Array.isArray(tableStart) && tableStart.filter(a => tableData.headers.includes(a)).length == 0) {
                        outputParameters['tableFound'] = false;
                        return { message: '', status: 0, data: outputParameters };
                    }
                    for (let i = 0, len = tableData.rows.length; i < len; i++) {
                        let row = tableData.rows[i];
                        let obj = {};
                        for (let j = 0, rlen = tableData.headers.length; j < rlen; j++) {
                            obj[tableData.headers[j]] = row[j] ? row[j] : '';
                        }
                        tableObj.push(obj);
                    }
                }
                else if (tableData.headers && tableData.rows.length > 1) {
                    tableData.headers = tableData.rows[0];
                    if (Array.isArray(tableStart) && tableStart.filter(a => tableData.headers.includes(a)).length == 0) {
                        outputParameters['tableFound'] = false;
                        return { message: '', status: 0, data: outputParameters };
                    }
                    tableData.rows.shift();
                    for (let i = 0, len = tableData.rows.length; i < len; i++) {
                        let row = tableData.rows[i];
                        let obj = {};
                        for (let j = 0, rlen = tableData.headers.length; j < rlen; j++) {
                            obj[tableData.headers[j]] = row[j] ? row[j] : '';
                        }
                        tableObj.push(obj);
                    }
                }
                console.log(tableObj);
                outputParameters['tableObj'] = tableObj;
                outputParameters['tableFound'] = tableObj.length > 0 ? true : false;
                return { message: '', status: 0, data: outputParameters };
            }
            catch (ex) {
                console.log("Error in tableExtractionfromMailBody--", ex);
                return { message: '', status: 1, data: ex };
            }
            finally {
                fs.unlinkSync(dummyPath);
            }
        });
    }
    // public async docxtotext(input: any, outputParameters, botId, projectId, iterationId) {
    //     try {
    //         let filePath = input.docxPath;
    //         let data = await this.extractTextFromDocx(filePath)
    //         outputParameters['textData'] = data;
    //         // outputParameters['jsonData'] = jsonData;
    //         return { message: '', status: 0, data: outputParameters };
    //     }
    //     catch (ex) {
    //         console.log("Error in docxtotext--", ex)
    //         return { message: '', status: 1, data: ex };
    //     }
    // }
    // public async extractTextFromDocx(docxFilePath) {
    //     return new Promise((resolve, reject) => {
    //         // Read the file as a buffer
    //         const fileBuffer = fs.readFileSync(docxFilePath);
    //         // Extract the text from the DOCX file using Mammoth
    //         mammoth.extractRawText({ buffer: fileBuffer })
    //             .then((result) => {
    //                 const extractedText = result.value.trim();
    //                 resolve(extractedText.split('\n').filter(a => a != '').map(a => ({ line: a })));
    //             })
    //             .catch(reject);
    //     });
    // }
    docxtotextusingXMLs(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let filePath = input.docxPath;
                let zipDir = yield this.docxToZip(filePath);
                let data = yield this.extractXmlData(zipDir);
                outputParameters['textData'] = data['textData'];
                // outputParameters['jsonData'] = jsonData;
                return { message: '', status: 0, data: outputParameters };
            }
            catch (ex) {
                console.log("Error in docxtotext--", ex);
                return { message: '', status: 1, data: ex };
            }
        });
    }
    docxToZip(filePath) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const tempDir = path.join(config.path, `temp${Date.now()}`);
                const zipDir = path.join(tempDir, 'zip');
                if (!fs.existsSync(tempDir)) {
                    fs.mkdirSync(tempDir);
                }
                if (!fs.existsSync(zipDir)) {
                    fs.mkdirSync(zipDir);
                }
                const fileBaseName = path.basename(filePath);
                const zipFilePath = path.join(zipDir, `${fileBaseName}.zip`);
                fs.copyFileSync(filePath, zipFilePath);
                const zip = new AdmZip(zipFilePath);
                zip.extractAllTo(zipDir, true);
                console.log('File extracted to:', zipDir);
                return zipDir;
            }
            catch (e) {
                console.log("Error in docxToZip----", e);
                return "";
            }
        });
    }
    extractXmlData(zipPath) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const self = this;
            try {
                const parser = new xml2js.Parser({ explicitArray: false });
                let documentXml = `${zipPath}/word/document.xml`;
                let documentRelsXml = `${zipPath}/word/_rels/document.xml.rels`;
                let documentRelsData;
                const xmlData = fs.readFileSync(documentXml, 'utf8');
                try {
                    documentRelsData = fs.readFileSync(documentRelsXml, 'utf8');
                    documentRelsData = yield parser.parseStringPromise(documentRelsData);
                }
                catch (e) {
                    console.log("Error ------", e);
                }
                const jsonData = yield parser.parseStringPromise(xmlData);
                // console.log(jsonData);
                let textParas = [];
                let imagesArr = [];
                const paras = jsonData["w:document"]["w:body"]["w:p"];
                for (let para of paras) {
                    if (para['w:r']) {
                        let obj = {};
                        if (Array.isArray(para['w:r'])) {
                            obj['line'] = '';
                            for (let line of para['w:r']) {
                                if (line['w:t'] && line['w:t']._ && typeof line['w:t']._ == 'string') {
                                    obj['line'] = obj['line'] + line['w:t']._;
                                }
                                else if (typeof line['w:t'] == 'string') {
                                    obj['line'] = obj['line'] + String(line['w:t']).trim();
                                }
                            }
                        }
                        else {
                            obj['line'] = !para['w:r']['w:t'] || typeof para['w:r']['w:t'] != 'string' ? '' : para['w:r']['w:t'];
                        }
                        obj['text'] = true;
                        textParas.push(obj);
                    }
                    let data = this.checkImage(para, documentRelsData);
                    if (data) {
                        let obj = {};
                        obj['image'] = true;
                        let imagePath = `${zipPath}/word/${data}`;
                        if (fs.existsSync(imagePath)) {
                            let path = `${config.path}/${Date.now()}_${data.substring(data.lastIndexOf('/') + 1)}`;
                            fs.copyFileSync(imagePath, path);
                            obj['path'] = path;
                            imagesArr.push(obj);
                            textParas.push(obj);
                        }
                    }
                }
                // console.log(textParas)
                const tables = jsonData["w:document"]["w:body"]["w:tbl"];
                let tableObjs = [];
                for (let tab of tables) {
                    let rows = tab["w:tr"];
                    let headers = [];
                    let tObj = [];
                    for (let i = 0, len = rows.length; i < len; i++) {
                        if (i == 0) { //fetch headers
                            for (let col = 0, clen = rows[i]['w:tc'].length; col < clen; col++) {
                                headers.push(self.fetchText(rows[i]['w:tc'][col]["w:p"]));
                            }
                        }
                        else {
                            let obj = {};
                            for (let col = 0, clen = rows[i]['w:tc'].length; col < clen; col++) {
                                obj[headers[col]] = self.fetchText(rows[i]['w:tc'][col]["w:p"]);
                            }
                            tObj.push(JSON.parse(JSON.stringify(obj)));
                            console.log(tObj);
                        }
                    }
                    let lObj = {
                        headers: headers,
                        tableData: tObj,
                        table: true
                    };
                    tableObjs.push(JSON.parse(JSON.stringify(lObj)));
                }
                textParas = textParas.concat(tableObjs);
                return { textData: textParas, tableObjs: tableObjs, imageArr: imagesArr };
            }
            catch (e) {
                return {};
            }
        });
    }
    checkImage(obj, documentRelsData) {
        try {
            if (obj["w:r"]["w:drawing"]["wp:inline"]["a:graphic"]["a:graphicData"]["pic:pic"]["pic:blipFill"]["a:blip"].$["r:embed"]) {
                let iD = obj["w:r"]["w:drawing"]["wp:inline"]["a:graphic"]["a:graphicData"]["pic:pic"]["pic:blipFill"]["a:blip"].$["r:embed"];
                let image = documentRelsData['Relationships']['Relationship'].filter(a => a.$.Id == iD);
                image = image.length == 1 ? image[0].$.Target : null;
                return image;
            }
        }
        catch (e) {
            return null;
        }
    }
    fetchText(obj) {
        const self = this;
        try {
            if (Array.isArray(obj)) {
                return obj.reduce((res, a) => {
                    if (Array.isArray(a["w:r"])) {
                        res = res + self.fetchText(a);
                    }
                    else if (a["w:r"]) {
                        res = res + (typeof a["w:r"]['w:t'] == 'object' ? a["w:r"]['w:t']['_'] : a["w:r"]['w:t']);
                    }
                    return res;
                }, '').replace(/(undefined)/g, '');
            }
            else if (Array.isArray(obj["w:r"])) {
                return obj["w:r"].reduce((res, a) => {
                    res = res + (typeof a['w:t'] == 'object' ? a['w:t']['_'] : a['w:t']);
                    return res;
                }, '').replace(/(undefined)/g, '');
            }
            else if (obj['w:hyperlink']) {
                return self.fetchText(obj['w:hyperlink']);
            }
            else if (obj["w:r"]["w:t"]['_']) {
                return String(obj["w:r"]["w:t"]['_']);
            }
            else {
                return String(obj["w:r"]["w:t"]);
            }
        }
        catch (e) {
            console.log("Error ----", e);
            return '';
        }
    }
    docxUsingTemplateMapping(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let filePath = input.templateDocxPath;
                let data = input.data;
                let tableFormat = `<w:tbl>
            <w:tblPr>
            <w:tblW w:w="9690" w:type="dxa" />
            <w:jc w:val="left" />
            <w:tblInd w:w="421" w:type="dxa" />
            <w:tblCellMar>
                <w:top w:w="0" w:type="dxa" />
                <w:left w:w="7" w:type="dxa" />
                <w:bottom w:w="0" w:type="dxa" />
                <w:right w:w="7" w:type="dxa" />
            </w:tblCellMar>
            <w:tblLook w:val="01e0" />
            </w:tblPr>
            <w:tblGrid>
            <w:gridCol w:w="750" />
            <w:gridCol w:w="751" />
            <w:gridCol w:w="751" />
            <w:gridCol w:w="2288" />
            <w:gridCol w:w="790" />
            <w:gridCol w:w="910" />
            <w:gridCol w:w="3449" />
            </w:tblGrid>
<w:tr>
    <w:trPr>
        <w:trHeight w:val="371" w:hRule="atLeast" />
    </w:trPr>
    <w:tc>
        <w:tcPr>
            <w:tcW w:w="751" w:type="dxa" />
            <w:tcBorders>
                <w:top w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:left w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:bottom w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:right w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
            </w:tcBorders>
            <w:shd w:color="auto" w:fill="FFEBE5" w:val="clear" />
        </w:tcPr>
        <w:p>
            <w:pPr>
                <w:pStyle w:val="TableParagraph" />
                <w:spacing w:before="113" w:after="0" />
                <w:ind w:left="157" w:right="0" w:hanging="0" />
                <w:rPr>
                    <w:rFonts w:ascii="Arial" w:hAnsi="Arial" />
                    <w:b />
                    <w:b />
                    <w:sz w:val="13" />
                </w:rPr>
            </w:pPr>
            <w:r>

                <w:rPr>
                    <w:rFonts w:ascii="Arial" w:hAnsi="Arial" />
                    <w:b />
                    <w:color w:val="7F007F" />
                    <w:w w:val="105" />
                    <w:sz w:val="13" />
                </w:rPr>
                <w:t>Sr.</w:t>
            </w:r>
        </w:p>
    </w:tc>
    <w:tc>
        <w:tcPr>
            <w:tcW w:w="751" w:type="dxa" />
            <w:tcBorders>
                <w:top w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:left w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:bottom w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:right w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
            </w:tcBorders>
            <w:shd w:color="auto" w:fill="FFEBE5" w:val="clear" />
        </w:tcPr>
        <w:p>
            <w:pPr>
                <w:pStyle w:val="TableParagraph" />
                <w:spacing w:before="113" w:after="0" />
                <w:ind w:left="157" w:right="0" w:hanging="0" />
                <w:rPr>
                    <w:rFonts w:ascii="Arial" w:hAnsi="Arial" />
                    <w:b />
                    <w:b />
                    <w:sz w:val="13" />
                </w:rPr>
            </w:pPr>
            <w:r>

                <w:rPr>
                    <w:rFonts w:ascii="Arial" w:hAnsi="Arial" />
                    <w:b />
                    <w:color w:val="7F007F" />
                    <w:w w:val="105" />
                    <w:sz w:val="13" />
                </w:rPr>
                <w:t>Sr.</w:t>
            </w:r>
        </w:p>
    </w:tc>
    <w:tc>
        <w:tcPr>
            <w:tcW w:w="751" w:type="dxa" />
            <w:tcBorders>
                <w:top w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:left w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:bottom w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:right w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
            </w:tcBorders>
            <w:shd w:color="auto" w:fill="FFEBE5" w:val="clear" />
        </w:tcPr>
        <w:p>
            <w:pPr>
                <w:pStyle w:val="TableParagraph" />
                <w:spacing w:before="113" w:after="0" />
                <w:ind w:left="157" w:right="0" w:hanging="0" />
                <w:rPr>
                    <w:rFonts w:ascii="Arial" w:hAnsi="Arial" />
                    <w:b />
                    <w:b />
                    <w:sz w:val="13" />
                </w:rPr>
            </w:pPr>
            <w:r>

                <w:rPr>
                    <w:rFonts w:ascii="Arial" w:hAnsi="Arial" />
                    <w:b />
                    <w:color w:val="7F007F" />
                    <w:w w:val="105" />
                    <w:sz w:val="13" />
                </w:rPr>
                <w:t>Sr.</w:t>
            </w:r>
        </w:p>
    </w:tc>
    <w:tc>
        <w:tcPr>
            <w:tcW w:w="616" w:type="dxa" />
            <w:tcBorders>
                <w:top w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:left w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:bottom w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:right w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
            </w:tcBorders>
            <w:shd w:color="auto" w:fill="FFEBE5" w:val="clear" />
        </w:tcPr>
        <w:p>
            <w:pPr>
                <w:pStyle w:val="TableParagraph" />
                <w:spacing w:before="113" w:after="0" />
                <w:ind w:left="157" w:right="0" w:hanging="0" />
                <w:rPr>
                    <w:rFonts w:ascii="Arial" w:hAnsi="Arial" />
                    <w:b />
                    <w:b />
                    <w:sz w:val="13" />
                </w:rPr>
            </w:pPr>
            <w:r>
                <w:rPr>
                    <w:rFonts w:ascii="Arial" w:hAnsi="Arial" />
                    <w:b />
                    <w:color w:val="7F007F" />
                    <w:w w:val="105" />
                    <w:sz w:val="13" />
                </w:rPr>
                <w:t>Area</w:t>
            </w:r>
        </w:p>
    </w:tc>
    <w:tc>
        <w:tcPr>
            <w:tcW w:w="1711" w:type="dxa" />
            <w:tcBorders>
                <w:top w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:left w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:bottom w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:right w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
            </w:tcBorders>
            <w:shd w:color="auto" w:fill="FFEBE5" w:val="clear" />
        </w:tcPr>
        <w:p>
            <w:pPr>
                <w:pStyle w:val="TableParagraph" />
                <w:spacing w:before="113" w:after="0" />
                <w:ind w:left="132" w:right="121" w:hanging="0" />
                <w:jc w:val="center" />
                <w:rPr>
                    <w:rFonts w:ascii="Arial" w:hAnsi="Arial" />
                    <w:b />
                    <w:b />
                    <w:sz w:val="13" />
                </w:rPr>
            </w:pPr>
            <w:r>
                <w:rPr>
                    <w:rFonts w:ascii="Arial" w:hAnsi="Arial" />
                    <w:b />
                    <w:color w:val="7F007F" />
                    <w:w w:val="105" />
                    <w:sz w:val="13" />
                </w:rPr>
                <w:t>Constraint/</w:t>
            </w:r>
        </w:p>
    </w:tc>
    <w:tc>
        <w:tcPr>
            <w:tcW w:w="751" w:type="dxa" />
            <w:tcBorders>
                <w:top w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:left w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:bottom w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:right w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
            </w:tcBorders>
            <w:shd w:color="auto" w:fill="FFEBE5" w:val="clear" />
        </w:tcPr>
        <w:p>
            <w:pPr>
                <w:pStyle w:val="TableParagraph" />
                <w:spacing w:before="113" w:after="0" />
                <w:ind w:left="156" w:right="0" w:hanging="0" />
                <w:rPr>
                    <w:rFonts w:ascii="Arial" w:hAnsi="Arial" />
                    <w:b />
                    <w:b />
                    <w:sz w:val="13" />
                </w:rPr>
            </w:pPr>
            <w:r>
                <w:rPr>
                    <w:rFonts w:ascii="Arial" w:hAnsi="Arial" />
                    <w:b />
                    <w:color w:val="7F007F" />
                    <w:w w:val="105" />
                    <w:sz w:val="13" />
                </w:rPr>
                <w:t>Impact</w:t>
            </w:r>
        </w:p>
    </w:tc>
    <w:tc>
        <w:tcPr>
            <w:tcW w:w="731" w:type="dxa" />
            <w:tcBorders>
                <w:top w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:left w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:bottom w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:right w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
            </w:tcBorders>
            <w:shd w:color="auto" w:fill="FFEBE5" w:val="clear" />
        </w:tcPr>
        <w:p>
            <w:pPr>
                <w:pStyle w:val="TableParagraph" />
                <w:spacing w:before="113" w:after="0" />
                <w:ind w:left="156" w:right="0" w:hanging="0" />
                <w:rPr>
                    <w:rFonts w:ascii="Arial" w:hAnsi="Arial" />
                    <w:b />
                    <w:b />
                    <w:sz w:val="13" />
                </w:rPr>
            </w:pPr>
            <w:r>
                <w:rPr>
                    <w:rFonts w:ascii="Arial" w:hAnsi="Arial" />
                    <w:b />
                    <w:color w:val="7F007F" />
                    <w:w w:val="105" />
                    <w:sz w:val="13" />
                </w:rPr>
                <w:t>Status</w:t>
            </w:r>
        </w:p>
    </w:tc>
</w:tr>
<w:tr>
    <w:trPr>
        <w:trHeight w:val="278" w:hRule="atLeast" />
    </w:trPr>
    <w:tc>
        <w:tcPr>
            <w:tcW w:w="751" w:type="dxa" />
            <w:tcBorders>
                <w:top w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:left w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:bottom w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:right w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
            </w:tcBorders>
        </w:tcPr>
        <w:p>
            <w:pPr>
                <w:pStyle w:val="TableParagraph" />
                <w:spacing w:before="65" w:after="0" />
                <w:ind w:left="68" w:right="0" w:hanging="0" />
                <w:rPr>
                    <w:sz w:val="13" />
                </w:rPr>
            </w:pPr>
            <w:r>
                <w:rPr>
                    <w:color w:val="7F007F" />
                    <w:w w:val="105" />
                    <w:sz w:val="13" />
                </w:rPr>
                <w:t>NA</w:t>
            </w:r>
        </w:p>
    </w:tc>
    <w:tc>
        <w:tcPr>
            <w:tcW w:w="751" w:type="dxa" />
            <w:tcBorders>
                <w:top w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:left w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:bottom w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:right w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
            </w:tcBorders>
        </w:tcPr>
        <w:p>
            <w:pPr>
                <w:pStyle w:val="TableParagraph" />
                <w:spacing w:before="65" w:after="0" />
                <w:ind w:left="68" w:right="0" w:hanging="0" />
                <w:rPr>
                    <w:sz w:val="13" />
                </w:rPr>
            </w:pPr>
            <w:r>
                <w:rPr>
                    <w:color w:val="7F007F" />
                    <w:w w:val="105" />
                    <w:sz w:val="13" />
                </w:rPr>
                <w:t>NA</w:t>
            </w:r>
        </w:p>
    </w:tc>
    <w:tc>
        <w:tcPr>
            <w:tcW w:w="751" w:type="dxa" />
            <w:tcBorders>
                <w:top w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:left w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:bottom w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:right w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
            </w:tcBorders>
        </w:tcPr>
        <w:p>
            <w:pPr>
                <w:pStyle w:val="TableParagraph" />
                <w:spacing w:before="65" w:after="0" />
                <w:ind w:left="68" w:right="0" w:hanging="0" />
                <w:rPr>
                    <w:sz w:val="13" />
                </w:rPr>
            </w:pPr>
            <w:r>
                <w:rPr>
                    <w:color w:val="7F007F" />
                    <w:w w:val="105" />
                    <w:sz w:val="13" />
                </w:rPr>
                <w:t>NA</w:t>
            </w:r>
        </w:p>
    </w:tc>
    <w:tc>
        <w:tcPr>
            <w:tcW w:w="616" w:type="dxa" />
            <w:tcBorders>
                <w:top w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:left w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:bottom w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:right w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
            </w:tcBorders>
        </w:tcPr>
        <w:p>
            <w:pPr>
                <w:pStyle w:val="TableParagraph" />
                <w:spacing w:before="65" w:after="0" />
                <w:ind w:left="67" w:right="0" w:hanging="0" />
                <w:rPr>
                    <w:sz w:val="13" />
                </w:rPr>
            </w:pPr>
            <w:r>
                <w:rPr>
                    <w:color w:val="7F007F" />
                    <w:w w:val="105" />
                    <w:sz w:val="13" />
                </w:rPr>
                <w:t>NA</w:t>
            </w:r>
        </w:p>
    </w:tc>
    <w:tc>
        <w:tcPr>
            <w:tcW w:w="1711" w:type="dxa" />
            <w:tcBorders>
                <w:top w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:left w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:bottom w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:right w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
            </w:tcBorders>
        </w:tcPr>
        <w:p>
            <w:pPr>
                <w:pStyle w:val="TableParagraph" />
                <w:spacing w:before="65" w:after="0" />
                <w:ind w:left="132" w:right="119" w:hanging="0" />
                <w:jc w:val="center" />
                <w:rPr>
                    <w:sz w:val="13" />
                </w:rPr>
            </w:pPr>
            <w:r>
                <w:rPr>
                    <w:color w:val="7F007F" />
                    <w:w w:val="105" />
                    <w:sz w:val="13" />
                </w:rPr>
                <w:t>NA</w:t>
            </w:r>
        </w:p>
    </w:tc>
    <w:tc>
        <w:tcPr>
            <w:tcW w:w="751" w:type="dxa" />
            <w:tcBorders>
                <w:top w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:left w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:bottom w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:right w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
            </w:tcBorders>
        </w:tcPr>
        <w:p>
            <w:pPr>
                <w:pStyle w:val="TableParagraph" />
                <w:spacing w:before="65" w:after="0" />
                <w:ind w:left="67" w:right="0" w:hanging="0" />
                <w:rPr>
                    <w:sz w:val="13" />
                </w:rPr>
            </w:pPr>
            <w:r>
                <w:rPr>
                    <w:color w:val="7F007F" />
                    <w:w w:val="105" />
                    <w:sz w:val="13" />
                </w:rPr>
                <w:t>NA</w:t>
            </w:r>
        </w:p>
    </w:tc>
    <w:tc>
        <w:tcPr>
            <w:tcW w:w="731" w:type="dxa" />
            <w:tcBorders>
                <w:top w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:left w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:bottom w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
                <w:right w:val="single" w:sz="6" w:space="0" w:color="C0C6D0" />
            </w:tcBorders>
        </w:tcPr>
        <w:p>
            <w:pPr>
                <w:pStyle w:val="TableParagraph" />
                <w:spacing w:before="65" w:after="0" />
                <w:ind w:left="66" w:right="0" w:hanging="0" />
                <w:rPr>
                    <w:sz w:val="13" />
                </w:rPr>
            </w:pPr>
            <w:r>
                <w:rPr>
                    <w:color w:val="7F007F" />
                    <w:w w:val="105" />
                    <w:sz w:val="13" />
                </w:rPr>
                <w:t>NA</w:t>
            </w:r>
        </w:p>
    </w:tc>
</w:tr>
</w:tbl>`;
                let mediaFormat = `<w:p>
            <w:pPr>
                <w:pStyle w:val="Normal" />
                <w:jc w:val="center" />
                <w:rPr>
                    <w:rFonts w:ascii="Arial" w:hAnsi="Arial" w:cs="Arial" />
                    <w:lang w:val="en-GB" />
                </w:rPr>
            </w:pPr>
            <w:r>
                <w:rPr></w:rPr>
                <w:drawing>
                    <wp:inline distT="0" distB="0" distL="0" distR="0">
                        <wp:extent cx="6274435" cy="4521200" />
                        <wp:effectExtent l="0" t="0" r="0" b="0" />
                        <wp:docPr id="3" name="Picture 8" descr=""></wp:docPr>
                        <wp:cNvGraphicFramePr>
                            <a:graphicFrameLocks
                                xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"
                                noChangeAspect="1" />
                        </wp:cNvGraphicFramePr>
                        <a:graphic xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main">
                            <a:graphicData
                                uri="http://schemas.openxmlformats.org/drawingml/2006/picture">
                                <pic:pic
                                    xmlns:pic="http://schemas.openxmlformats.org/drawingml/2006/picture">
                                    <pic:nvPicPr>
                                        <pic:cNvPr id="3" name="Picture 8" descr=""></pic:cNvPr>
                                        <pic:cNvPicPr>
                                            <a:picLocks noChangeAspect="1" noChangeArrowheads="1" />
                                        </pic:cNvPicPr>
                                    </pic:nvPicPr>
                                    <pic:blipFill>
                                        <a:blip r:embed="gibots_Id"></a:blip>
                                        <a:stretch>
                                            <a:fillRect />
                                        </a:stretch>
                                    </pic:blipFill>
                                    <pic:spPr bwMode="auto">
                                        <a:xfrm>
                                            <a:off x="0" y="0" />
                                            <a:ext cx="6274435" cy="4521200" />
                                        </a:xfrm>
                                        <a:prstGeom prst="rect">
                                            <a:avLst />
                                        </a:prstGeom>
                                    </pic:spPr>
                                </pic:pic>
                            </a:graphicData>
                        </a:graphic>
                    </wp:inline>
                </w:drawing>
            </w:r>
            </w:p>`;
                let imageFormat = `<Relationship Id="gibots_Id"
            Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image"
            Target="media/gibots_Image" />`;
                let outputPath = input.outputDocxPath ? input.outputDocxPath : `${config.path.replace(/\/$/, '')}/output${Date.now()}.docx`;
                let zipDir = yield this.docxToZip(filePath);
                let documentXml = `${zipDir}/word/document.xml`;
                let documentXmlrels = `${zipDir}/word/_rels/document.xml.rels`;
                let mediaPath = `${zipDir}/word/media/`;
                let xmlData = fs.readFileSync(documentXml, 'utf8');
                let xmlRelsData = fs.readFileSync(documentXmlrels, 'utf8');
                // console.log("Mapping-----", data);
                const parser = new xml2js.Parser({ explicitArray: false, preserveOrder: true });
                const builder = new xml2js.Builder({ renderOpts: { pretty: true }, headless: true });
                const totalData = yield parser.parseStringPromise(xmlData);
                // Convert XML to JSON
                for (let key in data) {
                    if (typeof data[key] == 'string') {
                        if (/(Diagram)$/.test(key)) {
                            if (!fs.existsSync(mediaPath)) {
                                fs.mkdirSync(mediaPath);
                            }
                            try {
                                let path = String(data[key]);
                                let fileName = path.substring(path.lastIndexOf('/') + 1);
                                fs.copyFileSync(path, mediaPath + fileName);
                                console.log(path, mediaPath, fileName);
                                let filter = totalData["w:document"]["w:body"]["w:p"].filter(a => JSON.stringify(a).includes(`gibots_${key}`));
                                // let beReplace = builder.buildObject(filter[0]);
                                console.log(filter.length);
                                for (let para of filter) {
                                    let beReplace = builder.buildObject(para);
                                    let randomNo = String(Date.now());
                                    console.log("=============>", xmlData.includes(beReplace.replace(/(root)/g, 'w:p').replace(/>\s+</g, '><')));
                                    if (xmlData.includes(beReplace.replace(/(root)/g, 'w:p').replace(/>\s+</g, '><'))) {
                                        xmlData = xmlData.replace(beReplace.replace(/(root)/g, 'w:p').replace(/>\s+</g, '><'), mediaFormat.replace(/(gibots_Id)/g, randomNo));
                                        xmlRelsData = xmlRelsData.replace('<Relationship ', `${imageFormat.replace(/(gibots_Image)/g, fileName).replace(/(gibots_Id)/g, randomNo)}<Relationship `);
                                        // break;
                                    }
                                }
                            }
                            catch (e) {
                                console.log("Error in image copying...", e);
                            }
                        }
                        else {
                            // console.log(key, data[key]);
                            xmlData = xmlData.replace(`gibots_${key}`, data[key]);
                        }
                    }
                    else if (data[key] && Array.isArray(data[key]) && !key.includes('invoiceItems')) {
                        console.log("Array -------");
                        let headers = Object.keys(data[key][0]);
                        let tableData = data[key];
                        // console.log(headers,tableData);
                        // Convert XML to JSON
                        const jsonData = yield parser.parseStringPromise(tableFormat);
                        // console.log(jsonData);
                        for (let k = 1; k < tableData.length; k++) {
                            //adding rows into table
                            jsonData["w:tbl"]["w:tr"].push(JSON.parse(JSON.stringify(jsonData["w:tbl"]["w:tr"][jsonData["w:tbl"]["w:tr"].length - 1])));
                        }
                        let rows = jsonData["w:tbl"]["w:tr"];
                        let headerObj = {};
                        for (let k of headers) {
                            headerObj[k] = k;
                        }
                        tableData.unshift(headerObj);
                        console.log(headers, tableData);
                        for (let i = 0, len = rows.length; i < len; i++) {
                            let dump = JSON.parse(JSON.stringify(rows[i]['w:tc']));
                            rows[i]['w:tc'] = new Array();
                            for (let j = 0; j < headers.length; j++) {
                                let elt = dump[j];
                                elt["w:p"]["w:r"]["w:t"] = String(tableData[i][headers[j]]);
                                // console.log(elt["w:p"]["w:r"]["w:t"], tableData[i][headers[j]])
                                rows[i]['w:tc'].push(elt);
                            }
                        }
                        let xml = builder.buildObject(jsonData);
                        let filter = totalData["w:document"]["w:body"]["w:p"].filter(a => JSON.stringify(a).includes(`gibots_${key}`));
                        // let beReplace = builder.buildObject(filter[0]);
                        for (let para of filter) {
                            let beReplace = builder.buildObject(para);
                            console.log("=============>", xmlData.includes(beReplace.replace(/(root)/g, 'w:p').replace(/>\s+</g, '><')));
                            if (xmlData.includes(beReplace.replace(/(root)/g, 'w:p').replace(/>\s+</g, '><'))) {
                                xmlData = xmlData.replace(beReplace.replace(/(root)/g, 'w:p').replace(/>\s+</g, '><'), xml);
                                break;
                            }
                        }
                    }
                }
                fs.writeFileSync(documentXml, xmlData);
                fs.writeFileSync(documentXmlrels, xmlRelsData);
                const zip = new AdmZip();
                this.addDirectoryToZip(zip, zipDir, '');
                zip.writeZip(outputPath);
                outputParameters['outputPath'] = outputPath;
                console.log("Output Path--------", outputPath);
                return { message: '', status: 0, data: outputParameters };
            }
            catch (ex) {
                console.log("Error in docxUsingTemplateMapping--", ex);
                return { message: '', status: 1, data: ex };
            }
        });
    }
    addDirectoryToZip(zip, directoryPath, parentPath) {
        let self = this;
        const files = fs.readdirSync(directoryPath);
        files.forEach(function (file) {
            const filePath = path.join(directoryPath, file);
            const stat = fs.statSync(filePath);
            if (stat.isFile()) {
                const fileData = fs.readFileSync(filePath);
                const entryPath = parentPath ? path.join(parentPath, file) : file;
                zip.addFile(entryPath, fileData);
            }
            else if (stat.isDirectory()) {
                const subdirectoryPath = path.join(directoryPath, file);
                const subdirectoryParentPath = parentPath ? path.join(parentPath, file) : file;
                self.addDirectoryToZip(zip, subdirectoryPath, subdirectoryParentPath);
            }
        });
    }
    copyImagesinFileNameDir(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let imageArr = input.imageArr;
                let orgFilePath = input.orgFilePath;
                const originalFileName = orgFilePath.substr(orgFilePath.lastIndexOf('/') + 1).replace(/(\.pdf)$/, '');
                let newDirectory = path.join(config.cudapath, originalFileName + '/OriginalImages/');
                console.log(newDirectory);
                if (!fs.existsSync(newDirectory)) {
                    fs.mkdirSync(newDirectory, { recursive: true });
                }
                const renamedFiles = [];
                for (let i = 0; i < imageArr.length; i++) {
                    let file = imageArr[i].imageFilePath;
                    let ext = file.substr(file.lastIndexOf('.') + 1);
                    let newFilePath = `${newDirectory}${Date.now()}.${ext}`;
                    console.log(file, newFilePath);
                    fs.copyFileSync(file, newFilePath);
                    renamedFiles.push({ imageFilePath: newFilePath });
                }
                const arrayCount = renamedFiles.length;
                outputParameters['renamedFiles'] = renamedFiles;
                outputParameters['arrayCount'] = arrayCount;
                outputParameters['dirPath'] = config.cudapath + originalFileName;
                outputParameters['dmsDirName'] = originalFileName;
                console.log("outputParameters ------------", outputParameters);
                return { status: 0, "message": 'Successfull', data: outputParameters };
            }
            catch (ex) {
                this.log.error("Error " + ex);
                return { message: ex, status: 1, data: ex };
            }
        });
    }
    splitterBotusingMapping(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                //splitter bot using the mapping from scanningfields
                let imageArr = input.imageArr;
                let ocrData = input.ocr_output;
                let docType = input.docType;
                let dirPath = input.dirPath ? input.dirPath : config.cudapath;
                let scanFields = yield (db.collection('scanningfields')).findOne({ documentType: docType }).lean();
                scanFields = JSON.parse(JSON.stringify(scanFields));
                let splitterMapping = scanFields.splitterMapping;
                let pageMapping = [];
                for (let i = 0, len = ocrData.length; i < len; i++) {
                    let obj = ocrData[i];
                    let combineWords = obj.combineWords;
                    combineWords = combineWords.filter(a => a.Name).filter(a => a.Name != '');
                    if (combineWords.length == 0) {
                        let res = Object.keys(splitterMapping).filter(a => splitterMapping[a].length == 0);
                        if (res.length == 1) {
                            pageMapping.push({
                                page: i,
                                pageType: res[0]
                            });
                        }
                        else {
                            console.log("Not Found proper blank pageTypes---", res);
                        }
                    }
                    else {
                        for (let pageType in splitterMapping) {
                            let keywords = splitterMapping[pageType].map(a => String(a).toUpperCase());
                            let res = combineWords.filter(a => keywords.includes(a.Name.toUpperCase()));
                            if (res.length > 0) {
                                pageMapping.push({
                                    page: i,
                                    pageType: pageType
                                });
                                break;
                            }
                        }
                    }
                }
                let adhar = [];
                let pan = [];
                let bill = [];
                let photo = [];
                let bank = [];
                for (const item of pageMapping) {
                    switch (item.pageType) {
                        case "Aadhar_Document":
                            adhar.push(item.page);
                            break;
                        case "PAN_Document":
                            pan.push(item.page);
                            break;
                        case "Bill_Document":
                            bill.push(item.page);
                            break;
                        case "Photo_Document":
                            photo.push(item.page);
                            break;
                        case "BankStatement_Document":
                            bank.push(item.page);
                            break;
                        default:
                            break;
                    }
                }
                const adharpage = adhar.join(', ');
                const panpage = pan.join(', ');
                const billpage = bill.join(', ');
                const photopage = photo.join(', ');
                const bankstatementpage = bank.join(', ');
                console.log(pageMapping);
                let adharOcr = [];
                let adharFlag = false;
                const extractedData = {};
                for (let key of pageMapping) {
                    if (key.pageType == "Aadhar_Document") {
                        adharOcr = input.aadharData.filter(obj => obj.pageNo == key.page);
                        adharFlag = true;
                    }
                }
                if (adharFlag == true) {
                    function extractAadharNumber(text) {
                        const aadharRegex = /\b\d{4}\s?\d{4}\s?\d{4}\b/g;
                        const match = text.match(aadharRegex);
                        return match ? match[0] : null;
                    }
                    adharOcr.forEach((ocrData) => {
                        if (ocrData.text) {
                            const aadharNumber = extractAadharNumber(ocrData.text);
                            if (aadharNumber) {
                                extractedData.aadharNumber = aadharNumber;
                            }
                        }
                    });
                }
                let panOcr = [];
                let panFlag = false;
                const extractedData2 = {
                    panNumber: null
                };
                for (let key of pageMapping) {
                    if (key.pageType == "PAN_Document") {
                        panOcr = input.panData.filter(obj => obj.pageNo == key.page);
                        panFlag = true;
                    }
                }
                if (panFlag == true) {
                    function extractPANNumber(text) {
                        const panRegex = /\b[A-Z]{5}[0-9]{4}[A-Z]{1}\b/g;
                        const match = text.match(panRegex);
                        return match ? match[0] : null;
                    }
                    panOcr.forEach((item) => {
                        if (item.text) {
                            if (!extractedData2.panNumber) {
                                const panNumber = extractPANNumber(item.text);
                                if (panNumber) {
                                    extractedData2.panNumber = panNumber;
                                }
                            }
                        }
                    });
                }
                let adharpandata = {
                    "aadharNumber": extractedData.aadharNumber,
                    "panNumber": extractedData2.panNumber,
                    "adharpage": adharpage,
                    "panpage": panpage,
                    "billpage": billpage,
                    "photopage": photopage,
                    "bankstatementpage": bankstatementpage
                };
                console.log(adharpandata);
                let imagesToPdf = {};
                for (let page of pageMapping) {
                    if (imagesToPdf[page['pageType']]) {
                        imagesToPdf[page['pageType']].push(page['page']);
                    }
                    else {
                        imagesToPdf[page['pageType']] = [page['page']];
                    }
                }
                console.log(imagesToPdf);
                let mergedPdfs = [], prmArr = [];
                for (let pdf in imagesToPdf) {
                    let fileName = `${dirPath}/_${pdf}_${Date.now()}.pdf`;
                    let filePaths = imagesToPdf[pdf].map(a => imageArr[a].imageFilePath);
                    let inputIObj = {
                        "fileArray": filePaths,
                        "outputFilePath": fileName
                    };
                    console.log(inputIObj);
                    mergedPdfs.push(fileName);
                    let data = yield this.ImagetoPDF2(inputIObj, {}, '', '', '');
                    prmArr.push(data);
                }
                let reso = yield Promise.all(prmArr);
                if (reso.filter(a => a.status == 0).length == mergedPdfs.length) {
                    let arrayCount = mergedPdfs.length;
                    outputParameters['Invobj'] = adharpandata;
                    outputParameters['arrayCount'] = arrayCount;
                    outputParameters['dirPath'] = dirPath;
                    outputParameters['filePaths'] = mergedPdfs;
                    return { message: "PDFs merged", status: 0, data: outputParameters };
                }
                else {
                    throw "Some issue while merging";
                }
                return { status: 0, "message": 'Successfull', data: outputParameters };
            }
            catch (ex) {
                this.log.error("Error " + ex);
                return { message: ex, status: 1, data: ex };
            }
        });
    }
    ImagetoPDF2(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const PDFDocument = require('pdfkit');
                let fileArray = input.fileArray;
                let outputFilePath = input.outputFilePath;
                const doc = new PDFDocument();
                const stream = fs.createWriteStream(outputFilePath);
                doc.pipe(stream);
                fileArray.forEach((imagePath) => {
                    doc.image(imagePath, {
                        fit: [doc.page.width, doc.page.height],
                    });
                    doc.addPage();
                });
                doc.end();
                console.log('PDF conversion completed!');
                return { status: 0, "message": 'Successfull' };
            }
            catch (ex) {
                this.log.error("Error " + ex);
                return { message: ex, status: 1, data: ex };
            }
        });
    }
    checkIfHasBlankPage(invoiceItems) {
        try {
            const hasBlankPage = Object.values(invoiceItems.reduce((acc, item) => {
                acc[item.pageNo] = acc[item.pageNo] || [];
                acc[item.pageNo].push(item.Name);
                return acc;
            }, {})).some((names) => Array.isArray(names) && names.every((name) => name === ''));
            if (hasBlankPage) {
                return "YES";
            }
            else {
                return "NO";
            }
        }
        catch (error) {
            console.error('Error occurred while checking for blank pages:', error);
            return "NO";
        }
    }
    lookupHeaderFeildDataInJson(sponser, invoiceItems) {
        if (invoiceItems.some(element => element.Name === sponser)) {
            return "NO";
        }
        else {
            return "YES";
        }
    }
    movefile(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let self = this;
                let sourcefilepath = input.sourceFilepath;
                let desFilepath = input.desFilepath;
                let sudo = '';
                if (util_1.isNullOrUndefined(sourcefilepath) && util_1.isNullOrUndefined(desFilepath) && desFilepath == '' && sourcefilepath == '') {
                    throw "file path not found";
                }
                let date = new Date();
                // Delete the filePaths which already done in docType 
                let docTypeData = yield db.collection(input.collectionName).find({}).lean();
                let filenames = docTypeData.map(a => a['fileName']);
                let dirFiles = fs.readdirSync(sourcefilepath);
                for (const file of dirFiles) {
                    if (filenames.includes(file)) {
                        const filePath = path.join(sourcefilepath, file);
                        fs.unlinkSync(filePath);
                        console.log(`Deleted file: ${filePath}`);
                    }
                }
                const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
                desFilepath = desFilepath + '_' + date.getDate() + '_' + monthNames[date.getMonth()] + '_' + date.getFullYear() + '_' + date.getHours() + 'H_' + date.getMinutes() + 'M_' + date.getSeconds();
                if (fs.readdirSync(sourcefilepath).length > 0) {
                    if (!fs.existsSync(desFilepath)) {
                        fs.mkdirSync(desFilepath);
                    }
                    if (!util_1.isNullOrUndefined(input.sudo) && input.sudo !== '') {
                        sudo = 'sudo';
                    }
                    sourcefilepath = sourcefilepath[sourcefilepath.length - 1] == '/' ? sourcefilepath + '* ' : sourcefilepath + '/* ';
                    console.log(sudo + " mv " + sourcefilepath + desFilepath);
                    yield self.sh(sudo + " mv " + sourcefilepath + desFilepath);
                    outPut['folderPath'] = desFilepath;
                    outPut['fileslenght'] = 1;
                    return { message: "success", status: 0, data: outPut };
                }
                outPut['fileslenght'] = 0;
                return { message: "success", status: 0, data: outPut };
            }
            catch (e) {
                console.log('error : ', e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    restartInProgressBots(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const botRequest = require("request-promise");
            const self = this;
            try {
                console.log('<----INSIDE restartInProgressBots---->');
                let projectIds = typeof (input.projectIdAndBotId) == 'string' ? JSON.parse(input.projectIdAndBotId) : JSON.parse(JSON.stringify(input.projectIdAndBotId));
                let watchCount = input.watchCount ? input.watchCount : 1;
                //get all evetestatuses form according to projectids
                let eventIds;
                eventIds = yield (db.collection('eventstatuses')).find({
                    projectId: { "$in": projectIds.map(a => ObjectId(a)) },
                    "category": "Automatic",
                    isDeleted: false,
                    orchestratorStatus: "inProgress"
                }, { _id: 1, botId: 1, eventId: 1, watchCount: 1 }).lean();
                eventIds = !util_1.isNullOrUndefined(eventIds) ? eventIds : [];
                let restartBots = eventIds.filter(a => a.watchCount >= watchCount);
                //find all bots whose watchCount is matching
                console.log("restartBots===========>", restartBots);
                let updateQ = yield (db.collection('eventstatuses')).updateMany({
                    _id: { $in: restartBots.map(a => a._id).map(a => ObjectId(a)) },
                }, {
                    $set: {
                        orchestratorStatus: "Failed"
                    }
                });
                console.log(updateQ);
                updateQ = yield (db.collection('events')).updateMany({
                    _id: { $in: [...new Set(restartBots.map(a => a.eventId).map(a => ObjectId(a)))] },
                }, {
                    $set: {
                        eventStatus: "Failed"
                    }
                });
                console.log(updateQ);
                for (let obj of eventIds) {
                    if (util_1.isNullOrUndefined(obj['watchCount'])) {
                        obj['watchCount'] = 0;
                    }
                }
                let watchCountInc = eventIds.filter(a => a.watchCount < watchCount).map(a => a._id);
                console.log("watchCountInc===========>", watchCountInc);
                let uData = yield (db.collection('eventstatuses')).updateMany({
                    _id: { "$in": watchCountInc.map(a => ObjectId(a)) },
                }, { $inc: { watchCount: 1 } });
                for (let obj of restartBots) {
                    console.log("Restarting ----------", obj);
                    let token = input.token ? input.token : yield self.createToken(input.userId, input.subscriberId, input.orgId);
                    console.info(" --- AFTER TOKEN CREATION ----");
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    console.info(" -- BEFORE ADD TASK OPTIONS ---- ");
                    let options = {
                        "method": 'POST',
                        "url": env_2.env.routes.gibots_orch + "orchestrator/re-execute/bot",
                        "body": {
                            "taskId": obj._id,
                            "eventId": obj.eventId
                        },
                        "headers": {
                            'authorization': 'Bearer ' + token.replace(/^(Bearer )/g, '').trim(),
                            'Content-Type': "application/json",
                            "selectedorgid": input.orgId,
                            "selectedgstin": "123456789876543"
                        },
                        json: true
                    };
                    let botResult = yield botRequest(options);
                    console.log("Res========>", botResult);
                }
                console.log(uData);
                outPut['result'] = restartBots;
                return { message: "success", status: 0, data: outPut };
            }
            catch (e) {
                console.log('<----Error in cleanBotInputOutput---->', e);
                return { message: e, status: 1, data: [] };
            }
        });
    }
    startNotStartedTasks(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const botRequest = require("request-promise");
            const self = this;
            try {
                let limit = input.limit ? input.limit : 10;
                let projectIds = typeof (input.projectIdAndBotId) == 'string' ? JSON.parse(input.projectIdAndBotId) : JSON.parse(JSON.stringify(input.projectIdAndBotId));
                // Not-started
                let notStarted = yield (db.collection('events')).find({
                    projectId: { "$in": projectIds.map(a => ObjectId(a)) },
                    eventStatus: 'Not-started'
                }).limit(limit);
                notStarted = JSON.parse(JSON.stringify(notStarted));
                console.log("Not-Started---", notStarted.map(a => a._id));
                for (let obj of notStarted) {
                    console.log("Executing ----------", obj);
                    let token = input.token ? input.token : yield self.createToken(input.userId, input.subscriberId, input.orgId);
                    console.info(" --- AFTER TOKEN CREATION ----");
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    let options = {
                        "method": 'POST',
                        "url": env_2.env.routes.gibots_orch + "orchestrator/executeProject",
                        "body": {
                            "from": "join_event",
                            'projectId': obj.projectId,
                            "eventId": obj._id
                        },
                        "headers": {
                            'authorization': 'Bearer ' + token,
                            'Content-Type': "application/json",
                            "selectedorgid": obj.orgId,
                            "selectedgstin": "123456789876543"
                        },
                        json: true
                    };
                    console.info(" -- EXECUTE EVENT ---- ", options);
                    let botResult = yield botRequest(options);
                    console.log("Res========>", botResult['Status']);
                }
                return { message: "success", status: 0, data: outPut };
            }
            catch (e) {
                console.log('<----Error in cleanBotInputOutput---->', e);
                return { message: e, status: 1, data: [] };
            }
        });
    }
    DateBeforeWordRemove(DATE) {
        if (/^\D.*\d/.test(DATE)) {
            DATE = DATE.replace(/^[^\d]*/, '');
            return DATE;
        }
        else {
            return DATE;
        }
    }
    sendExcelDatatoInvoiceViewFeild(GST_number_I, Vendor_Name, invoice_number_I, TOTAL, val) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                console.log(GST_number_I, Vendor_Name, invoice_number_I, val);
                let data = yield db.collection('ramco_excel').find({}).lean();
                for (let x of data) {
                    let invoiceNumberSimilarity = stringSimilarity.compareTwoStrings(invoice_number_I.toString().toLowerCase(), x["Invoice number"].toString().toLowerCase());
                    let totalSimilarity = stringSimilarity.compareTwoStrings(TOTAL.toString().toLowerCase(), x["Invoice Amount"].toString().toLowerCase());
                    if (totalSimilarity > 0.9 || invoiceNumberSimilarity > 0.8) {
                        let result = {
                            "GST_amount_E": x["GST amount"],
                            "invoice_amount_E": x["Invoice Amount"],
                            "invoice_date_E": x["Invoice Date"],
                            "GST_number_E": x["GST Number"],
                            "Vendor_Name_E": x["Vendor Name"],
                            "invoice_number_E": x["Invoice number"]
                        };
                        var res;
                        for (var key in result) {
                            if (val === key) {
                                res = result[key];
                            }
                        }
                        // console.log(res);
                        return res;
                    }
                }
                return "Not Matched";
            }
            catch (e) {
                console.log("Error in function", e);
            }
            return "Not Matched err";
        });
    }
    ramcoMatchData(GST_number_I, Vendor_Name, invoice_number_I, TOTAL, value1, value2) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let data = yield db.collection('ramco_excel').find({}).lean();
                for (let x of data) {
                    let invoiceNumberSimilarity = stringSimilarity.compareTwoStrings(invoice_number_I.toString().toLowerCase(), x["Invoice number"].toString().toLowerCase());
                    let totalSimilarity = stringSimilarity.compareTwoStrings(TOTAL.toString().toLowerCase(), x["Invoice Amount"].toString().toLowerCase());
                    if (totalSimilarity > 0.9 || invoiceNumberSimilarity > 0.8) {
                        let num1 = isNaN(value1) ? value1.trim() : parseFloat(value1);
                        let num2 = isNaN(value2) ? value2.trim() : parseFloat(value2);
                        if (typeof num1 === 'number' && typeof num2 === 'number') {
                            let num1String = num1.toString();
                            let num2String = num2.toString();
                            let stringSimilarityValue = stringSimilarity.compareTwoStrings(num1String, num2String);
                            return stringSimilarityValue >= 0.6 ? "Matched" : "Not Matched";
                            //   return num1 === num2 ? "Matched" : "Not Matched";
                        }
                        else {
                            let stringSimilarityValue = stringSimilarity.compareTwoStrings(num1.toString().toLowerCase(), num2.toString().toLowerCase());
                            return stringSimilarityValue > 0.65 ? "Matched" : "Not Matched";
                        }
                    }
                }
                return "Not Matched";
            }
            catch (e) {
                console.log("Error in function", e);
            }
            return "Not Matched err";
        });
    }
    sumofGSTamt(input) {
        const numberArray = input.split(' ').map(Number);
        if (numberArray.some(isNaN)) {
            return input;
            const sumWithout2_5 = numberArray.filter(num => num !== 2.5).reduce((acc, num) => acc + num, 0);
            return sumWithout2_5;
        }
    }
    extractDetails(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                if (input.doctype === "adharDoc") {
                    // Aadhar extraction function
                    const aadharData = input.aadharData;
                    const extractedData = {};
                    let governmentOfIndiaFound = false;
                    // Function to extract Aadhar number using regex
                    function extractAadharNumber(text) {
                        const aadharRegex = /\b\d{4}\s?\d{4}\s?\d{4}\b/g;
                        let match = text.match(aadharRegex);
                        if (match != null) {
                            match = match[0].replace(/\D/g, '').replace(/(\d{4})(\d{4})(\d{4})/, '$1 $2 $3');
                        }
                        return match ? match : null;
                    }
                    // Function to extract Name using regex
                    function extractName(text) {
                        // Assuming the name is below the "Government of India" line
                        if (governmentOfIndiaFound) {
                            const nameRegex = /^[A-Za-z\s]+$/;
                            const words = text.trim().split(/\s+/);
                            const allWordsHaveSameCase = words.every(word => word[0].toUpperCase() === word[0]) ||
                                words.every(word => word[0].toLowerCase() === word[0]);
                            const excludedWords = [
                                "Government of India",
                                "Unique Identification No",
                                "Enrollment No",
                                "GOVERNMENT OFINDIA",
                                "GOVERNMENT",
                                "OFINDIA",
                                "wiqhw",
                                "aTEr"
                            ];
                            if (words.length >= 2 &&
                                words.length <= 4 &&
                                !excludedWords.some(word => text.includes(word)) &&
                                words.every(word => nameRegex.test(word)) &&
                                allWordsHaveSameCase) {
                                return text.trim();
                            }
                        }
                        return null;
                    }
                    function extractName2(text) {
                        const lowerText = text.toLowerCase();
                        if (lowerText.includes("of india") ||
                            lowerText.includes("government of india") ||
                            lowerText.includes("unique identification no") ||
                            lowerText.includes("enrollment no") ||
                            lowerText.includes("goverriment") ||
                            lowerText.includes("government") ||
                            lowerText.includes("identification")) {
                            return null;
                        }
                        if (text.length > 10) {
                            const nameRegex = /^[a-zA-Z\s]+$/;
                            let match;
                            if (nameRegex.test(text)) {
                                match = text;
                            }
                            return match;
                        }
                        return null;
                    }
                    // Function to extract DOB using regex
                    function extractDOB(text) {
                        const dobRegex = /(DOB|BIRTH|YEAR\sOF|yer|yr|year)[0-9/]+/gi;
                        let match = text.match(dobRegex);
                        if (dobRegex.test(text)) {
                            match = text;
                        }
                        if (match == null) {
                            const dobRegex2 = /\b(?:dob|birth|year|yer|yr)\b|\d{1,2}\/\d{1,2}\/\d{4}/gi;
                            match = text.match(dobRegex2);
                            if (dobRegex2.test(text)) {
                                match = text;
                            }
                        }
                        if (match) {
                            const dobString = match;
                            let digitsOnly = dobString.replace(/[^\d]/g, '');
                            let digitCount = digitsOnly.length;
                            if (digitCount > 6) {
                                if (digitCount < 8) {
                                    digitsOnly = "0" + digitsOnly;
                                }
                                const last8Digits = digitsOnly.slice(-8);
                                let formattedDate = last8Digits.replace(/(\d{2})(\d{2})(\d{4})/, '$1/$2/$3');
                                return formattedDate;
                            }
                            else {
                                return digitsOnly;
                            }
                            //                           const dob = dobString.replace(/[A-Za-z]/g, '');
                            //                          return dob;
                        }
                        return null;
                    }
                    function extractGender(text) {
                        const genderRegex = /(Male|Female|Transgender|AGT\/FEMALE|FEMALE|MALE)/i;
                        const match = text.match(genderRegex);
                        return match ? match[0] : null;
                    }
                    aadharData.forEach((item) => {
                        if (item.text) {
                            const lowerText = item.text ? item.text.toLowerCase() : item.text;
                            if (lowerText.includes("government of india") ||
                                lowerText.includes("unique identification no") ||
                                lowerText.includes("enrollment no") ||
                                lowerText.includes("government") ||
                                lowerText.includes("unique")) {
                                governmentOfIndiaFound = true;
                            }
                            // Extract Name
                            if (!extractedData.name && governmentOfIndiaFound) {
                                const name = extractName(item.text);
                                if (name) {
                                    extractedData.name = name;
                                }
                            }
                            // Extract Aadhar number
                            if (!extractedData.aadharNumber) {
                                const aadharNumber = extractAadharNumber(item.text);
                                if (aadharNumber) {
                                    extractedData.aadharNumber = aadharNumber;
                                }
                            }
                            // Extract DOB
                            if (!extractedData.dob) {
                                const dob = extractDOB(item.text);
                                if (dob) {
                                    extractedData.dob = dob;
                                }
                            }
                            // Extract Gender
                            if (!extractedData.gender) {
                                const gender = extractGender(item.text);
                                if (gender) {
                                    extractedData.gender = gender;
                                }
                            }
                        }
                    });
                    if (!extractedData.name) {
                        aadharData.forEach((item) => {
                            if (item.text) {
                                if (!extractedData.name && item.text.length > 2) {
                                    // Assuming the name will be at least three characters long to avoid shorter text
                                    extractedData.name = extractName2(item.text);
                                }
                            }
                        });
                    }
                    ;
                    if (extractedData.name != null) {
                        const extractedName = extractedData.name;
                        let pincodeRegex = /\b\d{6}\b/;
                        let mobileNumberRegex = /\b\d{10}\b/;
                        let pincodeOrMobileFound = false;
                        let x = "";
                        aadharData.forEach((item) => {
                            if (pincodeOrMobileFound) {
                                return;
                            }
                            if (item.text === extractedName) {
                                let startIndex = aadharData.indexOf(item) + 1;
                                for (let i = startIndex; i < aadharData.length; i++) {
                                    const currentItem = aadharData[i];
                                    if (currentItem.text) {
                                        if (currentItem.text.toLowerCase().includes("electronically") ||
                                            currentItem.text.includes("GRT3RI") ||
                                            currentItem.text.includes("AIo4CT")) {
                                            continue;
                                        }
                                    }
                                    if (currentItem.text) {
                                        const pincodeMatch = currentItem.text.match(pincodeRegex);
                                        const mobileNumberMatch = currentItem.text.match(mobileNumberRegex);
                                        const includesPincodeKeyword = currentItem.text.toLowerCase().includes("pincode");
                                        const includesMobileKeyword = currentItem.text.toLowerCase().includes("mobile");
                                        x = x + " " + currentItem.text;
                                        if (["dob", "gender", "male", "female", "birth date"].some((word) => x.toLowerCase().includes(word))) {
                                            break;
                                        }
                                        if (pincodeMatch || mobileNumberMatch || includesPincodeKeyword || includesMobileKeyword) {
                                            extractedData.address = x.trim();
                                            pincodeOrMobileFound = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        });
                    }
                    //for address from c/o s/o address words
                    if (extractedData.address == null) {
                        let pincodeRegex = /\b\d{6}\b/;
                        let mobileNumberRegex = /\b\d{10}\b/;
                        let pincodeOrMobileFound = false;
                        let startProcessing = false;
                        let x = "";
                        for (let i = 0; i < aadharData.length; i++) {
                            const item = aadharData[i];
                            if (item.text) {
                                if (item.text.toLowerCase().includes("electronically") ||
                                    item.text.includes("GRT3RI") ||
                                    item.text.includes("AIo4CT")) {
                                    continue;
                                }
                            }
                            if (pincodeOrMobileFound) {
                                break;
                            }
                            if (startProcessing) {
                                const currentItem = aadharData[i];
                                if (currentItem.text) {
                                    const pincodeMatch = currentItem.text.match(pincodeRegex);
                                    const mobileNumberMatch = currentItem.text.match(mobileNumberRegex);
                                    const includesPincodeKeyword = currentItem.text.toLowerCase().includes("pincode");
                                    const includesMobileKeyword = currentItem.text.toLowerCase().includes("mobile");
                                    x = x + " " + currentItem.text;
                                    if (["dob", "gender", "male", "female", "birth date"].some((word) => x.toLowerCase().includes(word))) {
                                        break;
                                    }
                                    if (pincodeMatch || mobileNumberMatch || includesPincodeKeyword || includesMobileKeyword) {
                                        extractedData.address = x.trim();
                                        pincodeOrMobileFound = true;
                                        break;
                                    }
                                }
                            }
                            if ((!startProcessing && item.text.toLowerCase().includes("c/o")) || (!startProcessing && item.text.toLowerCase().includes("s/o")) || (!startProcessing && item.text.toLowerCase().includes("address"))) {
                                startProcessing = true;
                            }
                        }
                    }
                    let filePath = input.filePath;
                    let fullName = filePath.substring(filePath.lastIndexOf('/') + 1);
                    let underscoreIndex = fullName.indexOf('_');
                    let fileName = fullName.substring(underscoreIndex + 6);
                    outputParameters['fileName'] = fileName;
                    outputParameters['Invobj'] = extractedData;
                    console.log("outputParameters ------------", outputParameters);
                    return { status: 0, message: 'Successful', data: outputParameters };
                }
                else if (input.doctype === "panDoc") {
                    // PAN extraction function
                    let panData = input.panData;
                    const extractedData = {
                        panNumber: null,
                        name: null,
                        dob: null
                    };
                    // Function to extract PAN number using regex
                    function extractPANNumber(text) {
                        const panRegex = /\b[A-Z]{5}[0-9]{4}[A-Z]{1}\b/g;
                        const match = text.match(panRegex);
                        return match ? match[0] : null;
                    }
                    // Function to extract PAN holder's name using the provided assumption
                    // function extractName(panData) {
                    //     const startKeyword = "INCOME TAX DEPARTMENT";
                    //     const endKeyword = "GOVT.OFINDIA";
                    //     const nameRegex = /^[A-Z\s]+$/;
                    //     let name = null;
                    //     let foundStartKeyword = false;
                    //     for (const item of panData) {
                    //         if (item.text) {
                    //             const lowerText = item.text.toUpperCase();
                    //             if (!foundStartKeyword && lowerText.includes(startKeyword)) {
                    //                 foundStartKeyword = true;
                    //             } else if (foundStartKeyword && lowerText.includes(endKeyword)) {
                    //                 break; // Exit the loop when the endKeyword is found
                    //             } else if (foundStartKeyword && nameRegex.test(item.text)) {
                    //                 // Assuming the name will be in uppercase letters and not contain any special characters
                    //                 name = item.text.trim();
                    //                 break; // Exit the loop after extracting the name
                    //             }
                    //         }
                    //     }
                    //     return name;
                    // }
                    function extractNameWithConditions(panData) {
                        const ignoredWords = [
                            "INCOME",
                            "TAX",
                            "DEPARTMENT",
                            "GOVT.OFINDIA",
                            "PERNANNT",
                            "PERMANENT",
                            "ACCOUNT",
                            "NUMBER",
                            "NAME",
                            "PAN",
                            "IPERMANENTACCOUNTNUMBER",
                            "GOVTOFINDIA",
                            "TANAEGEUANS",
                            "OFINDIA",
                            "TORA",
                            "GOVT",
                            "BIRAX",
                            "PERMUENT",
                            "BTQCBZ",
                            "AAYKAR"
                        ];
                        const nameRegex = /^[A-Z\s]{11,}$/;
                        let name = null;
                        for (const item of panData) {
                            if (item.text) {
                                const text = item.text.trim().toUpperCase();
                                const words = text.split(/\s+/);
                                const isIgnored = words.some((word) => ignoredWords.includes(word));
                                if (isIgnored) {
                                    continue; // Skip this item and move to the next one if any ignored word is found
                                }
                                if (nameRegex.test(text)) {
                                    name = text;
                                    break; // Exit the loop when we find a name that matches the regex
                                }
                            }
                        }
                        return name;
                    }
                    // Function to extract DOB using regex
                    function extractDOB(text) {
                        const dobRegex = /(?:\b\d{1,2}[\/-]\d{1,2}[\/-]\d{4}\b)/g;
                        const match = text.match(dobRegex);
                        return match ? match[0] : null;
                    }
                    // Sort the data based on topY coordinates to process in the correct order
                    //       panData.sort((a: any, b: any) => a.topY - b.topY);
                    // Extract PAN holder's name using the provided assumption
                    //     extractedData.name = extractName(panData);
                    if (extractedData.name == null)
                        extractedData.name = extractNameWithConditions(panData);
                    // Extract PAN number from each item in panData
                    panData.forEach((item) => {
                        if (item.text) {
                            if (!extractedData.panNumber) {
                                const panNumber = extractPANNumber(item.text);
                                if (panNumber) {
                                    extractedData.panNumber = panNumber;
                                }
                            }
                        }
                    });
                    panData.forEach((item) => {
                        if (item.text) {
                            if (!extractedData.dob) {
                                const extractedDOB = extractDOB(item.text);
                                if (extractedDOB) {
                                    extractedData.dob = extractedDOB;
                                }
                            }
                        }
                    });
                    let filePath = input.filePath;
                    let fullName = filePath.substring(filePath.lastIndexOf('/') + 1);
                    let underscoreIndex = fullName.indexOf('_');
                    let fileName = fullName.substring(underscoreIndex + 6);
                    outputParameters['fileName'] = fileName;
                    outputParameters['Invobj'] = extractedData;
                    console.log("outputParameters ------------", outputParameters);
                    return { status: 0, message: 'Successful', data: outputParameters };
                }
                else {
                    // Handle other document types or raise an error if needed
                    throw new Error("Unsupported document type: " + input.doctype);
                }
            }
            catch (ex) {
                console.error("Error: ", ex);
                return { message: ex, status: 1, data: ex };
            }
        });
    }
    Generate15DigitNumber() {
        const now = new Date();
        const day = String(now.getDate()).padStart(2, '0');
        const month = String(now.getMonth() + 1).padStart(2, '0');
        const year = String(now.getFullYear());
        const hours = String(now.getHours()).padStart(2, '0');
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');
        const randomFiveDigits = String(Math.floor(Math.random() * 9) + 1);
        const randomDdmmyyhhmmss = `${day}${month}${year}${hours}${minutes}${seconds}${randomFiveDigits}`;
        return randomDdmmyyhhmmss;
    }
    sendSmsNPCL(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let mobiles = input.Mobile;
                let url = input.url; //'https://api.onex-aura.com/api/jsms?'
                let key = input.key;
                let from = input.from;
                let entityId = input.entityId;
                let templateId = input.templateId;
                // partners = Array.isArray(partners) ? partners : [partners];
                // let data = await (db.collection('customer_data')).find({
                //     Partner : { $in : partners }
                // }).lean()
                // let mobiles = data.map(a=>a.Mobile);
                let message = input.message;
                mobiles = Array.isArray(mobiles) ? mobiles : [mobiles];
                const options = {
                    method: 'POST',
                    url: url,
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: {
                        key: key,
                        to: mobiles,
                        from: from,
                        body: message,
                        entityid: entityId,
                        templateid: templateId,
                    },
                    json: true
                };
                const response = yield request(options);
                console.log(options);
                console.log(response);
                return { message: "success", status: 0, data: outPut };
            }
            catch (e) {
                console.log("Error in function", e);
            }
            return "Not Matched err";
        });
    }
    formatDateHrs(dateString) {
        const date = new Date(dateString);
        const day = date.getDate();
        const month = date.getMonth() + 1; // Months are zero-indexed, so we add 1
        const year = date.getFullYear() % 100; // Get the last two digits of the year
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const formattedDate = `${day}/${month}/${year}`;
        const formattedTime = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')} hrs`;
        return `${formattedDate},${formattedTime}`;
    }
    insertFrequncyInDb(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let docData;
                if (typeof input.document == "object") {
                    docData = input.document;
                }
                else {
                    docData = JSON.parse(input.document);
                }
                let collectionName = input.collectionName;
                let dbdata = [];
                dbdata.push({ "orgId": "645a14c6d62b575541ffb6b4", "Frequency": docData.Frequency, "LastUpdatedDate": docData.LastUpdatedDate, "LastUpdatedTime": docData.LastUpdatedTime });
                let data = yield db.collection(collectionName, { timestamps: true }).insertMany(dbdata);
                let Frequency = dbdata[0].Frequency;
                let LastUpdatedDate = dbdata[0].LastUpdatedDate;
                let LastUpdatedTime = dbdata[0].LastUpdatedTime;
                console.log(data);
                Frequency = Frequency.toString();
                if (!output) {
                    output = {};
                }
                output['Frequency'] = Frequency;
                output['LastUpdatedDate'] = LastUpdatedDate;
                output['LastUpdatedTime'] = LastUpdatedTime;
                return { message: 'search key value found.', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "key not found", status: 1, data: err };
            }
        });
    }
    mergeInObj2(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let dbdata = [];
                dbdata.push({ "Frequency": input.Frequency, "LastUpdatedDate": input.LastUpdatedDate, "LastUpdatedTime": input.LastUpdatedTime });
                output['frequencyData'] = dbdata[0];
                return { message: 'ssuccessful', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "key not found", status: 1, data: err };
            }
        });
    }
    extractFieldsFromExcel(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                // extract fields from excel using the mapping
                const workbook = XLSX.readFile(input.excelPath);
                const worksheet = input.sheetName ? workbook.Sheets[input.sheetName] : workbook.Sheets[workbook.SheetNames[0]];
                let data = yield (db.collection("scanningfields")).findOne({ documentType: input.docType }).lean();
                data = JSON.parse(JSON.stringify(data));
                let excelMapping = data.excelMapping;
                let finalObj = {};
                for (let key in excelMapping) {
                    try {
                        let range = XLSX.utils.decode_range(excelMapping[key]);
                        let valueStr = '';
                        for (let row = range.s.r; row <= range.e.r; row++) {
                            for (let col = range.s.c; col <= range.e.c; col++) {
                                const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                                if (worksheet[cellAddress] && worksheet[cellAddress].w) {
                                    valueStr = valueStr.trim() + ' ' + worksheet[cellAddress].w.trim();
                                }
                                else {
                                    valueStr = valueStr.trim();
                                }
                            }
                        }
                        console.log(valueStr);
                        finalObj[key] = valueStr;
                    }
                    catch (e) {
                        console.log("Error for key---", key, excelMapping[key]);
                    }
                }
                output['excelObj'] = finalObj;
                return { message: 'ssuccessful', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "key not found", status: 1, data: err };
            }
        });
    }
    DocumentCorrection(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let docType = input.docType;
                let refNo = input.refNo;
                let scanD = yield (db.collection("scanningfields")).findOne({ documentType: docType }).lean();
                let docD = yield (db.collection(docType)).findOne({ referenceNumber: refNo }).lean();
                let fields = scanD.fields;
                // Correction for Numeric
                let numericFields = fields.filter(a => a.fieldType == 'number');
                for (let field of numericFields) {
                    if (docD[field['fieldName']] && docD[field['fieldName']] != '') {
                        docD[field['fieldName']] = String(docD[field['fieldName']]).replace(/[\s,]/g, ''); // replacing spaces from String
                        docD[field['fieldName']] = String(docD[field['fieldName']]).replace(/[\)\(\|\!I]/g, '1'); // replacing )(| to 1
                        docD[field['fieldName']] = String(docD[field['fieldName']]).replace(/[&]/g, '2'); // replacing )(| to 1
                        docD[field['fieldName']] = String(docD[field['fieldName']]).replace(/[s|S]/g, '5'); // replacing )(| to 1
                        docD[field['fieldName']] = String(docD[field['fieldName']]).replace(/[a-zA-Z\s]/g, ''); // replacing remanining alphabets
                    }
                    if (!util_1.isNullOrUndefined(Number(docD[field['fieldName']]))) {
                        docD[field['fieldName']] = Number(docD[field['fieldName']]);
                    }
                }
                // Correction for EmailFields
                let emailFields = fields.filter(a => a.fieldType == 'email');
                for (let field of emailFields) {
                    if (docD[field['fieldName']] && docD[field['fieldName']] != '') {
                        docD[field['fieldName']] = String(docD[field['fieldName']]).replace(/\s/g, ''); // replacing spaces from String
                        docD[field['fieldName']] = String(docD[field['fieldName']]).replace(/(\-com)/g, '.com');
                    }
                }
                // Correction for DateFeilds
                let dateFields = fields.filter(a => a.fieldType == 'date');
                for (let field of dateFields) {
                    if (docD[field['fieldName']] && docD[field['fieldName']] != '') {
                        docD[field['fieldName']] = String(docD[field['fieldName']]).replace(/\s/g, ''); // replacing spaces from String
                        docD[field['fieldName']] = String(docD[field['fieldName']]).replace(/[sS]/g, '5'); // replacing )(| to 1
                        docD[field['fieldName']] = String(docD[field['fieldName']]).replace(/[()|!{}\[\]]/g, '/');
                        docD[field['fieldName']] = String(docD[field['fieldName']]).replace(/[g]/g, '9');
                        let s = String(docD[field['fieldName']]);
                        s = s.replace(/[\s(]/gi, '');
                        s = s.length === 11 ? s.replace(/^0/, '') : s;
                        s = s.length === 10 && /^[0-9!()[\]{}|;/]*$/.test(s) ? s.split("").map((c, i) => i === 2 || i === 5 ? s.includes("-") ? "-" : "/" : c).join('') : s;
                        docD[field['fieldName']] = s;
                    }
                }
                // Correction with fuzzyMatch
                let fuzzyFields = fields.filter(a => a.isFuzzyMatch);
                for (let field of fuzzyFields) {
                    if (docD[field['fieldName']] && docD[field['fieldName']] != '' && field['fuzzyWords'] && Array.isArray(field['fuzzyWords'])) {
                        let words = docD[field['fieldName']].toString().split(' ');
                        for (let i = 0, len = words.length; i < len; i++) {
                            let match = stringSimilarity.findBestMatch(words[i], field['fuzzyWords']);
                            console.log(words[i], match.bestMatch);
                            if (!util_1.isNullOrUndefined(match.bestMatch.rating) && match.bestMatch.rating > 0.3 && !util_1.isNullOrUndefined(match.bestMatch.target)) {
                                words[i] = match.bestMatch.target;
                            }
                        }
                        docD[field['fieldName']] = words.join(' ');
                    }
                }
                // console.log(scanD,docD)
                let updateD = yield (db.collection(docType)).updateOne({ referenceNumber: refNo }, { $set: docD }).lean();
                console.log(updateD);
                output['invObj'] = docD;
                return { message: 'ssuccessful', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "key not found", status: 1, data: err };
            }
        });
    }
    mergeInObj(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let dbdata = [];
                dbdata.push({ "randomno": input.randomNum });
                output['randomObj'] = dbdata[0];
                return { message: 'ssuccessful', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "key not found", status: 1, data: err };
            }
        });
    }
    removePatternsFromString(inputString, removeWordsArr) {
        let result = inputString.toString();
        removeWordsArr.forEach(pattern => {
            result = result.replace(pattern, '');
        });
        return result.trim();
    }
    getStockDetails(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const newStock = new stocks_1.default({
                    "Stock Code": "",
                    "Stock Name": "",
                    "Stock Price": "",
                    category: "",
                });
                console.log(newStock);
                let Symbols = input.list.split(',');
                const axios = require('axios');
                // const SYMBOL = 'INFY';
                // let stocksToInsert = [];
                for (let index = 0; index < Symbols.length; index++) {
                    let SYMBOL = Symbols[index] + '.NS';
                    // const SYMBOL = Symbols[0];
                    const apiUrl = `https://query1.finance.yahoo.com/v8/finance/chart/${SYMBOL}`;
                    const response = yield axios.get(apiUrl);
                    if (response.status === 200) {
                        const data = response.data.chart.result[0];
                        const stockName = data.meta.symbol;
                        const latestTimestamp = data.timestamp[data.timestamp.length - 1];
                        const latestPrice = data.indicators.quote[0].close[data.timestamp.length - 1];
                        const stockCategory = data.meta.exchangeName;
                        console.log(`Stock Name: ${stockName}`);
                        console.log(`Latest Timestamp: ${latestTimestamp}`);
                        console.log(`Latest Price: ${latestPrice}`);
                        // Use findOneAndUpdate to update or insert data
                        const result = yield stocks_1.default.findOneAndUpdate({ "Stock Code": stockName }, {
                            "Stock Code": stockName,
                            "Stock Name": Symbols[index],
                            "Stock Price": latestPrice,
                            "category": stockCategory,
                            "LastUpdatedDatetime": new Date(latestTimestamp * 1000),
                            "latestTimestamp": new Date()
                        }, { upsert: true, new: true });
                        console.log(result);
                    }
                    else {
                        console.error('Failed to fetch data');
                    }
                    // if (response.data.chart) {
                    //     const result = response.data.chart.result[0];
                    //     const latestData = result.indicators.quote[0];
                    //     const timestamp = result.timestamp.map((ts) => new Date(ts * 1000));
                    //     console.log(`Stock Symbol: ${SYMBOL}`);
                    //     console.log(`---------------------------------------------`)
                    //     console.log(`Latest Open Price: ${latestData.open}`);
                    //     console.log(`\n Latest High Price: ${latestData.high}`);
                    //     console.log(`Latest Low Price: ${latestData.low}`);
                    //     console.log(`\n Latest Close Price: ${latestData.close}`);
                    //     console.log(`Latest Volume: ${latestData.volume}`);
                    //     console.log(`\n Timestamp: ${timestamp}`);
                    // } else {
                    //     console.error('No data available for this symbol.');
                    // }
                }
                // if (stocksToInsert.length > 0) {
                //     let saveD = await Stocks.insertMany(stocksToInsert);
                //     console.log(saveD)
                // }
                return { message: 'ServerPath is at given folder path.', status: 0, data: output };
            }
            catch (e) {
                this.log.error("Error while doing scp" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    xirrUpdation(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let maxIterations = input.maxIterations;
                let tolerance = input.tolerance;
                let totalClients = yield (db.collection('Cash')).find().lean();
                let prmArr = [];
                for (let client of totalClients) {
                    prmArr.push(this.xirrCal(client['Client_Name'], maxIterations, tolerance));
                }
                let resArr = yield Promise.all(prmArr);
                for (let i = 0, len = resArr.length; i < len; i++) {
                    totalClients[i]['xirr'] = resArr[i]['xirr'];
                    totalClients[i]['currValue'] = resArr[i]['currValue'];
                }
                prmArr = [];
                for (let client of totalClients) {
                    prmArr.push((db.collection('Cash')).findOneAndUpdate({ Client_Name: client['Client_Name'] }, { $set: { 'LastXIRR': client['xirr'], 'CurrentValuation': client['currValue'] } }));
                }
                resArr = yield Promise.all(prmArr);
                return { message: 'ServerPath is at given folder path.', status: 0, data: { res: resArr } };
            }
            catch (e) {
                this.log.error("Error while doing scp" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    xirrCal(user, maxIterations, tolerance) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let tras = yield (db.collection('Transaction')).find({ 'Client_Name': user, 'Status': 'Executed' }).lean();
                let exp = tras.map(a => ({ Buy_Sell: a['Buy_Sell'], Txn_Date_Time: a['Txn_Date_Time'], ExecutedValue: a['ExecutedValue'] }));
                const groupedData = {};
                exp.forEach(item => {
                    const date = item.Txn_Date_Time.split(' ')[0]; // Extract the date part
                    if (!groupedData[date]) {
                        groupedData[date] = {
                            amount: 0,
                        };
                    }
                    if (/buy/i.test(item['Buy_Sell'])) {
                        groupedData[date]['amount'] = groupedData[date]['amount'] + (-Number(item['ExecutedValue']));
                    }
                    else {
                        groupedData[date]['amount'] = groupedData[date]['amount'] + Number(item['ExecutedValue']);
                    }
                });
                let arr = [];
                for (let t in groupedData) {
                    arr.push({
                        amount: groupedData[t]['amount'], when: new Date(t)
                    });
                }
                let amounts = arr.map(a => a.amount);
                let dates = arr.map(a => a.when);
                let ress = yield this.curCal(user);
                amounts.push(ress['currValue']);
                dates.push(new Date());
                let rate = this.calculateXIRR(amounts, dates, maxIterations, tolerance);
                rate = (rate * 100).toFixed(2);
                console.log(user, amounts, dates, rate);
                return { xirr: rate, currValue: ress['currValue'] };
            }
            catch (e) {
                console.log("Err in xirrCalculation :", e);
                return { xirr: e };
            }
        });
    }
    calculateXIRR(cashflows, dates, mT, t, guess = 0.1) {
        // Initial guess for the XIRR rate (e.g., 0.1 for 10%)
        guess = guess || 0.1;
        // Maximum number of iterations and tolerance level
        let maxIterations = mT ? mT : 100000;
        let tolerance = t ? t : 0.000000001;
        let x0 = guess;
        let x1;
        let i = 0;
        do {
            let fValue = 0;
            let fDerivative = 0;
            for (let j = 0; j < cashflows.length; j++) {
                let days = (dates[j] - dates[0]) / (1000 * 60 * 60 * 24); // Convert milliseconds to days
                fValue += cashflows[j] / Math.pow(1 + x0, days / 365);
                fDerivative -=
                    ((days / 365) * cashflows[j]) / Math.pow(1 + x0, days / 365 - 1);
            }
            x1 = x0 - fValue / fDerivative;
            if (Math.abs(x1 - x0) < tolerance) {
                return x1;
            }
            x0 = x1;
            i++;
        } while (i < maxIterations);
        // If no convergence, return undefined or handle accordingly
        return 'NA';
    }
    currValueUpdation(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let totalClients = yield (db.collection('Cash')).find().lean();
                let prmArr = [];
                for (let client of totalClients) {
                    prmArr.push(this.curCal(client['Client_Name']));
                }
                let resArr = yield Promise.all(prmArr);
                for (let i = 0, len = resArr.length; i < len; i++) {
                    totalClients[i]['currValue'] = resArr[i]['currValue'];
                }
                prmArr = [];
                for (let client of totalClients) {
                    prmArr.push((db.collection('Cash')).findOneAndUpdate({ Client_Name: client['Client_Name'] }, { $set: { 'CurrentValuation': client['currValue'] } }));
                }
                resArr = yield Promise.all(prmArr);
                return { message: 'ServerPath is at given folder path.', status: 0, data: { res: resArr } };
            }
            catch (e) {
                this.log.error("Error while doing scp" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    curCal(user) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let tras = yield (db.collection('client_to_model')).find({ 'Client_Name': user }).lean();
                tras = Array.isArray(tras) ? tras : [tras];
                let stocks = tras.map(a => a['Stock_Name']);
                let stockPrices = yield (db.collection('Stocks')).find({
                    'Stock Name': { $in: stocks }
                }).lean();
                stockPrices = Array.isArray(stockPrices) ? stockPrices : [stockPrices];
                let sPrices = {};
                for (let stock of stockPrices) {
                    sPrices[stock['Stock Name']] = stock['Stock Price'];
                }
                let total = 0;
                for (let stock of tras) {
                    if (!util_1.isNullOrUndefined(sPrices[stock['Stock_Name']])) {
                        total = total + (stock['Allocated_Shares'] * sPrices[stock['Stock_Name']]);
                    }
                    else {
                        total = total + (stock['Allocated_Shares'] * stock['Last_Executed_Price']);
                    }
                }
                console.log(sPrices, total);
                return { currValue: total };
            }
            catch (e) {
                console.log("Err in currCalculation :", e);
                return { currValue: e };
            }
        });
    }
    extractTableFromExcel(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let allData = input.jsonData;
                let tableStart = input.tableStart;
                let tableEnd = input.tableEnd;
                for (let data of allData) {
                    let jsonArr = data["data"];
                    let tableSt, tableObj;
                    let tables = [];
                    let text = [];
                    for (let obj of jsonArr) {
                        let keys = Object.keys(obj);
                        let values = Object.values(obj);
                        if (util_1.isNullOrUndefined(tableSt) &&
                            values.map((a) => String(a).trim()).filter((a) => tableStart.includes(a))
                                .length) {
                            tableSt = obj;
                            tableObj = [];
                        }
                        else if (!util_1.isNullOrUndefined(tableSt) &&
                            values.map((a) => String(a).trim()).filter((a) => tableEnd.includes(a))
                                .length) {
                            tableSt = undefined;
                            tables.push(JSON.parse(JSON.stringify(tableObj)));
                            tableObj = [];
                            let eKeys = keys.filter((a) => !/(EMPTY)/.test(a));
                            values = [...eKeys, ...values];
                            for (let i = 0; i < values.length; i++) {
                                if (i > 0 && /^:/.test(String(values[i]).trim())) {
                                    text[text.length - 1] = text[text.length - 1] + values[i];
                                }
                                else {
                                    text.push(values[i]);
                                }
                            }
                        }
                        else if (tableSt) {
                            let tObj = {};
                            for (let i = 0; i < keys.length; i++) {
                                if (tableSt[keys[i]]) {
                                    obj["__EMPTY"] =
                                        obj["__EMPTY"] && typeof obj["__EMPTY"] == "string"
                                            ? obj["__EMPTY"]
                                            : "";
                                    tObj[tableSt[keys[i]]] =
                                        Object.keys(tableSt).length > 2 &&
                                            tableStart.includes(tableSt[keys[i]])
                                            ? obj[keys[i]] + " " + obj["__EMPTY"]
                                            : obj[keys[i]];
                                    tObj[tableSt[keys[i]]] = String(tObj[tableSt[keys[i]]]).trim();
                                }
                                else if (Object.keys(tableSt).length == 1) {
                                    let str = `Value_${i}`;
                                    tObj[str] = obj[keys[i]];
                                    tableSt[keys[i]] = str;
                                }
                            }
                            tableObj.push(tObj);
                        }
                        else {
                            let eKeys = keys.filter((a) => !/(EMPTY)/.test(a));
                            values = [...eKeys, ...values];
                            for (let i = 0; i < values.length; i++) {
                                if (i > 0 && /^:/.test(String(values[i]).trim())) {
                                    text[text.length - 1] = text[text.length - 1] + values[i];
                                }
                                else {
                                    text.push(values[i]);
                                }
                            }
                        }
                    }
                    if (tableObj.length) {
                        tables.push(JSON.parse(JSON.stringify(tableObj)));
                    }
                    console.log(tables);
                    data["data"] = tables;
                    data["text"] = [...new Set(text)];
                }
                output["tables"] = allData;
                console.log("ssssssssss-", allData[0]["data"][0]);
                return {
                    message: "ServerPath is at given folder path.",
                    status: 0,
                    data: output,
                };
            }
            catch (e) {
                this.log.error("Error while doing scp" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    compareTableFromExcel(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let j1 = input.standardData;
                let j2 = input.compareData;
                let tableName = input.tableName;
                const result = [];
                for (let i = 0; i < j1.length; i++) {
                    if (j2[i] && j1[i]["sheetName"] == j2[i]["sheetName"]) {
                        let oneD = j1[i]["data"];
                        let twoD = j2[i]["data"];
                        let oneT = j1[i]["text"]
                            .filter((a) => String(a).trim() != "")
                            .map((a) => a.trim());
                        let twoT = j2[i]["text"]
                            .filter((a) => String(a).trim() != "")
                            .map((a) => a.trim());
                        console.log(oneT, twoT);
                        if (oneT.length > twoT.length) {
                            for (let s = 0; s < oneT.length; s++) {
                                let key = oneT[s];
                                let match = twoT.filter((a) => a.toLowerCase() == key.toLowerCase());
                                if (match.length == 0 && twoT.length) {
                                    let bestMatch = stringSimilarity.findBestMatch(key.toLowerCase(), twoT.map((a) => a.toLowerCase()));
                                    console.log(key, bestMatch["bestMatch"]);
                                    if (bestMatch["bestMatch"]["rating"] < 0.8) {
                                        let defectObj = {
                                            DefectID: "Def_6",
                                            Date: new Date(),
                                            MainReport: j1[i]["filePath"],
                                            ReportName: j2[i]["filePath"],
                                            TabName: j1[i]["sheetName"],
                                            Remarks: "Note not found :" + ` '${key}'`,
                                        };
                                        result.push(defectObj);
                                    }
                                    else if (bestMatch["bestMatch"]["rating"] != 1) {
                                        let defectObj = {
                                            DefectID: "Def_1",
                                            Date: new Date(),
                                            MainReport: j1[i]["filePath"],
                                            ReportName: j2[i]["filePath"],
                                            TabName: j1[i]["sheetName"],
                                            Remarks: "Note mismatch :" +
                                                ` '${key}' is displayed as '${twoT[bestMatch["bestMatchIndex"]]}'`,
                                        };
                                        result.push(defectObj);
                                    }
                                }
                                else if (twoT.length == 0) {
                                    let defectObj = {
                                        DefectID: "Def_6",
                                        Date: new Date(),
                                        MainReport: j1[i]["filePath"],
                                        ReportName: j2[i]["filePath"],
                                        TabName: j1[i]["sheetName"],
                                        Remarks: "Note not found :" + ` '${key}'`,
                                    };
                                    result.push(defectObj);
                                }
                            }
                        }
                        else {
                            for (let s = 0; s < twoT.length; s++) {
                                let key = twoT[s];
                                let match = oneT.filter((a) => a.toLowerCase() == key.toLowerCase());
                                if (match.length == 0 && oneT.length) {
                                    let bestMatch = stringSimilarity.findBestMatch(key.toLowerCase(), oneT.map((a) => a.toLowerCase()));
                                    console.log(key, bestMatch["bestMatch"]);
                                    if (bestMatch["bestMatch"]["rating"] < 0.8) {
                                        let defectObj = {
                                            DefectID: "Def_6",
                                            Date: new Date(),
                                            MainReport: j1[i]["filePath"],
                                            ReportName: j2[i]["filePath"],
                                            TabName: j1[i]["sheetName"],
                                            Remarks: "Note not found :" + ` '${key}'`,
                                        };
                                        result.push(defectObj);
                                    }
                                    else if (bestMatch["bestMatch"]["rating"] != 1) {
                                        let defectObj = {
                                            DefectID: "Def_1",
                                            Date: new Date(),
                                            MainReport: j1[i]["filePath"],
                                            ReportName: j2[i]["filePath"],
                                            TabName: j1[i]["sheetName"],
                                            Remarks: "Note mismatch :" +
                                                ` '${key}' is displayed as '${oneT[bestMatch["bestMatchIndex"]]}'`,
                                        };
                                        result.push(defectObj);
                                    }
                                }
                                else if (oneT.length == 0) {
                                    let defectObj = {
                                        DefectID: "Def_6",
                                        Date: new Date(),
                                        MainReport: j1[i]["filePath"],
                                        ReportName: j2[i]["filePath"],
                                        TabName: j1[i]["sheetName"],
                                        Remarks: "Note not found :" + ` '${key}'`,
                                    };
                                    result.push(defectObj);
                                }
                            }
                        }
                        for (let k = 0; k < oneD.length; k++) {
                            for (let i = 0; i < oneD[k].length; i++) {
                                if (oneD[k][i]["Outflows"] &&
                                    /(Others)/i.test(oneD[k][i]["Outflows"]) &&
                                    i > 0 &&
                                    oneD[k][i - 1]["Outflows"]) {
                                    oneD[k][i]["Outflows"] =
                                        oneD[k][i]["Outflows"] + oneD[k][i - 1]["Outflows"];
                                }
                                if (oneD[k][i]["Inflows"] &&
                                    /(Others)/i.test(oneD[k][i]["Inflows"]) &&
                                    i > 0 &&
                                    oneD[k][i - 1]["Inflows"]) {
                                    oneD[k][i]["Inflows"] =
                                        oneD[k][i]["Inflows"] + oneD[k][i - 1]["Inflows"];
                                }
                            }
                        }
                        for (let k = 0; k < twoD.length; k++) {
                            for (let i = 0; i < twoD[k].length; i++) {
                                if (twoD[k][i]["Outflows"] &&
                                    /(Others)/i.test(twoD[k][i]["Outflows"]) &&
                                    i > 0 &&
                                    twoD[k][i - 1]["Outflows"]) {
                                    twoD[k][i]["Outflows"] =
                                        twoD[k][i]["Outflows"] + twoD[k][i - 1]["Outflows"];
                                }
                                if (twoD[k][i]["Inflows"] &&
                                    /(Others)/i.test(twoD[k][i]["Inflows"]) &&
                                    i > 0 &&
                                    twoD[k][i - 1]["Inflows"]) {
                                    twoD[k][i]["Inflows"] =
                                        twoD[k][i]["Inflows"] + twoD[k][i - 1]["Inflows"];
                                }
                            }
                        }
                        for (let k = 0; k < oneD.length; k++) {
                            if (twoD[k] && twoD[k].length) {
                                let table1 = oneD[k];
                                let table2 = twoD[k];
                                let oneHeaders = table1.length ? Object.keys(table1[0]) : [];
                                let twoHeaders = table2.length ? Object.keys(table2[0]) : [];
                                console.log(oneHeaders, twoHeaders);
                                if (JSON.stringify(oneHeaders.map((a) => a.trim())) ==
                                    JSON.stringify(twoHeaders.map((a) => a.trim())) &&
                                    oneHeaders.length == twoHeaders.length &&
                                    oneHeaders.length) {
                                    let header = oneHeaders[0];
                                    for (let row of table1) {
                                        let key = row[header];
                                        let valE = table2.filter((a) => a[header] == key);
                                        valE = valE.length ? valE[0] : {};
                                        for (let h of oneHeaders) {
                                            if (row[h] && valE[h]) {
                                                if (row[h].replace(/:/, "").trim() !=
                                                    valE[h].replace(/:/, "").trim()) {
                                                    let defectObj = {
                                                        DefectID: "Def_4",
                                                        Date: new Date(),
                                                        MainReport: j1[i]["filePath"],
                                                        ReportName: j2[i]["filePath"],
                                                        TabName: j1[i]["sheetName"],
                                                        Field: `Row name '${key}'`,
                                                        Remarks: "Table Values mismatch :" +
                                                            ` '${row[h]
                                                                .replace(/:/, "")
                                                                .trim()}' displayed as '${valE[h]
                                                                .replace(/:/, "")
                                                                .trim()}'`,
                                                    };
                                                    result.push(defectObj);
                                                }
                                            }
                                        }
                                    }
                                }
                                else if (oneHeaders.filter((element) => twoHeaders.includes(element)).length >
                                    4 &&
                                    oneHeaders.length == twoHeaders.length) {
                                    for (let h = 0; h < oneHeaders.length; h++) {
                                        if (oneHeaders[h].trim().toLowerCase() !=
                                            twoHeaders[h].trim().toLowerCase()) {
                                            let defectObj = {
                                                DefectID: "Def_2",
                                                Date: new Date(),
                                                MainReport: j1[i]["filePath"],
                                                ReportName: j2[i]["filePath"],
                                                TabName: j1[i]["sheetName"],
                                                Remarks: "Table Columns mismatch -" +
                                                    ` '${oneHeaders[h]}' displayed as '${twoHeaders[h]}'`,
                                            };
                                            result.push(defectObj);
                                        }
                                    }
                                    let header = oneHeaders[0];
                                    for (let row of table1) {
                                        if (row[header]) {
                                            let key = row[header].trim();
                                            let valE = table2.filter((a) => stringSimilarity.compareTwoStrings(String(a[header])
                                                .replace(/[:|\d]/g, "")
                                                .trim(), String(key)
                                                .replace(/[:|\d]/g, "")
                                                .trim()) > 0.9);
                                            valE = valE.length ? valE[0] : {};
                                            if (valE[header] &&
                                                row[header].replace(/[:|\d|\s]/g, "").trim() !=
                                                    valE[header].replace(/[:|\d|\s]/g, "").trim()) {
                                                let defectObj = {
                                                    DefectID: "Def_3",
                                                    Date: new Date(),
                                                    MainReport: j1[i]["filePath"],
                                                    ReportName: j2[i]["filePath"],
                                                    TabName: j1[i]["sheetName"],
                                                    Remarks: "Table Keys mismatch :" +
                                                        ` '${row[header]
                                                            .replace(/\([IVXLCDMivxlcdm]+\)/g, "")
                                                            .replace(/\d/g, "")}' displayed as '${valE[header]
                                                            .replace(/\([IVXLCDMivxlcdm]+\)/g, "")
                                                            .replace(/\d/g, "")}'`,
                                                };
                                                result.push(defectObj);
                                            }
                                            else if (JSON.stringify(valE) == "{}") {
                                                let defectObj = {
                                                    DefectID: "Def_5",
                                                    Date: new Date(),
                                                    MainReport: j1[i]["filePath"],
                                                    ReportName: j2[i]["filePath"],
                                                    TabName: j1[i]["sheetName"],
                                                    Remarks: "Table Row header missing :" + `${key}`,
                                                };
                                                result.push(defectObj);
                                            }
                                            for (let h = 1; h < oneHeaders.length; h++) {
                                                if (row[oneHeaders[h]] && valE[twoHeaders[h]]) {
                                                    if (/[a-zA-Z]/.test(row[oneHeaders[h]]) ||
                                                        /[a-zA-Z]/.test(valE[twoHeaders[h]])) {
                                                        let similarity = stringSimilarity.compareTwoStrings(String(row[oneHeaders[h]]).replace(/:/, "").trim(), String(valE[twoHeaders[h]]).replace(/:/, "").trim());
                                                        console.log(String(row[oneHeaders[h]]).replace(/:/, "").trim(), String(valE[twoHeaders[h]]).replace(/:/, "").trim(), similarity);
                                                        if (row[oneHeaders[h]] != valE[twoHeaders[h]] &&
                                                            similarity < 0.9) {
                                                            let defectObj = {
                                                                DefectID: "Def_4",
                                                                Date: new Date(),
                                                                MainReport: j1[i]["filePath"],
                                                                ReportName: j2[i]["filePath"],
                                                                TabName: j1[i]["sheetName"],
                                                                Field: `Column name '${oneHeaders[h]}' with  row name '${key}'`,
                                                                Remarks: "Table Values mismatch :" +
                                                                    ` '${row[oneHeaders[h]]}' displayed as '${valE[twoHeaders[h]]}'`,
                                                            };
                                                            result.push(defectObj);
                                                        }
                                                    }
                                                    else if (row[oneHeaders[h]] != valE[twoHeaders[h]] &&
                                                        Math.floor(row[oneHeaders[h]]) !=
                                                            Math.floor(valE[twoHeaders[h]])) {
                                                        console.log(row[oneHeaders[h]], valE[twoHeaders[h]], row[oneHeaders[h]] != valE[twoHeaders[h]]);
                                                        let defectObj = {
                                                            DefectID: "Def_4",
                                                            Date: new Date(),
                                                            MainReport: j1[i]["filePath"],
                                                            ReportName: j2[i]["filePath"],
                                                            TabName: j1[i]["sheetName"],
                                                            Field: `Column name '${oneHeaders[h]}' with  row name '${key}'`,
                                                            Remarks: "Table Values mismatch :" +
                                                                ` '${row[oneHeaders[h]]}' displayed as '${valE[twoHeaders[h]]}'`,
                                                        };
                                                        result.push(defectObj);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                else {
                                    let defectObj = {
                                        DefectID: "Def_2",
                                        Date: new Date(),
                                        MainReport: j1[i]["filePath"],
                                        ReportName: j2[i]["filePath"],
                                        TabName: j1[i]["sheetName"],
                                        Remarks: "Table Columns mismatch",
                                    };
                                    result.push(defectObj);
                                }
                            }
                            else {
                                let defectObj = {
                                    DefectID: "Def_0",
                                    Date: new Date(),
                                    MainReport: j1[i]["filePath"],
                                    ReportName: j2[i]["filePath"],
                                    TabName: j1[i]["sheetName"],
                                    Remarks: "Table is not present",
                                };
                                result.push(defectObj);
                            }
                        }
                    }
                    else {
                        let defectObj = {
                            DefectID: "Def_-1",
                            Date: new Date(),
                            MainReport: j1[i]["filePath"],
                            ReportName: j2[i]["filePath"],
                            TabName: j1[i]["sheetName"],
                            Remarks: "Sheet is not present",
                        };
                        result.push(defectObj);
                    }
                }
                console.log(result);
                output["defects"] = result;
                result.forEach((item) => {
                    item["orgId"] = String(input.orgId);
                });
                let r = yield db.collection(tableName).insertMany(result);
                console.log("Resssssssss-------", r);
                return {
                    message: "ServerPath is at given folder path.",
                    status: 0,
                    data: output,
                };
            }
            catch (e) {
                this.log.error("Error while doing scp" + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    moveFileintoDir(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let filePath = !util_1.isNullOrUndefined(input.filePath) && typeof input.filePath == 'string' ? input.filePath : input.filePath;
                let dest = input.destPath;
                let check = !util_1.isNullOrUndefined(input.check) && typeof input.check == 'string' ? JSON.parse(input.check) : input.check;
                if (check == true) {
                    for (let index = 0; index < filePath.length; index++) {
                        yield fs.renameSync(filePath[index], dest + filePath[index].substring(filePath[index].lastIndexOf('/')));
                        //for all files to move to another folder
                    }
                }
                else {
                    if (typeof input.filePath == 'string')
                        yield fs.renameSync(filePath, dest + filePath.substring(filePath.lastIndexOf('/')));
                    else
                        yield fs.renameSync(filePath[0], dest + filePath[0].substring(filePath[0].lastIndexOf('/')));
                    //single file move to another folder
                }
                outputParameters["update"] = "Done";
                console.log(outputParameters);
                return { message: 'Your file has been moved', status: 0, data: outputParameters };
            }
            catch (e) {
                console.log("Error in Socket triggering to read google sheet.", e);
                return { message: e, status: 1, data: e + '[ eventId - ' + input.eventId + ' projectId - ' + projectId + ' botId - ' + botId + ' iterationId - ' + iterationId + ']' };
            }
        });
    }
    mergeInObj3(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let dbdata = [];
                dbdata.push({ "Acknowledgement_No": input.Acknowledgement_No, "Claim_No": input.Claim_No });
                output['randomObj'] = dbdata[0];
                return { message: 'ssuccessful', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "key not found", status: 1, data: err };
            }
        });
    }
    ConcatExcel(input, outputParameters, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = {
                    "excel": input.excel,
                    "excel1": input.excel1,
                    "outputPath": input.outputPath,
                    "key": input.key,
                    "excel2": input.excel2,
                    "excel3": input.excel3,
                    "excel4": input.excel4,
                    "outputPath1": input.outputPath1,
                    "key1": input.key1,
                    "T1": input.T1,
                    "K1": input.K1,
                    "projectId": projectId,
                    "botId": botId,
                    "iterationId": iterationId,
                    "eventId": input.eventId,
                    "from": 'ConcatExcel',
                    ///"userId": input.userId,
                    "accessControlList": input.accessControlList
                };
                this.socket.emit('trigger-event2', JSON.stringify(obj));
                this.log.info("Socket triggering to read files from folder.");
                return { message: 'Socket triggering to read file from folder.', status: 0, data: null };
            }
            catch (e) {
                this.log.error("Error in Socket triggering for read file utility." + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    tableThroughCustomRegex(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let data = input.combineLines;
                let rowregex = input.rowregex;
                let tableKeys = input.tableCols;
                let totalStrings = [];
                try {
                    tableKeys = JSON.parse(tableKeys);
                }
                catch (e) {
                    tableKeys = input.tableCols;
                }
                for (let row of data) {
                    totalStrings = totalStrings.concat(row.lineWithCombineWordsNew
                        .map((a) => a.reduce((acc, obj) => {
                        if (obj) {
                            if (!acc["Name"]) {
                                acc = JSON.parse(JSON.stringify(obj));
                            }
                            else {
                                acc["Name"] =
                                    acc["Name"] + " " + (obj["Name"] ? obj["Name"] : "");
                                acc["rightX"] = obj["rightX"] ? obj["rightX"] : acc["rightX"];
                            }
                        }
                        return acc;
                    }, {}))
                    // .map((a) => a["Name"])
                    );
                }
                console.log("Stringss---", totalStrings.length, rowregex);
                const regex = new RegExp(rowregex);
                let matchingStrings = totalStrings.filter(str => regex.test(str["Name"]));
                let tableObj = [];
                let tableCo = [];
                for (let str of matchingStrings) {
                    const match = str["Name"].match(regex);
                    let obj = {};
                    if (match) {
                        let i = 1;
                        for (let key of tableKeys) {
                            if (match[i]) {
                                obj[key] = match[i];
                            }
                            i++;
                        }
                    }
                    tableObj.push(obj);
                    tableCo.push({
                        pageNo: String(str["pageNo"]),
                        leftX: str["leftX"],
                        rightX: str["rightX"],
                        topY: str["topY"],
                        bottomY: str["bottomY"],
                    });
                }
                if (input.tableName) {
                    let Oobj = {};
                    Oobj[input.tableName] = tableObj;
                    output['tableObj'] = Oobj;
                    tableCo = tableCo.filter(a => a['tableName'] = input.tableName);
                    let Cobj = {};
                    Cobj[input.tableName] = tableCo;
                    output['tableCo'] = Cobj;
                }
                else {
                    output['tableObj'] = tableObj;
                    output['tableCo'] = tableCo;
                }
                console.log(matchingStrings, JSON.stringify(output));
                return { message: 'ssuccessful', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "key not found", status: 1, data: err };
            }
        });
    }
    reconcileWithPDFData(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let combineLData = input.combineLines;
                let reconcileData = input.reconcileData;
                let fieldsInfo = input.fieldsInfo;
                let refNo = input.refNo;
                let fileType = input.fileType;
                let totalStrings = [];
                let totalWords = [];
                let totalRaws = [];
                for (let row of combineLData) {
                    totalStrings = totalStrings.concat(row.lineWithCombineWordsNew
                        .map((a) => a.reduce((acc, obj) => {
                        if (obj) {
                            if (!acc["Name"]) {
                                acc = JSON.parse(JSON.stringify(obj));
                            }
                            else {
                                acc["Name"] =
                                    acc["Name"] + " " + (obj["Name"] ? obj["Name"] : "");
                                acc["rightX"] = obj["rightX"] ? obj["rightX"] : acc["rightX"];
                            }
                        }
                        return acc;
                    }, {}))
                        .map((a) => a["Name"]));
                    totalWords = totalWords.concat(row.docFeatures);
                    totalRaws = totalRaws.concat(row.raw);
                }
                console.log(totalStrings.length, totalWords.length);
                let keyValue = fieldsInfo.map((a) => ({
                    key: Object.keys(a)[0],
                    value: Object.values(a)[0],
                }));
                console.log(reconcileData);
                let finalRes = {};
                for (let obj of keyValue) {
                    if (reconcileData[obj["key"]]) {
                        finalRes[`${obj["key"]}`] = reconcileData[obj["key"]];
                        finalRes[`${obj["key"]}_Reconcile`] = "";
                        finalRes[`${obj["key"]}_Status`] = "";
                        if (reconcileData[obj["key"]] != "NA") {
                            let directSearch = totalStrings.filter((a) => a.toLowerCase().includes(reconcileData[obj["key"]].toLowerCase()));
                            console.log(obj, reconcileData[obj["key"]], directSearch);
                            if (directSearch.length == 1) {
                                finalRes[`${obj["key"]}_Reconcile`] = reconcileData[obj["key"]];
                                finalRes[`${obj["key"]}_Status`] = "ExactMatch";
                            }
                            else if (directSearch.length > 1) {
                                let vals = obj["value"];
                                let leftii = vals["left"].map((a) => String(a) + reconcileData[obj["key"]]);
                                let lmatches = leftii.filter((elementA) => directSearch.some((elementB) => elementB.toLowerCase().includes(elementA.toLowerCase())));
                                console.log("leftMatches---", lmatches);
                                if (lmatches.length) {
                                    finalRes[`${obj["key"]}_Reconcile`] = lmatches[0];
                                    finalRes[`${obj["key"]}_Status`] = "ExactMatch";
                                    continue;
                                }
                                let rightii = vals["right"].map((a) => reconcileData[obj["key"]] + String(a));
                                let rmatches = rightii.filter((elementA) => directSearch.some((elementB) => elementB.toLowerCase().includes(elementA.toLowerCase())));
                                console.log("rightMatches---", rmatches);
                                if (rmatches.length) {
                                    finalRes[`${obj["key"]}_Reconcile`] = rmatches[0];
                                    finalRes[`${obj["key"]}_Status`] = "ExactMatch";
                                    continue;
                                }
                            }
                            if (finalRes[`${obj["key"]}_Status`] == "") {
                                let directSearch = totalWords
                                    .filter((a) => a["Name"])
                                    .filter((a) => a["Name"]
                                    .toLowerCase()
                                    .includes(reconcileData[obj["key"]].toLowerCase()));
                                if (directSearch.length == 0) {
                                    directSearch = totalRaws
                                        .filter((a) => a["Name"])
                                        .filter((a) => a["Name"]
                                        .toLowerCase()
                                        .includes(reconcileData[obj["key"]].toLowerCase()));
                                }
                                console.log(obj, reconcileData[obj["key"]], directSearch.length);
                                if (directSearch.length) {
                                    let vals = obj["value"];
                                    if (isNaN(obj["value"]) &&
                                        vals["left"].length == 0 &&
                                        vals["right"].length == 0 &&
                                        vals["top"].length == 0 &&
                                        vals["bottom"].length == 0) {
                                        finalRes[`${obj["key"]}_Reconcile`] = reconcileData[obj["key"]];
                                        finalRes[`${obj["key"]}_Status`] = "ExactMatch";
                                        continue;
                                    }
                                    if (vals["left"].length) {
                                        directSearch = directSearch.filter((elementB) => elementB["LEFT_Name"]);
                                        let lmatches = vals["left"].filter((elementA) => directSearch.some((elementB) => elementB["LEFT_Name"]
                                            .toLowerCase()
                                            .includes(elementA.toLowerCase()) ||
                                            elementA
                                                .toLowerCase()
                                                .includes(elementB["LEFT_Name"].toLowerCase())));
                                        console.log("Words leftMatches---", lmatches);
                                        if (lmatches.length) {
                                            finalRes[`${obj["key"]}_Reconcile`] = lmatches[0];
                                            finalRes[`${obj["key"]}_Status`] = "ExactMatch";
                                            continue;
                                        }
                                    }
                                    if (vals["right"].length) {
                                        directSearch = directSearch.filter((elementB) => elementB["RIGHT_Name"]);
                                        let rmatches = vals["right"].filter((elementA) => directSearch.some((elementB) => elementB["RIGHT_Name"]
                                            .toLowerCase()
                                            .includes(elementA.toLowerCase()) ||
                                            elementA
                                                .toLowerCase()
                                                .includes(elementB["RIGHT_Name"].toLowerCase())));
                                        console.log("Words rightMatches---", rmatches);
                                        if (rmatches.length) {
                                            finalRes[`${obj["key"]}_Reconcile`] = rmatches[0];
                                            finalRes[`${obj["key"]}_Status`] = "ExactMatch";
                                            continue;
                                        }
                                    }
                                    if (vals["top"].length) {
                                        directSearch = directSearch.filter((elementB) => elementB["TOP_Name"]);
                                        let tmatches = vals["top"].filter((elementA) => directSearch
                                            .filter((elementB) => elementB["TOP_Name"])
                                            .some((elementB) => elementB["TOP_Name"]
                                            .toLowerCase()
                                            .includes(elementA.toLowerCase()) ||
                                            elementA
                                                .toLowerCase()
                                                .includes(elementB["TOP_Name"].toLowerCase())));
                                        console.log("Words topMatches---", tmatches);
                                        if (tmatches.length) {
                                            finalRes[`${obj["key"]}_Reconcile`] = tmatches[0];
                                            finalRes[`${obj["key"]}_Status`] = "ExactMatch";
                                            continue;
                                        }
                                    }
                                    if (vals["bottom"].length) {
                                        directSearch = directSearch.filter((elementB) => elementB["BOTTOM_Name"]);
                                        let bmatches = vals["bottom"].filter((elementA) => directSearch
                                            .filter((elementB) => elementB["BOTTOM_Name"])
                                            .some((elementB) => elementB["BOTTOM_Name"]
                                            .toLowerCase()
                                            .includes(elementA.toLowerCase()) ||
                                            elementA
                                                .toLowerCase()
                                                .includes(elementB["BOTTOM_Name"].toLowerCase())));
                                        console.log("Words bottomMatches---", bmatches);
                                        if (bmatches.length) {
                                            finalRes[`${obj["key"]}_Reconcile`] = bmatches[0];
                                            finalRes[`${obj["key"]}_Status`] = "ExactMatch";
                                            continue;
                                        }
                                    }
                                }
                                if (isNaN(reconcileData[obj["key"]])) {
                                    let compareValue = reconcileData[obj["key"]];
                                    let compareSplit = compareValue.split(" ");
                                    let lenofNos = compareSplit.filter((a) => !isNaN(a));
                                    console.log("sssssss----", lenofNos);
                                    let filterd = totalWords.filter((a) => a["Name"]);
                                    let fuzzyWords = filterd.map((a) => a["Name"].toLowerCase());
                                    let match = stringSimilarity.findBestMatch(compareValue.toLowerCase(), fuzzyWords);
                                    console.log(`---------match -------`, match.bestMatch, match.bestMatchIndex);
                                    if (lenofNos.length > 0) {
                                        if (match.bestMatch.rating > 0.9) {
                                            finalRes[`${obj["key"]}_Reconcile`] =
                                                filterd[match.bestMatchIndex]["Name"];
                                            finalRes[`${obj["key"]}_Status`] = `FuzzyMatch (${match.bestMatch.rating * 100})`;
                                            continue;
                                        }
                                    }
                                    else if (match.bestMatch.rating > 0.7) {
                                        finalRes[`${obj["key"]}_Reconcile`] =
                                            filterd[match.bestMatchIndex]["Name"];
                                        finalRes[`${obj["key"]}_Status`] = `FuzzyMatch (${match.bestMatch.rating * 100})`;
                                        continue;
                                    }
                                    if ((lenofNos.length / compareSplit.length) * 100 <= 25) {
                                        compareSplit = compareSplit.filter((a) => isNaN(a));
                                    }
                                    else if (lenofNos.length != 0) {
                                        compareSplit = [];
                                    }
                                    if (compareSplit.length > 1) {
                                        let avgFuzzy = 0;
                                        let finalStr = "";
                                        for (let str of compareSplit) {
                                            // console.log(fuzzyWords, str);
                                            let match = stringSimilarity.findBestMatch(str.toLowerCase(), fuzzyWords);
                                            console.log(`---------match -------`, match.bestMatch, match.bestMatchIndex);
                                            avgFuzzy = avgFuzzy + match.bestMatch.rating * 100;
                                            finalStr = finalStr + " " + filterd[match.bestMatchIndex]["Name"];
                                        }
                                        console.log("AvgFuzzy----", avgFuzzy, "------finalStr----------", finalStr);
                                        if (avgFuzzy / compareSplit.length > 70) {
                                            finalRes[`${obj["key"]}_Reconcile`] = finalStr;
                                            finalRes[`${obj["key"]}_Status`] = `FuzzyMatch (${avgFuzzy / compareSplit.length})`;
                                        }
                                    }
                                }
                                if (finalRes[`${obj["key"]}_Status`] == "") {
                                    finalRes[`${obj["key"]}_Reconcile`] = "NA";
                                    finalRes[`${obj["key"]}_Status`] = "NoMatch";
                                }
                            }
                        }
                    }
                    if (finalRes[`${obj["key"]}_Status`] == "") {
                        finalRes[`${obj["key"]}_Reconcile`] = "NA";
                        finalRes[`${obj["key"]}_Status`] = "NA";
                    }
                }
                console.log(finalRes);
                finalRes['fileRefNum'] = refNo;
                finalRes['orgId'] = String(input.orgId);
                let iRes = yield (db.collection(fileType)).insertMany([finalRes]);
                console.log(iRes);
                output['reconcileData'] = finalRes;
                return { message: 'ssuccessful', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "key not found", status: 1, data: err };
            }
        });
    }
    SeprateObjData(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let object = input.obj;
                console.log(object.refno + "\n\n" + object.filePath);
                output['refno'] = object.refno;
                output['filePath'] = object.filePath;
                return { message: 'ssuccessful', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "key not found", status: 1, data: err };
            }
        });
    }
    ConvertJsonTotextFile(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let Question = input.Question;
                let Answer = input.Answer;
                const fileName = +Date.now() + '.txt';
                const filePath = path.join(config.cudapath + input.dirPath, fileName);
                console.log("filepath------>", filePath);
                const content = 'Question: ' + Question + '\n' + 'Answer: ' + Answer;
                yield fs.writeFileSync(filePath, content);
                output['textFilePath'] = filePath;
                return { message: 'ssuccessful', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "key not found", status: 1, data: err };
            }
        });
    }
    ConvertJsonTotextFileForpdfandImage(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let pdfdata = input.pdfData;
                let concatenatedNames = '';
                let isFailed = true;
                pdfdata.forEach(item => {
                    if (item.lineWithCombineWordsNew) {
                        item.lineWithCombineWordsNew.forEach(subArray => {
                            subArray.forEach(subItem => {
                                if (subItem.Name) {
                                    concatenatedNames += subItem.Name + ' ';
                                    isFailed = false;
                                }
                            });
                            concatenatedNames += '\n';
                        });
                    }
                });
                let fileName = input.fileName;
                fileName = fileName.replace(fileName.substring(fileName.lastIndexOf('.')), '.txt');
                let filePath = path.join(config.cudapath + input.dirPath, fileName);
                console.log("filepath------>", filePath);
                let randomNo = Math.floor(Math.random() * 90) + 10;
                if (fs.existsSync(filePath)) {
                    fileName = fileName.replace(fileName.substring(fileName.lastIndexOf('.')), randomNo + '.txt');
                    filePath = path.join(config.cudapath + input.dirPath, fileName);
                    console.log("filepath2------>", filePath);
                }
                const content = concatenatedNames;
                yield fs.writeFileSync(filePath, content);
                output['txtFilePath'] = filePath;
                output['isFailed'] = isFailed;
                return { message: 'ssuccessful', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "key not found", status: 1, data: err };
            }
        });
    }
    DocxReader(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let fileName = input.FileName;
                let filePath = input.filePath;
                let dirPath = input.dirPath;
                if (util_1.isNullOrUndefined(dirPath)) {
                    dirPath = "";
                }
                const extension = path.extname(filePath);
                let outputfilePath = "";
                if (extension === '.docx') {
                    const content = fs.readFileSync(filePath, 'binary');
                    const zip = new PizZip(content);
                    const doc = new Docxtemplater();
                    doc.loadZip(zip);
                    const textContent = doc.getFullText();
                    fileName = fileName.replace(fileName.substring(fileName.lastIndexOf('.')), '.txt');
                    outputfilePath = path.join(config.cudapath + input.dirPath, fileName);
                    console.log("filepath------>", outputfilePath);
                    let randomNo = Math.floor(Math.random() * 90) + 10;
                    if (fs.existsSync(outputfilePath)) {
                        fileName = fileName.replace(fileName.substring(fileName.lastIndexOf('.')), randomNo + '.txt');
                        outputfilePath = path.join(config.cudapath + input.dirPath, fileName);
                        console.log("filepath2------>", outputfilePath);
                    }
                    yield fs.writeFileSync(outputfilePath, textContent, 'utf8');
                }
                else if (extension === '.doc') {
                    // For .doc files
                    fileName = fileName.replace(fileName.substring(fileName.lastIndexOf('.')), '.txt');
                    outputfilePath = path.join(config.cudapath + input.dirPath, fileName);
                    console.log("filepath------>", outputfilePath);
                    let randomNo = Math.floor(Math.random() * 90) + 10;
                    if (fs.existsSync(outputfilePath)) {
                        fileName = fileName.replace(fileName.substring(fileName.lastIndexOf('.')), randomNo + '.txt');
                        outputfilePath = path.join(config.cudapath + input.dirPath, fileName);
                        console.log("filepath2------>", outputfilePath);
                    }
                    const catdocPath = '/usr/bin/catdoc'; // Replace this with the actual path from 'which catdoc'
                    const antiwordCommand = `${catdocPath} "${filePath}"`;
                    yield exec(antiwordCommand, (error, stdout, stderr) => tslib_2.__awaiter(this, void 0, void 0, function* () {
                        if (error) {
                            console.error(`Error: ${error.message}`);
                            return;
                        }
                        if (stderr) {
                            console.error(`Error: ${stderr}`);
                            return;
                        }
                        yield fs.writeFile(outputfilePath, stdout, (err) => {
                            if (err) {
                                console.error(`Error writing the text file: ${err}`);
                            }
                            else {
                                console.log(`Text file has been saved as ${outputfilePath}`);
                            }
                        });
                        console.log('Conversion successful. Output written to:', outputfilePath);
                    }));
                }
                else {
                    console.error('Unsupported file format. Only .doc and .docx are supported.');
                }
                output['txtFilePath'] = outputfilePath;
                return { message: 'Successful', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { message: 'Key not found', status: 1, data: err };
            }
        });
    }
    callopenAI(prompt, subscriberId, orgId, collection) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const requestId = Date.now().toString();
            try {
                RequestTracker_1.RequestTracker.logRequest(requestId, 'callopenAI');
                const response = yield fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: "gpt-4o-mini",
                        response_format: { "type": "json_object" },
                        messages: [
                            { role: "user", content: prompt }
                        ],
                    }),
                });
                const data = yield response.json();
                RequestTracker_1.RequestTracker.logResponse(requestId, 200, { message: "working" });
                console.log(data);
                const promptTokens = data.usage.prompt_tokens;
                const completionTokens = data.usage.completion_tokens;
                console.log(data.choices[0].message.content);
                const parsedData = JSON.parse(data.choices[0].message.content);
                const output = parsedData.output;
                console.log(output);
                const ObjectId = require('mongodb').ObjectId;
                const query = {
                    subscriberId: ObjectId(subscriberId),
                    orgId: ObjectId(orgId),
                    collection: collection,
                    isDeleted: false
                };
                let doc = yield db.collection('LLM_Tokens').findOne(query);
                if (doc) {
                    const updateData = {
                        $inc: {
                            promptTokens: promptTokens,
                            completionTokens: completionTokens,
                            api_call_count: 1,
                        },
                        $set: {
                            updatedAt: new Date()
                        }
                    };
                    yield db.collection('LLM_Tokens').updateOne(query, updateData);
                }
                else {
                    const docData = {
                        subscriberId: ObjectId(subscriberId),
                        orgId: ObjectId(orgId),
                        promptTokens: promptTokens,
                        completionTokens: completionTokens,
                        api_call_count: 1,
                        collection: collection,
                        isDeleted: false,
                        createdAt: new Date(),
                        updatedAt: new Date()
                    };
                    yield db.collection('LLM_Tokens').create(docData);
                }
                return output;
            }
            catch (error) {
                console.error('Error:', error);
                RequestTracker_1.RequestTracker.logFailure(requestId, error);
                return { message: 'There was an error running this function' };
            }
        });
    }
    callgenAI(prompt) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: "gpt-4o-mini",
                        response_format: { "type": "json_object" },
                        messages: [
                            { role: "user", content: prompt }
                        ],
                    }),
                });
                const data = yield response.json();
                console.log(data);
                console.log(data.choices[0].message.content);
                const parsedData = JSON.parse(data.choices[0].message.content);
                const output = parsedData.output;
                console.log(output);
                return output;
            }
            catch (error) {
                console.error('Error:', error);
                return { message: 'There was an error running this function' };
            }
        });
    }
    generateStorylines(product, description, usp, industry, tone, postTopic, subscriberId, orgId, collection) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const custom_prompt = `Given the following details of a product: 
            Product name: ${product}, 
            Description: ${description}, 
            Unique selling proposition (USP): ${usp}, 
            Industry: ${industry}, 
            Post Topic: ${postTopic}, 
            and the desired tone: ${tone}, where tone can be one of the following values: 'Casual', 'Formal', 'Convincing', 'Critical', 'Funny', 'Humble', 'Humorous', 'Informative', 'Inspirational', 'Joyful', 'Passionate', 'Thoughtful', 'Urgent', 'Worried', generate the following in JSON format:
            1. Three distinct storyline options for a video about the product. Each storyline should be a paragraph that presents a potential video concept or narrative for the product.
            2. The tone of the storylines should match the given tone variable.
            3. Ensure the storylines are engaging and tailored to the product’s target audience and unique characteristics.`;
            const prompt = `${custom_prompt} populate the output in the following json format:
      {"output":
        {
          "storylineOption1": "...",
          "storylineOption2": "...",
          "storylineOption3": "...",
    }}`;
            const requestId = Date.now().toString();
            try {
                RequestTracker_1.RequestTracker.logRequest(requestId, 'generateStoryLines');
                const response = yield fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: "gpt-4o-mini",
                        response_format: { "type": "json_object" },
                        messages: [
                            { role: "user", content: prompt }
                        ],
                    }),
                });
                const data = yield response.json();
                RequestTracker_1.RequestTracker.logResponse(requestId, 200, { message: "working" });
                const parsedData = JSON.parse(data.choices[0].message.content);
                const output = parsedData.output;
                const promptTokens = data.usage.prompt_tokens;
                const completionTokens = data.usage.completion_tokens;
                const ObjectId = require('mongodb').ObjectId;
                const query = {
                    subscriberId: ObjectId(subscriberId),
                    orgId: ObjectId(orgId),
                    collection: collection,
                    isDeleted: false
                };
                let doc = yield db.collection('LLM_Tokens').findOne(query);
                if (doc) {
                    const updateData = {
                        $inc: {
                            promptTokens: promptTokens,
                            completionTokens: completionTokens
                        },
                        $set: {
                            updatedAt: new Date()
                        }
                    };
                    yield db.collection('LLM_Tokens').updateOne(query, updateData);
                }
                else {
                    const docData = {
                        subscriberId: ObjectId(subscriberId),
                        orgId: ObjectId(orgId),
                        promptTokens: promptTokens,
                        completionTokens: completionTokens,
                        collection: collection,
                        isDeleted: false,
                        createdAt: new Date(),
                        updatedAt: new Date()
                    };
                    yield db.collection('LLM_Tokens').create(docData);
                }
                return output;
            }
            catch (error) {
                RequestTracker_1.RequestTracker.logFailure(requestId, error);
                console.error('Error:', error);
            }
        });
    }
    generateTargetAudience(product, description, usp, industry, tone, subscriberId, orgId, collection) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const custom_prompt = `Generate an ideal customer profile in detail where demographics would be a paragraph and everything else would be in json for ${product}, ${description}`;
            const prompt = `${custom_prompt} populate the output in the following json format:
      {"output":
        {
          "demographics": "...",
          "everything else": "..."
    }}`;
            const requestId = Date.now().toString();
            try {
                RequestTracker_1.RequestTracker.logRequest(requestId, 'generateTargetAudience');
                const response = yield fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: "gpt-4o-mini",
                        response_format: { "type": "json_object" },
                        messages: [
                            { role: "user", content: prompt }
                        ],
                    }),
                });
                const data = yield response.json();
                RequestTracker_1.RequestTracker.logResponse(requestId, 200, { message: "working" });
                console.log(data);
                const parsedData = JSON.parse(data.choices[0].message.content);
                const output = parsedData.output;
                console.log(output);
                const promptTokens = data.usage.prompt_tokens;
                const completionTokens = data.usage.completion_tokens;
                const ObjectId = require('mongodb').ObjectId;
                const query = {
                    subscriberId: ObjectId(subscriberId),
                    orgId: ObjectId(orgId),
                    collection: collection,
                    isDeleted: false
                };
                let doc = yield db.collection('LLM_Tokens').findOne(query);
                if (doc) {
                    const updateData = {
                        $inc: {
                            promptTokens: promptTokens,
                            completionTokens: completionTokens
                        },
                        $set: {
                            updatedAt: new Date()
                        }
                    };
                    yield db.collection('LLM_Tokens').updateOne(query, updateData);
                }
                else {
                    const docData = {
                        subscriberId: ObjectId(subscriberId),
                        orgId: ObjectId(orgId),
                        promptTokens: promptTokens,
                        completionTokens: completionTokens,
                        collection: collection,
                        isDeleted: false,
                        createdAt: new Date(),
                        updatedAt: new Date()
                    };
                    yield db.collection('LLM_Tokens').create(docData);
                }
                return output;
            }
            catch (error) {
                RequestTracker_1.RequestTracker.logFailure(requestId, error);
                console.error('Error:', error);
            }
        });
    }
    generateVideoScript(product, description, usp, industry, selectedStoryline, tone, timelimit, postTopic, subscriberId, orgId, collection) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const prompt = `Given the following details of a product: 
Product name: ${product}, 
Description: ${description}, 
Unique selling proposition (USP): ${usp}, 
Industry: ${industry}, 
Selected storyline: ${selectedStoryline}, 
Desired tone: ${tone}, 
Approximate video time limit: ${timelimit} (in seconds), 
Post Topic: ${postTopic}, 
Generate a video script that adheres to the following constraints:
1. The total narration duration when converted to speech using Google TTS should be approximately **${timelimit} seconds**. Slightly exceeding this limit (e.g., up to ${timelimit + 5} seconds) is acceptable.
2. Use detailed descriptions, sensory language, and natural pauses to control narration length. Add elaborations and avoid being overly concise.
3. Divide the script into logical sections:
   - **Introduction**: Briefly set the stage and introduce the storyline (${Math.floor(timelimit * 0.10)}-${Math.floor(timelimit * 0.15)} seconds).
   - **Main Content**: Elaborate on key points with vivid descriptions, breaking it into multiple scenes (${Math.floor(timelimit * 0.7)}-${Math.floor(timelimit * 0.8)} seconds).
   - **Conclusion**: Wrap up the narrative and leave a lasting impression (${Math.floor(timelimit * 0.10)}-${Math.floor(timelimit * 0.15)} seconds).
4. Output the script in the JSON format:
   {"output":{
      'Introduction' : {'scene':'...','narration': '...'},
      'Main Content': [{'scene':'...','narration': '...'}],
      'Conclusion' : {'scene':'...','narration': '...'},
   }}`;
            const requestId = Date.now().toString();
            try {
                RequestTracker_1.RequestTracker.logRequest(requestId, 'generateVideoScript');
                const response = yield fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${process.env.OPENAI_API_KEY}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: "gpt-4o-mini",
                        response_format: { "type": "json_object" },
                        messages: [
                            { role: "user", content: prompt }
                        ],
                    }),
                });
                const data = yield response.json();
                RequestTracker_1.RequestTracker.logResponse(requestId, 200, { message: "working" });
                const parsedData = JSON.parse(data.choices[0].message.content);
                const output = parsedData.output;
                const promptTokens = data.usage.prompt_tokens;
                const completionTokens = data.usage.completion_tokens;
                const ObjectId = require('mongodb').ObjectId;
                const query = {
                    subscriberId: ObjectId(subscriberId),
                    orgId: ObjectId(orgId),
                    collection: collection,
                    isDeleted: false
                };
                let doc = yield db.collection('LLM_Tokens').findOne(query);
                if (doc) {
                    const updateData = {
                        $inc: {
                            promptTokens: promptTokens,
                            completionTokens: completionTokens
                        },
                        $set: {
                            updatedAt: new Date()
                        }
                    };
                    yield db.collection('LLM_Tokens').updateOne(query, updateData);
                }
                else {
                    const docData = {
                        subscriberId: ObjectId(subscriberId),
                        orgId: ObjectId(orgId),
                        promptTokens: promptTokens,
                        completionTokens: completionTokens,
                        collection: collection,
                        isDeleted: false,
                        createdAt: new Date(),
                        updatedAt: new Date()
                    };
                    yield db.collection('LLM_Tokens').create(docData);
                }
                return output;
            }
            catch (error) {
                RequestTracker_1.RequestTracker.logFailure(requestId, error);
                console.error('Error:', error);
            }
        });
    }
    arrFilter(arr, field) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let obj = typeof (arr) == 'string' ? JSON.parse(arr) : arr;
                const fields = field.split(',').map(f => f.trim());
                obj = obj.map(item => {
                    const filteredItem = {};
                    fields.forEach(f => {
                        if (item.hasOwnProperty(f)) {
                            filteredItem[f] = item[f];
                        }
                    });
                    return filteredItem;
                });
                return obj;
            }
            catch (e) {
                console.log("Error!!! -> " + e);
                return { message: e, status: 1, data: e };
            }
        });
    }
    InvoiceHtml(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                const invoiceData = typeof (input.InvDetail) == 'string' ? JSON.parse(input.InvDetail) : input.InvDetail;
                let sumTotal = 0;
                const discountText = Number(invoiceData.Discount) > 0 ? `${invoiceData.Discount}` : "";
                invoiceData.Durations.map(task => {
                    if (task["Billable Hrs"]) {
                        const billableHrs = parseFloat(task["Billable Hrs"]);
                        task["Total"] = billableHrs * task["Hourly Charges"];
                        delete task["Duration"];
                    }
                    else {
                        task['Billable Hrs'] = task["Duration"];
                        delete task["Duration"];
                    }
                    return task;
                });
                for (let i = 0; i < invoiceData.Durations.length; i++) {
                    sumTotal += invoiceData.Durations[i].Total;
                }
                if (!isNaN(invoiceData.Discount) && invoiceData.Discount !== 0) {
                    let igst = typeof (invoiceData.igst) == 'string' ? 0 : Number(invoiceData.igst);
                    let sgst = typeof (invoiceData.sgst) == 'string' ? 0 : Number(invoiceData.sgst);
                    let total = Number(sumTotal) - (Number(sumTotal) * (Number(invoiceData.Discount) / 100));
                    let taxs = Number(invoiceData.TaxSlab) * (total / 100);
                    if (igst > 0) {
                        invoiceData.igst = taxs.toFixed(2);
                    }
                    else if (sgst > 0) {
                        invoiceData.cgst = (taxs / 2).toFixed(2);
                        invoiceData.sgst = (taxs / 2).toFixed(2);
                    }
                    else {
                        invoiceData.Tax = taxs.toFixed(2);
                        invoiceData.Tax = typeof (invoiceData.Tax) == 'string' ? Number.isNaN(invoiceData.Tax) ? 0 : Number(invoiceData.Tax) : invoiceData.Tax;
                    }
                }
                let val = `<div style="display: -webkit-box;display: -ms-flexbox;display: flex;margin-bottom: 5px;"> <div style="width: 40%"><span style="font-weight: 700">Tax</span></div>
<div style="width: 10%">:</div>
<div style="width: 40%; text-align: -webkit-right;"><span>${invoiceData.Tax}</span></div></div>`;
                let taxSla = `<div style="display: -webkit-box;display: -ms-flexbox;display: flex;margin-bottom: 5px;"> <div style="width: 40%"><span style="font-weight: 700">Tax (%)</span></div>
<div style="width: 10%">:</div>
<div style="width: 40%; text-align: -webkit-right;"><span>${invoiceData.TaxSlab}</span></div></div>`;
                if (Number(invoiceData.igst) > 0) {
                    val = `
  <div style="display: -webkit-box;display: -ms-flexbox;display: flex;margin-bottom: 5px;"> <div style="width: 40%"><span style="font-weight: 700">IGST</span></div>
  <div style="width: 10%">:</div>
  <div style="width: 40%; text-align: -webkit-right;"><span>${invoiceData.igst}</span></div></div>`;
                    invoiceData.Tax = Number(invoiceData.igst);
                }
                else if (Number(invoiceData.sgst) > 0) {
                    val = `
  <div style="display: -webkit-box;display: -ms-flexbox;display: flex;margin-bottom: 5px;"> <div style="width: 40%"><span style="font-weight: 700">SGST</span></div>
  <div style="width: 10%">:</div>
  <div style="width: 40%; text-align: -webkit-right;"><span>${invoiceData.sgst}</span></div></div>
  <div style="display: -webkit-box;display: -ms-flexbox;display: flex;margin-bottom: 5px;"> <div style="width: 40%"><span style="font-weight: 700">CGST</span></div>
  <div style="width: 10%">:</div>
  <div style="width: 40%; text-align: -webkit-right;"><span>${invoiceData.cgst}</span></div></div>`;
                    invoiceData.Tax = Number(invoiceData.sgst) + Number(invoiceData.cgst);
                }
                const discountHtml = Number(invoiceData.Discount) > 0 ? `
                        <div style="display: -webkit-box;display: -ms-flexbox;display: flex;margin-bottom: 5px;">
                            <div style="width: 40%"><span style="font-weight: 700">Discount (%)</span></div>
                            <div style="width: 10%">:</div>
                            <div style="width: 40%; text-align: -webkit-right;"><span>${discountText}</span></div>
                        </div>
                        <div style="display: -webkit-box;display: -ms-flexbox;display: flex;margin-bottom: 5px;">
                            <div style="width: 40%"><span style="font-weight: 700">Discount</span></div>
                            <div style="width: 10%">:</div>
                            <div style="width: 40%; text-align: -webkit-right;"><span>${((sumTotal) * (invoiceData.Discount / 100))}</span></div>
                        </div>` : "";
                let htmlTemplate = `<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8">
    <style>
        @page {
            /* switch to landscape */
            size: landscape;
            /* set page margins */
            margin: 0.5cm;

            @top-center {
                content: element(header);
            }

            @bottom-center {
                content: element(footer);
            }

            @bottom-right {
                content: counter(page) " of " counter(pages);
            }
        }

        div.footer {
            display: block;
            text-align: center;
            position: running(footer);
            width: 100%;
        }
    </style>
</head>

<body style="font-family:'Calibri', sans-serif;font-size: 11px;">
    <header></header>
    <div style="width: 100%;padding-top: 8px;padding-bottom: 8px;padding-left: 2px;">
        <div style="font-size: 10px;text-align: -webkit-match-parent;;">
            <div class="header-section" style="height: 80px"> <!--startHeader-->
                <div>
                    <div style="width: 20%; font-weight: 800;">
                    <div>${invoiceData.FromName}</div>
                    <div>${invoiceData.FromEmail}</div>
                    <div>${invoiceData.FromMobile}</div>
                    <div>${invoiceData.FromGSTIN}</div>
                    </div>
                </div> <!--endHeader-->
            </div>
            <div
                style="text-align: center;margin-top: 5px;margin-bottom: 5px; font-size: 22px; font-weight: 900; height: 30px;">
                <div><span>Tax Invoice</span></div>
            </div>
            <div
                style="display: -webkit-box;display: -ms-flexbox;display: flex; border-style: groove; padding: 10px; height: 100px;">
                <div style="width: 60%">
                    <div style="display: -webkit-box;display: -ms-flexbox;display: flex;">
                        <div style="width: 60%"><span>To</span></div>
                        <div style="width: 40%; text-align: right;"></div>
                    </div>
                    <div style="display: -webkit-box;display: -ms-flexbox;display: flex;">
                    <div style="width: 40%"><span>${invoiceData.ClientName}</span></div>
                    </div>
                    <div style="display: -webkit-box;">
                        <div style="width: 40%"><span>${invoiceData.ClientMobile}</span></div>
                    </div>
                    <div style="display: -webkit-box;">
                        <div style="width: 40%"><span>${invoiceData.ClientEmail}</span></div>
                    </div>
                </div>
                <div style="width: 40%">
                    <div style="width: 100%; text-align: -webkit-match-parent; padding-left: 30%">
                        <div style="text-align: -webkit-match-parent;">
                            <div style="display: -webkit-box;display: -ms-flexbox;display: flex;">
                                <div style="width: 30%"><span>Invoice Date </span></div>
                                <div><span>: ${new Date().getDate()}-${new Date().getMonth() + 1}-${new Date().getFullYear()}</span></div>
                            </div>
                            <div style="display: -webkit-box;display: -ms-flexbox;display: flex;">
                                <div style="width: 30%"><span>Invoice Number </span></div>
                                <div><span>: ${invoiceData.InvoiceNo}</span></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div style="width: 100%;font-weight: 700;margin-top: 15px;"> <span>Description Of Services:</span> </div>
            <br>
            <div style="width: 100%"> <span>Charges for ${new Date(invoiceData.StartDate).toISOString().split('T')[0]} - ${new Date(invoiceData.EndDate).toISOString().split('T')[0]} as per the following details</span>
            </div>
            <div style="margin-top: 10px;width: 100%"> </div>
            <div>
                <table style="width:100%; border: 1px solid black;border-collapse: collapse;">
                    <tr>
                        <th>Project Name</th>
                        <th>Task Name</th>
                        <th>Assignee</th>
                        <th>Service Date</th>
                        <th>Qty/Hrs</th>
                        <th>Rate</th>
                        <th>Line Total</th>
                    </tr>
                    <tbody>${invoiceData.Durations.map(duration => `
                    <tr>
                        <td>${duration["Project"]}</td>
                        <td>${duration["Task"]}</td>
                        <td>${duration["Assign To"]}</td>
                        <td>${new Date(invoiceData.StartDate).toISOString().split('T')[0]}</td>
                        <td>${duration["Billable Hrs"]}</td>
                        <td>${duration["Hourly Charges"]}</td>
                        <td>${duration.Total}</td>
                    </tr>
                `).join('')}</tbody>
                </table>
                <div
                    style="display: -webkit-box;display: -ms-flexbox;display: flex;margin-bottom: 30px;margin-top:40px;font-family:'Calibri', sans-serif;font-size: 11px;">
                    <div style="width: 60%"> </div>
                    <div style="width: 40%">
                        <div style="display: -webkit-box;display: -ms-flexbox;display: flex;margin-bottom: 5px;">
                            <div style="width: 40%"><span style="font-weight: 700">SubTotal</span></div>
                            <div style="width: 10%">:</div>
                            <div style="width: 40%; text-align: -webkit-right;"><span>${sumTotal}</span></div>
                        </div>
                        ${discountHtml}
                        ${taxSla}
                        ${val}
                        ${taxSla}
                        <div style="display: -webkit-box;display: -ms-flexbox;display: flex;margin-bottom: 5px;">
                            <div style="width: 40%"><span style="font-weight: 700">Total Amount</span></div>
                            <div style="width: 10%">:</div>
                            <div style="width: 40%; text-align: -webkit-right;"><span>${(sumTotal + invoiceData.Tax - ((sumTotal) * (invoiceData.Discount / 100))).toFixed(2)}</span></div>
                        </div>
                        <div style="display: -webkit-box;display: -ms-flexbox;display: flex;margin-bottom: 5px;">
                            <div style="width: 40%"><span style="font-weight: 700"> </span></div>
                            <div style="width: 10%"></div>
                            <div style="width: 40%; text-align: -webkit-right;"><span> </span></div>
                        </div>
                    </div>
                </div>
                <div style="width: 100%;text-align: left;margin-top: 10px"> <span style="font-size: 8px;">Disclaimer:
                        "This invoice is computer generated and does not require any signature"</span> </div>
            </div>
        </div>
    </div>
    <footer></footer>
</body>

</html>`;
                output['html'] = htmlTemplate;
                return { message: 'ssuccessful', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "key not found", status: 1, data: err };
            }
        });
    }
    scrapeWebsite(input, outPut, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            const { url, action, nextButton, format } = input;
            if (!url || !action) {
                return { message: 'URL and action are required.', status: 1, data: null };
            }
            try {
                const browser = yield puppeteer.launch({
                    headless: true,
                    args: ['--no-sandbox', '--disable-setuid-sandbox'],
                });
                const page = yield browser.newPage();
                yield page.setViewport({ width: 1920, height: 1080 });
                let navigationAttempts = 3;
                while (navigationAttempts > 0) {
                    try {
                        yield page.goto(url, { waitUntil: 'networkidle2', timeout: 60000 });
                        break;
                    }
                    catch (error) {
                        navigationAttempts--;
                        console.error(`Attempt ${3 - navigationAttempts} failed:`, error);
                        if (navigationAttempts === 0) {
                            throw new Error('Navigation attempt limit reached.');
                        }
                    }
                }
                let scrapedData = [];
                const scrapePageData = () => tslib_2.__awaiter(this, void 0, void 0, function* () {
                    return yield page.evaluate(() => {
                        const extractData = () => {
                            const phoneRegex = /(?:\+?(\d{1,3}))?[-.\s]?\(?(\d{3})\)?[-.\s]?(\d{3})[-.\s]?(\d{4})(?:\s?(?:x|ext\.?)\s?(\d+))?/g;
                            const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
                            const websiteRegex = /(?:https?:\/\/)?(?:www\.)?([a-zA-Z0-9-]+(?:\.[a-zA-Z]{2,})+)/i;
                            const companyNameElement = document.querySelector('h1.company-name, h1, h2.company-name, h2, h3.company-name, h3, strong.company-name, strong, b.company-name, b, div.company-name, span.company-name, [id*="company"], [class*="company"], [id*="org"], [class*="org"], [class*="business"], [class*="brand"], [id*="brand"]') ||
                                document.querySelector('meta[property="og:site_name"]') ||
                                document.querySelector('title');
                            const industryElement = document.querySelector('span.industry, div.industry, [id*="industry"], [class*="industry"], p.industry');
                            const industry = industryElement ? (industryElement.innerText || industryElement.textContent).trim() : '';
                            const companyInfoElement = document.querySelector('p.company-info, div.company-info, [id*="company-info"], [class*="company-info"], [id*="about"], [class*="about"], p.description, div.description');
                            let companyInformation = companyInfoElement ? (companyInfoElement.innerText || companyInfoElement.textContent).trim() : '';
                            // Filter out common placeholder text
                            const placeholderTexts = [
                                'lorem ipsum',
                                'dummy text',
                                'placeholder',
                                'sample text',
                                'example content'
                            ];
                            const isPlaceholder = (text) => {
                                return placeholderTexts.some(phrase => text.toLowerCase().includes(phrase));
                            };
                            // Check if the extracted information is relevant
                            if (isPlaceholder(companyInformation) || companyInformation.length < 10) {
                                companyInformation = '';
                            }
                            const companyName = companyNameElement
                                ? (companyNameElement instanceof HTMLMetaElement
                                    ? companyNameElement.getAttribute('content')
                                    : companyNameElement.innerText || companyNameElement.textContent).trim()
                                : '';
                            const personNameElement = document.querySelector('h2') || document.querySelector('.person-name');
                            const personName = personNameElement ? personNameElement.innerText.trim() : '';
                            const pageText = document.body.innerText;
                            const phones = pageText.match(phoneRegex) || [];
                            const emails = pageText.match(emailRegex) || [];
                            const websiteMatch = pageText.match(websiteRegex);
                            const website = websiteMatch ? websiteMatch[0] : '';
                            return {
                                companyName,
                                industry,
                                personName,
                                companyInformation,
                                phones: phones.join(', '),
                                emails: emails.join(', '),
                                website
                            };
                        };
                        return [extractData()];
                    });
                });
                if (action === 'scroll' || action === 'simple') {
                    scrapedData = yield scrapePageData();
                }
                else if (action === 'pagination') {
                    let nextButtonFound = true;
                    while (nextButtonFound) {
                        const pageData = yield scrapePageData();
                        scrapedData = scrapedData.concat(pageData);
                        nextButtonFound = yield page.evaluate((userSelector) => {
                            const selectors = ['a[rel="next"]', 'button[rel="next"]', 'a[aria-label="Next"]', 'button[aria-label="Next"]'];
                            let nextButton = userSelector ? document.querySelector(userSelector) : selectors.map(sel => document.querySelector(sel)).find(Boolean);
                            if (nextButton) {
                                nextButton.scrollIntoView();
                                nextButton.click();
                                return true;
                            }
                            return false;
                        }, nextButton);
                        if (nextButtonFound) {
                            try {
                                yield page.waitForNavigation({ waitUntil: 'networkidle2', timeout: 60000 });
                            }
                            catch (e) {
                                console.error('Navigation timeout:', e);
                                break;
                            }
                        }
                    }
                }
                yield browser.close();
                if (format) {
                    if (scrapedData.length === 0) {
                        throw new Error('No data available to download.');
                    }
                    let dataToDownload;
                    const filepath = input.Path + input.fileName;
                    if (format === 'csv') {
                        const fields = Object.keys(scrapedData[0]);
                        const parser = new Parser({ fields });
                        dataToDownload = parser.parse(scrapedData);
                        fs.writeFileSync(filepath, dataToDownload);
                        outPut['filePath'] = filepath;
                    }
                    else if (format === 'json') {
                        dataToDownload = JSON.stringify(scrapedData, null, 2);
                        fs.writeFileSync(filepath, dataToDownload);
                        outPut['filePath'] = filepath;
                    }
                    return { message: '', status: 0, data: outPut };
                }
                outPut['data'] = scrapedData;
                return { message: '', status: 0, data: outPut };
            }
            catch (error) {
                console.error('Error:', error);
                return { message: 'Error scraping the website.', status: 1, data: error };
            }
        });
    }
    pushNotificationFirebase(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                input.headerParams = { subscriberId: input.subscriberId };
                this.OrganizationService.pushNotification(input, input);
                output['message'] = 'Notifications sent successfully';
                return { message: 'ssuccessful', status: 0, data: output };
            }
            catch (err) {
                console.log(err);
                return { "message": "key not found", status: 1, data: err };
            }
        });
    }
    importToTallyRemote(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let publicIPAddress = input.publicIPAddress;
                let port = input.tallyPort;
                let options = {
                    method: 'POST',
                    url: `${publicIPAddress}:${port}`,
                    body: input.xml,
                    headers: {
                        'Cache-Control': 'no-cache',
                        'Content-Type': 'text/xml'
                    },
                };
                const res = yield request(options);
                if (/LINEERROR/.test(res)) {
                    return { "message": "Could not set company.", status: 1, data: "Could not set company." };
                }
                else if (/Unknown Request/.test(res) || !/<ERRORS>0<\/ERRORS>/.test(res)) {
                    return { "message": "Import to Tally Failed", status: 1, data: "Unknown error" };
                }
                return { "message": "Succesfully imported data to tally", status: 0, data: output };
            }
            catch (err) {
                if (err['code'] === 'ECONNREFUSED') {
                    return { "message": "Connection failed!", status: 1, data: "Connection failed!" };
                }
                return { "message": "tally function failed", status: 1, data: "Insert into tally failed" };
            }
        });
    }
    syncLedgerTallyRemote(input, output, botId, projectId, iterationId) {
        return tslib_2.__awaiter(this, void 0, void 0, function* () {
            try {
                let ledgers = input.ledgers;
                let costcentres = input.costcentres;
                let publicIPAddress = input.publicIPAddress;
                let port = input.tallyPort;
                var list = [ledgers, costcentres];
                let resultFinal;
                let arr = [];
                function parse(file) {
                    return tslib_2.__awaiter(this, void 0, void 0, function* () {
                        const promise = yield new Promise((resolve, reject) => {
                            const parser = new xml2js.Parser({ explicitArray: false });
                            parser.parseString(file, (error, result) => {
                                if (error)
                                    reject(error);
                                else
                                    resolve(result);
                            });
                        });
                        return promise;
                    });
                }
                for (let i = 0; i < list.length; i++) {
                    let options = {
                        method: 'POST',
                        url: `${publicIPAddress}:${port}`,
                        headers: {
                            'Cache-Control': 'no-cache',
                            'Content-Type': 'text/xml'
                        },
                        body: list[i]
                    };
                    const res = yield request(options);
                    const xml = res;
                    const result = yield parse(xml);
                    const json = JSON.stringify(result, null, 4);
                    let json_data = JSON.parse(json);
                    let xyz;
                    if (i == 0) {
                        xyz = json_data.ENVELOPE.BODY.DATA.COLLECTION.LEDGER;
                    }
                    else {
                        xyz = json_data.ENVELOPE.BODY.DATA.COLLECTION.COSTCENTRE;
                    }
                    if (xyz) {
                        if (!Array.isArray(xyz)) {
                            let key = xyz['PARENT']['_'].replace(/[^\w\s]/gi, '');
                            if (i == 1) {
                                key = "CostCentres";
                            }
                            resultFinal[key] = [];
                            resultFinal[key].push(xyz.$.NAME);
                        }
                        else {
                            resultFinal = xyz.reduce((result, el) => {
                                console.log(Object.keys(el));
                                let key = el['PARENT']['_'].replace(/[^\w\s]/gi, '');
                                if (i == 1) {
                                    key = "CostCentres";
                                }
                                if (result[key]) {
                                    result[key].push(el.$.NAME);
                                }
                                else {
                                    result[key] = [];
                                    result[key].push(el.$.NAME);
                                }
                                return result;
                            }, {});
                        }
                        arr.push(resultFinal);
                    }
                }
                let finalres = Object.assign({}, arr[0], arr[1]);
                if (!finalres['Direct Expenses']) {
                    finalres['Direct Expenses'] = [];
                }
                if (!finalres['Indirect Expenses']) {
                    finalres['Indirect Expenses'] = [];
                }
                if (!finalres['Purchase Accounts']) {
                    finalres['Purchase Accounts'] = [];
                }
                if (!finalres['CostCentres']) {
                    finalres['CostCentres'] = [];
                }
                output['ledgersResult'] = finalres;
                return { "message": "Sync Ledger Successful", status: 0, data: output };
            }
            catch (err) {
                return { "message": "Sync Ledger Failed", status: 1, data: "Sync Ledger Failed" };
            }
        });
    }
}
tslib_2.__decorate([
    Logger_1.Logger(__filename),
    tslib_2.__metadata("design:type", Object)
], botCommonFunctions.prototype, "log", void 0);
exports.botCommonFunctions = botCommonFunctions;
//# sourceMappingURL=botCommonFunctions.js.map