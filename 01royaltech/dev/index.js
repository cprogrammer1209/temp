"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator.throw(value));
            }
            catch (e) {
                reject(e);
            }
        }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
//added 22 april'21
//start
const crypto = require('crypto');
const CryptoJS = require('crypto-js');
const hexToDec = require('hex-to-dec');
const json2csv = require("json2csv");
//end
// var nodemailer = require('nodemailer');
const smtpTransport = require('nodemailer-smtp-transport');

const { performance } = require('perf_hooks');
const contact = require('./contact');
const subscribe = require('./subscribe');
const payment = require('./payment');
const sendmail_2 = require("../../share/sendmail/sendmail");
const MongoClient = require('mongodb').MongoClient;
//added 22 april'21
//start
//const scanField = require('../../share/uploader/scanningForms/scanningFields');
let docTraining = require('../../share/uploader/training-models/documentTraining');
const errorInv = require("../error-invoices/error-invoice");
const index_1 = require("../../share/uploader/fileUploadHistory/index");
// const fileUploadHistory = require('../../share/uploader/fileUploadHistory/fileUploadHistory');
//end
// import * as async from "async";
var config = require('../../resource/config.json');
const express_2 = require('express');
const user = require('../user/user');
const manifestjson = require("../organisation/manifest.json");
const OTP = require('../user/otp');
const product = require('../product/product');
var bycrypt = require('bcryptjs');
var http = require("https");
var async = require("async");
const organisation = require('../organisation/organisation');
const feedback = require("../user/feedback");
const subscriber = require('../subscriber/subscriber');
const organisationHierarchy = require('../organisation/organisation.hierarchy');
var _ = require('underscore');
const response_model_2 = require("../../share/response.model");
const response_model_3 = require("../../share/response.model");
const response_model_4 = require("../../share/response.model");
var jwt = require('jwt-simple');
const path = require('path');
let fs = require("fs");
const mongoose = require('mongoose');
mongoose.Promise = require('bluebird');
const JWT_SECRET = 'AXRWJNqr9SjEYXdJFaFXqADq8ipb1vbf';
var math = require('mathjs');
// const subscriptionKey = "AIzaSyBVttNXNiUjh-ef9rKlRUbUGxDUlFuOlm0";
const util_1 = require("util");
var nodemailer = require('nodemailer');
const products = require('../product/product');
const creditproducts = require("../product/creditproduct");
const _organisation = require('../organisation/organisation');
const stateCode = require('../invoice/state');
const transaction = require('../transation/transaction');
const Subscriber = require('../subscriber/subscriber');
const response_model_5 = require("../../share/response.model");
const response_model_6 = require("../../share/response.model");
const businessType = require('../businessType/businessType');
const util_2 = require("util");
var request = require('request');
var moment = require('moment');
var _ = require('underscore');
var moment = require('moment');
var pdf = require('html-pdf');
var jsonexport = require('jsonexport');
const discount = require('../cart/discount');
const index_4 = require("../desktop.utility/storage.path/index");
const index_5 = require("../desktop.utility/tally/index");
const newsFeed = require("./newsFeedSchema");
const logOfUser = require('./userLog');
var s3 = require("../../resource/s3Config.json");
var parseXlsx = require('excel');
var md5 = require('md5');
var bytes = require('utf8-length')
const configSchema = require('../config/configschema');
const countryCode = require('../invoice/country');
const hsnSac = require('../hsn-sac/hsn_sac');
const resellerTransaction = require('../package/resellerTransaction');
const index_6 = require('../package/index');
const pricingSlabs = require('../package/pricingSlabs');
const reseller = require('../package/resellerCodes');
const crud_1 = require("../../share/crud/crud");
const invoiceHelper_1 = require('../invoice/invoiceHelper');
var logger = require('../../share/logger');
var commonConstants = require('../../resource/constants.json');
var dynamicWebsiteConfig = require('../../resource/dynamicWebsiteConfig.json');
const webRequest = require('./webRequest');
const websiteHelper_1 = require("./websiteHelper");
const organisation_1 = require("../organisation");
var accountsetup = require('../../resource/accountsetup.json');
const { exec, execSync } = require('child_process');
const scanField = require('../../share/uploader/scanningForms/scanningFields');
const templateTrainingData = require('../../share/uploader/training-models/templateTraining');

const scanHelper_1 = require("../../share/uploader/scanHelper");
let responseMessages = require('../../resource/messages.json');
var establishedModels = {};
const sortedLine = require('./sortedLine');
const { DH_CHECK_P_NOT_PRIME } = require('constants');
const _otp = require('../user/otp');
const commonFunctions = require('../../share/commonFunctions').commonFunctions;
const db = require('../../share/mongooseClient').default;
const ObjectId = mongoose.Types.ObjectId;
const subscriptionKey = "AIzaSyBbe1BsZJtVJw4poPXku5RNLv9Jsny5vmE";
const axios = require('axios');

Date.prototype.addDays = function (days) {
    var date = new Date(this.valueOf());
    date.setDate(date.getDate() + days);
    return date;
}
class WebsiteRoute {
    constructor() {
        // this.getAllSchemas();
        this.requestObjectComponent = new index_5.RequestObjectComponent();
        this.storageComponent = new index_4.StorageComponent();
        this.orgRoute = new organisation_1.SubscriberRoute();
        this.header = "";
        this.pc = new index_6.PackageRoute();
        this.crud = new crud_1.Crud();
        this.router = express_2.Router();
        this.init();
        this.sendMail = new sendmail_2.SendMail();
        // this.db = this.crud.db;
        this.invoiceHelper = new invoiceHelper_1.InvoiceHelperRoute();
        this.websiteHelper = new websiteHelper_1.WebsiteHelper();
        this.orgRoute = new organisation_1.SubscriberRoute();
        this.scanHelper = new scanHelper_1.scanningHelper();
        this.commonFunctions = commonFunctions;
        // }
        // on 22 April'21
        //start
        this.fileUploadHistory = new index_1.FileUploadHistoryComponent();
        //end
    }
    //on 22 april'21
    //start
    getDecimalNumber(str) {
        const string = crypto.createHash('md5').update(str).digest("hex");
        const decimal = hexToDec(string);
        return decimal;
    }
    //end
    init() {
        /*************************************NEW API UAE****************************************/
        this.router.post('/user/token', (req, res) => this.getToken(req, res));
        this.router.get('/user/:id', (req, res) => this.getUser(req, res));
        this.router.post('/fetch/otp', (req, res) => this.fetchOtp(req, res));
        this.router.post('/registeruser', (req, res) => this.registerUser(req, res));
        this.router.post('/registerUserAWS', (req, res) => this.registerUserAWS(req, res));
        this.router.post('/user/emailVerification',(req,res)=> this.emailVerification(req,res));
        this.router.post('/changepasswordWithNo', (req, res) => this.changepasswordWithNo(req, res));
        this.router.post('/orgConfiguration', (req, res) => this.getOrgConfiguration(req, res));
        this.router.post('/activateuser', (req, res) => this.activateUser(req, res));
        this.router.get('/deactivateUser/:id', (req, res) => this.deactivateUser(req, res));
        this.router.get('/getUserDetail/:mobileNo', (req, res) => this.getUserDetails(req, res));    
        this.router.post('/user/getUserData', (req, res) => this.getUserData(req, res));    
        this.router.post('/user/getUserPackages', (req, res) => this.getUserPackages(req, res));  
        this.router.post('/user/resetPassword', (req, res) => this.resetUserPassword(req, res));
        this.router.post('/user/newPassword', (req, res) => this.updateUserPassword(req, res));
        this.router.post('/sendrequest', (req, res) => this.sendRequestEmail(req, res));
        // check for subscriber existance
        this.router.get('/subscriber/check', (req, res) => this.subscriberExists(req, res));
        this.router.post('/license/valid', (req, res) => this.isLicenseValid(req, res));
        this.router.post('/license/validate', (req, res) => this.websiteHelper.validateLicense(req, res));
        this.router.post('/register/localUser', (req, res) => this.websiteHelper.registerLocalUser(req, res));
        /*****************************************************************************/
        this.router.post('/getdq', (req, res) => this.getResultOfDynamicQuery(req, res));
        this.router.post('/contact', (req, res) => this.saveContact(req, res));
        this.router.post('/contact/subscribe', (req, res) => this.saveSubscribe(req, res));
        this.router.post('/contact/unsubscribe', (req, res) => this.unSubscribe(req, res));
        this.router.post('/user/login', (req, res) => this.loginUser(req, res));
        this.router.post('/user/logout', (req, res) => this.logoutUser(req, res));

        this.router.post('/geomapJsonSave', (req, res) => this.geomapJsonSave(req, res));
        this.router.post('/register', (req, res) => this.register(req, res));
        this.router.post('/register', (req, res) => this.updateRegister(req, res));
        this.router.post('/verify', (req, res) => this.verify(req, res));
        this.router.post('/send/sms', (req, res) => this.sendSms(req, res));
        this.router.get('/checkduplicate/:mobileNo', (req, res) => this.checkDuplicate(req, res));
        this.router.get('/duplicate/:email', (req, res) => this.checkDuplicateEmail(req, res));
        this.router.post('/password', (req, res) => this.updatePassword(req, res));
        this.router.get('/pricing', (req, res) => this.pricing(req, res));
        this.router.get('/addon', (req, res) => this.getAddon(req, res));
        this.router.post('/pricingpkg', (req, res) => this.pricingpkg(req, res));
        this.router.post('/custompkg', (req, res) => this.custompkg(req, res));
        this.router.get('/state', (req, res) => this.getState(req, res));
        this.router.get('/test', (req, res) => this.getTest(req, res));
        this.router.get('/business', (req, res) => this.getAllBusinessType(req, res));
        this.router.get('/pmtData', (req, res) => this.getAllPaymentData(req, res));
        this.router.post('/actSub', (req, res) => this.actSub(req, res));
        this.router.get('/subscriber/:id?', (req, res) => this.getSubScriber(req, res));
        this.router.post('/resetpassword', (req, res) => this.resetPassword(req, res));
        this.router.post('/instamojo', (req, res) => this.instamojoPayment(req, res));
        this.router.post('/before/registration', (req, res) => this.beforeRegistration(req, res));
        this.router.post('/instamojo/afterpayment', (req, res) => this.instamojoafterPayment(req, res));
        this.router.post('/promocode', (req, res) => this.applyPromocode(req, res));
        this.router.get('/strgpath/:id', (req, res) => this.getStoragePath(req, res));
        this.router.post('/strgpath', (req, res) => this.saveStoragePath(req, res));
        this.router.get('/requestObject/:type', (req, res) => this.getRequestObject(req, res));
        this.router.post('/multifile', (req, res) => this.readMultipleFile(req, res));
        this.router.post('/saveuserandtransection', (req, res) => this.saveUserAndTransection(req, res));
        this.router.post('/addNewsFeed', (req, res) => this.addNewsFeed(req, res));
        this.router.get('/getNewsFeed', (req, res) => this.getNewsFeed(req, res));
        this.router.post('/updateNewsFeed', (req, res) => this.updateNewsFeed(req, res));
        this.router.get('/deleteNewsFeed/:id', (req, res) => this.deleteNewsFeed(req, res));
        this.router.post('/register/ca', (req, res) => this.registerCA(req, res));
        this.router.post('/registerbyca', (req, res) => this.registerbyCA(req, res));
        this.router.post('/tax/summary', (req, res) => this.calculateTaxSummary(req, res));
        this.router.get('/country', (req, res) => this.getCountry(req, res));
        this.router.get('/state/:name', (req, res) => this.getState(req, res));
        this.router.get('/copilot/info/:orgId',(req,res)=>this.getRequiredCopilotInfo(req,res));
        this.router.get('/manifest.json',(req,res)=>this.getManifestJSON(req,res));
        this.router.post('/create/manifest',(req,res)=>this.createCGManifestJSON(req,res));
        // this.router.post('/chatgenie/contactInfo',(req,res)=>this.setContactInfoChatGenie(req,res));
        // this.router.get('/chatgenie/contactinfo/:orgId',(req,res)=>this.getContactInfoChatGenie(req,res));
        this.router.post('/chatgenie/info',(req,res)=>this.setInfoChatGenie(req,res));
        this.router.post('/chatgenie/ticketRaise/apiInfo',(req,res)=>this.setTicketRaiseApiInfo(req,res));
        this.router.get('/chatgenie/info/:orgId',(req,res)=>this.getInfoChatGenie(req,res));
        // this.router.post('/gateway', (req, res)=>this.addSelectedGateWay(req, res));
        //this.router.post('/gateway', (req, res)=>this.getSelectedGateWay(req, res));
        // this.router.get('/gateway', (req, res)=>this.getSelectedGateWay(req, res));
        this.router.post('/pricingCode', (req, res) => this.price(req, res));
        this.router.get('/addOnPackages', (req, res) => this.getAddOnPackages(req, res));
        this.router.post('/createOrder', (req, res) => this.createOrder(req, res));
        this.router.post('/savePayment/offline', (req, res) => this.savePayment(req, res));
        this.router.get('/collection/names', (req, res) => this.getDBCollectionNames(req, res));
        this.router.get('/collection/keys/:name', (req, res) => this.getDBCollectionKeys(req, res));
        this.router.post('/taxPayer/access', (req, res) => this.getTaxPayerAccess(req, res));
        this.router.post('/caAccess', (req, res) => this.getCaAccess(req, res));
        this.router.post('/fileUplodeOnserver', (req, res) => this.fileUplodeOnserver(req, res));
        this.router.post('/linebylineformation', (req, res) => this.linebylineformation(req, res));
        this.router.post('/convertPdfToImage', (req, res) => this.convertPdfToImage(req, res));
        this.router.post('/cropImg', (req, res) => this.cropImg(req, res));
        this.router.post('/oflineOcrItems', (req, res) => this.oflineOcrItems(req, res));
        this.router.post('/jsontocsv', (req, res) => this.jsontocsv(req, res));
        this.router.post('/auto_training_req', (req, res) => this.auto_training_req(req, res));
        this.router.post('/auto_training_start', (req, res) => this.auto_training_start(req, res));
        this.router.post('/Auto_train', (req, res) => this.Auto_train(req, res));
        this.router.post('/update_fileuploadHistories', this.getbotInputOutput, (req, res) => this.update_fileuploadHistories(req, res));
        this.router.post('/searchFileData', (req, res) => this.searchFileData(req, res));
        this.router.post('/googleOcrData', (req, res) => this.googleOcrData(req, res));
        // this.router.post('/combineLines', (req, res) => this.combineLines(req, res));
        // this.router.post('/extractFeatures', (req, res) => this.extractFeatures(req, res));
        // this.router.post('/saveDocTrainData', (req, res) => this.saveDocTrainData(req, res));
        // this.router.post('/identifyTable', (req, res) => this.identifyTable(req, res));
        // this.router.post('/genrateCsv', (req, res) => this.genrateCsv(req, res));
        // this.router.post('/runTrainingForInvoice', (req, res) => this.runTrainingForInvoice(req, res));
        // this.router.post('/prepareFormData', (req, res) => this.prepareFormData(req, res));
        this.router.post('/mergeallfunction', (req, res) => this.mergeallfunction(req, res));
        // this.router.post('/saveObjectData', (req, res) => this.saveObjectData(req, res));
        ////adding on 22 april 2021  
        //start
        this.router.post('/addOrganisations', (req, res) => this.addOrganizationBulk(req, res))
        this.router.post('/cancelInvoice', (req, res) => this.cancelInvoice(req, res));
        this.router.post('/combinedFunctions', this.getbotInputOutput, (req, res) => this.combinedFunctions(req, res));
        this.router.post('/preMlFunctions', this.getbotInputOutput, (req, res) => this.preMlFunctions(req, res));
        this.router.post('/postMlFunctions', this.getbotInputOutput, (req, res) => this.postMlFunctions(req, res));

        this.router.post('/getsortedLines', this.getbotInputOutput, (req, res) => this.getsortedLines(req, res));
        this.router.post('/combineLines', this.getbotInputOutput, (req, res) => this.combineLines(req, res));
        this.router.post('/extractFeatures', this.getbotInputOutput, (req, res) => this.extractFeatures(req, res));
        this.router.post('/extractFeaturesAugment', this.getbotInputOutput, (req, res) => this.extractFeaturesAugment(req, res));
        this.router.post('/saveDocTrainData', this.getbotInputOutput, (req, res) => this.saveDocTrainData(req, res));
        this.router.post('/identifyTable', this.getbotInputOutput, (req, res) => this.identifyTable(req, res));
        this.router.post('/extractTableData', this.getbotInputOutput, (req, res) => this.extractTableData(req, res));
        this.router.post('/genrateCsv', this.getbotInputOutput, (req, res) => this.genrateCsv(req, res));
        this.router.post('/runTrainingForInvoice', this.getbotInputOutput, (req, res) => this.runTrainingForInvoice(req, res));
        this.router.post('/prepareFormData', this.getbotInputOutput, (req, res) => this.prepareFormData(req, res));
        this.router.post('/prepareCreateSave', this.getbotInputOutput, (req, res) => this.prepareCreateSave(req, res));
        this.router.post('/multiPageArray', this.getbotInputOutput, (req, res) => this.multiPageArray(req, res));
        this.router.post('/saveObjNew', this.getbotInputOutput, (req, res) => this.saveObjNew(req, res));
        this.router.post('/saveObjectData', this.getbotInputOutput, (req, res) => this.saveObjectData(req, res));
        this.router.post('/oflineocrItemsNew', this.getbotInputOutput, (req, res) => this.OflineocrItemsNew(req, res));
        this.router.post('/saveDocTrainData2', this.getbotInputOutput, (req, res) => this.saveDocTrainData2(req, res));
        this.router.post('/send-verify/otp', (req, res) => this.send_verify_otp(req, res));
        this.router.post('/send-verify/eOtp', (req, res) => this.send_verify_otp_email(req, res));
        this.router.post('/saveDeviceToken', (req, res) => this.saveDeviceToken(req, res));
        this.router.post('/pushNotication', (req, res) => this.pushNotication(req, res));
        this.router.post('/detectTable', (req, res) => this.detectTable(req, res));
        this.router.post('/linebylinemulti', (req, res) => this.linebylinemulti(req, res));

        this.router.post('/convertPdfToPng', (req, res) => this.convertPdfToPng(req, res));
        this.router.post('/saveFeedback',(req,res)=>this.saveFeedback(req,res));



        // end
        this.router.post('/send/sms/otp', function (request, res) {
            let http = require("https");
            let mobile_no = request.body.mobileNo;
            let options = {
                "method": "POST",
                "hostname": "sendotp.msg91.com",
                "port": null,
                "path": "/api/generateOTP",
                "headers": {
                    "application-key": "s6Z6niEo4dtygcgA0VCdmsqczRBGbFSMDYxABCa6NebFN-HlARjLn-cGEsv2hZc9VBlyWSm2A9TaQDLzj2gejqSnmjaMYERMOuqGQsNoBw2d7gJY_9iqJC2jjOBop2QZy0AOzoBtfZYxBgvUx9pRVw==",
                }
            };
            let req = http.request(options, function (response) {
                let chunks = [];
                response.on("data", function (chunk) {
                    chunks.push(chunk);
                });
                response.on("end", function () {
                    let body = Buffer.concat(chunks);
                    let data = JSON.parse(body.toString());
                    let entry = new OTP({ mobileNo: mobile_no, otp: data.response.oneTimePassword });
                    if (data.status == "success") {
                        entry.save(function (err) {
                            if (err) {
                                res.send({ "status": false, info: "unable to save otp" });
                            }
                            else {
                                res.send({ "status": true, info: "Otp saved" });
                            }
                        });
                    }
                    else {
                        res.send({ "status": false });
                    }
                });
            });
            req.write("{\n\n\"countryCode\": \"91\",\n \"mobileNumber\":" + mobile_no + ",\n  \"getGeneratedOTP\": true\n\n}");
            req.end();
        });
        
    }

    send_verify_otp(req, res) {
        const self = this;
        return __awaiter(this, void 0, void 0, function* () {
            try {
  
                const authkey = config.msg91AuthKey;
                const template_id = config.msg91templateId;
                let retryAPI = 5;
                let data;
                let otp_expiry = config.otp_expiry ? config.otp_expiry : 1;
                let mobileNo = req.body.mobileNo;
                let websiteUrl = req.body.websiteUrl;
                mobileNo = req.body.phoneCode ? `${req.body.phoneCode}${mobileNo}` : mobileNo;

                if(req.body.forgotPassword || req.body.action === 'verifyOtp'){
                    let info = yield user.findOne({"personalInfo.mobile":req.body.mobileNo,isDeleted:false},{"personalInfo.phoneCode":1});
		    console.log("info send verify otp",info);
                    if(!info){
                        return res.send({ message: 'No user found with this mobile number', type: 'error' });
                    }
                    if(info && info.personalInfo){
                        let phoneCode = info.personalInfo.phoneCode ? info.personalInfo.phoneCode : "91";
                        mobileNo = `${phoneCode}${mobileNo}`;
                    }
                }

                if (req.body.action == "sendOtp") {
                    let otp = Math.floor(1000000 + Math.random() * 9000000);

                    yield _otp.findOneAndUpdate({ mobileNo: req.body.mobileNo }, { otp: otp }, { upsert: true, new: true });

                    if(!util_1.isNullOrUndefined(req.body.forgotPassword))
                    {
                        let mailRes = yield self.sendMailforgetPass(req,otp);
                        if(mailRes['status']==1)
                        {
                          throw "Issue while sending Email"
                        }
                    }
                    do {
                        data = yield self.msg91ApisSend(`/api/v5/otp?template_id=${template_id}&mobile=${mobileNo}&authkey=${authkey}&otp_expiry=${otp_expiry}`,{'OTP' : otp})
                        // console.log(otp,data)
                        retryAPI--;
                    }
                    while (retryAPI && data['type'] != 'success');
                    data['expiry'] = otp_expiry;
                    res.send(data);
                }
                else if (req.body.action == "retryOtp") {
                    do {
                        data = yield self.msg91Apis(`/api/v5/otp/retry?authkey=${authkey}&retrytype=text&mobile=${mobileNo}`)
                        // console.log(data)
                        retryAPI--;
                    }
                    while (retryAPI && data['type'] != 'success' && !data['message'].includes("count maxed out"));
                    res.send(data);
                }
                else if (req.body.action == "verifyOtp") {
                    data = yield self.msg91Apis(`/api/v5/otp/verify?authkey=${authkey}&mobile=${mobileNo}&otp=${req.body.otp}`)
                    // console.log(data)

                    if (data['type'] == 'success') {

                        // let upD = yield (db.createDynamicModel('users')).findOne({ "personalInfo.mobile": req.body.mobileNo, isDeleted : false }).lean();
                        // if(upD)
                        // {
                        //     let uObj = { "OTPverification" : true };
                            
                        //     if(upD['Emailverification'])
                        //     {
                        //         uObj['isActive'] = true;
                        //         uObj['regStatus'] = true;
                        //     }
                        //     let uData = yield (db.createDynamicModel('users')).updateOne({ "personalInfo.mobile": req.body.mobileNo, isDeleted : false, }, {
                        //         $set : uObj
                        //     }).lean();
                        //     console.log(uObj,uData);

                        //     return res.send(data);
                        // }
                        // else
                        // {
                        //     return res.send({message: 'User not found', status : 1 , type: 'error'});
                        // }
                        let updateQuery = { isActive: true, OTPverification : true, regStatus : true };
                        if(util_1.isNullOrUndefined(req.body.forgotPassword)){
                            const userCount =  yield this.updateOrganisationUserCount(websiteUrl);
                            if(!util_1.isNullOrUndefined(userCount) && userCount === 0){
                                updateQuery.isActive = false;
                                updateQuery.limitExceeded = true;
                                data.limitExceeded = true;
                            }
                        }
                        let userData = yield (db.createDynamicModel('users')).findOneAndUpdate({ "personalInfo.mobile": req.body.mobileNo , isDeleted : false },updateQuery).lean();


                        if(!util_1.isNullOrUndefined(req.body.email)){
                        let license = "";
                        userData.parentUrl= "";
                        this.sendRegisterEmail(userData, license, userData.parentUrl, function (status, response) {
                            if (status) {
                                //throw 'err';
                                data.emailStatus = true;
                            }
                            else {
                                //res.send(new response_model_3.postResponse(true, null, userData));
                                data.emailStatus = false;
                            }
                        });
                    }

                        // console.log(userData);
                        data.verification = "verified";
                        return res.send(data);
                    }
                    else
                    {
                        return res.send(data)
                    }
                }
            }
            catch (e) {
                console.log("OTP--->", e)
                res.send({ message: 'Internal Server Error', type: 'error' });
            }
        });
    }

    send_verify_otp_email(req, res) {
        const self = this;
        return __awaiter(this, void 0, void 0, function* () {
            try {

                if (req.body.action == "sendOtp" || req.body.action == "retryOtp") {
                    let eOtp = Math.floor(1000000 + Math.random() * 9000000);

                    let transport = nodemailer.createTransport(accountsetup.createTransportObjectForRegister);
                    const emailOptions = {
                        from: accountsetup.from,
                        to: req.body.email,
                        subject: 'Verification code from AIQoD for sign up',
                        text: `<html><head><link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">${eOtp} is your verification code pls don't share it </span></p>                    <p><span><br></span></p>               </p></td>  </tr></table>  <p style="margin-left:px">Regards,</p><p></p> AIQoD | SaaS Support Team</p></body></html>`,
                        html: `<html><head><link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">${eOtp} is your verification code pls don't share it </span></p>                    <p><span><br></span></p>               </p></td>  </tr></table>  <p style="margin-left:px">Regards,</p><p></p> AIQoD | SaaS Support Team</p></body></html>`,
    
                    };
                    try {
                        const response = yield transport.sendMail(emailOptions);
                    
                        let test= yield user.findOneAndUpdate({ "personalInfo.email" : req.body.email, isDeleted : false }, { $set: { eOtp: String(eOtp) } });
                        
                        return res.send({message: 'Otp sent', status : 0  , type: 'success'});
                    } catch (error) {
                        console.log("otp_email errr------",e)
                        return res.send({ message: 'Internal Server Error',status : 1 , type: 'error' });
                    }
                }
                
                else if (req.body.action == "verifyOtp") {
                    
                    let upD = yield (db.createDynamicModel('users')).findOne({ "personalInfo.email" : req.body.email, isDeleted : false, eOtp : String(req.body.eOtp)}).lean();
                    if(upD)
                    {
                        let uObj = { "Emailverification" : true };
                        
                        if(upD['OTPverification'])
                        {
                            uObj['isActive'] = true;
                            uObj['regStatus'] = true;
                        }
                        let uData = yield (db.createDynamicModel('users')).updateOne({ "personalInfo.email" : req.body.email, isDeleted : false, eOtp : String(req.body.eOtp) }, {
                            $set : uObj
                        }).lean();
                        // console.log(uObj,uData);
                        return res.send({message: 'Otp verified', status : 0 , type: 'success' });
                    }
                    else
                    {
                        return res.send({message: 'Otp not matched', status : 1 , type: 'error'});
                    }
                }
            }
            catch (e) {
                console.log("OTP--->", e)
                res.send({ message: 'Internal Server Error', type: 'error' });
            }
        });
    }

    msg91ApisSend(path,data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield new Promise(function (resolve, reject) {

                const options = {
                    "method": "POST",
                    "url": `https://control.msg91.com${path}`,
                    "headers": {
                        "Content-Type": "application/json"
                    },
                    "body" : JSON.stringify(data)
                };

                // console.log(options);
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';

                request(options, function (error, res, body) {
                    if (error) {
                        resolve(error);
                    }
                    else {
                        try {
                            body = JSON.parse(body);
                        }
                        catch (e) { };

                        resolve(body);
                    }
                });
            })
        })
    }
    msg91Apis(path) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield new Promise(function (resolve, reject) {

                const options = {
                    "method": "GET",
                    "url": `https://control.msg91.com${path}`,
                    "headers": {
                        "Content-Type": "application/json"
                    }
                };

                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';

                request(options, function (error, res, body) {
                    if (error) {
                        resolve(error);
                    }
                    else {
                        try {
                            body = JSON.parse(body);
                        }
                        catch (e) { };

                        resolve(body);
                    }
                });
            })
        })
    }

    sendMailforgetPass(req,otp) {
      const self = this;
      return __awaiter(this, void 0, void 0, function* () {
          try {

            let a = yield user.findOne({ 'personalInfo.mobile': req.body.mobileNo, 'isActive': true }, { '_id': 1, 'personalInfo.name': 1, 'personalInfo.mobile': 1, 'personalInfo.email': 1 });
            let name, mobile, emailUser;
            if(!util_1.isNullOrUndefined(a)){
            name= a.personalInfo.name;
            mobile= a.personalInfo.mobile;
            mobile = mobile.replace(/.(?=..)/g, '*');
            emailUser= a.personalInfo.email;
          }

            if (emailUser) {
                // let emailconfig = config.emailConfig;
                //       var transport = nodemailer.createTransport(emailconfig);
                      let transport= nodemailer.createTransport(accountsetup.createTransportObjectForRegister);
                      const emailOptions = {
                          from: accountsetup.from,
                          to: emailUser,                    
                          subject: 'Verification code from AIQoD',
                          text: `<html><head><link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet"><title>Reset Password</title></head><body><table>  <tr>    <td> <p style="color: black;">Hi ${name},</p><p></p><p></p><p> <span style="color: black;"><b>There was a request to change your password <span style="color: rgb(107, 173, 222);">${mobile}</span> account.</b></span></p>                    <p><span style="color:black;">${otp} is your verification code pls don't share it </span></p>                    <p><span><br></span></p>               </p></td>  </tr></table>  <p style="margin-left:px">Regards,</p><p></p> AIQoD | SaaS Support Team</p></body></html>`,
                          html: `<html><head><link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet"><title>Reset Password</title></head><body><table>  <tr>    <td> <p style="color: black;">Hi ${name},</p><p></p><p></p><p> <span style="color: black;"><b>There was a request to change your password <span style="color: rgb(107, 173, 222);">${mobile}</span> account.</b></span></p>                    <p><span style="color:black;">${otp} is your verification code pls don't share it </span></p>                    <p><span><br></span></p>               </p></td>  </tr></table>  <p style="margin-left:px">Regards,</p><p></p> AIQoD | SaaS Support Team</p></body></html>`,
                      };
                      const response = yield transport.sendMail(emailOptions);

                    //   console.log(response);

                      return { message: 'Mail sent successfully', status: 0 };

              }
              else {
                  throw "Not found the Subscriber"
              }

          }
          catch (e) {
              console.log("User Not found--->", e)
              return { message: 'Internal Server Error', status: 1 };
              return 1;
          }
      });
  }

    geomapJsonSave(req, res) {

        return __awaiter(this, void 0, void 0, function* () {
            try {

                const fs = require('fs');

                let jsonContent = JSON.stringify(req.body);
                // console.log(jsonContent);
                let fileName = Date.now() + ".json";
                let filePath = config.path + fileName
                // console.log(filePath)

                fs.writeFile(filePath, jsonContent, 'utf8', function (err) {
                    if (err) {
                        console.log("An error occured while writing JSON Object to File.");
                        return console.log(err);
                    } else {
                        res.send({ status: true, info: filePath });
                        console.log("JSON file has been saved.");
                    }
                });
            }
            catch (e) {
                // console.log(e);
                res.send({ status: false, info: "Internal Server Error" });
            }
        });

    }



    saveDeviceToken(req, res) {
        const self = this;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let subId = req.body.subscriberId;
                let deviceToken = req.body.dT;

                if (subId && deviceToken) {
                    let raw = yield subscriber.findOne({ _id: subId });
                    raw = JSON.parse(JSON.stringify(raw));
                    if (raw.dT && raw.dT.includes(deviceToken)) {
                        res.send({ message: 'Alread Present', status: 0, data: data });
                    }
                    else {
                        let dTarr = raw.dT && Array.isArray(raw.dT) ? raw.dT : [];
                        dTarr.push(deviceToken);
                        let data = yield subscriber.findOneAndUpdate({ _id: subId },
                            {
                                $set: {
                                    dT: dTarr
                                }
                            })
                        // console.log(data)
                        res.send({ message: 'Updated Successfully', status: 0, data: data.dT });

                    }
                }
                else {
                    throw "Not found the Subscriber"
                }

            }
            catch (e) {
                console.log("OTP--->", e)
                res.send({ message: 'Internal Server Error', status: 1, type: 'error' });
                return 1;
            }
        });
    }
    pushNotication(req, res) {
        const self = this;
        return __awaiter(this, void 0, void 0, function* () {
            try {

                // let data = yield (db.createDynamicModel('subscribers')).find({ isDelete:false ,dT:{$exists:true}},{dT:1}).option({ allowDiskUse: true });                    ;
                let data = yield subscriber.find({ isDelete: false, dT: { $exists: true } }, { dT: 1 }).cursor();;

                let N = [];
                yield data.eachAsync(member => {
                    N = N.concat(member.dT)
                });

                N = [... new Set(N)];

                const options = {
                    "method": "POST",
                    "url": `https://fcm.googleapis.com/fcm/send`,
                    "headers": {
                        "Content-Type": "application/json",
                        "Authorization": `key=${config.fcmAuth}`
                    },
                    "body": {
                        "notification": {
                            "title": `${req.body.title}`,
                            "body": `${req.body.body}`,
                            "click_action": `${req.body.link}`
                        },
                        "priority": "high",
                        "registration_ids": N
                    },
                    "json": true,
                };

                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';

                request(options, function (error, r, body) {
                    if (error) {
                        res.send({ message: 'Internal Server Error', status: 1, data: error });
                    }
                    else {
                        res.send({ message: 'Data found Successfully', status: 0, data: body });
                    }
                });

                let d = yield subscriber.updateMany({ isDelete: false }, { $set: { uU: true } });
                // console.log(d);
            }
            catch (e) {
                console.log("OTP--->", e)
                res.send({ message: 'Internal Server Error', status: 1, type: 'error' });
            }
        });
    }

    // addSelectedGateWay(req,res){
    //
    //
    //
    //
    //
    // }
    //
    // getSelectedGateWay(req,res){
    //
    //     var query = businessType.find({isDeleted: false});
    //     query.exec(function (err, data) {
    //         if (err) {
    //             res.send(new getResponse(false, null, []));
    //         }
    //         else {
    //             if (data) {
    //                 res.send(new getResponse(true, null, data));
    //             }
    //             else {
    //                 res.send(new getResponse(false, null, data));
    //             }
    //         }
    //     });
    //
    // }
    // getAllSchemas()
    // {
    //     mongoose.modelNames().forEach(function(modelName){
    //         establishedModels[modelName] = mongoose.model(modelName);
    //     })
    // }
    // createDynamicModel(name, timeStamp="no") {
    //     if (!(name in establishedModels)) {
    //         var Any = new mongoose.Schema({}, { strict: false });
    //         if(timeStamp == "yes") {
    //             Any = new mongoose.Schema({}, { strict: false, timestamps:{createdAt:"created_At", updatedAt:"updated_At"}})
    //         }

    //         establishedModels[name] = mongoose.models[name]? mongoose.model(name): mongoose.model(name, Any , name);
    //     }
    //     return establishedModels[name];
    // }
    getbotInputOutput(req, res, next) {
        return __awaiter(this, void 0, void 0, function* () {
            try {

                console.log("In getBotInput----")
                let OutPutParse = JSON.parse(JSON.stringify(req.body.input))

                let ObjInput = {};
                for (let parameter in OutPutParse) {
                    if (!util_1.isNullOrUndefined(OutPutParse[parameter]) && typeof OutPutParse[parameter] == "string" && !util_1.isNullOrUndefined(OutPutParse[parameter].split("/"))) {
                        let splitChar = OutPutParse[parameter].split("/");
                        if (splitChar[splitChar.length - 1] == "isLocal") {
                            OutPutParse[parameter] = OutPutParse[parameter].replace("/isLocal", "");
                            console.log("Reading bot input from json file ----------------------->" + OutPutParse[parameter]);
                            OutPutParse[parameter] = yield fs.readFileSync(OutPutParse[parameter]);
                            ObjInput[parameter] = JSON.parse(OutPutParse[parameter]);
                        }
                        else {
                            ObjInput[parameter] = OutPutParse[parameter];
                        }
                    } else {
                        ObjInput[parameter] = OutPutParse[parameter];
                    }
                }

                req.body.input = ObjInput;

                // let ObjOutPut = {};
                // for(const parameter of OutPutParse.outputParameters){
                //     ObjOutPut[parameter] = "";
                // }
                //
                // OutPutParse.outputParameters = ObjOutPut

                next();
            } catch (err) {
                console.log("Error in read bot ", err);
                next();
            }
        });
    }

    formatBytes(bytes, decimals = 2) {
        if (bytes === 0) return '0 Bytes';

        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        const size = parseFloat((bytes / Math.pow(k, i)).toFixed(dm));
        console.log("fileSize ----  >>> ---- >> ", size + " " + sizes[i])
        if ((i < 2) || (i == 2 && size < 3)) {
            return true;
        } else {
            return false;
        }

    }

    writeBotOutPut(outputData, projectId, botId, iterationId, eventId,input={}) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                try {
                    let self = this;
                    // let outPut = JSON.parse(JSON.stringify(outputData));
                    let outPut = outputData;
                    console.log("In writeBotOuput----")
                    if (!util_1.isNullOrUndefined(outPut)) {
                        let outputKeys = Object.keys(outPut);
                        for (let i = 0; i < outputKeys.length; i++) {
                            if (!util_1.isNullOrUndefined(outPut[outputKeys[i]]) && typeof outPut[outputKeys[i]] !== "string" && isNaN(Number(outPut[outputKeys[i]]))) {
                                // let byte = bytes(JSON.stringify(outPut[outputKeys[i]]));
                                let byte = false;
                                try { if (JSON.stringify(outPut[outputKeys[i]]).length > 3 * 1024 * 1024) { byte = true; } } catch (e) { byte = true; }
                                if (byte || input.jsonRespond || (typeof outPut[outputKeys[i]] !== "object" && !util_1.isNullOrUndefined(outPut[outputKeys[i]].length) || outPut[outputKeys[i]].length > 100)) {
                                    let data = JSON.stringify(outPut[outputKeys[i]]);
                                    let filePath = config.OrchFilePath;
                                    if (!fs.existsSync(filePath)) {
                                        fs.mkdirSync(filePath);
                                    }
                                    filePath = filePath + projectId + '-' + eventId
                                    if (!fs.existsSync(filePath)) {
                                        fs.mkdirSync(filePath);
                                    }
                                    console.log("filePathb to write large json---------------------------->", filePath);
                                    filePath = filePath + "/" + botId + "_" + iterationId + "_" + outputKeys[i] + Math.random() + ".json";
                                    console.time("fileWrite")
                                    let file = yield fs.writeFileSync(filePath, data, 'utf-8');
                                    console.timeEnd("fileWrite")
                                    outPut[outputKeys[i]] = filePath + "/isLocal";
                                    // console.log(outPut[outputKeys[i]]);
                                }
                            }
                        }
                    }
                    resolve(outPut);
                } catch (e) {
                    console.log("Excewption in output bot" + JSON.stringify(e));
                    resolve(outputData);
                }
            }));
        });
    }
    getToken(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const query = user.findOne({ 'personalInfo.mobile': req.body.mobile, isDeleted: false, userType: { $in: ['admin-bu', 'admin-ca', 'admin-sme', 'employee', 'admin-gsp', 'admin-asp', 'admin-reseller', 'admin-sales', 'agent-employee'] } }).populate('organisation role');
                this.getUpdateToken(query, req, res);
            }
            catch (e) {
                // console.log(e);
                res.send({ status: false, info: "getToken not giving data" });
            }
        });
    }
    getUser(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const userId = req.params.id;
                const data = yield user.findById(userId).lean();
                return res.send({ status: 0, info: "UserData fetched successfully", data : data });
            }
            catch (e) {
                // console.log(e);
                return res.send({ status: 1, info: "getToken not giving data", data : e });
            }
        });
    }

    fetchOtp(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { mobileNo } = req.body;
    
                // Validation for input
                if (!mobileNo) {
                    return res.status(400).send({ status: 1, info: "Mobile number is required" });
                }
    
                let collectionOtp = yield  db.collection("otps").findOne({"mobileNo":Number(req.body.mobileNo)});
                collectionOtp = JSON.parse(JSON.stringify(collectionOtp))
// console.log(collectionOtp,typeof(req.body.mobileNo)) // Replace with your collection name
                
    
                if (collectionOtp) {
                    return res.send({ status: 0, info: "OTP fetched successfully", data: collectionOtp.otp });
                } else {
                   return res.status(404).send({ status: 1, info: "OTP not found for the given mobile number" });
                }
            } catch (error) {
                console.error("Error fetching OTP:", error);
                return res.status(500).send({ status: 1, info: "Internal server error", data: error });
            }
        });
    }
    

    getUpdateToken(query, req, res) {
        const self = this;
        query.exec(function (err, loginData) {
            if (loginData) {
                let subQuery = subscriber.findOne({ _id: loginData.subscriberId }).populate(['packages','creditpackages']);
                subQuery.exec((err, subscriberDetail) => {
                    let permissionsList = [];
                    let creditBased = subscriberDetail.creditBased ? true : false;
                    let packages = creditBased ? subscriberDetail.creditpackages : subscriberDetail.packages;
                    _.each(packages, function (packItem) {
                        _.each(packItem.additionalParametersValues, function (list) {
                            _.each(list.permissions, function (permission) {
                                if (permission.isChecked == true)
                                    permissionsList.push(permission);
                            });
                        });
                    });
                    permissionsList = _.uniq(permissionsList);
                    self.tokenWithPermissions(req, loginData, permissionsList,creditBased, function (status, token, error, data) {
                        if (status) {
                            res.send({
                                status: true,
                                token: token,
                                info: "Previous " +
                                    "session status has changed now you can log in",
                                userData: data
                            });
                        }
                        else {
                            res.send({
                                status: false,
                                token: "",
                                info: "Error" +
                                    " code 4",
                                userData: []
                            });
                        }
                    });
                });
            }
            else {
                res.send({ status: false, info: "getUpdateToken didn't give data" });
            }
        });
    }
    tokenWithPermissions(req, loginData, permissionsList,creditBased, callback) {
        let permissions;
        permissions = _.chain(permissionsList).groupBy('permissionName').map(function (value, key) {
            return key;
        }).value();
        if (loginData.userType == "admin-sme" || loginData.userType == "admin-ca" || loginData.userType == "admin-bu" || loginData.userType == "admin-gsp" || loginData.userType == "admin-asp" || loginData.userType == "admin-reseller" || loginData.userType == "admin-sales") {
            permissionsList = permissions;
        }
        else {
            permissionsList = [];
            _.each(loginData.role.permissions, function (permission) {
                permissionsList.push(permission.permissionName);
            });
        }
        permissionsList = permissionsList.filter(function (item, i, ar) {
            return ar.indexOf(item) === i;
        });
        var token = jwt.encode({
            "permission": permissionsList,
            "userId": loginData._id,
            "userType": loginData.userType,
            // "allPermissions":permissions,
            "subscriberId": loginData.subscriberId,
            "userName": loginData.personalInfo.name,
            //"role": loginData.role,
            //"roleId":loginData.role["_id"],
            "type": loginData.type,
            "accessKeyId": s3.accessKeyId,
            "secretAccessKey": s3.secretAccessKey,
            "endpoint": s3.endpoint,
            "signatureVersion": s3.signatureVersion,
            "creditBased": creditBased,
            "region": s3.region,
            "Bucket": s3.Bucket,
            "ACL": s3.ACL,
            "kli": (req.body.kli ? req.body.kli : false),
            // nbf: (Date.now() / 1000),
            exp: Math.round(new Date(Date.now() + config.tokenExpiry * 60 * 1000).getTime() / 1000)
        }, JWT_SECRET);
        callback(true, token, "Here is the updated token");
    }

    getSelectedGateWay(req, res) {
        var query = configSchema.find({ isDeleted: false });
        query.exec(function (err, data) {
            if (err) {
                logger.error(err);
                res.send(new response_model_4.getResponse(false, null, []));
            }
            else {
                if (data) {
                    res.send(new response_model_4.getResponse(true, null, data));
                }
                else {
                    res.send(new response_model_4.getResponse(false, null, data));
                }
            }
        });
    }
    saveContact(req, res) {
        var Contact = new contact(req.body);
        var self = this;
        Contact.save((err) => {
            if (err) {
                res.send(new response_model_5.postResponse(false, err, []));
            }
            else {
                var mailOptions = {
                    from: '"Adhigam" <helpdesk@adhigam.com>',
                    to: 'helpdesk@adhigam.com',
                    subject: req.body.company + '(' + req.body.mobile + ')' + req.body.email + '--Name:' + req.body.name,
                    //subject:"welcome", // Subject line
                    // plain text body
                    html: 'Hello,<br>' + req.body.message,
                    replyTo: req.body.email
                };
                this.sendMail.sendEmail(mailOptions, function (err, data) {
                    if (!err) {
                        res.json(new response_model_2.customResponse(true, null, [], "Thank you for Your Interest in Adhigam , we will get back to you in 24 hours."));
                    }
                    else {
                        ////console.log(err);
                        res.json(new response_model_5.postResponse(false, null, []));
                    }
                });
            }
        });
    }
    saveSubscribe(req, res) {
        var Subscribe = new subscribe(req.body);
        Subscribe.save((err) => {
            if (err) {
                res.send(new response_model_5.postResponse(false, err, []));
            }
            else {
                var link = "http://" + config.URL + "/" + req.body.email;
                var mailOptions = {
                    from: '"Adhigam" <adhigam@gmail.com.com>',
                    to: req.body.email,
                    subject: 'Subscribe to Adhigam',
                    // plain text body
                    html: '"Hello,Thanku For subscription<br> Please Click on the link to unsubscribe.<br><a href="' + link + '">Click here to reset</a>"'
                };
                if (this.sendMail.sendEmail(mailOptions)) {
                    res.json(new response_model_5.postResponse(true, null, []));
                }
                else {
                    res.json(new response_model_5.postResponse(false, null, []));
                }
            }
        });
    }
    unSubscribe(req, res) {
        var self = this;
        subscribe.findOne({ email: req.body.email }, function (err, data) {
            if (data) {
                ////console.log(data);
                data.isSubcribe = false;
                data.save(function (err, data) {
                    if (err) {
                        res.send(new response_model_2.putResponse(false, err, []));
                    }
                    else {
                        var mailOptions = {
                            from: '"Adhigam" <adhigam@gmail.com.com>',
                            to: req.body.email,
                            subject: 'unSubscribe to Adhigam',
                            // plain text body
                            html: '<H1>unsubscribe succesfully<H1>' // html body
                        };
                        if (self.sendMail.sendEmail(mailOptions)) {
                            res.json(new response_model_5.postResponse(true, null, []));
                        }
                        else {
                            res.json(new response_model_5.postResponse(false, null, []));
                        }
                    }
                });
            }
            else {
                res.send(new response_model_2.putResponse(false, null, []));
            }
        });
    }
    buy(req, res) {
        product.find({ _id: req.body.productId }, function (err, pakageData) {
            if (err)
                res.send(new response_model_4.getResponse(false, err, []));
            else {
                let packages = [];
                let permissionsList = [];
                let permissions = [];
                packages.push(pakageData[0]._id);
                _.each(pakageData[0].additionalParametersValues, function (list) {
                    _.each(list.permissions, function (permission) {
                        if (permission.isChecked == true)
                            permissionsList.push(permission);
                    });
                });
                permissions = _.chain(permissionsList).groupBy('permissionName').map(function (value, key) {
                    return key;
                }).value();
                userData.permission = permissions;
                ////console.log(permissions);
                let transactionData = new transaction(req.body);
                transactionData.description = "cash payment";
                transactionData.paymentStatus = req.body.paymentStatus;
                transactionData.packageId = req.body.productId;
                transactionData.paymentId = req.body.paymentId;
                //transactionData.tax=pakageData[0].tax;
                //transactionData.amount=pakageData[0].amount;
                transactionData.userId = userData._id;
                transactionData.paymentMode = "online";
                transactionData.subscriberId = subscriber._id;
                transactionData.save((err) => {
                    if (err) {
                        res.send(new response_model_5.postResponse(false, null, err));
                    }
                    else {
                        res.send(new response_model_5.postResponse(true, null, transactionData));
                    }
                });
            }
        });
    }
    register(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            const self = this;
            let personalInfo = req.body.personalInfo;
            if (util_2.isNullOrUndefined(req.body.personalInfo)) {
                personalInfo = req.body;
            }
            user.findOne({ "personalInfo.mobile": personalInfo.mobile }, function (err, data) {
                if (err) {
                    res.send(new response_model_4.getResponse(false, err, []));
                }
                else {
                    if (data) {
                        //res.send(new getResponse(false, null, [],"Mobile number already registered !"));
                        res.send(new response_model_2.customResponse(false, [], [], "Mobile number already registered !"));
                    }
                    else {
                        if (!req.body.productId) {
                            let subscriberObj = { user: {}, subscriber: {} };
                            subscriberObj = personalInfo;
                            subscriberObj["user"] = req.body.userId;
                            subscriberObj["subscriber"] = req.body.subscriberId;
                            subscriberObj["subscriptionDate"] = new Date();
                            subscriberObj["renewalDate"] = new Date();
                            subscriberObj["isDelete"] = false;
                            subscriberObj["paymentStatus"] = false;
                            let subscriber = new Subscriber(subscriberObj);
                            subscriber.save((err) => {
                                if (err) {
                                    if (err.name === 'MongoError' && err.code === 11000) {
                                        res.send(new response_model_6.duplicateResponse(false, null, err));
                                    }
                                    else {
                                        res.send({ status: false, info: "subscriber not saved", data: [] });
                                    }
                                }
                                else {
                                    ////console.log("Subscriber ID created");
                                    let subscriberId = subscriber._id;
                                    let userData = new user(req.body);
                                    if (req.body.subscriberType == 'individual') {
                                        userData.userType = 'admin-sme';
                                    }
                                    else {
                                        if (req.body.subscriberType == 'business') {
                                            userData.userType = 'admin-bu';
                                        }
                                        else if (req.body.subscriberType == 'admin-gsp') {
                                            userData.userType = 'admin-gsp';
                                        }
                                        else if (req.body.subscriberType == 'admin-asp') {
                                            userData.userType = 'admin-asp';
                                        }
                                        else {
                                            userData.userType = 'admin-ca';
                                        }
                                    }
                                    userData.address = {
                                        stateCode: "",
                                        area: "",
                                        pinCode: 0,
                                        city: "",
                                        state: null,
                                    };
                                    userData.personalInfo = personalInfo;
                                    //userData.personalInfo.password = req.body.personalInfo.password;
                                    userData.personalInfo.password =
                                        bycrypt.hashSync(personalInfo.password);
                                    // userData.personalInfo.password = personalInfo.password;
                                    if (req.body.status == 'active') {
                                        userData.isActive = true;
                                    }
                                    else {
                                        userData.isActive = false;
                                    }
                                    userData.subscriberId = subscriber._id;
                                    //let packages = [];
                                    //let permissionsList = [];
                                    //let permissions = [];
                                    //packages.push(pakageData[0]._id);
                                    //_.each(pakageData[0].additionalParametersValues, function (list) {
                                    //
                                    //    _.each(list.permissions, function (permission) {
                                    //        if(permission.isChecked==true)
                                    //            permissionsList.push(permission);
                                    //    });
                                    //});
                                    //permissions = _.chain(permissionsList).groupBy('permissionName').map(function (value, key) {
                                    //    return key
                                    //}).value();
                                    //
                                    //userData.permission = permissions;
                                    //
                                    userData.save((err) => {
                                        if (err) {
                                            res.send(new response_model_5.postResponse(false, null, err));
                                        }
                                        else {
                                            //Aj mail to be integrated
                                            var mailOptions = {
                                                from: '"Adhigam" <helpdesk@adhigam.com>',
                                                to: personalInfo.email,
                                                subject: "Thank you for subscribing to adhigam",
                                                //subject:"welcome", // Subject line
                                                // plain text body
                                                html: '<!DOCTYPE html><html><head><title></title></head><body style="font-family: roboto"><table align="center" width="600px" style="background:#2A7447; padding: 15px"><tr><td style="background: #0F5E5B; padding:0 15px;padding-bottom: 20px"><table align="center" width="100%"><tr><td align="center" width="600px"><h2 style="background: #4f7b61;padding: 10px 0;color:#FFFFFF;font-size: 20px;text-align: center;margin:0">Thank you for subscribing to Adhigam</h2></td></tr><tr><td style="color: #FFFFFF;font-size: 15px;padding-top: 10px"><p style="margin:5px 0">Hi ' + personalInfo.name + '!</p><p style="margin:5px 0">Welcome to Adhigam - Your Wise Choice, GSTwise!</p><p style="margin:5px 0">We simplify GST implementation with premium products and service offerings.</p></td></tr><tr><td><table align="center" width="100%"><tr><td> <img src="https://www.adhigam.com/assets/template-pages/comment@300.png"></td><td> <a href="https://www.adhigam.com/#/login" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"> <img src="https://www.adhigam.com/assets/template-pages/phone@200.png"> </a></td></tr></table></td></tr><tr><td style="color: #FFFFFF"><p style="margin:5px 0">In the meantime, you can</p><p style="position: relative;"> <img src="https://www.adhigam.com/assets/template-pages/horn.png" style="position: absolute;left: 0;bottom: 0;position: absolute;left: -45px;bottom: -45px;width: 50px;"> <a href="https://www.adhigam.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><span style="color: #FFFFFF;background-color: #436FCC;padding: 10px;cursor: pointer;">Return to our website</span></a> to continue browsing.</p><p style="margin:5px 0"><br></p><p style="margin:5px 0">For assistance please reply to <a href="mailto:helpdesk@adhigam.com" title="helpdesk@adhigam.com" style="color: #FFFFFF;">helpdesk@adhigam.com</a></p><p style="margin:5px 0"><br></p><p style="margin:5px 0">Best Regards</p><p style="margin:5px 0">Team Adhigam</p></td></tr></table></td></tr><tr><td align="center" width="600px"><table><tr><td style="padding: 5px;color:#FFFFFF;font-size: 15px;text-align: center;">Contact us on</td></tr><tr><td style="color: #FFFFFF"><table><tr><td><a href="https://www.facebook.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/fb.png" style="width: 30px"></a></td><td><a href="https://www.twitter.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/tw.png" style="width: 30px"></a></td><td><a href="https://www.linkedin.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/ln.png" style="width: 30px"></a></td></tr></table></td></tr></table></td></tr></table></body></html>'
                                            };
                                            self.sendMail.sendEmail(mailOptions, function (err, data) {
                                                if (!err) {
                                                }
                                                else {
                                                }
                                            });
                                            if (util_2.isNullOrUndefined(req.body.personalInfo)) {
                                                res.send(new response_model_5.postResponse(true, null, subscriber));
                                            }
                                            else {
                                                res.send(new response_model_5.postResponse(true, null, userData));
                                            }
                                        }
                                        //    //else {
                                        //    //    let userData = new user(req.body);
                                        //    //
                                        //    //    if (req.body.subscriberType == 'individual') {
                                        //    //        userData.userType = 'admin-sme';
                                        //    //    }
                                        //    //    else {
                                        //    //        if (req.body.subscriberType == 'business') {
                                        //    //            userData.userType = 'admin-bu';
                                        //    //
                                        //    //        } else {
                                        //    //            userData.userType = 'admin-ca';
                                        //    //        }
                                        //    //    }
                                        //    //
                                        //    //    userData.address = {
                                        //    //        stateCode: "",
                                        //    //        area: "",
                                        //    //        pinCode: 0,
                                        //    //        city: "",
                                        //    //        state: null,
                                        //    //    };
                                        //    //
                                        //    //    userData.personalInfo = req.body.personalInfo;
                                        //    //    //userData.personalInfo.password = req.body.personalInfo.password;
                                        //    //    userData.personalInfo.password = bycrypt.hashSync(req.body.personalInfo.password);
                                        //    //    userData.isActive=true;
                                        //    //    userData.subscriberId=subData._id;
                                        //    //    let packages=[];
                                        //    //    let permissionsList=[];
                                        //    //    let permissions=[];
                                        //    //
                                        //    //    packages.push(pakageData[0]._id);
                                        //    //    _.each(pakageData[0].additionalParametersValues, function (list) {
                                        //    //
                                        //    //        _.each(list.permissions, function (permission) {
                                        //    //            permissionsList.push(permission);
                                        //    //        });
                                        //    //    });
                                        //    //    permissions= _.chain(permissionsList).groupBy('permissionName').map(function(value, key) {
                                        //    //        return key
                                        //    //    }).value();
                                        //    //
                                        //    //    userData.permission=permissions;
                                        //    //    userData.save((err) => {
                                        //    //        if (err) {
                                        //    //            res.send(new postResponse(false,null,err));
                                        //    //
                                        //    //        } else {
                                        //    //
                                        //    //            let transactionData = new transaction(req.body);
                                        //    //            transactionData.description="cash payment";
                                        //    //            transactionData.paymentStatus=req.body.paymentStatus;
                                        //    //            transactionData.packageId=req.body.productId;
                                        //    //            transactionData.paymentId=req.body.paymentId;
                                        //    //            transactionData.tax=pakageData.tax;
                                        //    //            transactionData.amount=pakageData.amount;
                                        //    //            transactionData.userId=userData._id;
                                        //    //            transactionData.paymentMode="cash";
                                        //    //            transactionData.subscriberId=subData._id;
                                        //    //
                                        //    //            transactionData.save((err) => {
                                        //    //                if (err) {
                                        //    //
                                        //    //                    res.send(new postResponse(false,null,err));
                                        //    //
                                        //    //                } else {
                                        //    //                    res.send(new postResponse(true, null, {
                                        //    //                        subscriberId: subData._id,
                                        //    //                        userId: userData._id
                                        //    //                    }));
                                        //    //                }
                                        //    //            });
                                        //    //
                                        //    //        }
                                        //    //    });
                                        //    //
                                        //    //}
                                        //});
                                    });
                                }
                            });
                        }
                        else {
                            ////console.log(req.body.productId);
                            product.find({ _id: req.body.productId }, function (err, pakageData) {
                                if (err)
                                    res.send(new response_model_4.getResponse(false, err, []));
                                else {
                                    let subscriber = new Subscriber(personalInfo);
                                    subscriber.packages = req.body.productId;
                                    subscriber.status = "active";
                                    subscriber.save((err) => {
                                        if (err) {
                                            if (err.name === 'MongoError' && err.code === 11000) {
                                                res.send(new response_model_6.duplicateResponse(false, null, err));
                                            }
                                        }
                                        else {
                                            ////console.log("Subscriber ID created");
                                            let subscriberId = subscriber._id;
                                            let userData = new user(req.body);
                                            if (req.body.subscriberType == 'individual') {
                                                userData.userType = 'admin-sme';
                                            }
                                            else {
                                                if (req.body.subscriberType == 'business') {
                                                    userData.userType = 'admin-bu';
                                                }
                                                else {
                                                    userData.userType = 'admin-ca';
                                                }
                                            }
                                            userData.address = {
                                                stateCode: "",
                                                area: "",
                                                pinCode: 0,
                                                city: "",
                                                state: null,
                                            };
                                            userData.personalInfo = personalInfo;
                                            //userData.personalInfo.password = req.body.personalInfo.password;
                                            userData.personalInfo.password = bycrypt.hashSync(personalInfo.password);
                                            //userData.personalInfo.password = personalInfo.password;
                                            userData.isActive = true;
                                            userData.subscriberId = subscriber._id;
                                            let packages = [];
                                            let permissionsList = [];
                                            let permissions = [];
                                            packages.push(pakageData[0]._id);
                                            _.each(pakageData[0].additionalParametersValues, function (list) {
                                                _.each(list.permissions, function (permission) {
                                                    if (permission.isChecked == true)
                                                        permissionsList.push(permission);
                                                });
                                            });
                                            permissions = _.chain(permissionsList).groupBy('permissionName').map(function (value, key) {
                                                return key;
                                            }).value();
                                            userData.permission = permissions;
                                            ////console.log(permissions);
                                            userData.save((err) => {
                                                if (err) {
                                                    res.send(new response_model_5.postResponse(false, null, err));
                                                }
                                                else {
                                                    let transactionData = new transaction(req.body);
                                                    transactionData.description = "cash payment";
                                                    transactionData.paymentStatus = req.body.paymentStatus;
                                                    transactionData.packageId = req.body.productId;
                                                    transactionData.paymentId = req.body.paymentId;
                                                    //transactionData.tax=pakageData[0].tax;
                                                    //transactionData.amount=pakageData[0].amount;
                                                    transactionData.userId = userData._id;
                                                    transactionData.paymentMode = "online";
                                                    transactionData.subscriberId = subscriber._id;
                                                    transactionData.save((err) => {
                                                        if (err) {
                                                            res.send(new response_model_5.postResponse(false, null, err));
                                                        }
                                                        else {
                                                            var mailOptions = {
                                                                from: '"Adhigam" <helpdesk@adhigam.com>',
                                                                to: personalInfo.email,
                                                                subject: "Thank you for subscribing to adhigam",
                                                                //subject:"welcome", // Subject line
                                                                // plain text body
                                                                html: '<!DOCTYPE html><html><head><title></title></head><body style="font-family: roboto"><table align="center" width="600px" style="background:#2A7447; padding: 15px"><tr><td style="background: #0F5E5B; padding:0 15px;padding-bottom: 20px"><table align="center" width="100%"><tr><td align="center" width="600px"><h2 style="background: #4f7b61;padding: 10px 0;color:#FFFFFF;font-size: 20px;text-align: center;margin:0">Thank you for subscribing to Adhigam</h2></td></tr><tr><td style="color: #FFFFFF;font-size: 15px;padding-top: 10px"><p style="margin:5px 0">Hi ' + req.body.personalInfo.name + '!</p><p style="margin:5px 0">Welcome to Adhigam - Your Wise Choice, GSTwise!</p><p style="margin:5px 0">We simplify GST implementation with premium products and service offerings.</p></td></tr><tr><td><table align="center" width="100%"><tr><td> <img src="https://www.adhigam.com/assets/template-pages/comment@300.png"></td><td> <a href="https://www.adhigam.com/#/login" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"> <img src="https://www.adhigam.com/assets/template-pages/phone@200.png"> </a></td></tr></table></td></tr><tr><td style="color: #FFFFFF"><p style="margin:5px 0">In the meantime, you can</p><p style="position: relative;"> <img src="https://www.adhigam.com/assets/template-pages/horn.png" style="position: absolute;left: 0;bottom: 0;position: absolute;left: -45px;bottom: -45px;width: 50px;"> <a href="https://www.adhigam.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><span style="color: #FFFFFF;background-color: #436FCC;padding: 10px;cursor: pointer;">Return to our website</span></a> to continue browsing.</p><p style="margin:5px 0"><br></p><p style="margin:5px 0">For assistance please reply to <a href="mailto:helpdesk@adhigam.com" title="helpdesk@adhigam.com" style="color: #FFFFFF;">helpdesk@adhigam.com</a></p><p style="margin:5px 0"><br></p><p style="margin:5px 0">Best Regards</p><p style="margin:5px 0">Team Adhigam</p></td></tr></table></td></tr><tr><td align="center" width="600px"><table><tr><td style="padding: 5px;color:#FFFFFF;font-size: 15px;text-align: center;">Contact us on</td></tr><tr><td style="color: #FFFFFF"><table><tr><td><a href="https://www.facebook.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/fb.png" style="width: 30px"></a></td><td><a href="https://www.twitter.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/tw.png" style="width: 30px"></a></td><td><a href="https://www.linkedin.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/ln.png" style="width: 30px"></a></td></tr></table></td></tr></table></td></tr></table></body></html>'
                                                            };
                                                            self.sendMail.sendEmail(mailOptions, function (err, data) {
                                                                if (!err) {
                                                                }
                                                                else {
                                                                }
                                                            });
                                                            res.send(new response_model_5.postResponse(true, null, transactionData));
                                                        }
                                                    });
                                                }
                                                //    //else {
                                                //    //    let userData = new user(req.body);
                                                //    //
                                                //    //    if (req.body.subscriberType == 'individual') {
                                                //    //        userData.userType = 'admin-sme';
                                                //    //    }
                                                //    //    else {
                                                //    //        if (req.body.subscriberType == 'business') {
                                                //    //            userData.userType = 'admin-bu';
                                                //    //
                                                //    //        } else {
                                                //    //            userData.userType = 'admin-ca';
                                                //    //        }
                                                //    //    }
                                                //    //
                                                //    //    userData.address = {
                                                //    //        stateCode: "",
                                                //    //        area: "",
                                                //    //        pinCode: 0,
                                                //    //        city: "",
                                                //    //        state: null,
                                                //    //    };
                                                //    //
                                                //    //    userData.personalInfo = req.body.personalInfo;
                                                //    //    //userData.personalInfo.password = req.body.personalInfo.password;
                                                //    //    userData.personalInfo.password = bycrypt.hashSync(req.body.personalInfo.password);
                                                //    //    userData.isActive=true;
                                                //    //    userData.subscriberId=subData._id;
                                                //    //    let packages=[];
                                                //    //    let permissionsList=[];
                                                //    //    let permissions=[];
                                                //    //
                                                //    //    packages.push(pakageData[0]._id);
                                                //    //    _.each(pakageData[0].additionalParametersValues, function (list) {
                                                //    //
                                                //    //        _.each(list.permissions, function (permission) {
                                                //    //            permissionsList.push(permission);
                                                //    //        });
                                                //    //    });
                                                //    //    permissions= _.chain(permissionsList).groupBy('permissionName').map(function(value, key) {
                                                //    //        return key
                                                //    //    }).value();
                                                //    //
                                                //    //    userData.permission=permissions;
                                                //    //    userData.save((err) => {
                                                //    //        if (err) {
                                                //    //            res.send(new postResponse(false,null,err));
                                                //    //
                                                //    //        } else {
                                                //    //
                                                //    //            let transactionData = new transaction(req.body);
                                                //    //            transactionData.description="cash payment";
                                                //    //            transactionData.paymentStatus=req.body.paymentStatus;
                                                //    //            transactionData.packageId=req.body.productId;
                                                //    //            transactionData.paymentId=req.body.paymentId;
                                                //    //            transactionData.tax=pakageData.tax;
                                                //    //            transactionData.amount=pakageData.amount;
                                                //    //            transactionData.userId=userData._id;
                                                //    //            transactionData.paymentMode="cash";
                                                //    //            transactionData.subscriberId=subData._id;
                                                //    //
                                                //    //            transactionData.save((err) => {
                                                //    //                if (err) {
                                                //    //
                                                //    //                    res.send(new postResponse(false,null,err));
                                                //    //
                                                //    //                } else {
                                                //    //                    res.send(new postResponse(true, null, {
                                                //    //                        subscriberId: subData._id,
                                                //    //                        userId: userData._id
                                                //    //                    }));
                                                //    //                }
                                                //    //            });
                                                //    //
                                                //    //        }
                                                //    //    });
                                                //    //
                                                //    //}
                                                //});
                                            });
                                        }
                                    });
                                }
                            });
                        }
                    }
                }
            });
        });
    }
    updateRegister(req, res) {
        //"subscriberId": "591818d415092857e7fa72c8",
        //"userId": "591818d415092857e7fa72c9",
        //"paymentId": "pay_7qTUj0LPnW51O7",
        //"paymentStatus": true,
        //"cartList": []
        let permissionsList = [];
        let permissions = [];
        let userData;
        let subscriberData;
        let packages = [];
        let orgData = {};
        if (req.body.paymentStatus == true) {
            ////console.log("Payment Done");
            product.find({ "packageType": "Free" }, function (err, adhigamPackage) {
                if (err)
                    res.send(new response_model_2.putResponse(false, err, []));
                else {
                    packages.push(adhigamPackage[0]._id);
                    _.each(adhigamPackage[0].additionalParametersValues[0].value, function (list) {
                        _.each(list.permissions, function (permission) {
                            permissionsList.push(permission);
                        });
                    });
                    permissions = _.chain(permissionsList).groupBy('permissionName').map(function (value, key) {
                        return key;
                    }).value();
                    //res.send(new putResponse(true,err,permissions));
                    userData = {
                        permission: permissions,
                        isActive: true
                    };
                    subscriberData = {
                        packages: packages,
                        status: "active",
                    };
                    ////console.log("sub", subscriberData);
                    Subscriber.findOneAndUpdate({ _id: req.body.subscriberId }, subscriberData, {
                        new: true,
                        upsert: true,
                        setDefaultsOnInsert: true
                    }, function (err, subscriberD) {
                        if (err)
                            res.send(new response_model_2.putResponse(false, err, []));
                        else {
                            ////console.log("Subscriber ID Updated");
                            ////console.log(subscriberD);
                            user.findOneAndUpdate({ _id: req.body.userId }, userData, {
                                new: true,
                                upsert: true,
                                setDefaultsOnInsert: true
                            }, function (err, UserD) {
                                if (err)
                                    res.send(new response_model_2.putResponse(false, err, []));
                                else {
                                    ////console.log("Transaction ID Updated");
                                    ////console.log(UserD);
                                    let tran = new transaction();
                                    tran.status = "paid";
                                    tran.description = "Package paid";
                                    tran.paymentId = req.body.paymentId;
                                    tran.subscriberId = req.body.subscriberId;
                                    tran.createUser = req.body.userId;
                                    tran.amount = '25000';
                                    tran.tax = '250';
                                    tran.package = packages;
                                    tran.save(function (err) {
                                        if (err) {
                                            res.send(new response_model_2.putResponse(false, err, tran));
                                        }
                                        else {
                                            ////console.log("Transaction ID Updated");
                                            res.send(new response_model_5.postResponse(true, null, {
                                                userId: req.body.userId,
                                                subscriberId: subscriberD._id
                                            }));
                                        }
                                    });
                                }
                            });
                        }
                    });
                }
            });
        }
        else {
        }
    }
    registerrnew(req, res) {
        ////console.log("Registration Started");
        //user.findOne({"personalInfo.mobile": req.body.personalInfo.mobile}, function (err, fuser) {
        //    if (err) {
        //        res.send(new getResponse(false, err, []));
        //    }
        //    else {
        //        if (fuser) {
        //            res.send(new duplicateResponse(false, null, fuser));
        //        }
        //        else {
        let subscriber = new Subscriber(req.body.personalInfo);
        subscriber.save((err) => {
            if (err) {
                if (err.name === 'MongoError' && err.code === 11000) {
                    res.send(new response_model_6.duplicateResponse(false, null, err));
                }
            }
            else {
                ////console.log("Subscriber ID created");
                let subscriberId = subscriber._id;
                var org = new organisation(req.body.personalInfo);
                org.subscriberId = subscriberId;
                org.save((err) => {
                    if (err) {
                        if (err.name === 'MongoError' && err.code === 11000) {
                            ////console.log("Organisation Org Exist");
                            res.send(new response_model_6.duplicateResponse(false, null, err));
                        }
                        else {
                        }
                    }
                    else {
                        ////console.log("Organisation ID created");
                        let orgId = org._id;
                        var newUser = new user(req.body);
                        newUser.supervisor = 0;
                        newUser.isActive = false;
                        newUser.subscriberId = subscriberId;
                        newUser.orgId = orgId;
                        newUser.organisation = orgId;
                        newUser.userType = 'admin';
                        newUser.personalInfo.password = bycrypt.hashSync(req.body.personalInfo.password);
                        newUser.personalInfo.email = req.body.personalInfo.email;
                        newUser.personalInfo.name = req.body.personalInfo.name;
                        newUser.save((err) => {
                            if (err) {
                                if (err.name === 'MongoError' && err.code === 11000) {
                                    // Duplicate username
                                    res.send(new response_model_6.duplicateResponse(false, null, err));
                                }
                                else {
                                    res.json({
                                        status: false,
                                        info: 'while storing User somthing went wrong',
                                        data: err
                                    });
                                }
                            }
                            else {
                                ////console.log("User ID created");
                                res.send(new response_model_5.postResponse(true, null, {
                                    userId: newUser._id,
                                    orgId: org._id,
                                    subscriberId: subscriber._id
                                }));
                            }
                        });
                    }
                });
            }
        }); //subscriber saved
        //    }
        //    }
        //
        //
        //});
    }
    registerr(req, res) {
        let org = new _organisation();
        org.save((err) => {
            if (err) {
                if (err.name === 'MongoError' && err.code === 11000) {
                    // Duplicate username
                    return res.status(500).send({
                        succes: false,
                        message: 'Organisation already exist!'
                    });
                }
            }
            else {
                ////console.log("called org saved");
                var organisationHchy = new organisationHierarchy();
                organisationHchy.orgId = org._id;
                ////console.log(organisationHchy);
                organisationHchy.save((err) => {
                    if (err) {
                        if (err.name === 'MongoError' && err.code === 11000) {
                        }
                        else {
                        }
                    }
                    else {
                        ////console.log("Hierrchy Saved");
                        ////console.log(req.body);
                        req.body.orgId = org._id;
                        req.body.supervisor = 0;
                        //req.body.permission = permissions;
                        var newUser = new user(req.body);
                        ////console.log(newUser);
                        //newUser.parentOrg=org._id;
                        //newUser.organisation=organisationHchy._id;
                        newUser.isActive = false;
                        newUser.userType = 'admin';
                        newUser.personalInfo.password = bycrypt.hashSync(req.body.personalInfo.password);
                        newUser.save((err) => {
                            if (err) {
                                if (err.name === 'MongoError' && err.code === 11000) {
                                    // Duplicate username
                                    res.json({
                                        status: false,
                                        info: 'user already exists',
                                        data: [{
                                            userId: newUser._id,
                                            ordId: newUser.orgId,
                                            childOrg: organisationHchy._id
                                        }]
                                    });
                                }
                                else {
                                    res.json({
                                        status: false,
                                        info: 'Somthing Went Wrong',
                                        data: err
                                    });
                                }
                            }
                            else {
                                res.json({
                                    status: true,
                                    info: 'user saved successfully',
                                    data: [{ userId: newUser._id, ordId: newUser.orgId, childOrg: organisationHchy._id }]
                                });
                            }
                        });
                    }
                });
            }
        }); //organisation save end
        ////console.log("register called");
        let permissions;
        var organisationData = {};
        var cartlist = req.body.cartList;
        var arrayData = [];
        var permissionNameList = [];
        product.findOne({ "packageType": "Free" }, function (err, data) {
            if (err) {
                ////console.log("Package Not found");
                res.json({
                    status: false,
                    info: 'Error!! Free Registration Not allowed !!',
                    data: []
                });
            }
            else {
                if (!data) {
                    res.json({
                        status: true,
                        info: 'Free Registration Not allowed !!',
                        data: []
                    });
                }
                else {
                    ////console.log("Free Product Found");
                    data = JSON.parse(JSON.stringify(data));
                    product.find({ '_id': data._id }, function (err, docs) {
                        ////console.log("called product find");
                        let permissionsList = [];
                        _.each(docs[0].additionalParametersValues[0].value, function (list) {
                            _.each(list.permissions, function (permission) {
                                permissionsList.push(permission);
                            });
                        });
                        permissions = _.chain(permissionsList).groupBy('permissionName').map(function (value, key) {
                            return key;
                        }).value();
                    }); //find free package end here
                }
            }
        });
    }
    updateRegisterNew(req, res) {
        ////console.log("Update Register");
        let permissionsList = [];
        let permissions = [];
        let userData;
        let subscriberData;
        let packages = [];
        let orgData = {};
        if (req.body.paymentStatus == true) {
            ////console.log("Payment Done");
            product.find({ "packageType": "Free" }, function (err, adhigamPackage) {
                if (err)
                    res.send(new response_model_2.putResponse(false, err, []));
                else {
                    packages.push(adhigamPackage[0]._id);
                    _.each(adhigamPackage[0].additionalParametersValues[0].value, function (list) {
                        _.each(list.permissions, function (permission) {
                            permissionsList.push(permission);
                        });
                    });
                    permissions = _.chain(permissionsList).groupBy('permissionName').map(function (value, key) {
                        return key;
                    }).value();
                    //res.send(new putResponse(true,err,permissions));
                    userData = {
                        permission: permissions,
                        isActive: true
                    };
                    subscriberData = {
                        packages: packages,
                    };
                    ////console.log("sub", subscriberData);
                    Subscriber.findOneAndUpdate({ _id: req.body.subscriberId }, subscriberData, {
                        new: true,
                        upsert: true,
                        setDefaultsOnInsert: true
                    }, function (err, subscriberD) {
                        if (err)
                            res.send(new response_model_2.putResponse(false, err, []));
                        else {
                            ////console.log("Subscriber ID Updated");
                            ////console.log(subscriberD);
                            user.findOneAndUpdate({ _id: req.body.userId }, userData, {
                                new: true,
                                upsert: true,
                                setDefaultsOnInsert: true
                            }, function (err, UserD) {
                                if (err)
                                    res.send(new response_model_2.putResponse(false, err, []));
                                else {
                                    ////console.log("Transaction ID Updated");
                                    ////console.log(UserD);
                                    let tran = new transaction();
                                    tran.status = "paid";
                                    tran.description = "Package paid";
                                    tran.paymentId = req.body.paymentId;
                                    tran.save(function (err) {
                                        if (err) {
                                            res.send(new response_model_2.putResponse(false, err, tran));
                                        }
                                        else {
                                            ////console.log("Transaction ID Updated");
                                            res.send(new response_model_5.postResponse(true, null, {
                                                userId: req.body.userId,
                                                subscriberId: subscriberD._id
                                            }));
                                        }
                                    });
                                }
                            });
                        }
                    });
                }
            });
        }
        else {
            ////console.log("No Payment");
            req.body.organisation.primaryAddress = req.body.address;
            orgData = req.body.organisation;
            userData = { address: req.body.address };
            ////console.log("Subscriber ID Updated");
            organisation.findOneAndUpdate({ _id: req.body.orgId }, orgData, {
                new: true,
                upsert: true,
                setDefaultsOnInsert: true
            }, function (err, org) {
                if (err)
                    res.send(new response_model_2.putResponse(false, err, []));
                else {
                    ////console.log("Organisation ID Updated");
                    user.findOneAndUpdate({ _id: req.body.userId }, userData, {
                        new: true,
                        upsert: true,
                        setDefaultsOnInsert: true
                    }, function (err, org) {
                        if (err)
                            res.send(new response_model_2.putResponse(false, err, []));
                        else {
                            ////console.log("User ID Updated");
                            res.send(new response_model_5.postResponse(true, null, {
                                userId: req.body.userId,
                                orgId: req.body.orgId,
                                subscriberId: req.body.subscriberId
                            }));
                        }
                    });
                }
            });
        }
    }
    updateRegistere(req, res) {
        ////console.log("Update Registerd Called");
        let updateData = req.body;
        if (req.body.paymentStatus == undefined) {
            ////console.log(updateData);
            var newUser = new user();
            ////console.log(newUser);
            ////console.log("====");
            ////console.log(updateData);
            ////console.log(user);
            ////console.log(req.body.userId);
            ////console.log(updateData.organisation);
            ////console.log(updateData.address);
            //updateData.primaryAddress=updateData.address;
            let org = new _organisation(req.body.organisation);
            org._id = req.body.orgId;
            org.primaryAddress = req.body.address;
            ////console.log(org);
            //res.send({status:true,info:"Empty",data:org});
            var query = { _id: req.body.userId };
            user.findOne(query, function (err, us) {
                if (err) {
                    res.send(new response_model_4.getResponse(false, err, []));
                }
                else {
                    us.address = req.body.address;
                    us.save(err => {
                        if (!err) {
                        }
                    });
                }
            });
            organisation.findOneAndUpdate({ _id: req.body.orgId }, org, {
                new: true,
                upsert: true,
                setDefaultsOnInsert: true
            }, function (err, doc) {
                if (err) {
                    ////console.log("Fail");
                    res.send(new response_model_2.putResponse(false, err, []));
                }
                else {
                    //let orgh=new organisationHierarchy(req.body.organisation);
                    //
                    ////console.log(org);
                    ////console.log(orgh);
                    organisationHierarchy.findOneAndUpdate({ _id: req.body.childOrg }, req.body.organisation, {
                        new: true,
                        upsert: true,
                        setDefaultsOnInsert: true
                    }, function (err, orgHi) {
                        if (err) {
                            if (err.name === 'MongoError' && err.code === 11000) {
                            }
                            else {
                                ////console.log("Hierrchy Update Error");
                                res.send(new response_model_2.putResponse(false, err, []));
                            }
                        }
                        else {
                            res.send(new response_model_2.putResponse(true, null, orgHi));
                        }
                    });
                }
            });
        }
        else if (req.body.paymentStatus == true) {
            if (req.body.cartList) {
                ////console.log("Payment Done Successfully !");
                user.findOne({ _id: req.body.userId }, function (err, data) {
                    ////console.log("Finding User", req.body.userId);
                    _.each(req.body.cartList, function (cart) {
                        data.cartList.push(cart);
                        ////console.log("getting all cart");
                    });
                    data.save(function (err) {
                        ////console.log("adding cart to user schema");
                        if (err) {
                            ////console.log("Got Error while saving user", err);
                            res.send(new response_model_2.putResponse(false, err, []));
                        }
                        else {
                            ////console.log("user updated successfully save");
                            user.findOne({ _id: req.body.userId }, function (err, data) {
                                ////console.log("inside Data");
                                if (err) {
                                    res.send({ "status": false, info: "user not found" });
                                }
                                else {
                                    let arrayData = [];
                                    let permissionNameList = [];
                                    if (data) {
                                        ////console.log("data array");
                                        _.each(data.cartList, function (cart) {
                                            arrayData.push(cart._id);
                                        });
                                    }
                                    else {
                                        res.send(new response_model_2.putResponse(false, null, []));
                                    }
                                }
                            });
                        }
                    });
                });
            }
            else {
                user.findOne({ _id: req.body.userId }, function (err, userData) {
                    ////console.log(userData);
                    if (err) {
                        res.send({ "status": false, info: "user not found" });
                    }
                    else {
                        let arrayData = [];
                        let permissionNameList = [];
                        if (userData) {
                            _.each(userData.cartList, function (cart) {
                                arrayData.push(cart._id);
                            });
                            product.find({ '_id': { $in: arrayData } }, function (err, docs) {
                                _.each(docs, function (comments) {
                                    _.each(comments.permissionsMaster, function (masterObj) {
                                        if (masterObj.isAll) {
                                            permissionNameList.push(masterObj.groupName + '.' + 'all');
                                        }
                                        else {
                                            _.each(masterObj.permissions, function (permission) {
                                                if (permission) {
                                                    permissionNameList.push(permission.key);
                                                }
                                            });
                                        }
                                    });
                                });
                                userData.permission = _.union(permissionNameList, userData.permission);
                                userData.paymentId = updateData.paymentId;
                                //userData.save(function (err) {
                                //
                                //    if (err) {
                                //        res.send(new putResponse(false,err,[]));
                                //    }
                                //    else
                                //    {
                                //        res.send(new putResponse(true,null,[]));
                                //    }
                                //
                                //});
                            });
                        }
                        else {
                            res.send(new response_model_2.putResponse(false, null, []));
                        }
                    }
                });
            }
        }
    }
    loginUser(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // const userData = req.body;
                // const orgData = yield this.orgRoute.getParentOrgDetails(userData.parentUrl);
                // const subscribers = yield this.getParentSubscriberList(orgData.subscriberId);
                const query = user.findOne({ 'personalInfo.mobile': req.body.mobile, isDeleted: false, userType: { $in: ['admin-bu', 'admin-ca', 'admin-sme', 'employee', 'admin-gsp', 'admin-asp', 'admin-reseller', 'admin-sales', 'agent-employee'] } }).populate('role');
                // user.findOne({ "personalInfo.mobile": userData.mobile, "subscriberId": { $in: subscribers }, "isDeleted": false }).populate('organisation role');
                this.login(query, req, res);
            }
            catch (e) {
                // console.log(e);
                res.send({ status: false, info: "Internal Server Error" });
            }
        });
    }
    logoutUser(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const userData = req.body;
                let ip = req.body.ip;
                let uId = req.body.uId;
                const re = yield logOfUser.updateMany({ userId: uId, ip: ip }, { $set: { lO: true } })
                res.send({ status: true, info: "Logged out" })
            }
            catch (e) {
                // console.log(e);
                res.send({ status: false, info: "Internal Server Error" });
            }
        });
    }
    login(query, req, res) {
        // let userData = new user();
        const self = this;
        // let headers = req.headers;
        let threshold = config.threshold === undefined ? "00:00:00" : config.threshold;
        this.header = req.headers;
        query.exec(function (err, loginData) {
            if (loginData) {
                let subQuery = subscriber.findOne({ _id: loginData.subscriberId }).populate(['packages','creditpackages']);
                subQuery.exec(async (err, subscriberDetail) => {
                    __awaiter(this, void 0, void 0, function* () {
                    try {
                        console.log("subscriber data",subscriberDetail);
                        if (!util_1.isNullOrUndefined(subscriberDetail.licenseExpiry)) {
                            let validityDaysRemaining = self.websiteHelper.calculateLicenseValidityRemainingDays(subscriberDetail, new Date());
                            if (validityDaysRemaining < 0) {
                                return res.send({
                                    status: false,
                                    info: responseMessages.license.expired,
                                    userData: []
                                });
                            }
                        }
                        let permissionsList = [];
                        let creditBased = subscriberDetail.creditBased ? true : false;
                        let packages = creditBased ? subscriberDetail.creditpackages : subscriberDetail.packages;
                        // let packageIdList = [];
                        _.each(packages, function (packItem) {
                            _.each(packItem.additionalParametersValues, function (list) {
                                _.each(list.permissions, function (permission) {
                                    if (permission.isChecked == true)
                                        permissionsList.push(permission);
                                });
                            });
                        });
                        permissionsList = _.uniq(permissionsList);
                        if (loginData.personalInfo.password === null) {
                            res.send({
                                status: false,
                                info: "reset your account password. please contact your system administrator",
                                userData: []
                            });
                        }
                        else {
    
                            if (req.body.encrypt) {
                                // let algorithm = config.crypto.Alogo; // or any other algorithm supported by OpenSSL
                                // let key = config.crypto.key;
                                // let iv = config.crypto.IV;
    
                                // let decipher = crypto.createDecipheriv(algorithm, key, iv);
                                // let decrypted = decipher.update(req.body.password, 'base64', 'utf8');
                                // decrypted = (decrypted + decipher.final('utf8'));
    
                                let decrypted;
                                try {
                                    const bytes = CryptoJS.AES.decrypt(req.body.password, config.crypto.key);
                                    if (bytes.toString()) {
                                        decrypted = JSON.parse(bytes.toString(CryptoJS.enc.Utf8));
                                    }
                                    else {
                                        decrypted = req.body.password;
                                    }
                                } catch (e) {
                                    decrypted = req.body.password;
                                    // console.log(e);
                                }
    
                                console.log("Decrypting password ---- ", req.body.password);
    
                                req.body.password = decrypted;
    
                                console.log("Decrypted password ---- ", req.body.password);
    
                            }
                            // var data = bycrypt.compareSync(req.body.password, loginData.personalInfo.password);
                            const data = yield bycrypt.compare(req.body.password, loginData.personalInfo.password);

                            //data =
                            // req.body.password.localeCompare(loginData.personalInfo.password)==0? 1:0;
                            if (data) {
                                if(!loginData.isActive && loginData.limitExceeded === true){
                                        let userCount = yield self.updateOrganisationUserCount(req.body.parentUrl);
                                        if(!util_1.isNullOrUndefined(userCount) && userCount > 0){
                                            let userInfo = yield (db.createDynamicModel('users')).findOneAndUpdate({_id:loginData._id},{isActive:true,limitExceeded:false},{
                                                new:true
                                            }).lean();
                                            loginData.isActive = userInfo.isActive;
                                            loginData.limitExceeded = userInfo.limitExceeded
                                        }
                                }
                                if (!loginData.isActive || loginData.isDeleted || loginData.limitExceeded === true) {
                                    if (loginData.isDeleted) {
                                        res.send({
                                            status: false,
                                            info: "your account is deleted. please contact your system administrator",
                                            userData: []
                                        });
                                    }
                                    else if(loginData.limitExceeded === true) {
    
                                        res.send({
                                            status: false,
                                            info: "We experiencing high registration with the platform we already registered you but you will not able to login we will notify once you will able to login",
                                            userData: []
                                        });
                                    } else {
                                        res.send({
                                            status: false,
                                            info: "your account is disabled. please contact your system administrator",
                                            userData: []
                                        });
                                    }
                                }
                                else {
                                    let userId = loginData._id;
                                    let subscriberId = loginData.subscriberId;
                                    let gstin = "";
                                    self.userLoggedInOnMutlipleMachines(userId, subscriberId, gstin, function (status, msg, data) {
                                        if (status && data.length) {
                                            // let _id = data[0]._id;
                                            // let ip = data[0].ip;
                                            // let lO = data[0].lO;
                                            let lastLogin = data[0].lastLogin;
                                            let browserName = data[0].data;
                                            let currentDateTime = moment();
                                            let lastLoginDateTime = moment.utc(lastLogin);
                                            let duration = moment(currentDateTime).diff(moment(lastLoginDateTime));
                                            let differenceBetweenSession = moment(duration).format("HH:mm:ss");
                                            let checkWithTime = self.timeToMinutes(differenceBetweenSession) >=
                                                self.timeToMinutes(threshold);
    
                                            // let exp = new Date(new Date(lastLogin).getTime() + config.lSession * 60000);
                                            // if (ip !== req.body.ip && exp > new Date() && !lO && false) {
                                            //     checkWithTime = false;
                                            // }
                                            if (checkWithTime) {
                                                //Here you have to change status of userLog status to False
                                                self.checkLogin(req, loginData, permissionsList,creditBased, function (status, token, error, data) {
                                                    if (status) {

                                                            self.insertUserLogData(userId, subscriberId, gstin, req.body.ip, function (insertError, insertResp) {
                                                                if (!insertError && insertResp) {
                                                                    res.send({
                                                                        status: true,
                                                                        token: token,
                                                                        info: "Previous " +
                                                                            "session status has changed now you can log in",
                                                                        userData: data
                                                                    });
                                                                }
                                                                else {
                                                                    res.send({
                                                                        status: false,
                                                                        token: "",
                                                                        info: "Error" +
                                                                            " code 4",
                                                                        userData: []
                                                                    });
                                                                }
                                                            });
                                                        }
                                                    else {
                                                        res.send({
                                                            status: false, token: "", info: "Error" +
                                                                " code 6",
                                                            userData: []
                                                        });
                                                    }
                                                });
                                            }
                                            else {
                                                //Here you will be sending message to user saying "you
                                                // looged in with another machine as well"
                                                if (!util_1.isNullOrUndefined(threshold)) {
                                                    browserName = "another machine";
                                                    let ableToLoginAfter = self.timeToMinutes(differenceBetweenSession) -
                                                        self.timeToMinutes(threshold);
                                                    let information = " We found ,you logged in on" +
                                                        browserName +
                                                        " Either you logout from that" +
                                                        " browser or" +
                                                        " wait for " + ableToLoginAfter + " min";
                                                    res.send({
                                                        status: false, token: "", info: information,
                                                        userData: []
                                                    });
                                                }
                                                else {
                                                    res.send({
                                                        status: false, token: "", info: "Please" +
                                                            " specify threshold value from config file",
                                                        userData: []
                                                    });
                                                }
                                            }
                                        }
                                        else {
                                            self.checkLogin(req, loginData, permissionsList,creditBased, function (status, token, error, data) {
                                                if (status) {

                                                        self.insertUserLogData(userId, subscriberId, gstin, req.body.ip, function (insertError, insertResp) {
                                                            if (!insertError && insertResp) {
                                                                res.send({
                                                                    status: status,
                                                                    token: token,
                                                                    info: "",
                                                                    userData: data
                                                                });
                                                            }
                                                            else {
                                                                res.send({
                                                                    status: false,
                                                                    token: "",
                                                                    info: "Error" +
                                                                        " code 4",
                                                                    userData: []
                                                                });
                                                            }
                                                        });
                                                }
                                                else {
                                                    res.send({
                                                        status: status,
                                                        token: "",
                                                        info: error,
                                                        userData: data
                                                    });
                                                }
                                            });
                                        }
                                    });
                                }
                            }
                            else {
                                if (loginData.mtries && loginData.mtries.ct && loginData.mtries.exp && loginData.mtries.ct > config.limit && loginData.mtries.exp > new Date()) {
    
                                    user.findByIdAndUpdate(loginData._id, { isActive: false }, function (err, model) {
                                        res.send({
                                            status: false,
                                            info: "Mobile No. or Password is incorrect",
                                            userData: loginData
                                        });
                                    });
                                }
                                else {
                                    if (loginData.mtries.exp && loginData.mtries.exp < new Date()) {
                                        loginData.mtries.ct = 1;
                                        loginData.mtries.exp = new Date(new Date().getTime());
    
                                    }
                                    else if (loginData.mtries.ct) {
                                        loginData.mtries.ct++;
                                    }
                                    else {
                                        loginData.mtries = {};
                                        loginData.mtries.ct = 1;
    
                                        loginData.mtries.exp = new Date(new Date().getTime());;
                                    }
    
                                    if (loginData.mtries && loginData.mtries.ct && loginData.mtries.exp && loginData.mtries.ct > config.limit && loginData.mtries.exp > new Date()) {
    
                                        user.findByIdAndUpdate(loginData._id, { isActive: false }, function (err, model) {
                                            res.send({
                                                status: false,
                                                info: "Your account is disabled. Please, Contact your system administrator",
                                                userData: loginData
                                            });
                                        });
                                    }
                                    else {
    
                                        user.findByIdAndUpdate(loginData._id, { mtries: loginData.mtries }, function (err, model) {
                                            res.send({
                                                status: false,
                                                info: "Mobile No. or Password is incorrect",
                                                userData: loginData
                                            });
                                        });
                                    }
                                }
                            }
                        }
                    } catch(e){
                        // console.log(e);
                        res.send({ status: false, info: "Internal Server Error" });
                    }
                })
                });
            }
            else {
                res.send({ status: false, info: "Mobile No. or Password is incorrect" });
            }
        });
    }
    timeToMinutes(time) {
        var timeArray = time.split(":");
        var finalMinutes = (parseInt(timeArray[0]) * 60) + parseInt(timeArray[1]);
        return finalMinutes;
    }
    checkLogin(req, loginData, permissionsList,creditBased, callback) {
        /*
         This function will take req and login data that we got when we are checking mobile
         number exists . This function will simply return only whethere user data present or not
         */
        //let permissionsList = [];
        let permissions;
        permissions = _.chain(permissionsList).groupBy('permissionName').map(function (value, key) {
            return key;
        }).value();
        // if (loginData.userType == "admin-sme" || loginData.userType == "admin-ca" ||
        //     loginData.userType == "admin-bu") {
        //     ////console.log("User Type : Yes");
        //     permissionsList = loginData.permission;
        // }
        // else {
        //     _.each(loginData.role.permissions, function (permission) {
        //         permissionsList.push(permission.permissionName);
        //     });
        // }
        //
        // permissionsList = permissionsList.filter(function (item, i, ar) {
        //     return ar.indexOf(item) === i;
        // });
        //
        // var token = jwt.encode({
        //     "permission": permissionsList,
        //     "userId": loginData._id,
        //     "subscriberId": loginData.subscriberId,
        //     "userName": loginData.personalInfo.name,
        //     "panNumber": loginData.personalInfo.panNumber,
        //     "role":loginData.role,
        //     nbf: (Date.now() / 1000),
        //     exp: Math.round(new Date(Date.now() + config.tokenExpiry*60*1000).getTime() / 1000)
        // }, JWT_SECRET);
        //
        // var query = user.findOne({'personalInfo.mobile': req.body.mobile}, '-personalInfo.password -permission').populate('organisation role');
        // query.exec(function (err, data) {
        //     if (err) {
        //         //res.send({status: false, info: "Password not match", userData: data});
        //         callback(false,"","Password not match",data);
        //     }
        //     else {
        //         var query = Subscriber.findOne({
        //             _id: loginData.subscriberId,
        //             isDelete: false
        //         }).populate('packages');
        //
        //         query.exec(function (err, subscribeData) {
        //             if (err) {
        //                 //res.send(new getResponse(false, err, []));
        //                 callback(false,"",err,[]);
        //             }
        //             else {
        //                 data.subscriber = subscribeData;
        //                 //res.send({
        //                 //    status: true,
        //                 //    token: token,
        //                 //    info: "Password match",
        //                 //    userData: data
        //                 //});
        //                 callback(true,token,"Password matched",data);
        //             }
        //         });
        //     }
        // });
        if (loginData.userType == "admin-sme" || loginData.userType == "admin-ca" || loginData.userType == "admin-bu" || loginData.userType == "admin-gsp" || loginData.userType == "admin-asp" || loginData.userType == "admin-reseller" || loginData.userType == "admin-sales") {
            permissionsList = permissions;
        }
        else {
            permissionsList = [];
            _.each(loginData.role.permissions, function (permission) {
                permissionsList.push(permission.permissionName);
            });
        }
        permissionsList = permissionsList.filter(function (item, i, ar) {
            return ar.indexOf(item) === i;
        });
        permissionsList.push('dashboard.screen');
        loginData=JSON.parse(JSON.stringify(loginData))
        var token = jwt.encode({
            "permission": permissionsList,
            "userId": loginData._id,
            "userType": loginData.userType,
            "regType": loginData.regType,
            // "allPermissions":permissions,
            "subscriberId": loginData.subscriberId,
            "userName": loginData.personalInfo.name,
            "role": { "_id": loginData.role ? loginData.role["_id"] : "" },
            "deptId" : loginData.deptId,
            //"roleId": loginData.role["_id"],
            "type": loginData.type,
            "creditBased": creditBased,
            "accessKeyId": s3.accessKeyId,
            "secretAccessKey": s3.secretAccessKey,
            "endpoint": s3.endpoint,
            "signatureVersion": s3.signatureVersion,
            "region": s3.region,
            "Bucket": s3.Bucket,
            "ACL": s3.ACL,
            "kli": (req.body.kli ? req.body.kli : false),
            "defaultAccessContol":util_1.isNullOrUndefined(loginData.defaultAccessContol)?[]:loginData.defaultAccessContol,
            // nbf: (Date.now() / 1000),
            exp: Math.round(new Date(Date.now() + config.tokenExpiry * 60 * 1000).getTime() / 1000)
        }, JWT_SECRET);
        var query = user.findOne({ 'personalInfo.mobile': req.body.mobile,isDeleted:false }, '-personalInfo.password -permission').populate('organisation role');
        query.lean().exec(function (err, data) {
            if (err) {
                //res.send({status: false, info: "Password not match", userData: data});
                callback(false, "Password not match", null);
            }
            else {
                var query = Subscriber.findOne({
                    _id: loginData.subscriberId,
                    isDelete: false
                });
                query.lean().exec(function (err, subscribeData) {
                    if (err) {
                        //res.send(new getResponse(false, err, []));
                        callback(false, err, []);
                    }
                    else {
                        data.subscriber = subscribeData;
                        data.locationPreference = data.organisation.locationPreference;
                        
                        /*var renewDate=moment(subscribeData.renewalDate).format("YYYY/MM/DD");
                         var currentDate=moment().format("YYYY/MM/DD");
                         if(currentDate >= moment(renewDate).add(15,'days').format("YYYY/MM/DD")){
                         res.send({status: false, info: "Your subcription is expired please recharge your account!!!", userData: data})
                         }
                         else{
                         res.send({status: true, token: token, info: "Password match", userData: data});
                         }*/
                        // res.send({
                        //     status: true,
                        //     token: token,
                        //     info: "Password match",
                        //     userData: data
                        // });
                        callback(true, token, "Password match", data);
                    }
                });
            }
        });
    }
    userLoggedInOnMutlipleMachines(userId, subscriberId, gstin, callback) {
        var self = this;
        self.getUserLogDataByUserId(userId, function (err, resp) {
            if (!err) {
                if (resp.status) {
                    //code here to check current status of user logg data.Of it is true then
                    // code for user is logged in other machine as well
                    //callback(true,"Got logg data",userLoggData);
                    var userLoggData = resp.data;
                    if (userLoggData.length > 0) {
                        var status = userLoggData[0].status;
                        if (status) {
                            //If status is true then give him message that Please close previous
                            // session and write a code for updating status to false after 10mins
                            callback(true, "Some other session is still exists . Please logout" +
                                " your previous session or wait for 10 min and login again", userLoggData);
                        }
                        else {
                            //do normal login
                            callback(false, "No other session found", userLoggData);
                        }
                    }
                    else {
                        callback(false, "No other session found", userLoggData);
                    }
                }
                else {
                    callback(false, "Error while getting user logg data2 ", []);
                }
            }
            else {
                callback(false, err, []);
            }
        });
    }
    getUserLogDataByUserId(userId, callback) {
        /*
         This function is used to get user loggs data . It will take userId as an input
         */
        logOfUser.find({ userId: userId }).sort({ lastLogin: -1 }).limit(1).exec(function (err, data) {
            if (!err) {
                if (data == null) {
                    callback(null, { status: true, data: [] });
                }
                else {
                    if (data.length > 0) {
                        callback(null, { status: true, data: data });
                    }
                    else {
                        callback(null, { status: true, data: [] });
                    }
                }
            }
            else {
                callback(err, { status: false, data: [] });
            }
        });
    }
    insertUserLogData(userId, subscriberId, gstin, ip, callback) {
        /*
         This function is used to insert a data into userLogg
         */
        var tzoffset = (new Date()).getTimezoneOffset() * 60000; //offset in milliseconds
        var localISOTime = (new Date(Date.now() - tzoffset)).toISOString().slice(0, -1);
        let dHeader = JSON.parse(JSON.stringify(this.header));
        delete dHeader['cookie'];

        var userData = {
            userId: userId,
            subscriberId: subscriberId,
            gstin: gstin,
            lastLogin: localISOTime,
            isFeaturesUpdated: false,
            status: true,
            data: dHeader,
            ip: ip
        };
        var logOfUsers = new logOfUser(userData);
        logOfUsers.save((saveError) => {
            if (!saveError) {
                callback(null, true);
            }
            else {
                callback(saveError, false);
            }
        });
    }
    updateUserLogStatus(_id, status, currentDateTime, callback) {
        var d = new Date();
        var d = new Date();
        var tzoffset = (new Date()).getTimezoneOffset() * 60000; //offset in milliseconds
        var localISOTime = (new Date(Date.now() - tzoffset)).toISOString().slice(0, -1);
        var userData = {
            status: status,
            lastLogin: localISOTime,
        };
        logOfUser.findOneAndUpdate({ _id: _id }, userData).exec(function (err, data) {
            if (!err) {
                callback(null, { status: true, data: data });
            }
            else {
                callback(err, { status: false, data: [] });
            }
        });
    }
    verify(req, res) {
        let oneHours = 3600 * 1000;
        let oneHoursAgo = new Date(new Date().getTime() - oneHours);
        let query = {
            mobileNo: req.body.mobileNo, otp: req.body.otp, createdAt: {
                $gte: oneHoursAgo,
                $lt: Date.now()
            }
        };
        ////console.log(req.body.otp);
        OTP.findOne(query, function (err, response) {
            if (err) {
                res.send({ "status": false, info: "Invalid OTP" });
            }
            else {
                if (response) {
                    ////console.log("otp " + response.otp);
                    if (response.otp && req.body.otp) {
                        ////console.log(response.otp);
                        if (req.body.otp == response.otp)
                            res.send({ "status": true, info: "Valid OTP" });
                        else
                            res.send({ "status": false, info: "Invalid OTP" });
                    }
                    else {
                        res.send({ "status": false, info: "Invalid OTP" });
                    }
                }
                else {
                    res.send({ "status": false, info: "Invalid OTP" });
                }
            }
        });
    }
    sendSms(request, res) {
        user.findOne({ 'personalInfo.mobile': request.body.mobileNo }, function (err, data) {
            if (data) {
                let http = require("https");
                let mobile_no = request.body.mobileNo;
                let options = {
                    "method": "POST",
                    "hostname": "sendotp.msg91.com",
                    "port": null,
                    "path": "/api/generateOTP",
                    "headers": {
                        "application-key": "s6Z6niEo4dtygcgA0VCdmsqczRBGbFSMDYxABCa6NebFN-HlARjLn-cGEsv2hZc9VBlyWSm2A9TaQDLzj2gejqSnmjaMYERMOuqGQsNoBw2d7gJY_9iqJC2jjOBop2QZy0AOzoBtfZYxBgvUx9pRVw==",
                    }
                };
                let req = http.request(options, function (response) {
                    let chunks = [];
                    response.on("data", function (chunk) {
                        chunks.push(chunk);
                    });
                    response.on("end", function () {
                        let body = Buffer.concat(chunks);
                        let data = JSON.parse(body.toString());
                        let entry = new OTP({ mobileNo: mobile_no, otp: data.response.oneTimePassword });
                        if (data.status == "success") {
                            entry.save(function (err) {
                                if (err) {
                                    res.send({ "status": false, info: "unable to save otp" });
                                }
                                else {
                                    res.send({ "status": true, info: "Otp saved" });
                                }
                            });
                        }
                        else {
                            res.send({ "status": false });
                        }
                    });
                });
                req.write("{\n\n\"countryCode\": \"91\",\n \"mobileNumber\":" + mobile_no + ",\n  \"getGeneratedOTP\": true\n\n}");
                req.end();
            }
            else {
                res.send({ status: false, info: "Mobile number not exists" });
            }
        });
    }
    checkDuplicate(req, res) {
        user.findOne({ "personalInfo.mobile": req.params.mobileNo, "userType": { $in: ["admin-sme", "admin-ca", "admin-bu", "admin-sales", "admin-reseller", "employee"] } }, function (err, data) {
            if (err) {
                res.send(new response_model_4.getResponse(false, err, []));
            }
            else {
                if (data) {
                    res.send(new response_model_4.getResponse(true, null, []));
                }
                else {
                    res.send(new response_model_4.getResponse(false, 'No data found', []));
                }
            }
        });
    }
    checkDuplicateEmail(req, resp) {
        var email = req.params.email;
        user.findOne({ "personalInfo.email": req.params.email, "userType": "admin-bu" }, function (err, data) {
            if (err) {
                resp.send(new response_model_4.getResponse(false, err, []));
            }
            else {
                if (data) {
                    resp.send(new response_model_4.getResponse(true, null, []));
                }
                else {
                    resp.send(new response_model_4.getResponse(false, 'No data found', []));
                }
            }
        });
    }
    updatePassword(req, res) {
        ////console.log(req.body);
        if (req.body.verifyParameter == 'mobile') {
            var query = { "personalInfo.mobile": req.body.id };
            user.findOne(query, function (err, User) {
                if (!err) {
                    User.personalInfo.password = bycrypt.hashSync(req.body.password);
                    User.save(function (err) {
                        if (err) {
                            //console.error('ERROR!');
                            res.send({ "status": false, info: "server Error" });
                        }
                        else {
                            res.send({ "status": true, info: "password updated" });
                        }
                    });
                }
                else {
                    res.send({ "status": false, info: "server Error" });
                }
            });
        }
        else {
            var token = jwt.decode(req.body.id, JWT_SECRET);
            var query = { _id: token.userId };
            user.findOne(query, function (err, User) {
                ////console.log(User);
                User.personalInfo.password = bycrypt.hashSync(req.body.password);
                User.save(function (err) {
                    if (err) {
                    }
                    else {
                        res.send({ "status": true, info: "password updated" });
                    }
                });
            });
        }
    }
    pricing(req, res) {
        ////console.log(req.body);
        //var query={};
        //for(var key in req.body)
        //{
        //    req.body[key] !== "" ? query[key] = req.body[key] : null;
        //}
        //
        //query["packageType"]="paid";
        //query["orgId"]="58e3b1f8557a4d0cf22c0ba2";
        ////console.log(query);
        //var res = products.find().populate('productType');
        //////console.log(res);
        //res.exec(function (err, data) {
        //    if(err) {
        //        res.send(new getResponse(false, err, []))
        //    }
        //    else {
        //        res.send(new getResponse(true, null, data));
        //    }
        //});
        //var res = products.find();
        //res.exec(function(err,data){
        //    if(err)
        //    {
        //        res.send(new getResponse(false,err,[]))
        //    }
        //    else
        //    {
        //        res.send(new getResponse(true,null,data));
        //    }
        //});
        products.find({ isPackage: true }).populate('hsnSac').exec(function (err, data) {
            if (err) {
                res.send(new response_model_4.getResponse(false, err, []));
            }
            else {
                res.send(new response_model_4.getResponse(true, null, data));
            }
        });
        //products.find({},'productName _id description amount qty permissions productType isPermission packageType',function(err,data)
        //{
        //    if(err)
        //    {
        //        res.send(new getResponse(false,err,[]))
        //    }
        //    else
        //    {
        //        //console.log(data);
        //        res.send(new getResponse(true,null,data));
        //
        //    }
        //});
    }
    getAddon(req, res) {
        products.find({ isPackage: true, pkgOrAddon: "Addon" }).populate('hsnSac').exec(function (err, data) {
            if (err) {
                res.send(new response_model_4.getResponse(false, err, []));
            }
            else {
                res.send(new response_model_4.getResponse(true, null, data));
            }
        });
    }
    pricingpkg(req, res) {
        let query = { isPackage: true, businessCategory: req.body.businessCategory, language: util_2.isNullOrUndefined(req.body.language) ? "English" : req.body.language, packageType: { $nin: ["Custom", "Free"] } };
        products.find(query, '-additionalParametersValues').populate('hsnSac').exec(function (err, data) {
            if (err) {
                res.send(new response_model_4.getResponse(false, err, []));
            }
            else {
                res.send(new response_model_4.getResponse(true, null, data));
            }
        });
    }
    custompkg(req, res) {
        products.find({ isPackage: true, language: util_2.isNullOrUndefined(req.body.language) ? "English" : req.body.language, productCode: req.body.pkgCode }, '-additionalParametersValues').populate('hsnSac').exec(function (err, data) {
            if (err) {
                res.send(new response_model_4.getResponse(false, err, []));
            }
            else {
                res.send(new response_model_4.getResponse(true, null, data));
            }
        });
    }
    getState(req, res) {
        ////console.log("Header ABC : ", req.headers['selectedgstin']);
        //
        stateCode.find().populate("countryId").sort({ stateName: 1 }).exec(function (err, state) {
            if (err) {
                console.log("ERRor : ", err);
                res.send(new response_model_4.getResponse(false, err, []));
            }
            else {
                // console.log("countries : ", state);
                res.send(new response_model_4.getResponse(true, null, state));
            }
        });
    }

    getRequiredCopilotInfo(req, res){
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const userInfo = yield user.findOne({
                        organisation:req.params.orgId,
                        isDeleted:false,
                        userType: {$elemMatch: {$regex:/admin/}}
                    }).lean();
                    const {subscriberId,organisation,_id} = userInfo;
                    let obj = {
                        subscriberId,
                        organisation,
                        _id
                    };
                    res.send({ "status": true, info: obj });
                }
                catch (err) {
                    logger.error('Failed to create manifest json - ' + err);
                    res.send({ status: false, info: "Error" });
                }
            });
    }

    createCGManifestJSON(req,res){
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const userInfo = yield user.findOne({
                    organisation:req.body.orgId,
                    isDeleted:false,
                    userType: {$elemMatch: {$regex:/admin/}}
                }).populate('organisation').lean();
                const manifest = this.websiteHelper.generateManifest(userInfo,req.body.url);
                yield manifestjson.findOneAndUpdate({orgId:userInfo.organisation._id},manifest,{upsert:true});
                yield organisation.findOneAndUpdate({_id:userInfo.organisation._id},{
                    $set: {
                        generatedManifest: true
                    }
                })
                res.send(new response_model_5.postResponse(true, null, { msg: "Manifest json created successfully!" }));
            }
            catch (err) {
                logger.error('Failed to create manifest json - ' + err);
                res.send(new response_model_5.postResponse(false, err, null, err));
            }
        });
    }

    getManifestJSON(req, res){
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const manifest = yield manifestjson.findOne({orgId:req.query.orgId}).lean();
                res.json(manifest);
            }
            catch (err) {
                logger.error('Failed to find manifest json - ' + err);
                res.send(new response_model_5.getResponse(false, err,[]));
            }
        });
    };

    saveFeedback(req,res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                console.log("feedback",req.body.data);
                yield feedback.insertMany([req.body.data]);
                res.send(new response_model_5.postResponse(true, null, { msg: "Feedback saved" }));
            }
            catch (err) {
                logger.error('Failed to save feedback' + err);
                res.send(new response_model_5.postResponse(false, err, null, err));
            }
        });
    }
    

    // setContactInfoChatGenie(req,res){
    //     return __awaiter(this, void 0, void 0, function* () {
    //         try {
    //             yield organisation.findOneAndUpdate({_id:req.body.orgId},{
    //                 $set: {
    //                     chatgenieContactInfo: req.body.contactInfo
    //                 }
    //             })
    //             res.send(new response_model_5.postResponse(true, null, { msg: "Contact details updated!" }));
    //         }
    //         catch (err) {
    //             logger.error('Failed to update organisation - ' + err);
    //             res.send(new response_model_5.getResponse(false, err,[]));
    //         }
    //     });
    // }

    // getContactInfoChatGenie(req,res){
    //     return __awaiter(this, void 0, void 0, function* () {
    //         try {
    //             const contactInfo = yield organisation.findOne({_id:req.params.orgId},{
    //                 "chatgenieContactInfo":1
    //             });
    //             res.send(new response_model_5.getResponse(true, null, contactInfo));
    //         }
    //         catch (err) {
    //             logger.error('Failed to update organisation - ' + err);
    //             res.send(new response_model_5.getResponse(false, err,[]));
    //         }
    //     });
    // }

    setInfoChatGenie(req,res){
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield organisation.findOneAndUpdate({_id:req.body.orgId},{
                    $set: {
                        "chatgenie": req.body
                    }
                })
                res.send(new response_model_5.postResponse(true, null, { msg: "Contact details updated!" }));
            }
            catch (err) {
                logger.error('Failed to update organisation - ' + err);
                res.send(new response_model_5.getResponse(false, err,[]));
            }
        });
    }

    setTicketRaiseApiInfo(req,res){
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield organisation.findOneAndUpdate({_id:req.body.orgId},{
                    $set: {
                        "chatgenie.ticketRaise": req.body.ticketRaise
                    }
                })
                res.send(new response_model_5.postResponse(true, null, { msg: "Ticket Raise Api Info updated!" }));
            }
            catch (err) {
                logger.error('Failed to update organisation - ' + err);
                res.send(new response_model_5.getResponse(false, err,[]));
            }
        });
    }

    getInfoChatGenie(req,res){
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const contactInfo = yield organisation.findOne({_id:req.params.orgId},{
                    "chatgenie":1
                });
                res.send(new response_model_5.getResponse(true, null, contactInfo));
            }
            catch (err) {
                logger.error('Failed to update organisation - ' + err);
                res.send(new response_model_5.getResponse(false, err,[]));
            }
        });
    }

    getGSTIN(req, res) {
        ////console.log("Header ABC : ", req.headers['selectedgstin']);
        let gstin = req.headers['selectedgstin'];
        res.send(new response_model_4.getResponse(true, null, { gstin: gstin }));
    }
    getTest(req, res) {
        let array = ['Jammu and Kashmir', 'Punjab'];
        var query = { 'stateName': { $in: array } };
        stateCode.find(query).sort({ stateName: 1 }).exec(function (err, state) {
            if (err) {
                res.send(new response_model_4.getResponse(false, err, []));
            }
            else {
                res.send(new response_model_4.getResponse(true, null, state));
            }
        });
    }
    getAllBusinessType(req, res) {
        var query = businessType.find({ isDeleted: false });
        query.exec(function (err, data) {
            if (err) {
                res.send(new response_model_4.getResponse(false, null, []));
            }
            else {
                if (data) {
                    res.send(new response_model_4.getResponse(true, null, data));
                }
                else {
                    res.send(new response_model_4.getResponse(false, null, data));
                }
            }
        });
    }
    getSubScriber(req, res) {
        // let populateQuery = [{path:'organisation', select:'name businessType gstin '}];;
        let id;
        let searchParams = { isDelete: false };
        if (!util_2.isNullOrUndefined(req.params.id)) {
            id = req.params.id;
        }
        var query = Subscriber.find({ isDelete: false, _id: id }).populate('user subscriber packages');
        query.exec(function (err, data) {
            if (err) {
                ////console.log("error rit" + err);
                res.send(new response_model_4.getResponse(false, null, []));
            }
            else {
                ////console.log("data rit" + JSON.stringify(data));
                if (data) {
                    res.send(new response_model_4.getResponse(true, null, data));
                }
                else {
                    res.send(new response_model_4.getResponse(false, null, data));
                }
            }
        });
    }
    resetPassword(req, res) {
        let self = this;
        ////console.log("heello jkbjk");
        if (req.body.parameterType == 'mobile') {
            user.findOne({ 'personalInfo.mobile': req.body.verifyParameter }, function (err, data) {
                if (data) {
                    var message = "One+time+password+for+password+rest+is";
                    var otp = self.sendSms(req.body.verifyParameter, message);
                    res.send({ "data": { otp: otp, userId: data._id }, "status": true });
                }
                else {
                    res.send({ "data": { otp: null, userId: null }, "info": "user not found", "status": false });
                }
            });
        }
        else {
            user.findOne({ 'personalInfo.email': req.body.verifyParameter }, function (err, data) {
                if (data) {
                    let token = jwt.encode({ "userId": data._id }, JWT_SECRET);
                    let link = config.URL + token;
                    let url = link;
                    let mailOptions = {
                        from: '"Adhigam" <adhigam@gmail.com.com>',
                        to: req.body.verifyParameter,
                        subject: 'Reset password for Adhigam',
                        html: '<p>Click <a href="' + url + '">here</a> to reset your password</p> <br> <br>copy the following  link and put it in your browser </br>' + url + '</h6>'
                    };
                    let otp = self.sendMail.sendEmail(mailOptions);
                    res.send({ "status": true, info: "Reset password link has sent to your register Email Id" });
                }
                else {
                    res.send({ status: false, info: "Email not exists" });
                }
            });
        }
    }
    instamojoPayment(req, res) {
        var self = this;
        let list;
        let quantity = 1;
        let flag = false;
        let msgSent = false;
        products.find({ isPackage: true }, '-additionalParametersValues').populate('hsnSac').populate('userId').exec(function (err, dbList) {
            if (err) {
            }
            else {
                let totalVal = 0;
                let removeId = [];
                let index = 0;
                let newCartList = [];
                let productTamper = false;
                //console.log(req.body.cartList);
                for (let i = 0; i < req.body.cartList.length; i++) {
                    newCartList.push(req.body.cartList[i]);
                }
                _.each(req.body.cartList, function (cartPackage) {
                    _.each(dbList, function (systemCartList) {
                        if (cartPackage._id == systemCartList._id) {
                            if (cartPackage.price.salesPrice == systemCartList.price.salesPrice) {
                            }
                            else {
                                cartPackage.price.salesPrice = systemCartList.price.salesPrice;
                                flag = true;
                            }
                            if (cartPackage.hsnSac.code == systemCartList.hsnSac.code) {
                            }
                            else {
                                hsnSac.findOne({ code: systemCartList.hsnSac.code }, function (err, data) {
                                    if (err) {
                                    }
                                    else {
                                        if (req.body.personalInfo.stateCode == systemCartList.userId.address.stateCode) {
                                            let rate = (data.gstTaxRate) / 2;
                                            let cgstrate = rate;
                                            let sgstrate = rate;
                                            let salesPrice = (systemCartList.price.salesPrice) * quantity;
                                            let cgst = salesPrice * (rate / 100);
                                            let sgst = salesPrice * (rate / 100);
                                            // let salesPrice = (data[counter].price.salesPrice)*quantity;
                                            totalVal = (cgst + sgst + salesPrice);
                                            let taxvalue = (cgst + sgst);
                                        }
                                        else {
                                            let rate = (data.gstTaxRate);
                                            let totalAmount = 0;
                                            //let discount=data[counter].price.discount;
                                            let salesPrice = (systemCartList.price.salesPrice) * quantity;
                                            let igst = salesPrice * (rate / 100);
                                            totalVal = igst + salesPrice;
                                        }
                                    }
                                });
                            }
                        }
                        else {
                        }
                    });
                    index = index + 1;
                });
                /*
                 if(totalVal !== req.body.amount)
                 {
                 req.body.amount = totalVal;
                 flag=true;
                 }*/
                index = 0;
                _.each(req.body.cartList, function (cartPackage) {
                    list = _.filter(dbList, function (dt) {
                        return cartPackage._id == dt._id;
                    });
                    if (list.length > 0) {
                    }
                    else {
                        //console.log("tamper data");
                        productTamper = true;
                        if (newCartList.length == 1) {
                            newCartList = [];
                        }
                        newCartList.splice(index, 1);
                    }
                    index = index + 1;
                });
                if (productTamper) {
                    flag = true;
                    if (msgSent == false) {
                        msgSent = true;
                        res.send({ "status": false, "info": "Product expire", data: newCartList });
                    }
                }
                if (flag) {
                    if (msgSent == false) {
                        res.send({ "status": false, "info": "Cartlist updated", "data": req.body.cartList });
                    }
                }
                else {
                    var headers = {
                        'X-Api-Key': 'c561232aa83e97d0f29c81e930be617b',
                        'X-Auth-Token': '4f9fdc997dc2e114f991b686b84ea64f'
                    };
                    var payload = {
                        purpose: 'Adhigam Payment',
                        amount: req.body.amount,
                        phone: req.body.personalInfo.mobile,
                        buyer_name: req.body.personalInfo.name,
                        redirect_url: config.paymentRedirectUrl,
                        send_email: true,
                        send_sms: true,
                        email: req.body.personalInfo.email,
                        allow_repeated_payments: false
                    };
                    var data;
                    //instamojo getway
                    if (req.body.selectedGetWay == "InstaMojo") {
                        request.post('https://test.instamojo.com/api/1.1/payment-requests/', {
                            form: payload,
                            headers: headers
                        }, function (error, response, body) {
                            if (!error && response.statusCode == 201) {
                                data = JSON.parse(response.body);
                                // console.log("------------------data", data);
                                var object = {
                                    "dataBeforeRegister": req.body,
                                    "paymentRequestId": data.payment_request.id,
                                    "selectedGetWay": req.body.selectedGetWay,
                                };
                                self.storePaymentData(object, function (status, data) {
                                    ////console.log("after save" + status);
                                    if (status) {
                                        if (msgSent == false) {
                                            res.send(new response_model_5.postResponse(true, null, {
                                                "longurl": data.payment_request.longurl,
                                                "payment_request_id": data.payment_request.id
                                            }));
                                        }
                                    }
                                    else {
                                        if (msgSent == false) {
                                            res.send(new response_model_5.postResponse(true, null, {
                                                "longurl": data.payment_request.longurl,
                                                "payment_request_id": data.payment_request.id
                                            }));
                                        }
                                    }
                                });
                            }
                            else {
                                if (msgSent == false) {
                                    res.send(new response_model_5.postResponse(false, null, data));
                                }
                            }
                        });
                    }
                    else {
                        var object = {
                            "dataBeforeRegister": req.body,
                            //bind razor pay id here
                            "paymentRequestId": req.body.cartList[0]._id,
                            "selectedGetWay": req.body.selectedGetWay,
                        };
                        self.storePaymentData(object, function (status, data) {
                            ////console.log("after save" + status);
                            if (msgSent == false) {
                                res.send(new response_model_5.postResponse(true, null, {
                                    "longurl": "",
                                    "payment_request_id": data._id
                                }));
                            }
                        });
                    }
                }
            }
        });
        //go after validation done
        //end validation
    }
    storePaymentData(paymentData, callback) {
        ////console.log("Inside Data");
        let saveData = new payment(paymentData);
        saveData.save(function (err, data) {
            if (err) {
                callback(false, []);
            }
            else {
                callback(true, data);
            }
        });
    }
    getAllPaymentData(req, res) {
        console.log("inside get All Payment-------");
        payment.find({ "status": "Pending" }).sort().exec(function (err, getAllPaymentData) {
            if (err) {
                res.send(new response_model_4.getResponse(false, err, []));
            }
            else {
                res.send(new response_model_4.getResponse(true, "Payment data found successfully", getAllPaymentData));
            }
        });
    }
    actSub(req, res) {
        // console.log("**********************9", req.body.paymentRequestId);
        var self = this;
        var headers = {
            'X-Api-Key': 'c561232aa83e97d0f29c81e930be617b',
            'X-Auth-Token': '4f9fdc997dc2e114f991b686b84ea64f'
        };
        request.get('https://test.instamojo.com/api/1.1/payment-requests/' + req.body.paymentRequestId + '/', { headers: headers }, function (error, response, body) {
            var data = JSON.parse(body);
            // console.log(body);
            if (!error && response.statusCode == 200) {
                if (data.payment_request.payments.length > 0) {
                    _.each(data.payment_request.payments, function (data) {
                        // console.log(data.payment_id);
                        res.send(new response_model_5.postResponse(true, "payment Id", data.payment_id));
                    });
                    let updatedData = { "status": "" };
                    updatedData.status = "Done";
                    payment.findOneAndUpdate({ "paymentRequestId": req.body.paymentRequestId }, updatedData, { new: true }, (err, statusUpdate) => {
                    });
                }
                else {
                    console.log("no Payment Array");
                    res.send(new response_model_5.postResponse(false, "no payment Id", data));
                }
            }
            else {
                res.send(new response_model_5.postResponse(false, "no payment Id", data));
                console.log("no Payment ID");
            }
        });
    }
    cancelInvoice(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let eventId = req.body.eventId;
                let refNum = req.body.referenceNumber;
                if (!util_1.isNullOrUndefined(eventId) && !util_1.isNullOrUndefined(refNum)) {
                    yield (db.createDynamicModel('events')).findOneAndUpdate({ _id: ObjectId(eventId) }, { 'isDeleted': true });
                    yield (db.createDynamicModel('eventstatuses')).updateMany({ eventId: ObjectId(eventId) }, { 'isDeleted': true });
                    yield (db.createDynamicModel("fileuploadhistories")).findOneAndUpdate({ fileRefNum: refNum }, { $set: { 'isDeleted': true } });
                    yield (db.createDynamicModel('filequeues')).findOneAndUpdate({ fileRefNum: refNum }, { $set: { 'isDeleted': true } });
                    yield (db.createDynamicModel('Invoice_Document')).findOneAndUpdate({ referenceNumber: refNum }, { $set: { 'tally_status': 'Deleted' } });
                    res.send(new response_model_5.postResponse(true, null, { msg: "Invoice Cancelled Successfully" }));
                }
            }
            catch (err) {
                logger.error('Failed to cancel invoice - ' + err);
                res.send(new response_model_5.postResponse(false, err, null, err));
            }
        });
    }
    instamojoafterPayment(req, res) {
        var self = this;
        console.log("**********************8");
        var headers = {
            'X-Api-Key': 'c561232aa83e97d0f29c81e930be617b',
            'X-Auth-Token': '4f9fdc997dc2e114f991b686b84ea64f'
        };
        request.get('https://test.instamojo.com/api/1.1/payments/' + req.body.paymentId + '/', { headers: headers }, function (error, response, body) {
            var data = JSON.parse(response.body);
            if (!error && response.statusCode == 200) {
                var string1 = 'Credit';
                var string2 = data.payment.status;
                var areEqual = string1.toUpperCase() === string2.toUpperCase();
                if (areEqual) {
                    payment.findOne({ "paymentRequestId": req.body.paymentRequestId }, function (err, data) {
                        if (data) {
                            self.instamojoafterPaymentRegister(data, req, function (err, status) {
                                if (status) {
                                    res.send(new response_model_5.postResponse(true, null, req.body.paymentId));
                                }
                                else {
                                    res.send(new response_model_5.postResponse(false, null, []));
                                }
                            });
                        }
                        else {
                            res.send(new response_model_5.postResponse(false, null, []));
                        }
                    });
                    let updatedData = { "status": "" };
                    updatedData.status = "Done";
                    payment.findOneAndUpdate({ "paymentRequestId": req.body.paymentRequestId }, updatedData, { new: true }, (err, statusUpdate) => {
                    });
                }
                else {
                    res.send(new response_model_5.postResponse(false, null, []));
                }
            }
            else {
                res.send(new response_model_5.postResponse(false, null, []));
            }
        });
    }
    instamojoafterPaymentRegister(payment, req, callback) {
        let self = this;
        let subscriber = new Subscriber(payment.dataBeforeRegister.personalInfo);
        subscriber.cartList = payment.dataBeforeRegister.cartList;
        subscriber["packages"] = [];
        _.each(payment.dataBeforeRegister.cartList, function (cart) {
            subscriber.packages.push(cart._id);
        });
        _.each(payment.dataBeforeRegister.addOn, function (cart) {
            subscriber.packages.push(cart._id);
        });
        subscriber.status = "active";
        subscriber.save((err) => {
            if (err) {
                if (err.name === 'MongoError' && err.code === 11000) {
                    callback(false, err);
                }
            }
            else {
                let subscriberId = subscriber._id;
                let userData = new user(payment.dataBeforeRegister);
                if (payment.dataBeforeRegister.personalInfo.subscriberType == 'individual') {
                    userData.userType = 'admin-sme';
                }
                else {
                    if (payment.dataBeforeRegister.personalInfo.subscriberType == 'business') {
                        userData.userType = 'admin-bu';
                    }
                    else {
                        userData.userType = 'admin-ca';
                    }
                }
                userData.address = {
                    stateCode: "",
                    area: "",
                    pinCode: 0,
                    city: "",
                    state: null,
                };
                userData.personalInfo = payment.dataBeforeRegister.personalInfo;
                //userData.personalInfo.password = req.body.personalInfo.password;
                userData.personalInfo.password = bycrypt.hashSync(payment.dataBeforeRegister.personalInfo.password);
                userData.isActive = true;
                userData.subscriberId = subscriber._id;
                let packages = [];
                let permissionsList = [];
                let arrayData = [];
                let permissions = [];
                _.each(payment.dataBeforeRegister.cartList, function (cart) {
                    arrayData.push(cart._id);
                });
                product.find({
                    '_id': { $in: arrayData }
                }, function (err, docs) {
                    _.each(docs, function (comments) {
                        _.each(comments.additionalParametersValues, function (list) {
                            _.each(list.permissions, function (permission) {
                                if (permission.isChecked == true)
                                    permissionsList.push(permission);
                            });
                        });
                        permissions = _.chain(permissionsList).groupBy('permissionName').map(function (value, key) {
                            return key;
                        }).value();
                    });
                    userData.permission = permissions;
                    userData.save((err, data) => {
                        if (err) {
                            callback(err, false);
                        }
                        else {
                            // payment.dataBeforeRegister.cartList[0].subscriberId
                            Subscriber.findOneAndUpdate({ "_id": userData.subscriberId }, { $set: { "invNoPattern": "INV00", "invNoCount": 1 } }, function (err, subRecord) {
                                if (err) {
                                    callback(err, false);
                                }
                                else {
                                    console.log("sub transaction found");
                                    // console.log(payment.dataBeforeRegister);
                                    let transactionData = new transaction(payment.dataBeforeRegister);
                                    transactionData.description = "cash payment";
                                    transactionData.paymentStatus = true;
                                    transactionData.packageId = payment.dataBeforeRegister.productId;
                                    transactionData.paymentId = req.body.paymentId;
                                    transactionData.paymentRequestId = req.body.paymentRequestId;
                                    //transactionData.tax=pakageData[0].tax;
                                    transactionData.amount = payment.dataBeforeRegister.calculatedAmount[0].finalAmountToPay;
                                    transactionData.userId = userData._id;
                                    transactionData.paymentMode = "online";
                                    transactionData.subscriberId = subscriber._id;
                                    transactionData.packageType = "SUBSCRIPTION";
                                    let cartData = payment.dataBeforeRegister.cartList;
                                    let totaltax = 0;
                                    let totalDiscount = 0;
                                    let salepricetotal = 0;
                                    console.log("amounts calc" + payment.dataBeforeRegister.calculatedAmount);
                                    for (var i = 0; i < cartData.length; i++) {
                                        salepricetotal = salepricetotal + cartData[i].price.salesPrice;
                                        totaltax = totaltax + payment.dataBeforeRegister.calculatedAmount[0].totalTax;
                                        totalDiscount = totalDiscount + payment.dataBeforeRegister.calculatedAmount[0].totalDiscount;
                                    }
                                    if (payment.dataBeforeRegister.isCode) {
                                        let reSaleTransaction = new resellerTransaction({
                                            "code": payment.dataBeforeRegister.personalInfo.code,
                                            "userId": data._id,
                                            "subscriberId": userData.subscriberId,
                                            "amount": payment.dataBeforeRegister.calculatedAmount[0].finalAmountToPay
                                        });
                                        reSaleTransaction.save(function (err, data) {
                                            if (err) {
                                                // console.log(err);
                                            }
                                            else {
                                                // console.log("data saved" + JSON.stringify(data));
                                            }
                                        });
                                    }
                                    transactionData.save((err) => {
                                        if (err) {
                                            callback(false, err);
                                        }
                                        else {
                                            var html = '<!DOCTYPE html><html lang="en"> ' +
                                                '<head><meta charset="UTF-8"><title>Receipt</title></head> ' +
                                                '<body style="padding-top:10%"> ' +
                                                '<div style="border: 1px solid black;margin: 0 auto;width:90%"> ' +
                                                '<div style="width: 100%; display: table;"> ' +
                                                '<img src="https://www.adhigam.com/assets/index/logo/final-logo.png" style="padding: 3%; width: 10%"/> ' +
                                                '<label style="text-transform: uppercase;padding-left: 15%; vertical-align: 35px;font-size: 20px;font-weight: bolder;">Payment Receipt</label> ' +
                                                '<div style="display: inline-block; padding-left: 18%;vertical-align: 36px;font-size: 18px;"> ' +
                                                '</div> ' +
                                                '</div> ' +
                                                '<br/><br/> ' +
                                                '<div style="padding: 3%;"> ' +
                                                '<div> ' +
                                                '<table style="width: 100%;font-size: 15px; background: rgba(158, 158, 158, 0.07);text-align: center;"> ' +
                                                '<thead> ' +
                                                '<th>Receipt Number: #' + req.body.paymentId + '</th> ' +
                                                '</thead> ' +
                                                '<tbody> ' +
                                                '</tbody> ' +
                                                ' </table> ' +
                                                '</div> ' +
                                                '<br/> <br/> ' +
                                                '<div style="font-size: 15px;"> ' +
                                                '<strong>Purchase Details</strong> ' +
                                                '</div> ' +
                                                '<div style="padding: 2%;font-size: 12px;"> ' +
                                                '<table style="text-align: left;width: 100%;padding-left: 6%;"> ' +
                                                '<tbody> ' +
                                                '<tr> ' +
                                                '<td>Buyer Name</td> ' +
                                                '<td>' + payment.dataBeforeRegister.personalInfo.name + '</td> ' +
                                                '</tr> ' +
                                                '<tr> ' +
                                                '<td>Buyer Email Address</td> ' +
                                                '<td>' + payment.dataBeforeRegister.personalInfo.email + '</td> ' +
                                                ' </tr> ' +
                                                '<tr> ' +
                                                ' <td>Buyer Phone Number</td> ' +
                                                '<td>+91 ' + payment.dataBeforeRegister.personalInfo.mobile + '</td> ' +
                                                '</tr> ' +
                                                '<tr> ' +
                                                '<td>Purchase Date</td> ' +
                                                '<td>' + moment().format("DD MMM YYYY HH:MM") + '</td> ' +
                                                '</tr> ' +
                                                '<tr> ' +
                                                '<td>Product Price</td> ' +
                                                '<td>&#8377; ' + salepricetotal.toLocaleString('en-IN') + '</td> ' +
                                                '</tr> ' +
                                                '<tr> ' +
                                                '<td>Tax</td> ' +
                                                '<td>&#8377; ' + totaltax.toLocaleString('en-IN') + '</td> ' +
                                                '</tr> ' +
                                                '<tr> ' +
                                                '<td>Discount</td> ' +
                                                '<td>&#8377; ' + totalDiscount.toLocaleString('en-IN') + '</td> ' +
                                                '</tr> ' +
                                                '<tr> ' +
                                                '<td>Total Price</td> ' +
                                                '<td>&#8377; ' + payment.dataBeforeRegister.calculatedAmount[0].finalAmountToPay.toLocaleString('en-IN') + '</td> ' +
                                                '</tr> ' +
                                                '</tbody> ' +
                                                '</table> ' +
                                                '</div> ' +
                                                '</div> ' +
                                                '</div> ' +
                                                '</body> ' +
                                                '</html> ';
                                            //Some HTML String from code above
                                            var options = {
                                                "height": "10.5in",
                                                "width": "8in",
                                                "phantomPath": config.phantomPath
                                            };
                                            pdf.create(html, options).toBuffer(function (error, buffer) {
                                                if (error) {
                                                    console.log('Oh noes! Error!');
                                                    // console.log(error);
                                                }
                                                else {
                                                    // console.log('Woot! Success!');
                                                    //console.log(success);
                                                    var mailOptions = {
                                                        from: '"Adhigam" <helpdesk@adhigam.com>',
                                                        to: payment.dataBeforeRegister.personalInfo.email,
                                                        subject: "Thank you for subscribing to adhigam",
                                                        //subject:"welcome", // Subject line
                                                        // plain text body
                                                        attachments: [{
                                                            filename: 'payment_receipt.pdf',
                                                            content: buffer
                                                        }
                                                        ],
                                                        //html:'<h1>Hello </h1>'
                                                        html: '<!DOCTYPE html><html><head><title></title></head><body style="font-family: roboto"><table align="center" width="600px" style="background:#2A7447; padding: 15px"><tr><td style="background: #0F5E5B; padding:0 15px;padding-bottom: 20px"><table align="center" width="100%"><tr><td align="center" width="600px"><h2 style="background: #4f7b61;padding: 10px 0;color:#FFFFFF;font-size: 20px;text-align: center;margin:0">Thank you for subscribing to Adhigam</h2></td></tr><tr><td style="color: #FFFFFF;font-size: 15px;padding-top: 10px"><p style="margin:5px 0">Hi ' + payment.dataBeforeRegister.personalInfo.name + '!</p><p style="margin:5px 0">Welcome to Adhigam - Your Wise Choice, GSTwise!</p><p style="margin:5px 0">We simplify GST implementation with premium products and service offerings.</p></td></tr><tr><td><table align="center" width="100%"><tr><td> <img src="https://www.adhigam.com/assets/template-pages/comment@300.png"></td><td> <a href="https://www.adhigam.com/#/login" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"> <img src="https://www.adhigam.com/assets/template-pages/phone@200.png"> </a></td></tr></table></td></tr><tr><td style="color: #FFFFFF"><p style="margin:5px 0">In the meantime, you can</p><p style="position: relative;"> <img src="https://www.adhigam.com/assets/template-pages/horn.png" style="position: absolute;left: 0;bottom: 0;position: absolute;left: -45px;bottom: -45px;width: 50px;"> <a href="https://www.adhigam.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><span style="color: #FFFFFF;background-color: #436FCC;padding: 10px;cursor: pointer;">Return to our website</span></a> to continue browsing.</p><p style="margin:5px 0"><br></p><p style="margin:5px 0">For assistance please reply to <a href="mailto:helpdesk@adhigam.com" title="helpdesk@adhigam.com" style="color: #FFFFFF;">helpdesk@adhigam.com</a></p><p style="margin:5px 0"><br></p><p style="margin:5px 0">Best Regards</p><p style="margin:5px 0">Team Adhigam</p></td></tr></table></td></tr><tr><td align="center" width="600px"><table><tr><td style="padding: 5px;color:#FFFFFF;font-size: 15px;text-align: center;">Contact us on</td></tr><tr><td style="color: #FFFFFF"><table><tr><td><a href="https://www.facebook.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/fb.png" style="width: 30px"></a></td><td><a href="https://www.twitter.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/tw.png" style="width: 30px"></a></td><td><a href="https://www.linkedin.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/ln.png" style="width: 30px"></a></td></tr></table></td></tr></table></td></tr></table></body></html>'
                                                    };
                                                    self.sendMail.sendEmail(mailOptions, function (err, data) {
                                                        if (!err) {
                                                        }
                                                        else {
                                                        }
                                                        buffer = null;
                                                    });
                                                }
                                            });
                                            callback(true, transactionData);
                                        }
                                    });
                                }
                            });
                        }
                    });
                });
            }
        });
    }
    sentTestEmail(req, res) {
        /*
         var self = this;
         var payment= { "dataBeforeRegister" : {
         "amount" : 15.75,
         "cartList" : [
         {
         "productCode" : "",
         "isProduct" : false,
         "isPermission" : false,
         "permissionMaster" : [

         ],
         "categoryName" : "",
         "isCart" : true,
         "packageType" : "Paid",
         "productId" : "",
         "price" : {
         "purchasePrice" : 15.75,
         "salesPrice" : 15,
         "discount" : 0,
         "discountType" : "%"
         },
         "productType" : "",
         "isDelete" : false,
         "createUser" : "5931d4efc929c6537af3ab62",
         "updateUser" : "",
         "gstin" : "",
         "lifeTime" : 0,
         "status" : "",
         "hsn" : "",
         "sac" : "",
         "priceType" : "Yearly",
         "featuresList" : [
         {
         "featureDescription" : "Product Kit for End to end GST Needs"
         },
         {
         "featureDescription" : "Compatible with almost all ERP and Accounting systems"
         },
         {
         "featureDescription" : "100% automated process from registration to ERP integration to reconciliation and GSTN filing of returns"
         },
         {
         "featureDescription" : "Simplified explanation of the GST Law"
         },
         {
         "featureDescription" : "Over 600 FAQs on interpretation of the GST law"
         },
         {
         "featureDescription" : "Industry specific customised FAQs and on - going updates"
         },
         {
         "featureDescription" : "Online self-paced GST training course (basic & advanced)"
         },
         {
         "featureDescription" : "30 minutes of basic GST learning and 4 hours of advanced GST knowledge & training modules"
         },
         {
         "featureDescription" : "Webinars and workshop schedules and registration"
         },
         {
         "featureDescription" : "Industry specific customised training modules"
         },
         {
         "featureDescription" : "Online tech support"
         }
         ],
         "isPackage" : true,
         "category" : "",
         "gstTax" : "",
         "quantity" : null,
         "__v" : 0,
         "unit" : "",
         "subscriberId" : "5915a868acbbf90d4515ce84",
         "userId" : "5915a868acbbf90d4515ce86",
         "description" : "COMPLIANCE, LEGAL ANALYSIS AND TRAINING",
         "productName" : "Full Product Package",
         "tax" : {
         "taxCode" : "",
         "taxName" : "5% GST",
         "taxRate" : "5",
         "gstin" : "",
         "__v" : 0,
         "subscriberId" : "5915a868acbbf90d4515ce84",
         "userId" : "5915a868acbbf90d4515ce86",
         "createdAt" : "2017-05-15T07:08:38.173Z",
         "updatedAt" : "2017-05-15T07:08:38.173Z",
         "_id" : "591953f64036b74abca5d59e"
         },
         "createdAt" : "2017-06-04T17:07:26.370Z",
         "updatedAt" : "2017-06-04T17:07:26.370Z",
         "_id" : "59343e4edfbe9872b11af88c"
         }
         ],
         "personalInfo" : {
         "password" : "Test@123",
         "email" : "nitesh@gibots.com",
         "mobile" : "9766394993",
         "name" : "Nitesh",
         "subscriberType" : "business",
         "businessType" : "592061585fa6293f2c539291"
         }
         },
         "paymentId": 'MOJO7619005A90954309'
         };
         let salepricetotal = 15;
         let totaltax = 0.75;
         let totalDiscount = 0;

         var personalInfo = payment.dataBeforeRegister.personalInfo;

         var html = '<!DOCTYPE html><html lang="en"> ' +
         '<head><meta charset="UTF-8"><title>Title</title></head> ' +
         '<body style="padding-top:10%"> ' +
         '<div style="border: 1px solid black;margin: 0 auto;width:90%"> ' +
         '<div style="width: 100%; display: table;"> ' +
         '<img src="https://www.adhigam.com/assets/index/logo/final-logo.png" style="padding: 3%; width: 10%"/> ' +
         '<label style="text-transform: uppercase;padding-left: 15%; vertical-align: 35px;font-size: 20px;font-weight: bolder;">Payment Receipt</label> ' +
         '<div style="display: inline-block; padding-left: 18%;vertical-align: 36px;font-size: 18px;"> '+

         '</div> '+
         '</div> ' +
         '<br/><br/> ' +
         '<div style="padding: 3%;"> ' +
         '<div> ' +
         '<table style="width: 100%;font-size: 15px; background: rgba(158, 158, 158, 0.07);text-align: center;"> '+
         '<thead> '+
         '<th>Receipt Number: #'+req.body.paymentId +'</th> '+

         '</thead> '+
         '<tbody> '+

         '</tbody> '+
         ' </table> '+

         '</div> ' +
         '<br/> <br/> ' +
         '<div style="font-size: 15px;"> ' +
         '<strong>Purchase Details</strong> ' +

         '</div> ' +
         '<div style="padding: 2%;font-size: 12px;"> ' +
         '<table style="text-align: left;width: 100%;padding-left: 6%;"> ' +

         '<tbody> ' +

         '<tr> ' +
         '<td>Buyer Name</td> ' +
         '<td>' + payment.dataBeforeRegister.personalInfo.name + '</td> ' +
         '</tr> ' +
         '<tr> ' +
         '<td>Buyer Email Address</td> ' +
         '<td>' + payment.dataBeforeRegister.personalInfo.email + '</td> ' +
         ' </tr> ' +
         '<tr> ' +
         ' <td>Buyer Phone Number</td> ' +
         '<td>+91 ' + payment.dataBeforeRegister.personalInfo.mobile + '</td> ' +
         '</tr> ' +
         '<tr> ' +
         '<td>Purchase Date</td> ' +
         '<td>' + moment().format("DD MMM YYYY HH:MM") + '</td> ' +
         '</tr> ' +
         '<tr> ' +
         '<td>Product Price</td> ' +
         '<td>&#8377; ' + salepricetotal.toLocaleString('en-IN') + '</td> ' +
         '</tr> ' +
         '<tr> ' +
         '<td>Tax</td> ' +
         '<td>&#8377; ' + totaltax.toLocaleString('en-IN') + '</td> ' +
         '</tr> ' +
         '<tr> ' +
         '<td>Discount</td> ' +
         '<td>&#8377; ' + totalDiscount.toLocaleString('en-IN') + '</td> ' +
         '</tr> ' +
         '<tr> ' +
         '<td>Total Price</td> ' +
         '<td>&#8377; ' + payment.dataBeforeRegister.amount.toLocaleString('en-IN') + '</td> ' +
         '</tr> ' +
         '</tbody> ' +
         '</table> ' +
         '</div> ' +
         '</div> ' +
         '</div> ' +
         '</body> ' +
         '</html> ';
         //Some HTML String from code above
         var options = {
         "height": "10.5in",
         "width": "8in",
         "phantomPath": './node_modules/phantomjs-prebuilt/lib/phantom/bin/phantomjs'
         };
         pdf.create(html, options).toBuffer(
         function (error, buffer) {
         if (error) {
         console.log('Oh noes! Error!');
         console.log(error);
         } else {
         // console.log('Woot! Success!');
         //console.log(success);
         var mailOptions =
         {
         from: '"Adhigam" <helpdesk@adhigam.com>', // sender address
         to: payment.dataBeforeRegister.personalInfo.email, // list of receivers
         subject: "Thank you for subscribing to adhigam",// Subject line
         //subject:"welcome", // Subject line
         // plain text body
         attachments: [{
         filename: 'payment_receipt.pdf',
         content: buffer
         }
         ],
         //html:'<h1>Hello </h1>'
         html: '<!DOCTYPE html><html><head><title></title></head><body style="font-family: roboto"><table align="center" width="600px" style="background:#2A7447; padding: 15px"><tr><td style="background: #0F5E5B; padding:0 15px;padding-bottom: 20px"><table align="center" width="100%"><tr><td align="center" width="600px"><h2 style="background: #4f7b61;padding: 10px 0;color:#FFFFFF;font-size: 20px;text-align: center;margin:0">Thank you for subscribing to Adhigam</h2></td></tr><tr><td style="color: #FFFFFF;font-size: 15px;padding-top: 10px"><p style="margin:5px 0">Hi ' + payment.dataBeforeRegister.personalInfo.name + '!</p><p style="margin:5px 0">Welcome to Adhigam - Your Wise Choice, GSTwise!</p><p style="margin:5px 0">We simplify GST implementation with premium products and service offerings.</p></td></tr><tr><td><table align="center" width="100%"><tr><td> <img src="https://www.adhigam.com/assets/template-pages/comment@300.png"></td><td> <a href="https://www.adhigam.com/#/login" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"> <img src="https://www.adhigam.com/assets/template-pages/phone@200.png"> </a></td></tr></table></td></tr><tr><td style="color: #FFFFFF"><p style="margin:5px 0">In the meantime, you can</p><p style="position: relative;"> <img src="https://www.adhigam.com/assets/template-pages/horn.png" style="position: absolute;left: 0;bottom: 0;position: absolute;left: -45px;bottom: -45px;width: 50px;"> <a href="https://www.adhigam.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><span style="color: #FFFFFF;background-color: #436FCC;padding: 10px;cursor: pointer;">Return to our website</span></a> to continue browsing.</p><p style="margin:5px 0"><br></p><p style="margin:5px 0">For assistance please reply to <a href="mailto:helpdesk@adhigam.com" title="helpdesk@adhigam.com" style="color: #FFFFFF;">helpdesk@adhigam.com</a></p><p style="margin:5px 0"><br></p><p style="margin:5px 0">Best Regards</p><p style="margin:5px 0">Team Adhigam</p></td></tr></table></td></tr><tr><td align="center" width="600px"><table><tr><td style="padding: 5px;color:#FFFFFF;font-size: 15px;text-align: center;">Contact us on</td></tr><tr><td style="color: #FFFFFF"><table><tr><td><a href="https://www.facebook.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/fb.png" style="width: 30px"></a></td><td><a href="https://www.twitter.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/tw.png" style="width: 30px"></a></td><td><a href="https://www.linkedin.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/ln.png" style="width: 30px"></a></td></tr></table></td></tr></table></td></tr></table></body></html>'
         };
         self.sendMail.sendEmail(mailOptions, function (err, data) {
         if (!err) {
         console.log("email sent");
         res.json(new postResponse(true,null,[]));
         }
         else
         {
         console.log(err);
         res.json(new postResponse(false,null,[]));
         }
         buffer = null;
         });

         }
         });


         */
    }
    applyPromocode(req, res) {
        var finalDiscount = 0;
        ////console.log(JSON.stringify(req.body));
        discount.findOne({
            discountCoupons: req.body.promocode,
            businessType: req.body.businessType,
            isDeleted: false,
            discountStatus: "active",
            couponExpiry: { $gte: Date.now() }
        }).where('userCount').gt(0).exec(function (err, data) {
            if (!err) {
                if (data) {
                    var discountType = data.discountType;
                    _.each(data.packageItem, function (item) {
                        var isData = _.findWhere(req.body.cartList, { "_id": item });
                        if (isData) {
                            if (discountType == 'amount') {
                                finalDiscount = finalDiscount + parseInt(data.discountAmount);
                            }
                            else {
                                var percentAmount = (parseInt(data.discountAmount) / 100) * isData.price.salesPrice;
                                finalDiscount = finalDiscount + percentAmount;
                            }
                        }
                        else {
                        }
                    });
                    res.send(new response_model_2.customResponse(true, null, finalDiscount, "Promocode applied successfully"));
                }
                else {
                    res.send(new response_model_2.customResponse(false, null, [], "Invalid promocode"));
                }
            }
            else {
                res.send(new response_model_5.postResponse(false, null, "Invalid promocode"));
            }
        });
    }
    //Desktop Application Service
    saveStoragePath(req, res) {
        // console.log(req.body);
        this.storageComponent.saveStoragePath(req.body, function (err, data) {
            if (!err) {
                res.send(new response_model_5.postResponse(true, null, data));
            }
            res.send(new response_model_5.postResponse(false, err, {}));
        });
    }
    getStoragePath(req, res) {
        this.storageComponent.getStoragePath(req.params.id, function (err, data) {
            if (!err) {
                res.send(new response_model_4.getResponse(true, null, data));
            }
            else {
                res.send(new response_model_4.getResponse(false, err, []));
            }
        });
    }
    getRequestObject(req, res) {
        // console.log(req.params.type);
        let self = this;
        var parser = require('xml2json');
        var xml = "<foo attr=\"value\"><b>bar</b></foo>";
        console.log("input -> %s", xml);
        // xml to json
        var json = parser.toJson(xml);
        console.log("to json -> %s", json);
        // json to xml
        var xml1 = parser.toXml(json);
        console.log("back to xml -> %s", xml1);
        res.send(new response_model_4.getResponse(true, null, { xml: xml, json: json, xml1: xml1 }));
        /*this.requestObjectComponent.getRequestObject(req.params.type,function (err,data) {
         if(!err){
         let jsonData=JSON.parse(JSON.stringify(data));

         res.send(new getResponse(true,null,self.convertJsonToXML(jsonData)));
         }
         res.send(new getResponse(false,err,[]));

         })*/
    }
    convertXmlToJson(xml) {
        const parser = require('xml2json');
        return parser.toJson(xml);
    }
    convertJsonToXML(json) {
        const parser = require('xml2json');
        return parser.toXml(json);
    }
    readMultipleFile(req, res) {
        let dt = new Date();
        var self = this;
        dt = moment().format('YYYY-MM-DD_HH-mm-ss');
        let uploadPath = config.path;
        // console.log(req.body.data);
        this.downloadAnyFile(req, function (err) {
            if (!err) {
                // console.log(err);
                res.send(false);
            }
            res.send(true);
        });
        // this.writeFile(uploadPath + dt + '_' + req.body.fileName,req.body.data,null,res)
        /*
         var fs = require('fs');

         let dt = new Date();
         var self=this;
         var foo = "71%73%70%56%57%97%50%0%50%0%247%0%0%150%140%115%102%94%69%198%187%159%123%114%90%71%71%71%138%129%101%202%193%166%201%193%172%238%234%221%200%197%188%140"
         var bytes = foo.split("%");
         var b = req.body.data;
         dt = moment().format('YYYY-MM-DD_HH-mm-ss');
         var c = "";
         for (var i = 0;i < bytes.length;i++) {
         b[i] = bytes[i];
         c = c + " " + bytes[i]
         }

         fs.writeFile(uploadPath + dt + '_' +req.body.fileName, c,  "binary",function(err) {
         if(err) {
         console.log(err);
         } else {
         console.log("The file was saved!");
         }
         });




         console.log(req.body.data);
         // res.send(true);
         req.files.file=req.body.data;
         req.files.file.name=req.body.fileName;

         console.log("file Type");
         console.log(typeof req.files);


         let sampleFile = req.files.file;
         //let sampleFile = "./sampleFormatForInvoice.xlsx";
         let fileName = req.files.file.name;
         // dt = moment().format('YYYY-MM-DD_HH-mm-ss');
         // let uploadPath = config.path;
         let image_path = dt + '_' + fileName;

         /!*sampleFile.mv(uploadPath + dt + '_' + fileName, function (err) {
         if (err)
         res.send({status: false, data: [], "info": "error in uploading file"});
         else {*!/
         parseXlsx(uploadPath + dt + '_' + fileName, function (err, exceldata) {
         if (err) {
         res.send({status: false, data: [], info: err});

         }
         else {

         console.log("dataaaa");
         console.log(exceldata);
         // var csv_data = self.convertToJson(exceldata,req);


         }
         });*/
    }
    // });
    // }
    writeFile(path, buffer, permission, res) {
        var fs = require('fs');
        permission = permission || 438; // 0666
        var fileDescriptor;
        try {
            fileDescriptor = fs.openSync(path, 'w', permission);
        }
        catch (e) {
            fs.chmodSync(path, permission);
            fileDescriptor = fs.openSync(path, 'w', permission);
        }
        if (fileDescriptor) {
            // fs.writeFileSync(fileDescriptor,buffer, 0, buffer.length, 0);
            // fs.closeSync(fileDescriptor);
            res.send(true);
        }
    }
    downloadAnyFile(req, callback) {
        /*
         This function is used to download any file from S3.It waork as follow,
         1 . Load aws-swd
         2 . Set all confuguration as mentioned at very start of the code
         3 . Create S3 object and pass necessary parameters to this
         4 . Set parameters for accessing bucket.
         5 . Acces getObject methos of AWS to load our current bucket files
         6 . Key in params is the file name in AWS bucket
         */
        var fs = require('fs');
        var file = fs.createWriteStream("1.xlsx");
        file.write(req.body);
        fs.close();
    }
    saveUserAndTransection(req, res) {
        let self = this;
        payment.findById(req.body.paymentRequestId, function (err, data) {
            if (data) {
                self.instamojoafterPaymentRegister(data, req, function (err, status) {
                    if (status) {
                        res.send(new response_model_5.postResponse(true, null, req.body.paymentId));
                    }
                    else {
                        res.send(new response_model_5.postResponse(false, null, []));
                    }
                });
            }
            else {
                res.send(new response_model_5.postResponse(false, null, []));
            }
        });
    }
    addNewsFeed(req, res) {
        var newsData = new newsFeed(req.body);
        newsData.save((err) => {
            if (err) {
                res.send(new response_model_5.postResponse(false, err, []));
            }
            else {
                res.send(new response_model_5.postResponse(true, err, newsData));
            }
        });
    }
    getNewsFeed(req, res) {
        var query = newsFeed.find({ isDelete: false, isActive: true }).sort({ createdAt: -1 });
        query.exec((err, newsFeeds) => {
            if (err) {
                res.send(new response_model_4.getResponse(false, err, []));
            }
            else {
                if (newsFeeds) {
                    res.send(new response_model_4.getResponse(true, null, newsFeeds));
                }
                else {
                    res.send(new response_model_4.getResponse(false, null, []));
                }
            }
        });
        //newsFeed.find({isDelete:false},(err, newsFeeds) =>{
        //
        //});
    }
    updateNewsFeed(req, res) {
        let updatedData = {};
        let feedId = req.body._id;
        updatedData.subject = req.body.subject;
        updatedData.content = req.body.content;
        updatedData.imageURL = req.body.imageURL;
        updatedData.videoLink = req.body.videoLink;
        updatedData.isActive = req.body.isActive;
        updatedData.address = req.body.address;
        newsFeed.findOneAndUpdate({ _id: feedId }, updatedData, { new: true }, (err, newsUpdate) => {
            if (err) {
                res.send(new response_model_2.putResponse(false, err, []));
            }
            else {
                res.send(new response_model_2.putResponse(true, null, newsUpdate));
            }
        });
    }
    deleteNewsFeed(req, res) {
        newsFeed.findOneAndUpdate({ _id: req.params.id }, { isDelete: true, isActive: false }, { new: true }, (err, deletedNews) => {
            if (err) {
                res.send(new response_model_3.deleteResponse(false, err, []));
            }
            else {
                res.send(new response_model_3.deleteResponse(true, null, deletedNews));
            }
        });
    }
    registerCA(req, res) {
        let self = this;
        let code = "";
        let personalInfo = req.body.personalInfo;
        let selectedSubscriberType = req.body.personalInfo.subscriberType;
        if (util_2.isNullOrUndefined(req.body.personalInfo)) {
            personalInfo = req.body;
        }
        user.findOne({ "personalInfo.mobile": personalInfo.mobile }, function (err, data) {
            if (err) {
                res.send(new response_model_4.getResponse(false, err, []));
            }
            else {
                if (data) {
                    //res.send(new getResponse(false, null, [],"Mobile number already registered !"));
                    res.send(new response_model_2.customResponse(false, [], [], "Mobile number already registered !"));
                }
                else {
                    let subscriberObj = { user: {}, subscriber: {} };
                    subscriberObj = personalInfo;
                    subscriberObj["user"] = req.body.userId;
                    subscriberObj["subscriber"] = req.body.subscriberId;
                    subscriberObj["subscriptionDate"] = new Date();
                    subscriberObj["renewalDate"] = new Date();
                    subscriberObj["isDelete"] = false;
                    subscriberObj['subscriberType'] = selectedSubscriberType;
                    let subscriber = new Subscriber(subscriberObj);
                    let selectedPackageId;
                    if (selectedSubscriberType == 'ca') {
                        selectedPackageId = config.caPackageId;
                    }
                    else if (selectedSubscriberType == 'reseller') {
                        selectedPackageId = config.resellerPackageId;
                    }
                    else if (selectedSubscriberType == 'sales') {
                        selectedPackageId = config.salesAgentPackageId;
                    }
                    if (!util_2.isNullOrUndefined(selectedPackageId)) {
                        subscriber.packages = selectedPackageId;
                        subscriber.status = "active";
                        subscriber.save((err) => {
                            if (err) {
                                if (err.name === 'MongoError' && err.code === 11000) {
                                    res.send(new response_model_6.duplicateResponse(false, null, err));
                                }
                                else {
                                    res.send({ status: false, info: "subscriber not saved", data: [] });
                                }
                            }
                            else {
                                product.find({ _id: selectedPackageId }, function (err, pakageData) {
                                    if (err)
                                        res.send(new response_model_4.getResponse(false, err, []));
                                    else {
                                        let subscriberId = subscriber._id;
                                        let userData = new user(req.body);
                                        userData.address = {
                                            stateCode: "",
                                            area: "",
                                            pinCode: 0,
                                            city: "",
                                            state: null,
                                        };
                                        userData.personalInfo = personalInfo;
                                        userData.personalInfo.password = bycrypt.hashSync(personalInfo.password);
                                        userData.isActive = true;
                                        userData.activeStatus = "online";
                                        userData.subscriberId = subscriber._id;
                                        userData.userType = 'admin-' + selectedSubscriberType;
                                        userData.address = {
                                            stateCode: "",
                                            area: "",
                                            pinCode: 0,
                                            city: "",
                                            state: null,
                                        };
                                        let packages = [];
                                        let permissionsList = [];
                                        let permissions = [];
                                        if (!util_2.isNullOrUndefined(pakageData)) {
                                            if (pakageData.length == 0) {
                                                res.send(new response_model_2.customResponse(false, null, [], "Package not found"));
                                            }
                                            else {
                                                packages.push(pakageData[0]._id);
                                                _.each(pakageData[0].additionalParametersValues, function (list) {
                                                    _.each(list.permissions, function (permission) {
                                                        if (permission.isChecked == true)
                                                            permissionsList.push(permission);
                                                    });
                                                });
                                                permissions = _.chain(permissionsList).groupBy('permissionName').map(function (value, key) {
                                                    return key;
                                                }).value();
                                                userData.permission = permissions;
                                                userData.save((err, dataSave) => {
                                                    if (err) {
                                                        res.send(new response_model_5.postResponse(false, null, err));
                                                    }
                                                    else {
                                                        res.send(new response_model_5.postResponse(true, null, dataSave));
                                                        let subscriberId = dataSave.subscriberId;
                                                        let userId = dataSave._id;
                                                        if (personalInfo.subscriberType == 'sales') {
                                                            var fristnm = personalInfo.name;
                                                            self.pc.saveCommissionDiscountCode(fristnm, subscriberId, userId, req, res, function (status, data) {
                                                                code = JSON.parse(JSON.stringify(data));
                                                                var mailOptions = {
                                                                    from: '"Adhigam" <helpdesk@adhigam.com>',
                                                                    to: personalInfo.email,
                                                                    subject: "Coupon Code : " + code,
                                                                    //subject:"welcome", // Subject line
                                                                    // plain text body
                                                                    html: '<!DOCTYPE html><html><head><title></title></head><body style="font-family: roboto"><table align="center" width="600px" style="background:#2A7447; padding: 15px"><tr><td style="background: #0F5E5B; padding:0 15px;padding-bottom: 20px"><table align="center" width="100%"><tr><td align="center" width="600px"><h2 style="background: #4f7b61;padding: 10px 0;color:#FFFFFF;font-size: 20px;text-align: center;margin:0">Thank you for subscribing to Adhigam</h2></td></tr><tr><td style="color: #FFFFFF;font-size: 15px;padding-top: 10px"><p style="margin:5px 0">Hi ' + personalInfo.name + '!</p><p style="margin:5px 0">Welcome to Adhigam - Your Wise Choice, GSTwise!</p><p style="margin:5px 0">We simplify GST implementation with premium products and service offerings.</p></td></tr><tr><td><table align="center" width="100%"><tr><td> <img src="https://www.adhigam.com/assets/template-pages/comment@300.png"></td><td> <a href="https://www.adhigam.com/#/login" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"> <img src="https://www.adhigam.com/assets/template-pages/phone@200.png"> </a></td></tr></table></td></tr><tr><td style="color: #FFFFFF"><p style="margin:5px 0">In the meantime, you can</p><p style="position: relative;"> <img src="https://www.adhigam.com/assets/template-pages/horn.png" style="position: absolute;left: 0;bottom: 0;position: absolute;left: -45px;bottom: -45px;width: 50px;"> <a href="https://www.adhigam.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><span style="color: #FFFFFF;background-color: #436FCC;padding: 10px;cursor: pointer;">Return to our website</span></a> to continue browsing.</p><p style="margin:5px 0"><br></p><p style="margin:5px 0">For assistance please reply to <a href="mailto:helpdesk@adhigam.com" title="helpdesk@adhigam.com" style="color: #FFFFFF;">helpdesk@adhigam.com</a></p><p style="margin:5px 0"><br></p><p style="margin:5px 0">Best Regards</p><p style="margin:5px 0">Team Adhigam</p></td></tr></table></td></tr><tr><td align="center" width="600px"><table><tr><td style="padding: 5px;color:#FFFFFF;font-size: 15px;text-align: center;">Contact us on</td></tr><tr><td style="color: #FFFFFF"><table><tr><td><a href="https://www.facebook.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/fb.png" style="width: 30px"></a></td><td><a href="https://www.twitter.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/tw.png" style="width: 30px"></a></td><td><a href="https://www.linkedin.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/ln.png" style="width: 30px"></a></td></tr></table></td></tr></table></td></tr></table></body></html>'
                                                                };
                                                                self.sendMail.sendEmail(mailOptions, function (err, data) {
                                                                    if (!err) {
                                                                    }
                                                                    else {
                                                                    }
                                                                });
                                                            });
                                                        }
                                                        else {
                                                            var mailOptions = {
                                                                from: '"Adhigam" <helpdesk@adhigam.com>',
                                                                to: personalInfo.email,
                                                                subject: "Thank you for subscribing to adhigam",
                                                                //subject:"welcome", // Subject line
                                                                // plain text body
                                                                html: '<!DOCTYPE html><html><head><title></title></head><body style="font-family: roboto"><table align="center" width="600px" style="background:#2A7447; padding: 15px"><tr><td style="background: #0F5E5B; padding:0 15px;padding-bottom: 20px"><table align="center" width="100%"><tr><td align="center" width="600px"><h2 style="background: #4f7b61;padding: 10px 0;color:#FFFFFF;font-size: 20px;text-align: center;margin:0">Thank you for subscribing to Adhigam</h2></td></tr><tr><td style="color: #FFFFFF;font-size: 15px;padding-top: 10px"><p style="margin:5px 0">Hi ' + personalInfo.name + '!</p><p style="margin:5px 0">Welcome to Adhigam - Your Wise Choice, GSTwise!</p><p style="margin:5px 0">We simplify GST implementation with premium products and service offerings.</p></td></tr><tr><td><table align="center" width="100%"><tr><td> <img src="https://www.adhigam.com/assets/template-pages/comment@300.png"></td><td> <a href="https://www.adhigam.com/#/login" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"> <img src="https://www.adhigam.com/assets/template-pages/phone@200.png"> </a></td></tr></table></td></tr><tr><td style="color: #FFFFFF"><p style="margin:5px 0">In the meantime, you can</p><p style="position: relative;"> <img src="https://www.adhigam.com/assets/template-pages/horn.png" style="position: absolute;left: 0;bottom: 0;position: absolute;left: -45px;bottom: -45px;width: 50px;"> <a href="https://www.adhigam.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><span style="color: #FFFFFF;background-color: #436FCC;padding: 10px;cursor: pointer;">Return to our website</span></a> to continue browsing.</p><p style="margin:5px 0"><br></p><p style="margin:5px 0">For assistance please reply to <a href="mailto:helpdesk@adhigam.com" title="helpdesk@adhigam.com" style="color: #FFFFFF;">helpdesk@adhigam.com</a></p><p style="margin:5px 0"><br></p><p style="margin:5px 0">Best Regards</p><p style="margin:5px 0">Team Adhigam</p></td></tr></table></td></tr><tr><td align="center" width="600px"><table><tr><td style="padding: 5px;color:#FFFFFF;font-size: 15px;text-align: center;">Contact us on</td></tr><tr><td style="color: #FFFFFF"><table><tr><td><a href="https://www.facebook.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/fb.png" style="width: 30px"></a></td><td><a href="https://www.twitter.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/tw.png" style="width: 30px"></a></td><td><a href="https://www.linkedin.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/ln.png" style="width: 30px"></a></td></tr></table></td></tr></table></td></tr></table></body></html>'
                                                            };
                                                            self.sendMail.sendEmail(mailOptions, function (err, data) {
                                                                if (!err) {
                                                                }
                                                                else {
                                                                }
                                                            });
                                                        }
                                                    }
                                                });
                                            }
                                        }
                                        else {
                                            res.send(new response_model_2.customResponse(false, null, [], "Package not found"));
                                        }
                                    }
                                });
                            }
                        });
                    }
                    else {
                        res.send(new response_model_2.customResponse(false, null, [], "No package available for " + selectedSubscriberType));
                    }
                }
            }
        });
    }
    registerbyCA(req, res) {
        var self = this;
        let personalInfo = req.body.personalInfo;
        if (util_2.isNullOrUndefined(req.body.personalInfo)) {
            personalInfo = req.body;
        }
        user.findOne({ "personalInfo.mobile": personalInfo.mobile }, function (err, data) {
            if (err) {
                res.send(new response_model_4.getResponse(false, err, []));
            }
            else {
                console.log("user data");
                // console.log(data);
                if (data) {
                    res.send(new response_model_2.customResponse(false, [], [], "Mobile number already registered !"));
                }
                else {
                    if (!req.body.productId) {
                        let subscriberObj = { user: {}, subscriber: {} };
                        subscriberObj = personalInfo;
                        subscriberObj["user"] = req.body.userId;
                        subscriberObj["subscriber"] = req.body.subscriberId;
                        subscriberObj["subscriptionDate"] = new Date();
                        subscriberObj["renewalDate"] = new Date();
                        subscriberObj["isDelete"] = false;
                        subscriberObj["paymentStatus"] = false;
                        let subscriber = new Subscriber(subscriberObj);
                        subscriber.save((err) => {
                            if (err) {
                                if (err.name === 'MongoError' && err.code === 11000) {
                                    res.send(new response_model_6.duplicateResponse(false, null, err));
                                }
                                else {
                                    res.send({ status: false, info: "subscriber not saved", data: [] });
                                }
                            }
                            else {
                                let subscriberId = subscriber._id;
                                let userData = new user(req.body);
                                if (req.body.subscriberType == 'individual') {
                                    userData.userType = 'admin-sme';
                                }
                                else {
                                    if (req.body.subscriberType == 'business') {
                                        userData.userType = 'admin-bu';
                                    }
                                    else {
                                        userData.userType = 'admin-ca';
                                    }
                                }
                                userData.address = {
                                    stateCode: "",
                                    area: "",
                                    pinCode: 0,
                                    city: "",
                                    state: null,
                                };
                                userData.personalInfo = personalInfo;
                                userData.personalInfo.password = personalInfo.password;
                                userData.isActive = true;
                                userData.subscriberId = subscriber._id;
                                userData.save((err) => {
                                    if (err) {
                                        res.send(new response_model_5.postResponse(false, null, err));
                                    }
                                    else {
                                        var mailOptions = {
                                            from: '"Adhigam" <helpdesk@adhigam.com>',
                                            to: personalInfo.email,
                                            subject: "Thank you for subscribing to adhigam",
                                            html: '<!DOCTYPE html><html><head><title></title></head><body style="font-family: roboto"><table align="center" width="600px" style="background:#2A7447; padding: 15px"><tr><td style="background: #0F5E5B; padding:0 15px;padding-bottom: 20px"><table align="center" width="100%"><tr><td align="center" width="600px"><h2 style="background: #4f7b61;padding: 10px 0;color:#FFFFFF;font-size: 20px;text-align: center;margin:0">Thank you for subscribing to Adhigam</h2></td></tr><tr><td style="color: #FFFFFF;font-size: 15px;padding-top: 10px"><p style="margin:5px 0">Hi ' + personalInfo.name + '!</p><p style="margin:5px 0">Welcome to Adhigam - Your Wise Choice, GSTwise!</p><p style="margin:5px 0">We simplify GST implementation with premium products and service offerings.</p></td></tr><tr><td><table align="center" width="100%"><tr><td> <img src="https://www.adhigam.com/assets/template-pages/comment@300.png"></td><td> <a href="https://www.adhigam.com/#/login" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"> <img src="https://www.adhigam.com/assets/template-pages/phone@200.png"> </a></td></tr></table></td></tr><tr><td style="color: #FFFFFF"><p style="margin:5px 0">In the meantime, you can</p><p style="position: relative;"> <img src="https://www.adhigam.com/assets/template-pages/horn.png" style="position: absolute;left: 0;bottom: 0;position: absolute;left: -45px;bottom: -45px;width: 50px;"> <a href="https://www.adhigam.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><span style="color: #FFFFFF;background-color: #436FCC;padding: 10px;cursor: pointer;">Return to our website</span></a> to continue browsing.</p><p style="margin:5px 0"><br></p><p style="margin:5px 0">For assistance please reply to <a href="mailto:helpdesk@adhigam.com" title="helpdesk@adhigam.com" style="color: #FFFFFF;">helpdesk@adhigam.com</a></p><p style="margin:5px 0"><br></p><p style="margin:5px 0">Best Regards</p><p style="margin:5px 0">Team Adhigam</p></td></tr></table></td></tr><tr><td align="center" width="600px"><table><tr><td style="padding: 5px;color:#FFFFFF;font-size: 15px;text-align: center;">Contact us on</td></tr><tr><td style="color: #FFFFFF"><table><tr><td><a href="https://www.facebook.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/fb.png" style="width: 30px"></a></td><td><a href="https://www.twitter.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/tw.png" style="width: 30px"></a></td><td><a href="https://www.linkedin.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/ln.png" style="width: 30px"></a></td></tr></table></td></tr></table></td></tr></table></body></html>'
                                        };
                                        self.sendMail.sendEmail(mailOptions, function (err, data) {
                                            if (!err) {
                                            }
                                            else {
                                            }
                                        });
                                        if (util_2.isNullOrUndefined(req.body.personalInfo)) {
                                            res.send(new response_model_5.postResponse(true, null, subscriber));
                                        }
                                        else {
                                            res.send(new response_model_5.postResponse(true, null, userData));
                                        }
                                    }
                                });
                            }
                        });
                    }
                    else {
                        console.log("user data");
                        // console.log(data);
                        product.find({ _id: req.body.productId }, function (err, pakageData) {
                            if (err)
                                res.send(new response_model_4.getResponse(false, err, []));
                            else {
                                let subscriber = new Subscriber(personalInfo);
                                subscriber.packages = req.body.productId;
                                subscriber.status = "active";
                                subscriber.save((err) => {
                                    if (err) {
                                        if (err.name === 'MongoError' && err.code === 11000) {
                                            res.send(new response_model_6.duplicateResponse(false, null, err));
                                        }
                                    }
                                    else {
                                        let subscriberId = subscriber._id;
                                        let userData = new user(req.body);
                                        if (req.body.subscriberType == 'individual') {
                                            userData.userType = 'admin-sme';
                                        }
                                        else {
                                            if (req.body.subscriberType == 'business') {
                                                userData.userType = 'admin-bu';
                                            }
                                            else {
                                                userData.userType = 'admin-ca';
                                            }
                                        }
                                        userData.address = {
                                            stateCode: "",
                                            area: "",
                                            pinCode: 0,
                                            city: "",
                                            state: null,
                                        };
                                        userData.personalInfo = personalInfo;
                                        //userData.personalInfo.password = req.body.personalInfo.password;
                                        userData.personalInfo.password = bycrypt.hashSync(personalInfo.password);
                                        //userData.personalInfo.password = personalInfo.password;
                                        userData.isActive = true;
                                        userData.subscriberId = subscriber._id;
                                        let packages = [];
                                        let permissionsList = [];
                                        let permissions = [];
                                        packages.push(pakageData[0]._id);
                                        _.each(pakageData[0].additionalParametersValues, function (list) {
                                            _.each(list.permissions, function (permission) {
                                                if (permission.isChecked == true)
                                                    permissionsList.push(permission);
                                            });
                                        });
                                        permissions = _.chain(permissionsList).groupBy('permissionName').map(function (value, key) {
                                            return key;
                                        }).value();
                                        userData.permission = permissions;
                                        ////console.log(permissions);
                                        console.log("user before save");
                                        // console.log(userData);
                                        userData.save((err) => {
                                            if (err) {
                                                res.send(new response_model_5.postResponse(false, null, err));
                                            }
                                            else {
                                                console.log("user after save");
                                                let transactionData = new transaction(req.body);
                                                transactionData.description = "cash payment";
                                                transactionData.paymentStatus = req.body.paymentStatus;
                                                transactionData.packageId = req.body.productId;
                                                transactionData.paymentId = req.body.paymentId;
                                                //transactionData.tax=pakageData[0].tax;
                                                //transactionData.amount=pakageData[0].amount;
                                                transactionData.userId = userData._id;
                                                transactionData.paymentMode = "online";
                                                transactionData.subscriberId = subscriber._id;
                                                transactionData.paymentType = "RECHARGE";
                                                transactionData.save((err) => {
                                                    if (err) {
                                                        res.send(new response_model_5.postResponse(false, null, err));
                                                    }
                                                    else {
                                                        console.log("transactionData");
                                                        user.findOneAndUpdate({ _id: req.body.userId }, { $push: { accessSubscribers: userData.subscriberId } }, function (err, cadata) {
                                                            if (err) {
                                                                res.send(new response_model_2.customResponse(false, err, [], "Sorry,Problem while approving subscriber for CA"));
                                                            }
                                                            else {
                                                                console.log("sub find update");
                                                                // console.log(cadata);
                                                                var mailOptions = {
                                                                    from: '"Adhigam" <helpdesk@adhigam.com>',
                                                                    to: personalInfo.email,
                                                                    subject: "Thank you for subscribing to adhigam",
                                                                    //subject:"welcome", // Subject line
                                                                    // plain text body
                                                                    html: '<!DOCTYPE html><html><head><title></title></head><body style="font-family: roboto"><table align="center" width="600px" style="background:#2A7447; padding: 15px"><tr><td style="background: #0F5E5B; padding:0 15px;padding-bottom: 20px"><table align="center" width="100%"><tr><td align="center" width="600px"><h2 style="background: #4f7b61;padding: 10px 0;color:#FFFFFF;font-size: 20px;text-align: center;margin:0">Thank you for subscribing to Adhigam</h2></td></tr><tr><td style="color: #FFFFFF;font-size: 15px;padding-top: 10px"><p style="margin:5px 0">Hi ' + req.body.personalInfo.name + '!</p><p style="margin:5px 0">Welcome to Adhigam - Your Wise Choice, GSTwise!</p><p style="margin:5px 0">We simplify GST implementation with premium products and service offerings.</p></td></tr><tr><td><table align="center" width="100%"><tr><td> <img src="https://www.adhigam.com/assets/template-pages/comment@300.png"></td><td> <a href="https://www.adhigam.com/#/login" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"> <img src="https://www.adhigam.com/assets/template-pages/phone@200.png"> </a></td></tr></table></td></tr><tr><td style="color: #FFFFFF"><p style="margin:5px 0">In the meantime, you can</p><p style="position: relative;"> <img src="https://www.adhigam.com/assets/template-pages/horn.png" style="position: absolute;left: 0;bottom: 0;position: absolute;left: -45px;bottom: -45px;width: 50px;"> <a href="https://www.adhigam.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><span style="color: #FFFFFF;background-color: #436FCC;padding: 10px;cursor: pointer;">Return to our website</span></a> to continue browsing.</p><p style="margin:5px 0"><br></p><p style="margin:5px 0">For assistance please reply to <a href="mailto:helpdesk@adhigam.com" title="helpdesk@adhigam.com" style="color: #FFFFFF;">helpdesk@adhigam.com</a></p><p style="margin:5px 0"><br></p><p style="margin:5px 0">Best Regards</p><p style="margin:5px 0">Team Adhigam</p></td></tr></table></td></tr><tr><td align="center" width="600px"><table><tr><td style="padding: 5px;color:#FFFFFF;font-size: 15px;text-align: center;">Contact us on</td></tr><tr><td style="color: #FFFFFF"><table><tr><td><a href="https://www.facebook.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/fb.png" style="width: 30px"></a></td><td><a href="https://www.twitter.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/tw.png" style="width: 30px"></a></td><td><a href="https://www.linkedin.com" target="_blank" title="www.adhigam.com" style="color: #FFFFFF;text-decoration: none"><img src="https://www.adhigam.com/assets/template-pages/ln.png" style="width: 30px"></a></td></tr></table></td></tr></table></td></tr></table></body></html>'
                                                                };
                                                                self.sendMail.sendEmail(mailOptions, function (err, data) {
                                                                    if (!err) {
                                                                    }
                                                                    else {
                                                                    }
                                                                });
                                                                res.send(new response_model_2.customResponse(true, null, userData, "Subscriber registered succesfully"));
                                                            }
                                                        });
                                                    }
                                                });
                                            }
                                        });
                                    }
                                });
                            }
                        });
                    }
                }
            }
        });
    }
    getCountry(req, res) {
        countryCode.find({ "isDelete": false }).sort({ "name": 1 }).exec(function (err, country) {
            if (err) {
                res.send(new response_model_4.getResponse(false, err, []));
            }
            else {
                res.send(new response_model_4.getResponse(true, "Country found successfully", country));
            }
        });
    }
    getState(req, res) {
        stateCode.find({ "countryName": req.params.name, isDelete: false }).sort({ "stateName": 1 }).exec(function (err, state) {
            if (err) {
                res.send(new response_model_4.getResponse(false, err, []));
            }
            else {
                res.send(new response_model_4.getResponse(true, "states found susccessfully ", state));
            }
        });
    }
    calculateTaxSummary(req, res) {
        let arr = [];
        let data = req.body.cartList;
        let taxrate;
        //  let quantity=req.body.cartList[0].quantity;
        let quantity = 1;
        _.each(data, function (list) {
            arr.push(list._id);
        });
        var query = product.find({ isDelete: false, _id: { $in: arr } }).populate('hsnSac');
        query.exec(function (err, data) {
            let finalResponse = [];
            let totalCGST = 0;
            let totalSGST = 0;
            let totalSalesPrice = 0;
            let totalIGST = 0;
            let totalAmount = 0;
            if (data != null) {
                if (config.adhigamStateCode == req.body.stateCode) {
                    var length = data.length;
                    for (var counter = 0; counter < length; counter++) {
                        taxrate = data[counter].hsnSac.gstTaxRate;
                        let rate = Number((util_2.isUndefined(data[counter].hsnSac) ?
                            0 : data[counter].hsnSac.gstTaxRate)) / 2;
                        let productName = data[counter].productName;
                        let _id = data[counter]._id;
                        let price = (data[counter].price.salesPrice);
                        let discount = data[counter].price.discount;
                        let cgstrate = rate;
                        let sgstrate = rate;
                        let salesPrice = (data[counter].price.salesPrice) * quantity;
                        let cgst = salesPrice * (rate / 100);
                        let sgst = salesPrice * (rate / 100);
                        // let salesPrice = (data[counter].price.salesPrice)*quantity;
                        let total = (cgst + sgst + salesPrice);
                        let taxvalue = (cgst + sgst);
                        var object = {
                            // product_id : _id,
                            _id: _id,
                            quantity: quantity,
                            // discount:discount,
                            productName: productName,
                            cgst: cgst,
                            sgst: sgst,
                            salesPrice: salesPrice,
                            tax: data[counter].tax,
                            hsnSac: data[counter].hsnSac,
                            price: data[counter].price,
                            total: total,
                            cgstrate: cgstrate,
                            sgstrate: sgstrate,
                            taxvalue: taxvalue,
                            taxrate: taxrate,
                            // price:.price,
                            igst: 0
                        };
                        finalResponse.push(object);
                        totalCGST += cgst;
                        totalSGST += sgst;
                        totalSalesPrice += total;
                        totalAmount += salesPrice;
                    }
                    var response = {
                        "product": finalResponse, totalValues: {
                            cgst: totalCGST,
                            sgst: totalSGST,
                            totaltax: totalCGST + totalSGST,
                            totalSalesPrice: totalSalesPrice,
                            totalAmount: totalAmount
                        }
                    };
                    res.send({ status: true, info: "tax found ", data: response });
                }
                else {
                    var length = data.length;
                    let totalAmount = 0;
                    for (var counter = 0; counter < length; counter++) {
                        taxrate = data[counter].hsnSac.gstTaxRate;
                        let rate = Number((util_2.isUndefined(data[counter].hsnSac) ?
                            0 : data[counter].hsnSac.gstTaxRate));
                        let productName = data[counter].productName;
                        let _id = data[counter]._id;
                        //let discount=data[counter].price.discount;
                        let price = (data[counter].price.salesPrice);
                        let salesPrice = (data[counter].price.salesPrice) * quantity;
                        let igst = salesPrice * (rate / 100);
                        let total = igst + salesPrice;
                        totalAmount += salesPrice;
                        var objectdata = {
                            //  product_id : _id,
                            _id: _id,
                            productName: productName,
                            quantity: quantity,
                            discount: discount,
                            igst: igst,
                            tax: data[counter].tax,
                            price: data[counter].price,
                            hsnSac: data[counter].hsnSac,
                            salesPrice: salesPrice,
                            total: total,
                            igstrate: rate,
                            taxvalue: igst,
                            taxrate: taxrate,
                            // price:price,
                            cgst: 0,
                            sgst: 0
                        };
                        finalResponse.push(objectdata);
                        totalIGST += igst;
                        totalSalesPrice += total;
                    }
                    var responsedata = {
                        "product": finalResponse, totalValues: {
                            totaltax: totalIGST,
                            totalSalesPrice: totalSalesPrice,
                            totalAmount: totalAmount,
                        }
                    };
                    res.send({ status: true, info: "tax found ", data: responsedata });
                }
            }
            else {
                res.json({
                    info: 'Tax not found',
                    data: {
                        "totalTax": 0,
                        "cgst": 0,
                        "sgst": 0,
                        "igst": 0,
                        "cgstRate": 0,
                        "sgstRate": 0,
                        "igstRate": 0,
                        "total": 0,
                        "taxvalue": 0,
                        "price": 0,
                        "taxrate": 0
                    },
                    status: false
                });
            }
        });
    }
    beforeRegistration(req, res) {
        var object = {
            "dataBeforeRegister": req.body,
            //bind razor pay id here
            "paymentRequestId": req.body.cartList[0]._id,
            "selectedGetWay": req.body.selectedGetWay,
        };
        this.storePaymentData(object, function (status, data) {
            res.send(new response_model_5.postResponse(true, null, {
                "longurl": "",
                "payment_request_id": data._id
            }));
        });
    }
    price(req, res) {
        let self = this;
        let count = 0;
        if (req.body.isCode) {
            reseller.findOne({ "code": req.body.code, "isActive": true }, 'reSaleAmount count isSeller', function (err, resaleAmount) {
                if (err) {
                    res.send(new response_model_5.postResponse(false, err, []));
                }
                else {
                    if (resaleAmount) {
                        if (!resaleAmount.isSeller) {
                            var data = { "package": [], "addOn": [], "calculatedAmount": { "totalDiscount": 0, "totalAmount": 0, "finalAmountToPay": 0, "totalTax": 0, "igst": 0, "cgst": 0, "sgst": 0, "taxRate": 0, "isIgst": 0, "taxableAmount": 0 }, "count": 0, "isCommision": true };
                            res.send(new response_model_5.postResponse(true, [], data));
                        }
                        else {
                            self.invoiceHelper.packageCalculation(resaleAmount.reSaleAmount, req.body.stateCode, resaleAmount.count, function (err, data) {
                                if (err) {
                                    res.send(new response_model_5.postResponse(false, err, [], "System Error"));
                                }
                                else {
                                    res.send(new response_model_5.postResponse(true, [], data));
                                }
                            });
                        }
                    }
                    else {
                        res.send(new response_model_5.postResponse(false, [], [], "Invalid Code"));
                    }
                }
            });
        }
        else {
            self.invoiceHelper.slabCalculation(commonConstants.taxpayer, req.body.count, req.body.isMonthly, function (err, countDetails) {
                if (err) {
                    res.send(new response_model_5.postResponse(false, err, [], "Error while find count of invoice"));
                }
                else {
                    if (!util_2.isNullOrUndefined(countDetails)) {
                        self.invoiceHelper.packageCalculation(countDetails.salesPrice, req.body.stateCode, countDetails.count, function (err, data) {
                            if (err) {
                                res.send(new response_model_5.postResponse(false, err, [], "System Error"));
                            }
                            else {
                                res.send(new response_model_5.postResponse(true, [], data));
                            }
                        });
                    }
                    else {
                        res.send(new response_model_5.postResponse(false, err, [], "calculation error"));
                    }
                }
            });
        }
    }
    getAddOnPackages(req, res) {
        product.find({ "isAddOn": true, "isDelete": false }, 'price.salesPrice _id productName', function (err, addOns) {
            if (err) {
                res.send(new response_model_5.postResponse(false, err, [], "Service Error while getting price of add on package"));
            }
            else {
                let totalAmount = 0;
                let totalDiscountRate = 0;
                _.each(addOns, function (addOn) {
                    totalAmount += addOn.price.salesPrice;
                });
                pricingSlabs.findOne({ "type": "ALL_PACKAGES_DISC" }, function (err, discount) {
                    if (err) {
                        res.send(new response_model_5.postResponse(false, err, [], "Service Error while getting rate of add on pakage"));
                    }
                    else {
                        totalDiscountRate = discount.rate;
                        var data = { "addOn": addOns, "totalDiscount": Number((totalDiscountRate).toFixed(2)) };
                        res.send(new response_model_4.getResponse(true, null, data));
                    }
                });
            }
        });
    }
    getDBCollectionNames(req, res) {
        this.crud.getDBCollectionNames(req, res);
    }
    getDBCollectionKeys(req, res) {
        this.crud.getDBCollectionKeys(req, res);
    }
    getResultOfDynamicQuery(req, res) {
        this.crud.getDynamicData(req, res);
    }
    // createOrder(req,res)
    // {
    //
    //     var request = require("request");
    //
    //     var options = { method: 'POST',
    //         url: 'https://rzp_live_3lX4sJiPvZPWHe:I93lsX1eSOavJhoXCJ3da0Nm@api.razorpay.com/v1/orders',
    //         headers:
    //             {
    //                 'cache-control': 'no-cache',
    //                 'content-type': 'application/json' },
    //         body: { amount: req.body.amount, currency: 'INR', receipt: 'test1',payment_capture:1},
    //         json: true };
    //
    //     request(options, function (error, response, body) {
    //         if (error) throw new Error(error);
    //
    //         console.log(body);
    //
    //         res.send(new getResponse(true, null, body));
    //     });
    //
    // }
    createOrder(req, res) {
        var request = require("request");
        var options = {
            method: 'POST',
            url: 'https://rzp_live_3lX4sJiPvZPWHe:I93lsX1eSOavJhoXCJ3da0Nm@api.razorpay.com/v1/orders',
            headers: {
                'cache-control': 'no-cache',
                'content-type': 'application/json'
            },
            body: { amount: req.body.amount, currency: req.body.currency, receipt: 'test1', payment_capture: 1 },
            json: true
        };
        request(options, function (error, response, body) {
            if (error)
            res.send(new response_model_5.postResponse(false, error, {}));
            // console.log(body);
            body.status = false;
            body.orderId = body.id;
            body.package = req.body.packages;
            let paymentObj = new payment(body);
            paymentObj.save((err) => {
                if (err) {
                    res.send(new response_model_5.postResponse(false, err, body));
                }
                else {
                    res.send(new response_model_4.getResponse(true, null, body));
                }
            })
            // res.send(new response_model_4.getResponse(true, null, body));
        });
    }
    savePayment(req, res) {
        let paymentObj = new payment();
        let obj = {
            "calculatedAmount": {
                "totalAmount": req.body.data.totalAmount
            }
        };
        paymentObj.dataBeforeRegister = obj;
        paymentObj.type = "offline";
        paymentObj.selectedGetWay = "";
        paymentObj.status = "done";
        paymentObj.save((err) => {
            if (err) {
                res.send(new response_model_5.postResponse(false, err, []));
            }
            else {
                res.json(new response_model_2.customResponse(true, null, [], "Payment saved"));
            }
        });
    }
    /***create bulk org***/
    addOrganizationBulk(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let request = req.body
                let orgList = request['orgList']
                let subscriberId = request['subscriberId']
                let websiteUrl = request['websiteUrl']
                let orgInfoArr = []
                if (!util_1.isNullOrUndefined(orgList) && !util_1.isNullOrUndefined(subscriberId) && !util_1.isNullOrUndefined(websiteUrl)) {
                    if (Array.isArray(orgList) && orgList.length > 0) {
                        const orgData = yield this.orgRoute.getParentOrgDetails(websiteUrl);
                        for (let i = 0; i < orgList.length; i++) {
                            let organizationData = new organisation();
                            organizationData['subscriberId'] = subscriberId;
                            organizationData['name'] = orgList[i];
                            organizationData['owner'] = request['name'];
                            organizationData['email'] = request.email;
                            organizationData['mobile'] = request.mobile;
                            organizationData['isActive'] = false;
                            organizationData['tallyCompanyActive'] = request.tallyCompanyActive ? request.tallyCompanyActive : ''
                            organizationData['tallyCompanySelected'] = request.tallyCompanySelected ? request.tallyCompanySelected : false
                            organizationData['tallyCompanyPath'] = request.tallyCompanyPath ? request.tallyCompanyPath : ''
                            organizationData['primaryAddress']['countryName'] = request['country']
                            organizationData['primaryAddress']['state'] = request['state']
                            organizationData['primaryAddress']['stateCode'] = request['stateCode']
                            organizationData['configuration']['extRegAllow'] = orgData.configuration.extRegAllow;
                            organizationData['configuration']['urlRequired'] = orgData.configuration.urlRequired;
                            if (!util_1.isNullOrUndefined(orgData.configuration) && orgData.configuration.urlRequired) {
                                organizationData['websiteUrl'] = orgData.websiteUrl;
                            }
                            organizationData['websiteType'] = orgData.websiteType;
                            organizationData['logoURL'] = orgData.logoURL;
                            organizationData['labelFile'] = orgData.labelFile;
                            organizationData['loginBackground'] = orgData.loginBackground;
                            let orgInfo = yield organizationData.save();
                            orgInfo = JSON.parse(JSON.stringify(orgInfo))
                            orgInfoArr.push(orgInfo)
                        }
                        res.send(new response_model_5.postResponse(true, null, { msg: "Organisations added successfully", data: orgInfoArr }));
                    } else {
                        res.send(new response_model_3.getResponse(false, null, 'Orglist is empty'));
                    }
                } else {
                    res.send(new response_model_3.getResponse(false, null, 'Website url or subscriber id is empty'));
                }
            }
            catch (e) {
                res.send(new response_model_3.getResponse(false, null, 'Please try again later'));
            }
        });
    }
    /******************************* UAE *****************************************/
    registerUser(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let license = '';
                // let userData = req.body.userData;
                let userData = req.body;


                const orgData = yield this.orgRoute.getParentOrgDetails(userData.parentUrl);
                const duplicateUser = yield this.checkDuplicateUser(orgData, userData);
                // const packageData = await products.findOne({ productName: userData.selectpkg});

                let packageData = yield products.findOne({ packageType: "free", type : userData.regType });
                if(userData.ProductCode && userData.CustomerIdentifier) {
                    packageData = yield db.collection('creditproducts').findOne({ productCode: userData.ProductCode, type : userData.regType });  
                }
                packageData = JSON.parse(JSON.stringify(packageData))
            
                if (duplicateUser) {
                    if(duplicateUser['personalInfo']['email']==userData.email && duplicateUser['personalInfo']['mobile']==userData.mobile)
                        return res.send(new response_model_3.getResponse(false, null, 'Email & Mobile already exists'))
                    else if(duplicateUser['personalInfo']['email']==userData.email)
                        return res.send(new response_model_3.getResponse(false, null, 'Email already exists'))
                    else
                        return res.send(new response_model_3.getResponse(false, null, 'Mobile already exists'))
                }
                else if(userData._id)
                { // this flow is to update the mobile and name from user and verify OTP

                    if(util_1.isNullOrUndefined(userData.mobile) || util_1.isNullOrUndefined(userData.email) || util_1.isNullOrUndefined(userData.name) || userData.mobile == '' || userData.email == '' || userData.name == '' || userData.countryCode == '')
                    {
                        return res.send(new response_model_3.getResponse(false, null, 'Please fill mandetory fields'));

                    }

                    let userD = yield user.findOne({
                            "personalInfo.name" : userData.name,
                            "subscriberId" : ObjectId(userData.subscriberId),
                            "organisation" : ObjectId(userData.organisation)
                        }).lean()

                    if(userD && userD.length && String(userD._id) === String(userData._id))
                    {
                      return res.send(new response_model_3.getResponse(false, null, 'Username already exits in enterprise.'));
                    }

                    userData.password = bycrypt.hashSync(userData.pwd);
                    // userData.recentPwds = [userData.password];
                    // userData.pwdExpiresOn = Date.now() + config.pwdExpiryTime; 
                    let uUser = yield user.findOneAndUpdate({ _id : userData._id },{
                        $set : {
                            "personalInfo.name" : userData.name,
                            "personalInfo.mobile" : userData.mobile,
                            "personalInfo.password" : userData.password,
                            "personalInfo.phoneCode": userData.phoneCode
                            // "recentPwds":userData.recentPwds,
                            // "pwdExpiresOn":userData.pwdExpiresOn
                        }
                    })

                    console.log("User updated----");
                    return res.send(new response_model_3.getResponse(true, null, 'User Updated. Please login.'));
                }
                else {
                    if (!util_1.isNullOrUndefined(userData.offline) && userData.offline != '' && userData.offline == true) {
                        license = this.websiteHelper.createLicense(userData, packageData);
                    }
                    const subscriberInfo = yield this.addSubscriber(orgData, userData, packageData, license);
                    // const uploadInvErrCodes = yield this.addUploadInvErrorCodes(subscriberInfo._id, orgData.subscriberId);
                    const orgInfo = yield this.addOrganization(userData, subscriberInfo, orgData);
                    const userInfo = yield this.addUser(userData, subscriberInfo, orgInfo);
                    const paymentInfo = yield this.savePaymentDetails(req.body, userInfo, subscriber);

                    
                    let token = yield this.createTokenFor(String(userInfo._id),String(subscriberInfo._id),String(orgInfo._id))
                    const subRoute = (userData.ProductCode && userData.CustomerIdentifier) ? 'addTokenPackage' : 'addPackage';
                    let options = {
                        method: 'POST',
                        url: config.apiUrl.replace(/\/$/,'')  + `/gibots-api/subs/${subRoute}`,
                        headers:  { 
                            'authorization': "Bearer " + token, 
                            'content-type': "application/json", 
                            "selectedorgid": String(orgInfo._id) 
                        },
                        body: [
                            {
                                "id" : packageData._id,
                                "name": "Free Package",
                                "amount": 0
                            }
                        ],
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';       

                    let addPackage = yield this.remoteApiCall(options);

                    if(addPackage['status']==0){
                        res.send(new response_model_3.getResponse(true, null, 'User registered. Please login.'));
                    }
                    else
                        res.send(new response_model_3.getResponse(false, null, 'Free package purchase failed. Please login.'));

                    // THIS CODE IS FOR SENDING EMAIL AS "registerUser" API CALLED

                    // this.sendRegisterEmail(userInfo, license, userData.parentUrl, function (status, response) {
                    //     if (!status) {
                    //         throw 'err';
                    //     }
                    //     else {
                    //         res.send(new response_model_3.postResponse(true, null, userData));
                    //     }
                    // });
                }
            }
            catch (e) {
                console.log('-------',e);
                res.send(new response_model_3.getResponse(false, null, 'Please try again later'));
            }
        });
    }
    registerUserAWS(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {

                if(req.body['Records']){
                    for (let index = 0; index < req.body['Records'].length; index++) {
                        let element = req.body['Records'][index];
                        if(element['dynamodb'] && element['dynamodb']['NewImage']){
                            let license = '';
                            // let userData = req.body.userData;
                            let userData = req.body;
                            // let url="localhost:4200"
                            let url=config.websiteUrl;
                            userData['mobile']=element['dynamodb']['NewImage']['contactPhone']['S'];
                            userData['email']=element['dynamodb']['NewImage']['contactEmail']['S'];
                            req.body['mobile']=element['dynamodb']['NewImage']['contactPhone']['S'];
                            req.body['email']=element['dynamodb']['NewImage']['contactEmail']['S'];
                            userData['parentUrl']=url
                            userData['name']=element['dynamodb']['NewImage']['contactPerson']['S'];
                            userData['pwd']="user@123*"
                            userData['cpwd']="user@123*"
                            userData['trmcond']=true
                            userData['offline']=""
                            userData['machineId']=""
                            userData['businessType']=""
                            userData['websiteUrl']=url
                            userData['regType']="Enterprise"
                            userData['type']="taxpayer"
                            userData['locationPreference']={
                                "country":"INDIA",
                                "timezone":"Asia/Kolkata",
                                "locale":"en"
                            }
            
                            const orgData = yield this.orgRoute.getParentOrgDetails(userData.parentUrl);
                            const duplicateUser = yield this.checkDuplicateUser(orgData, userData);
                            // const packageData = await products.findOne({ productName: userData.selectpkg});
                            let packageData = yield products.findOne({ packageType: "free" });
                            packageData = JSON.parse(JSON.stringify(packageData))

                            let userPackageData = [];
                            const jsonString = element['dynamodb']['NewImage']['entitlement']['S'];
                            const jsonObject = JSON.parse(jsonString);
                            if(jsonObject.Entitlements){
                                for (let index = 0; index < jsonObject.Entitlements.length; index++) {
                                    let pkg = jsonObject.Entitlements[index];
                                    userPackageData.push(pkg['Dimension'])
                                }
                            }
                            let packages=yield products.find({ productName: { $in: userPackageData } })
                            if (duplicateUser) {
                                res.send(new response_model_3.getResponse(false, null, 'User already exists'));
                            }
                            else {
                                if (!util_1.isNullOrUndefined(userData.offline) && userData.offline != '' && userData.offline == true) {
                                    license = this.websiteHelper.createLicense(userData, packageData);
                                }
                                const subscriberInfo = yield this.addSubscriberN(orgData, userData, packageData, packages, license);
                                const uploadInvErrCodes = yield this.addUploadInvErrorCodes(subscriberInfo._id, orgData.subscriberId);
                                const orgInfo = yield this.addOrganization(userData, subscriberInfo, orgData);
                                const userInfo = yield this.addUser(userData, subscriberInfo, orgInfo);
                                const paymentInfo = yield this.savePaymentDetails(req.body, userInfo, subscriber);
                                // this.sendRegisterEmail(userInfo, license, userData.parentUrl, function (status, response) {
                                //     if (!status) {
                                //         throw 'err';
                                //     }
                                //     else {
                                //         res.send(new response_model_3.postResponse(true, null, userData));
                                //     }
                                // });
                                // const userCount =  yield self.updateOrganisationUserCount(userData['websiteUrl']);
                                let isActive = true;
                                let limitExceeded = false;
                                // if(!util_1.isNullOrUndefined(userCount) && userCount === 0){
                                //     isActive = false;
                                //     limitExceeded = true;
                                // }
                                let updateQuery = { isActive: isActive, OTPverification : true, regStatus : true };
                                // if(limitExceeded){
                                //     updateQuery.limitExceeded = true;
                                //     data.limitExceeded = true;
                                // }
                                let userDataN = yield (db.createDynamicModel('users')).findOneAndUpdate({ "personalInfo.mobile": req.body.mobile , isDeleted : false },updateQuery).lean();
            
            
                                if(!util_1.isNullOrUndefined(req.body.email)){
                                // let license = "";
                                // userDataN.parentUrl= "";
                                // this.sendRegisterEmail(userDataN, license, '', function (status, response) {
                                //     if (status) {
                                //         //throw 'err';
                                //         data.emailStatus = true;
                                //     }
                                //     else {
                                //         //res.send(new response_model_3.postResponse(true, null, userData));
                                //         data.emailStatus = false;
                                //     }
                                // });
                                this.sendRegisterEmail(userInfo, license, userData.parentUrl, function (status, response) {
                                    if (!status) {
                                        throw 'err';
                                    }
                                    else {
                                        res.send(new response_model_3.postResponse(true, null, userData));
                                    }
                                });
                                }
                                res.send(new response_model_3.getResponse(true, null, 'User registered. Please login.'));
                            }
                           
                        }
                        
                    }
                }else{
                    res.send(new response_model_3.getResponse(false, null, 'no records'));
                }
            }
            catch (e) {
                res.send(new response_model_3.getResponse(false, null, 'Please try again later'));
            }
        });
    }
    updateOrganisationUserCount(url){
        return __awaiter(this, void 0, void 0, function* () {
            let userCount;
            try{
                const orgData = yield this.orgRoute.getParentOrgDetails(url);
                userCount = orgData.userCount;
                if(userCount){
                    userCount--;
                    if(userCount < 0){
                        userCount = 0;
                    }
                    const updatedOrgData = yield this.orgRoute.updateOrgUserCount(url,userCount);
                    return userCount === 0 ? 1 : userCount;
                }
                return userCount;
            }catch (e) {
                return e;
            }
        });
    }

    emailVerification(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const userId = req.body.id;
                let userInfo = yield user.findOne({_id:userId,isDeleted:false});
                if(userInfo && !userInfo.Emailverification){
                    let token = yield this.createTokenFor(String(userInfo._id),String(userInfo.subscriberId),String(userInfo.organisation));
                    let options = {
                        method: 'POST',
                        url: config.apiUrl.replace(/\/$/,'') + "/gibots-api/user/emailVerification",
                        headers:  { 
                            'authorization': "Bearer " + token, 
                            'content-type': "application/json", 
                            "selectedorgid": String(userInfo.organisation)
                        },
                        body: 
                            {
                                action:"updateStatus",
                                payload: {
                                    id: userInfo._id,
                                    Emailverification: true
                                }
                            }
                        ,
                        json: true
                    };

                    let emailVerification = yield this.remoteApiCall(options);
                    if(emailVerification['status']==0){
                        res.send(new response_model_3.getResponse(true, null, 'Email verified. You can login in and can continue enjoying our services!!'));
                    }
                    else
                        res.send(new response_model_3.getResponse(false, null, 'Email Verification failed'));
                } else if(userInfo && userInfo.Emailverification){
                    res.send(new response_model_3.getResponse(true, null, 'Email Already Verified'));
                } 
                else {
                    res.send(new response_model_3.getResponse(false, null, 'User not found'));
                }
            }
            catch (e) {
                console.log('-------',e);
                res.send(new response_model_3.getResponse(false, null, 'Please try again later'));
            }
        });
    }

    checkDuplicateUser(orgData, userData) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // const subscribers = yield this.getParentSubscriberList(orgData.subscriberId);
                let userInfo = yield user.findOne({
                    $or : [
                        { "personalInfo.mobile": userData.mobile },
                        { "personalInfo.email": userData.email }
                    ],
                    // "subscriberId": { $in: subscribers },
                    "isDeleted": false
                }).lean();
                if(userInfo && !userInfo.regStatus)
                {
                  yield user.findOneAndUpdate(
                    {
                      _id: userInfo._id,
                    },
                    {
                      $set: {
                        isDeleted: true,
                      },
                    }
                  );
                  userInfo = null;
                }
                else if(userData && userInfo && userData._id && String(userInfo._id) === String(userData._id))
                { // for emailregistration
                    userInfo = null;
                }
                return userInfo;
            }
            catch (e) {
                console.log("Err------",e);
                return e;
            }
        });
    }

    changepasswordWithNo(req, res) {
        return __awaiter(this, void 0, void 0, function* () { 
        try {
            let userdata;
            // let userInfo = yield user.findOne({"personalInfo.mobile":req.body.mobile,isDeleted:false},{recentPwds:1});
            // let recentPwds = userInfo.recentPwds ? userInfo.recentPwds : [];
            // let flag = false;
            // for(let i=0;i<recentPwds.length;i++){
            //     if(bycrypt.compareSync(req.body.password,recentPwds[i])){
            //         flag = true;
            //         break;
            //     }
            // }
            // if(flag){
            //     return res.status(400).send({message: 'Previous 3 passwords cannot be used!', data: [] });
            // }
            const password = bycrypt.hashSync(req.body.password);
            // if(recentPwds.length!=3){
            //     recentPwds.push(password);
            // } else {
            //     recentPwds.push(password);
            //     recentPwds.shift();
            // }
            userdata = yield user.findOneAndUpdate({ 'personalInfo.mobile': req.body.mobile,
            isDeleted : false
         }, {
                $set: {
                    'personalInfo.password': password,
                    // "recentPwds": recentPwds,
                    // "pwdExpiresOn": Date.now() + config.pwdExpiryTime
                }
            }, { new: true });
            return res.status(200).send({message: 'Password updated successfully', data: userdata });
        } catch (err) {
            return res.status(500).send({message: 'Please try again later', error: err});
        }
        });
    }

    getParentSubscriberList(subscriberId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const subscriberList = yield subscriber.find({ parentSubscriberId: subscriberId }).select({ _id: 1 });
                const list = subscriberList.map(a => a._id);
                list.push(subscriberId); // For checking duplicate user in parent subscriber
                return list;
            }
            catch (e) {
                return e;
            }
        });
    }
    addDays(pD, days) {
        let date = new Date(pD);
        date.setDate(date.getDate() + days);
        return date;
    }
    addSubscriber(orgData, userData, packageData, license) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const subscriberType = userData.type == accountsetup.agent ? 'ca' : 'business';
                let subscriber = new Subscriber(userData);
                subscriber.licenseKey = license;
                subscriber.machineId = userData.machineId;
                subscriber.locationPreference = userData.locationPreference;
                subscriber.licenseValidity = packageData.validityNumber;
                subscriber.licenseExpiry = moment().add(+packageData.validityNumber, 'd');
                subscriber.packages = packageData._id;
                subscriber.status = "active";
                subscriber.subscriberType = subscriberType;
                subscriber.parentSubscriberId = orgData.subscriberId;
                if (!util_1.isNullOrUndefined(userData.offline) && userData.offline != '' && userData.offline == true) {
                    const packageInfo = JSON.parse(JSON.stringify(packageData));
                    const license = this.websiteHelper.createLicense(userData, packageInfo);
                    subscriber.licenseKey = license;
                    subscriber.licenseValidity = packageInfo.validityNumber;
                    subscriber.licenseExpiry = moment().add(+packageInfo.validityNumber, 'd');
                }
                const savedInfo = yield subscriber.save();
                return savedInfo;
            }
            catch (e) {
                console.log("errowr while adding subscriber-----",e);
                return e;
            }
        });
    }
    addSubscriberN(orgData, userData, packageData, packages, license) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const subscriberType = userData.type == accountsetup.agent ? 'ca' : 'business';
                let subscriber = new Subscriber(userData);
                subscriber.licenseKey = license;
                subscriber.machineId = userData.machineId;
                subscriber.licenseValidity = packageData.validityNumber;
                subscriber.licenseExpiry = moment().add(+packageData.validityNumber, 'd');
                subscriber.packages = packageData._id;
                subscriber.status = "active";
                subscriber.subscriberType = subscriberType;
                subscriber.parentSubscriberId = orgData.subscriberId;
                if(subscriber.features && packageData.features){
                    subscriber.features.push(packageData.features);
                }
                for (let sub = 0, len = packageData.documentTypeList.length; sub < len; sub++) {
                    let D = new Date();
                    if (packageData.documentTypeList[sub]['documentTypeExpiry'] && typeof packageData.documentTypeList[sub]['documentTypeExpiry'] == 'number' && packageData.documentTypeList[sub]['documentTypeExpiry'] >= 0) {
                        packageData.documentTypeList[sub]['documentTypeExpiry'] = D.addDays(packageData.documentTypeList[sub]['documentTypeExpiry'])
                    }
                    if (packageData.documentTypeList[sub]['storageExpiry'] && typeof packageData.documentTypeList[sub]['storageExpiry'] == 'number' && packageData.documentTypeList[sub]['storageExpiry'] >= 0) {
                        packageData.documentTypeList[sub]['storageExpiry'] = D.addDays(packageData.documentTypeList[sub]['storageExpiry'])
                    }
                }
                for (let index = 0; index < packages.length; index++) {
                    let element =JSON.parse(JSON.stringify(packages[index]));
                    for (let sub = 0, len = element.documentTypeList.length; sub < len; sub++) {
                        let D = new Date();
                        if (element.documentTypeList[sub]['documentTypeExpiry'] && typeof element.documentTypeList[sub]['documentTypeExpiry'] == 'number' && element.documentTypeList[sub]['documentTypeExpiry'] >= 0) {
                            element.documentTypeList[sub]['documentTypeExpiry'] = D.addDays(element.documentTypeList[sub]['documentTypeExpiry'])
                        }
                        if (element.documentTypeList[sub]['storageExpiry'] && typeof element.documentTypeList[sub]['storageExpiry'] == 'number' && element.documentTypeList[sub]['storageExpiry'] >= 0) {
                            element.documentTypeList[sub]['storageExpiry'] = D.addDays(element.documentTypeList[sub]['storageExpiry'])
                        }
                    }
                    if(packageData.documentTypeList){
                        packageData.documentTypeList = packageData.documentTypeList.concat(element.documentTypeList);
                    }
                    subscriber.packages.push(element._id);
                    if(subscriber.features && element.features){
                        subscriber.features.push(element.features);
                    }
                }

                subscriber.documentTypeList = packageData.documentTypeList ? packageData.documentTypeList : [];



                if (!util_1.isNullOrUndefined(userData.offline) && userData.offline != '' && userData.offline == true) {
                    const packageInfo = JSON.parse(JSON.stringify(packageData));
                    const license = this.websiteHelper.createLicense(userData, packageInfo);
                    subscriber.licenseKey = license;
                    subscriber.licenseValidity = packageInfo.validityNumber;
                    subscriber.licenseExpiry = moment().add(+packageInfo.validityNumber, 'd');
                }
                const savedInfo = yield subscriber.save();
                return savedInfo;
            }
            catch (e) {
                return e;
            }
        });
    }
    addOrganization(userData, subscriber, orgData) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let organizationData = new organisation();
                organizationData['subscriberId'] = subscriber._id;
                organizationData['name'] = userData.regType &&  userData.regType =="Individual" ? userData.name  : ' ';
                organizationData['owner'] = userData.name;
                organizationData['email'] = userData.email;
                organizationData['mobile'] = userData.mobile;
                organizationData['primaryAddress']['countryName'] = userData.locationPreference.country;
                organizationData['isActive'] = false;
                organizationData['configuration']['extRegAllow'] = orgData.configuration.extRegAllow;
                organizationData['configuration']['urlRequired'] = orgData.configuration.urlRequired;
                organizationData['locationPreference'] = userData.locationPreference;
                if (!util_1.isNullOrUndefined(orgData.configuration) && orgData.configuration.urlRequired) {
                    organizationData['websiteUrl'] = orgData.websiteUrl;
                }
                organizationData['websiteType'] = orgData.websiteType;
                organizationData['logoURL'] = orgData.logoURL;
                organizationData['labelFile'] = orgData.labelFile;
                organizationData['loginBackground'] = orgData.loginBackground;
                organizationData['utilityReminder'] = userData.regType &&  userData.regType =="Individual" ? true: false ;
                const orgInfo = yield organizationData.save();
                return orgInfo;
            }
            catch (e) {
                return e;
            }
        });
    }
    addUser(userInfo, subscriber, orgData) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let userData = new user(userInfo);
                let userType = userInfo.type == accountsetup.agent ? 'admin-ca' : 'admin-sme';
                userData.userType = userType;
                //userData.type = userInfo.type;
                userData.type = "taxpayer";
                userData.regType = userInfo.regType;
                userData.address = {
                    stateCode: "",
                    area: "",
                    pinCode: 0,
                    city: "",
                    state: null,
                };
                userData.Emailverification = false;
                userData.personalInfo = userInfo;
                userData.personalInfo.password = bycrypt.hashSync(userInfo.pwd);
                // userData.recentPwds = [userData.personalInfo.password];
                // userData.pwdExpiresOn = Date.now() + config.pwdExpiryTime; 
                //userData.isActive = false;
                //if isActive is true then only the user would be able to login
                userData.isActive = false; //set false => this will be active after the OTP verification
                userData.subscriberId = subscriber._id;
                userData.organisation = orgData._id;
                let packages = [];
                let permissionsList = [];
                let permissions = [];
                packages.push(userData._id);
                _.each(userData.additionalParametersValues, function (list) {
                    _.each(list.permissions, function (permission) {
                        if (permission.isChecked == true)
                            permissionsList.push(permission);
                    });
                });
                permissions = _.chain(permissionsList).groupBy('permissionName').map(function (value, key) {
                    return key;
                }).value();
                userData.permission = permissions;
                const savedInfo = yield userData.save();
                return savedInfo;
            }
            catch (e) {
                return e;
            }
        });
    }
    savePaymentDetails(transationInfo, userData, subscriber) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let transactionData = new transaction(transationInfo);
                transactionData.description = "cash payment";
                transactionData.paymentStatus = transationInfo.paymentStatus;
                transactionData.packageId = transationInfo.productId;
                transactionData.paymentId = transationInfo.paymentId;
                transactionData.userId = userData._id;
                transactionData.paymentMode = "online";
                transactionData.subscriberId = subscriber._id;
                const savedData = yield transactionData.save();
                return savedData;
            }
            catch (e) {
                return e;
            }
        });
    }
    addUploadInvErrorCodes(subscriberId, parentSubscrberId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const errorCodeList = yield errWarn_1.ErrWarnMaster.find({ isDeleted: false, subscriberId: parentSubscrberId }, { _id: 0, applicable: 1, field: 1, description: 1, priority: 1, category: 1, code: 1, isDeleted: 1 });
                let list = JSON.parse(JSON.stringify(errorCodeList));
                list.forEach(function (obj) { obj.subscriberId = subscriberId; });
                const savedInfo = yield errWarn_1.ErrWarnMaster.insertMany(list);
                return savedInfo;
            }
            catch (e) {
                return e;
            }
        });
    }
    getOrgConfiguration(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const url = req.body.websiteUrl;
                const configuration = {};
                console.log("inside");
                const orgData = yield organisation.findOne({ websiteUrl: url }).select({ subscriberId: 1, logoURL: 1, websiteType: 1, labelFile: 1, configuration: 1,winUrl: 1,offlineUrl: 1,macUrl: 1,linuxUrl: 1,applicationName: 1, _id: 1 });
                if (orgData) {
                    const subscriberInfo = yield subscriber.findOne({ _id: orgData.subscriberId }).select({ businessType: 1 });
                    if (util_2.isNullOrUndefined(subscriberInfo) && util_2.isNullOrUndefined(subscriberInfo.businessType)) {
                        throw 'err';
                    }
                    configuration['subscriberId'] = orgData.subscriberId;
                    configuration['orgId'] = orgData._id;
                    configuration['logoURL'] = orgData.logoURL;
                    configuration['websiteType'] = orgData.websiteType;
                    configuration['labelFile'] = orgData.labelFile;
                    configuration['businessType'] = subscriberInfo.businessType;
                    configuration['loginBackground'] = orgData.loginBackground;
                    configuration['setupDownloadUrl'] = {
                        winUrl:orgData.winUrl,
                        offlineUrl:orgData.offlineUrl,
                        macUrl:orgData.macUrl,
                        linuxUrl:orgData.linuxUrl,
                        applicationName:orgData.applicationName,
                    }
                    if (!util_2.isNullOrUndefined(orgData.configuration)) {

                        console.log("inside prg configuration")
                        configuration['urlRequired'] = orgData.configuration.urlRequired;
                        configuration['extRegAllow'] = orgData.configuration.extRegAllow;
                        configuration['mobileNoPattern'] = orgData.configuration.mobileNoPattern;
                        configuration['iconURL'] = orgData.configuration.iconURL;
                        configuration['isRpaAllow'] = orgData.configuration.isRpaAllow;
                        configuration['conditionalTermsUrl'] = orgData.configuration.conditionalTermsUrl;
                        configuration['loginImageUrl'] = orgData.configuration.loginImageUrl;
                        configuration['loginBtnText'] = orgData.configuration.loginBtnText;//loginBtnText
                        configuration['loginBtnColor'] = orgData.configuration.loginBtnColor;//loginBtnColor
                        configuration['showSideImage'] = orgData.configuration.showSideImage;
                        configuration['cardHeaderContent'] = orgData.configuration.cardHeaderContent;
                        configuration['userName'] = orgData.configuration.userName;
                        configuration['passWord'] = orgData.configuration.passWord;
                        configuration['cardFooterArray'] = orgData.configuration.cardFooterArray;
                        configuration['footerContent'] = orgData.configuration.footerContent;
                        configuration['privacy'] = orgData.configuration.privacy;
                        configuration['privacyhref'] = orgData.configuration.privacyhref;
                        configuration['fetchUser'] = orgData.configuration.fetchUser;
                        configuration['fetchPackages'] = orgData.configuration.fetchPackages;
                    }
                    res.send(new response_model_4.getResponse(true, null, configuration));
                }
                else {
                    res.send(new response_model_4.getResponse(false, null, 'Url Not Found'));
                }
            }
            catch (e) {
                res.send(new response_model_4.getResponse(false, null, 'Please try again later'));
            }
        });
    }
    registeruser(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            let license = '';
            let personalInfo = req.body.userData;
            user.findOne({
                "personalInfo.mobile": personalInfo.mobile,
                "userType": { $in: ["admin-sme", "admin-ca"] }
            }, function (err, data) {
                if (err) {
                    res.send(new response_model_4.getResponse(false, null, 'Please try again later'));
                }
                else {
                    if (data) {
                        res.send(new response_model_4.getResponse(false, null, 'User already exist please login to continue'));
                    }
                    else {
                        let packageName = !util_2.isNullOrUndefined(req.body.userData) && !util_2.isNullOrUndefined(req.body.userData.selectpkg) ? req.body.userData.selectpkg : "";
                        //personalInfo.type == accountsetup.agent ? accountsetup.agentPackage : accountsetup.taxPayerPackage;
                        let subscriberType = personalInfo.type == accountsetup.agent ? 'ca' : 'business';
                        products.findOne({ productName: packageName }, function (err, pakageData) {
                            if (err)
                                res.send(new response_model_4.getResponse(false, err, []));
                            else {
                                if (pakageData) {
                                    req.body.productId = pakageData._id;
                                    let subscriber = new Subscriber(personalInfo);
                                    subscriber.packages = req.body.productId;
                                    subscriber.status = "active";
                                    subscriber.subscriberType = subscriberType;
                                    //console.log(personalInfo.utilityType);
                                    if (!util_2.isNullOrUndefined(personalInfo.offline) && personalInfo.offline != '' && personalInfo.offline == true) {
                                        const packageData = JSON.parse(JSON.stringify(pakageData));
                                        license = self.websiteHelper.createLicense(req.body.userData, packageData);
                                        subscriber.licenseKey = license;
                                        subscriber.licenseValidity = packageData.validityNumber;
                                        subscriber.licenseExpiry = moment().add(+packageData.validityNumber, 'd');
                                    }
                                    subscriber.save((err) => {
                                        if (err) {
                                            if (err.name === 'MongoError' && err.code === 11000) {
                                                res.send(new response_model_6.duplicateResponse(false, null, err));
                                            }
                                        }
                                        else {
                                            let subscriberId = subscriber._id;
                                            let userData = new user(req.body.userData);
                                            let packageType = personalInfo.type == accountsetup.agent ? 'admin-ca' : 'admin-sme';
                                            userData.userType = packageType;
                                            userData.type = personalInfo.type;
                                            userData.address = {
                                                stateCode: "",
                                                area: "",
                                                pinCode: 0,
                                                city: "",
                                                state: null,
                                            };
                                            userData.personalInfo = personalInfo;
                                            userData.personalInfo.password = bycrypt.hashSync(personalInfo.pwd);
                                            userData.isActive = false;
                                            userData.subscriberId = subscriber._id;
                                            let packages = [];
                                            let permissionsList = [];
                                            let permissions = [];
                                            packages.push(pakageData._id);
                                            _.each(pakageData.additionalParametersValues, function (list) {
                                                _.each(list.permissions, function (permission) {
                                                    if (permission.isChecked == true)
                                                        permissionsList.push(permission);
                                                });
                                            });
                                            permissions = _.chain(permissionsList).groupBy('permissionName').map(function (value, key) {
                                                return key;
                                            }).value();
                                            userData.permission = permissions;
                                            userData.save((err) => {
                                                if (err) {
                                                    res.send(new response_model_5.postResponse(false, null, err));
                                                }
                                                else {
                                                    let transactionData = new transaction(req.body);
                                                    transactionData.description = "cash payment";
                                                    transactionData.paymentStatus = req.body.paymentStatus;
                                                    transactionData.packageId = req.body.productId;
                                                    transactionData.paymentId = req.body.paymentId;
                                                    transactionData.userId = userData._id;
                                                    transactionData.paymentMode = "online";
                                                    transactionData.subscriberId = subscriber._id;
                                                    transactionData.save((err) => {
                                                        if (err) {
                                                            res.send(new response_model_5.postResponse(false, null, err));
                                                        }
                                                        else {
                                                            self.sendRegisterEmail(userData, license, function (status, emailResponse) {
                                                                if (status) {
                                                                    res.send(new response_model_5.postResponse(true, null, userData));
                                                                }
                                                                else {
                                                                    res.send(new response_model_5.postResponse(false, null, 'Please try again later'));
                                                                }
                                                            });
                                                        }
                                                    });
                                                }
                                            });
                                        }
                                    });
                                }
                                else {
                                    res.send(new response_model_5.postResponse(false, null, 'Please try again later'));
                                }
                            }
                        });
                    }
                }
            });
        });
    }
    sendRegisterEmail(userData, license, parentUrl, emailCb) {
        let uid = require('rand-token').uid;
        let token = uid(16);
        let userRec = {
            userName: userData.personalInfo.name,
        };
        let activationLink = config.activationLink;
        let activationEmailBody = this.createRegistrationTemplateForMSME(userRec, activationLink);
        // let referralCode = "msme42"+member.slice(-4);
        // activationLink=activationLink+"?referralCode="+referralCode;
        let emailContent = {
            from: accountsetup.from,
            to: userData.personalInfo.email,
            cc: accountsetup.cc,
            subject: accountsetup.subject,
            message: activationEmailBody,
            status: '',
            name: userData.personalInfo.name,
            phone: userData.personalInfo.mobile,
            userId: userData._id,
            messageType: 'Register',
            isExpired: false,
            token: token
        };
        let mailOptions = {
            from: emailContent.from,
            to: emailContent.to,
            cc: emailContent.cc,
            subject: emailContent.subject,
            html: emailContent.message,
            text: emailContent.message
        };
        var transporter = nodemailer.createTransport(accountsetup.createTransportObjectForRegister);
        // console.log(emailContent);
        // console.log(transporter);
        // console.log(mailOptions);
        transporter.sendMail(mailOptions, function (error, response) {
            let rec = emailContent;
            rec.subject = mailOptions.subject;
            if (error) {
                rec.status = 'failed';
                let webReq = new webRequest(rec);
                webReq.save((err) => {
                    if (err) {
                        emailCb(false, 'Please try again later');
                    }
                    else {
                        emailCb(false, 'Please try again later');
                    }
                });
            }
            else {
                rec.status = 'sent';
                let webReq = new webRequest(rec);
                webReq.save((err) => {
                    if (err) {
                        emailCb(true, response);
                    }
                    else {
                        emailCb(true, response);
                    }
                });
            }
        });
    }
    activateUser(req, res) {
        let self = this;
        webRequest.findOne({ token: req.body.token, isExpired: false }).exec(function (err, reqData) {
            if (!err) {
                if (reqData) {
                    user.findOne({
                        "_id": reqData.userId
                    }, function (err, userData) {
                        if (err) {
                            res.send(new response_model_4.getResponse(false, null, 'Please try again later'));
                        }
                        else {
                            if (userData) {
                                userData.isActive = true;
                                userData.save((err) => {
                                    if (err) {
                                        res.send(new response_model_4.getResponse(false, null, 'Please try again later'));
                                    }
                                    else {
                                        reqData.isExpired = true;
                                        reqData.save((err) => {
                                            if (err) {
                                                res.send(new response_model_4.getResponse(false, null, 'Please try again later'));
                                            }
                                            else {
                                                self.sendActivationEmailContent(userData, function (status, emailResponse) {
                                                    if (status) {
                                                        res.send(new response_model_5.postResponse(true, null, userData));
                                                    }
                                                    else {
                                                        res.send(new response_model_5.postResponse(false, null, 'Please try again later'));
                                                    }
                                                });
                                            }
                                        });
                                    }
                                });
                            }
                            else {
                                res.send(new response_model_4.getResponse(false, null, 'Please try again later'));
                            }
                        }
                    });
                }
                else {
                    res.send(new response_model_5.postResponse(false, null, 'Token has expired'));
                }
            }
            else {
                res.send(new response_model_5.postResponse(false, err, 'Please try again later'));
            }
        });
    }
    deactivateUser(req, res) {
        let self = this;
        if (!req.params.id || req.params.id == "") {
            res.send(new getResponse(false, null, []));
        }
        else {
            console.log("Deactivating the user --", req.params.id)
            user.findByIdAndUpdate(req.params.id, { isActive: false }, function (err, model) {
                if (err) {
                    res.send({ status: false, mssg: err });
                }
                else {
                    res.send({ status: true, mssg: "Deactivated login" });
                }
            });

        }
    }

    getUserDetails(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            try {
                logger.info('Inside getUserDetails');
                if (!req.params.mobileNo || req.params.mobileNo == "") {
                    res.send(new response_model_4.getResponse(false, null, null));
                }
                else {
                    console.log("user --", req.params.id)
                let userData= yield user.findOne({"personalInfo.mobile":req.params.mobileNo});
                let subscriberData=yield subscriber.findOne({_id:ObjectId(userData.subscriberId)});
                let organisationData=yield organisation.findOne({_id:ObjectId(userData.organisation)});
                // let packageData=yield product.findOne({_id:ObjectId(subscriberData.packages[0])});

                const packageIds = subscriberData.packages.map(id => ObjectId(id));
                let packageData = yield product.find({ _id: { $in: packageIds } });


                let userDetails={
                    userData:userData,
                    subscriberData:subscriberData,
                    organisationData:organisationData,
                    packageData:packageData
                }
                res.send(new response_model_5.postResponse(true, null, userDetails));

                }
                ///////////////////////////////////////////////////////
            }
            catch (err) {
                logger.error('Inside catch---- ' + err);
                res.send(new response_model_4.getResponse(false, err, null));
            }
        });
    }
    getUserData(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            try {
                logger.info('Inside getUserData');
                if (!req.body.mobile || req.body.mobile == "") {
                    res.send(new response_model_4.getResponse(false, null, null));
                }
                else {
                    // const response = yield axios.get(`http://localhost:3000/adhigam-api/website/getUserDetail/${req.body.mobile}`);
                    console.log("before call",config.getUserServerUrl)
                    const response = yield axios.get(`${config.getUserServerUrl}/adhigam-api/website/getUserDetail/${req.body.mobile}`);
                    console.log("after call",response)

                    // console.log(response.data);
                    if(response.data.status){


                        response.data.data.userData['_id'] = ObjectId(response.data.data.userData['_id']);
                        response.data.data.subscriberData['_id'] = ObjectId(response.data.data.subscriberData['_id']);
                        response.data.data.organisationData['_id'] = ObjectId(response.data.data.organisationData['_id']);
                        // response.data.data.packageData['_id'] = ObjectId(response.data.data.packageData['_id']);
                        if (Array.isArray(response.data.data.packageData)) {
                            response.data.data.packageData = response.data.data.packageData.map(pkg => {
                                pkg['_id'] = ObjectId(pkg['_id']);
                                return pkg;
                            });
                        }

                        const newUser=new user(response.data.data.userData);
                        const newSubcriber=new subscriber(response.data.data.subscriberData);
                        const newOrganisation=new organisation(response.data.data.organisationData);
                        // const newProduct=new product(response.data.data.packageData);
                        
                        const existingUser = yield user.findById(newUser._id);
    
                        if (!existingUser) {
                            yield newUser.save();
                        }
                        const existingSubscriber = yield subscriber.findById(newSubcriber._id);
    
                        if (!existingSubscriber) {
                            yield newSubcriber.save();
                        }
                        const existingOrganisation = yield organisation.findById(newOrganisation._id);
    
                        if (!existingOrganisation) {
                            if(req.body.ipAddress && req.body.ipAddress!=""){
                                newOrganisation['websiteUrl']=req.body.ipAddress;
                            }
                            yield newOrganisation.save();
                        }
                        
                        for (const pkg of response.data.data.packageData) {
                            const newProduct = new product(pkg);

                            const existingProduct = yield product.findById(newProduct._id);
    
                            if (!existingProduct) {
                                yield newProduct.save();
                            }
                        }
                        yield organisation.updateOne(
                            { _id: ObjectId(response.data.data.organisationData['_id']) },
                            { $set: {"configuration.fetchUser":false,"configuration.fetchPackages":true} } // Set the fields to be updated
                        );
                        if(req.body.orgId!=""){

                            console.log('updating org------------------------------------->')
                            yield organisation.updateOne(
                                { _id: ObjectId(req.body.orgId) },
                                { $set: {"configuration.fetchUser":false} } // Set the fields to be updated
                            );
                        }
                        res.send(new response_model_5.postResponse(true, null, []));

                    }else{
                        res.send(new response_model_4.getResponse(false, null, null));
                    }

                }
                ///////////////////////////////////////////////////////
            }
            catch (err) {
                logger.error('Inside catch---- ' + err);
                res.send(new response_model_4.getResponse(false, err, null));
            }
        });
    }
    getUserPackages(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            try {
                logger.info('Inside getUserPackages');
                if (!req.body.mobile || req.body.mobile == "") {
                    res.send(new response_model_4.getResponse(false, null, null));
                }
                else {
                    // const response = yield axios.get(`http://localhost:3000/adhigam-api/website/getUserDetail/${req.body.mobile}`);
                    const response = yield axios.get(`${config.getUserServerUrl}/adhigam-api/website/getUserDetail/${req.body.mobile}`);
                    // console.log(response.data);
                    if(response.data.status){
                        for (const pkg of response.data.data.packageData) {
                            const packageId = pkg._id; 
                        
                            let result=yield product.updateOne(
                                { _id: ObjectId(packageId) },
                                { $set: pkg } // Set the fields to be updated
                            );
                            // console.log(result);
                        }

                    }

                    let result=yield subscriber.updateOne(
                        { _id: ObjectId(response.data.data.subscriberData._id) },
                        { $set: response.data.data.subscriberData } // Set the fields to be updated
                    );
                    // console.log(result);
                    let userDetails={
                        // packageData:packageData
                    }
                    res.send(new response_model_5.postResponse(true, null, userDetails));
                }
                ///////////////////////////////////////////////////////
            }
            catch (err) {
                logger.error('Inside catch---- ' + err);
                res.send(new response_model_4.getResponse(false, err, null));
            }
        });
    }

    createRegistrationTemplateForMSME(userData, link) {
        let userName = userData['userName'] ? userData['userName'] : ""
        let utilityLink = link ? link : ""
        let mailBody = `
        <p><span style="font-size:12pt;">Hi ${userName},</span></p>
<p><span style="font-size:12pt;">Welcome to the AIQoD 360 based on Gen AI! We&apos;re thrilled to have you on board and excited to help you to ease your work.</span></p>
<p><span style="font-size:12pt;">Step into a world of innovation with us! With Gen AI&apos;s magic touch, we&apos;re reimagining every product to bring you something extraordinary. Keep an eye out for updates that will wow you!</span></p>
<p><span style="font-size:12pt;">If you have any questions or need assistance, please don&apos;t hesitate to contact our support team through&nbsp;</span><a href="mailto:help@aiqod.com"><u><span style="color:#1155cc;font-size:12pt;">help@aiqod.com</span></u></a><span style="font-size:12pt;">&nbsp;or call us on +91 8888500058.</span></p>
<p><span style="font-size:12pt;">Please visit&nbsp;</span><a href="https://www.aiqod360.com" target="_blank" rel="noopener noreferrer"><u><span style="color:#1155cc;font-size:12pt;">https://www.AIQoD360.com</span></u></a><span style="font-size:12pt;">&nbsp;for details on the overall offering. We look forward to being part of your journey and helping you achieve your goals!</span></p>
<p><span style="font-size:12pt;">Sincerely,</span></p>`;

return mailBody;


    }

    createRegistrationTemplate(userData, license) {
        // console.log(license);
        let emailBody = '<html>' +
            '<head>' +
            '<link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">' +
            '<title>Product Activation</title>' +
            '</head>' +
            '<body style="text-align: -webkit-center;">' +
            '<table>' +
            '  <tr>' +
            '    <td> <p style="color: black;">Dear ' + userData.userName + ',</p><p style="color: rgb(255, 255, 255);">Greetings of the Day!</p>' +
            '<p></p>' +
            '<p></p>' +
            '<p> <span style="color: black;"> Welcome to Manage My Vat!! </span></p>' +
            '                    <p><span style="color: black;">Thanks for Signing Up & taking a step towards VAT Compliance.</span></p>' +
            '                    <p><span style="color: black;">If you did not create a ManageMyVAT account using this email address, please contact us at help@managemyvat.com</span></p>';
        if (!util_2.isNullOrUndefined(license) && license != '') {
            emailBody += '                    <p><span style="color: black;" >Your License for Offline Utility is. </span></p>' + license +
                '                    <p><span ><br></span></p>' +
                '                    <p><a style="color: rgb(255, 255, 255); background-color: #0e5dde;padding: 10px" href="' + accountsetup.offlineUtilityDownloadLink + '">CLICK HERE TO DOWNLOAD UTILITY</a></p>';
        }
        emailBody += '                    <p><span ><br></span></p>' +
            '                    <p><a style="color: rgb(255, 255, 255); background-color: #0e5dde;padding: 10px" href="' + userData.activationLink + '">CLICK HERE TO ACTIVATE</a></p>' +
            '                    <p></p><p></p><p><br></p></td>' +
            '    <td> <img src="https://dynamic.gibots.com/assets/img/Rocket1.png" alt="Norway"></td> ' +
            '  </tr>' +
            '  <tr>' +
            '  <td colspan="2"><img src="https://dynamic.gibots.com/assets/img/Ground.png" alt="Norway"></td>' +
            '  </tr>' +
            '  <tr>' +
            '  <td>' +
            '  <p style="margin-left:20px">With Regards,&nbsp;&nbsp;<br>Team Manage My Vat&nbsp;&nbsp;</p></td>' +
            '  <td>' +
            '   <img style="margin-left:71px" src="https://vatdemo.gibots.com/assets/img/managemylogo1.png" style=" ' + "text-align:'center'" + '"></td>' +
            '  </tr>' +
            '</table>' +
            '</body>' +
            '</html>';
        return emailBody;
    }
    sendActivationEmailContent(userData, emailCb) {
        let userRec = {
            userName: userData.personalInfo.name
        };
        let activationEmailBody = this.createActivationEmailTemplate(userRec);
        let emailContent = {
            from: 'No-Reply@aiqod.com',
            to: userData.personalInfo.email,
            subject: 'Successfully Subscribed',
            message: activationEmailBody,
            status: '',
            name: userData.personalInfo.name,
            phone: userData.personalInfo.mobile,
            userId: userData._id,
            messageType: 'Activation',
            isExpired: false,
            token: ''
        };
        let mailOptions = {
            from: emailContent.from,
            to: emailContent.to,
            subject: emailContent.subject,
            html: emailContent.message
        };
        var transporter = nodemailer.createTransport(accountsetup.createTransportObjectForRegister);
        transporter.sendMail(mailOptions, function (error, response) {
            let rec = emailContent;
            rec.subject = mailOptions.subject;
            if (error) {
                rec.status = 'failed';
                let webReq = new webRequest(rec);
                webReq.save((err) => {
                    if (err) {
                        emailCb(false, 'Please try again later');
                    }
                    else {
                        emailCb(false, 'Please try again later');
                    }
                });
            }
            else {
                rec.status = 'sent';
                let webReq = new webRequest(rec);
                webReq.save((err) => {
                    if (err) {
                        emailCb(true, response);
                    }
                    else {
                        emailCb(true, response);
                    }
                });
            }
        });
    }
    createActivationEmailTemplate(userData) {
        let email = '<html>' +
            '<head>' +
            '<link href="https://fonts.googleapis.com/css?family=Raleway" rel="stylesheet">' +
            '<title>Activation</title>' +
            '</head>' +
            '<body style="text-align: -webkit-center;">' +
            '<table>' +
            '  <tr>' +
            '    <td> <p>Hello ' + userData.userName + ',</p>' +
            '<p></p>' +
            '<p></p>' +
            '<p> <span style="color: black;"> Thank you for signing up for ManagemyVAT Compliance Software!! </span></p>' +
            '                    <p><span style="color: black;" >Now that you are a member, you will be able to make your business 100% compliant using our various Compliance Tools like Invoicing, Accounting, Automated VAT Filing & Intuitive Reports. </span></p>' +
            '                    <p><span style="color: black;">Our Team member will reach out to you to help you explore our product with free online demos & training sessions.<br> If you have any questions or concerns you can contact our support centre on <b>+97142627388 , +971503581633</b>.</span></p>' +
            '                    <p><span style="color: black;"><br></span></p>' +
            '                    <p></p><p></p><p><br></p></td>' +
            '    <td> <img src="https://dynamic.gibots.com/assets/img/Rocket1.png" alt="Norway"></td> ' +
            '  </tr>' +
            '  <tr>' +
            '  <td colspan="2"><img src="https://dynamic.gibots.com/assets/img/Ground.png" alt="Norway"></td>' +
            '  </tr>' +
            '  <tr>' +
            '  <td>' +
            '  <p style= "margin-left:20px">With Regards,&nbsp;&nbsp;<br>Team Manage My Vat&nbsp;&nbsp;</p></td>' +
            '  <td>' +
            '   <img style="margin-left:71px" src="https://vatdemo.gibots.com/assets/img/managemylogo1.png" style=" ' + "text-align:'center'" + '"></td>' +
            '  </tr>' +
            '</table>' +
            '</body>' +
            '</html>';
        return email;
    }
    resetUserPasswordOld(req, res) {
        let self = this;
        let mobile = req.body.mobile;
        let type = req.body.type
        async.waterfall([
            async.apply(self.websiteHelper.finduser, mobile),
            async.apply(self.websiteHelper.sendUserMail.bind(self.websiteHelper)),
            async.apply(self.websiteHelper.sendUserMsg.bind(self.websiteHelper), type),
            async.apply(self.websiteHelper.updateUserLoginInfo)
        ], function (err, result) {
            if (err) {
                res.send(new response_model_4.getResponse(false, err, err));
            }
            else {
                res.send(new response_model_4.getResponse(true, null, result));
            }
        });
    }

    resetUserPassword(req,res){
        let body = req.body;
        this.websiteHelper.resetUserPassword(body, function (status,message) {
            res.send({ "status": status, info: message });
        });
    }

    sendEmail(mailOptions, callback) {
        //console.log(mailOptions);
        config = config.emailConfig;
                //this.log.info("configuartion string==" + config);
        var transporter = nodemailer.createTransport(config);
        // var transporter = nodemailer.createTransport({
        //     service: 'gmail',
        //     auth: {
        //         "user": "No-Reply@aiqod.com",
        //         "pass": ""
        //     }
        // });
        transporter.sendMail(mailOptions, function (error, response) {
            if (error) {
                callback(error, null);
            }
            else {
                callback(null, response);
            }
        });
    }
    updateUserPassword(req, res) {
        if (req) {
            let body = req.body;
            this.websiteHelper.updateUserPassword(body, function (err, Result) {
                if (err) {
                    res.send(new response_model_2.putResponse(false, err, err));
                }
                else {
                    res.send(new response_model_2.putResponse(true, null, responseMessages.dynamic.passwordSuccess));
                }
            });
        }
        else {
            res.send(new response_model_2.putResponse(false, null, responseMessages.dynamic.dataNotFound));
        }
    }
    sendRequestEmail(req, res) {
        if (req) {
            let body = req.body;
            this.websiteHelper.sendRequestEmail(body, function (err, Result) {
                if (err) {
                    res.send(new response_model_5.postResponse(false, err, err));
                }
                else {
                    res.send(new response_model_5.postResponse(true, null, responseMessages.dynamic.messageSent));
                }
            });
        }
        else {
            res.send(new response_model_5.postResponse(false, null, responseMessages.dynamic.dataNotFound));
        }
    }
    getTaxPayerAccess(req, res) {
        if (!util_2.isNullOrUndefined(req.body)) {
            let body = req.body;
            let self = this;
            async.waterfall([
                async.apply(self.websiteHelper.taxPayerAccess, body),
                async.apply(self.websiteHelper.createToken, body)
            ], function (err, data) {
                if (err) {
                    res.send(new response_model_5.postResponse(false, err, null, responseMessages.inventory.tokenNotFound));
                }
                else {
                    res.send(new response_model_5.postResponse(true, null, data, responseMessages.inventory.tokenFound));
                }
            });
        }
        else {
            res.send(new response_model_5.postResponse(false, responseMessages.inventory.dataNotFound, null, responseMessages.inventory.dataNotFound));
        }
    }
    terminalCoomand(cmd) {
        return __awaiter(this, void 0, void 0, function* () {
            var exec = require('child_process').exec;
            var child;
            child = exec(cmd, function (error, stdout, stderr) {
                console.log('stdout: ' + stdout);
                console.log('stderr: ' + stderr);
                if (error !== null) {
                    console.log('exec error: ' + error);
                }
            });
            console.log("-------------IN-terminal");
            return child;
            //	let temp={}
            //        yield  execSync(cmd);
            //    console.log("-----------------before---returnnnn",temp)
            //    return temp;
        });
        /*
                return __awaiter(this, void 0, void 0, function* () {
                  return yield new Promise(function (resolve, reject) {
                   console.log("-----------------------------------terminal cmdd up---------------")
                   /*  exec (cmd, function(err,stdout){

                            if(err){
                                console.log("----------------IN errrr promiss")
                            }else{
                                console.log("------------IN stdOut")
                            }
                        })



                        exec(cmd, (err, stdout, stderr) => {

                          console.log("-----------errrrrTER",err);
                          console.log("---------stdOut",stdout);
                         console.log("---------stdErrrr",stderr);

                            if (err) {
                             console.log("----------------------------------opopopoperr---------------")
                             resolve({ status: 1, err: err });
                           }
                            if (stderr !== '') {
                                 console.log("-----------------------------------errrr---------------")
                                resolve({ status: 1, err: stderr });
                            }
                            else {
                                resolve({ status: 0, output: stdout });
                               console.log("-----------------------------------terminal cmdd---------------")
                            }
                        });
                    });
                });
        */
    }
    terminalCoomandOfline(cmd) {
        console.log("in terminal");
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(function (resolve, reject) {
                exec(cmd, (err, stdout, stderr) => {
                    //          console.log("intttternminal --stdout----",JSON.stringify(stdout));
                    resolve({ status: 0, output: stdout });
                    /*
                                        if (err) {
                                            resolve({ status: 1, err: err });


                                        }
                                        if (stderr !== '') {
                                            console.log("sttrrd errr--- ",stderr);

                                            resolve({ status: 1, err: stderr });


                                        }
                                        else {
                                            resolve({ status: 0, output: stdout });
                                        }

                    */
                });
            });
        });
    }
    fileUplodeOnserver(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            try {
                res.send({ status: 0 });
                logger.info('Inside findUplode');
                let body = req.body;
                // console.log("---------------body---", JSON.stringify(body));
                let folderPath = body.input.folderPath;
                let renameFile1 = body.input.renameFile;
                //    if (!util_2.isNullOrUndefined(req.body.renameFile)) {
                //  personalInfo = req.body;
                //  }
                let renameFile = '#' + renameFile1;
                console.log("folderpath----", folderPath);
                console.log("renameFile----", renameFile);
                let cmd = 'node /var/node-server/cuda-testing-backend/share/uploader/fileuplodeOnserver.js ' + folderPath + renameFile;
                console.log("cmd CMND------", cmd);
                // let cmd='node /var/node-server/cuda-testing-backend/share/uploader/fileuplodeOnserver.js ' + folderPath;
                // let temp = yield execSync(cmd);
                let tmp = yield self.terminalCoomand(cmd);
                console.log("dataa-----------------------------------", JSON.stringify(body));
                let outputData = { "uplodeStatus": true, 'statusCode': '200' };
                let taskData = { 'projectId': body['projectId'], 'botId': body['botId'], 'eventId': body.input['eventId'], iterationId: body['iterationId'], 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'authorization': body['token'], 'content-type': "application/json", "selectedorgid": body['selectedorgid'] };
                //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
                // console.log(JSON.stringify(headers), " ======>>>>>>>----------->>>>>>>> ", JSON.stringify(taskData));
                var options = {
                    method: 'POST',
                    url: pdfServerUrl + "/gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     console.log("--------------err in res", error);
                //     //  console.log("body---responce",body);
                //     // console.log("---res",response);
                // });
                ///////////////////////////////////////////////////////
                // let self=this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
            }
            catch (err) {
                logger.error('Inside catch---- ' + err);
            }
        });
    }
    /*

      convertPdfToImage(req, res) {



            return __awaiter(this, void 0, void 0, function* () {
                let self = this;

                try {

                    let imagesPathaaray;
                    let body = req.body;
                    let eventId= body.input.eventId;
            let docType = body.input.docType;
            let fileRefNum = body.input.fileRefNum;
                    let projectId=body.projectId;
                    let botId = body.botId;
                    let token = body.token;
                    let iterationId = body.iterationId;
            let isOcr = !util_1.isNullOrUndefined(body.input.isOcr) && body.input.isOcr !== "" ? body.input.isOcr : false;
                   let  filePath = body.input.filePath;
                    console.log("---------------body of convertpdftopng",JSON.stringify(body));
            let imgPaths = [];

                    //let filePath = !util_1.isNullOrUndefined(body) && !util_1.isNullOrUndefined(body.input.filePath) ? body.filePath : '';

                    console.log("filepath---",filePath);

                    if (filePath !== '') {
                        let ext = path.extname(filePath);
                        let base = path.basename(filePath);
                        let extension = !util_1.isNullOrUndefined(ext) ? ext : '';
                        if (extension !== '' && base !== '') {
                        //    if (extension.toLowerCase() === '.pdf') {
                             if (extension.toLowerCase() === '.pdf' || extension.toLowerCase() === '.tif') {

                                let name = base.split('.');
                                // let path ="/home/user/Desktop/output/";
                                let path = config.path;

                                // 'convert -density 180 -alpha off -verbose ' + filePath + ' ' + path + name[0] + '.png'
                               // exec('convert -density 180 -alpha off -verbose ' + filePath + ' ' + path + name[0] + '.png', function (err, data, ssd) {
                         //           exec('convert -density 180 ' + filePath + ' -alpha off -verbose ' + path + name[0] + '.png', function (err, data, ssd) {

                       // exec('convert -units PixelsPerInch -density 300  ' + filePath + ' -compress jpeg -verbose ' + path + name[0] + '.png', function (err, data, ssd) {
                        exec('convert  -density 300 -background white -alpha remove ' + filePath + ' -verbose ' + path + name[0] + '.png', function (err, data, ssd) {
                                    if (err) {
                                        throw err;
                                    }



                           else {
                                        if (ssd !== '') {
                                      console.log("SSD DATATATATTATASJNDNAJNDJANSD"+ssd)
                                            ssd = ssd.split('\n');
                                            console.log("NEW ===============>>>>>>>.>>>>SSD===" + ssd);
                                            //ssd.shift();
                                            ssd.pop();
                                            console.log("SSD-------afterrrr===========>>>>>>>>>>>>>>>>>" + ssd);
                                        }
                                        let imagesPath = [];
                                        let counter = 0;
                                        console.log("SSDDDDDDDDD LENGHT AJIANKAIUAIA"+ssd.length);

                                        if (ssd.length <= 1) {
                                            imagesPath.push({ imageFilePath: path + name[0] + ".png" });
                                           console.log("ssd.lengthIMAGEPATH<=1======",imagesPath)
                                        }
                                        else {
                                            ssd.forEach((list) => {

                                                if (list.trim() !== '') {
                                                    let imgpath=path + name[0] + '-' + counter + '.png';
                                                    imagesPath.push({ imageFilePath: path + name[0] + '-' + counter + '.png' });

                                                    counter++;
                                                }
                                            });
                                        }

                                        // let  file = fs.readFileSync(imagesPath);
                                     let tmp=[];
                                     let temp=[];

                                        for (let index = 0; index < imagesPath.length; index++) {
                                            const element = imagesPath[index];

                                            if (fs.existsSync(element.imageFilePath)) {
                                                //file exists
                                                console.log('file existsfirsttttt!!!');
                                                temp.push(element)

                                              }else{

                                                console.log('file not exists!!!!!!!!!!!');

                                                tmp.push(element)
                                                // console.log(str.slice(0, -1));

                                                //  imagesPath.splice(0, -1); //
                                                // delete imagesPath[index].imageFilePath;



                                              }         // console.log('pathpppp)


                                        }

                                        console.log("tmppp",tmp.length);

                                    if(tmp.length != 0){

                                        imagesPath=temp

                                    }else{
                                        console.log("--------------file found successfullyyyy");

                                    }
                    imgPaths = imagesPath;
                                    imagesPathaaray = imagesPath;
                                    let outputData = { "imagesPathaaray":imagesPathaaray,"uplodeStatus": true, 'statusCode': '200' };
                                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId,'iterationId':iterationId, 'status': 'Complete', 'outputParameters': outputData }
                                    let headers = { 'authorization': token, 'content-type': "application/json" };

                                  //  let headers = { 'authorization': body['token'], 'content-type': "application/json", "selectedorgid": body['selectedorgid'] };
                                    //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
                                        console.log(JSON.stringify(headers)," ======>>>>>>>----------->>>>>>>> ", JSON.stringify(taskData));
                                    var options = {
                                        method: 'POST',
                                        url: "http://ocri.gibots.com:1443/gibots-orch/orchestrator/botsiowrite",
                                        headers: headers,
                                        body: taskData,
                                        json: true
                                    };
                                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                                    request(options, function (error, response, body) {
                                               // console.log("--------------err in res",error);

                                                //console.log("body---responce",body);
                                                //console.log("---res",response);
                                    });





                                          //    });
                                    // callback(null, fileData);
                                    }



                                });
                            }
                            else {
                                let imagesPath = [];
                                imagesPath.push({ imageFilePath: filePath });
                                // fileData['imagesPath'] = imagesPath;
                                imagesPathaaray = imagesPath;
                    imgPaths = imagesPath;
                                let outputData = { "output":imagesPathaaray,"uplodeStatus": true, 'statusCode': '200' };
                                let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId,'iterationId':iterationId, 'status': 'Complete', 'outputParameters': outputData }
                                let headers = { 'authorization': token, 'content-type': "application/json" };

                              //  let headers = { 'authorization': body['token'], 'content-type': "application/json", "selectedorgid": body['selectedorgid'] };
                                //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
                                   // console.log(JSON.stringify(headers)," ======>>>>>>>----------->>>>>>>> ", JSON.stringify(taskData));
                                var options = {
                                    method: 'POST',
                                    url: "http://ocri.gibots.com:1443/gibots-orch/orchestrator/botsiowrite",
                                    headers: headers,
                                    body: taskData,
                                    json: true
                                };
                                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                                request(options, function (error, response, body) {
                                           // console.log("--------------err in res",error);

                                            //console.log("body---responce",body);
                                            //console.log("---res",response);
                                });


                                      //    });
                                // callback(null, fileData);
                            }


            //Krishna Code ------>>>>>>>
                    if(isOcr){
                         const MongoClient = require('mongodb').MongoClient;
                         let mClient = yield MongoClient.connect(config.mongoConnection);
                         let dbName = config.mongoConnection.split('/');
                         let db = yield mClient.db(dbName[dbName.length - 1]);
                    if(util_1.isNullOrUndefined(imgPaths) && imgPaths.length > 0 && typeof imgPaths !== "string"){
                       // imgPaths.forEach((row,i)=>{
                for(let i = 0 ; i < imgPaths.length ; i++){
                            let update = {filePath : imgPaths[i].imageFilePath};
                            let find = {isOcr : isOcr , documentType : docType , fileRefNum : fileRefNum};
                            let fileUploadHistoryUpdate = yield db.collection('fileuploadhistories').findOneAndUpdate(find,{$set: update},{upsert: true});

                            };
                        }else{
                            let update = {imagesPath : imgPaths};
                            let find = {isOcr : isOcr , documentType : docType , fileRefNum : fileRefNum};
                            let fileUploadHistoryUpdate = yield db.collection('fileuploadhistories').findOneAndUpdate(find,{$set: update},{upsert: true});
                        }

                    }

                                 console.log("imagesPath-------new-",imagesPath);
    // ----- end of Krishna Code ------>>>



                        }
                        else {
                            // logger.error('File Path Not Found');
                            throw 'File Path Not Found';
                        }
                    }
                    else {
                        // logger.error('File Path Not Found');
                        throw 'File Path Not Found';
                    }
                }
                catch (err) {
                    console.log("errrrrrrrrrr",err);

                    // logger.error('Failed for save document training data - ' + err);
                    // callback(null, fileData);
                }
            });
        }



    --kk by sohail
    */
    cropImg(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            try {
                res.send({ status: 0 });
                let imagesPathaaray;
                let body = req.body;
                let eventId = body.input.eventId;
                let projectId = body.projectId;
                let botId = body.botId;
                let token = body.token;
                let iterationId = body.iterationId;
                // console.log("---------------body---", JSON.stringify(body));
                //let  imagesPathaaray = body.input.imagesPathaaray;
                let imagesPathaaray_1 = JSON.parse(body.input.crop_imagesPathaaray);
                imagesPathaaray = imagesPathaaray_1.imagesPathaaray;
                let filePath;
                let newfilePath;
                let objimg = {};
                let tmparry = [];
                logger.info("In convert pdftoimg==============");
                // console.log("---------------body---", JSON.stringify(body));
                // console.log(imagesPathaaray.length);
                for (let i = 0; i < imagesPathaaray.length; i++) {
                    objimg = {};
                    filePath = imagesPathaaray[i].imageFilePath;
                    //let filePath = !util_1.isNullOrUndefined(body) && !util_1.isNullOrUndefined(body.input.filePath) ? body.filePath : '';
                    console.log("filepath---", filePath);
                    //      let command = 'convert '+filePath ' -crop 2210X3508+135+0 /home/gibots/ui_img/Test_Croppednewwww.png'
                    let command = 'identify  -ping -format "%w.%h\\n" ' + filePath;
                    console.log("comandd iss--", command);
                    //      let  pythonOutput = yield exec(command);
                    let SizeofOutput = yield this.terminalCoomandOfline(command);
                    console.log("=================pythhh===newww==rmdirrrr", SizeofOutput.output);
                    SizeofOutput = SizeofOutput.output;
                    SizeofOutput = SizeofOutput.toString().split('.');
                    console.log("----------------bhurr", SizeofOutput);
                    let pageWidth = SizeofOutput[0];
                    let pageHeight = SizeofOutput[1];
                    console.log("pageWidth======", pageWidth);
                    console.log("pageHeight=========", pageHeight);
                    let up_width = pageWidth * 90 / 100;
                    let crp_size = pageWidth * 6 / 100;
                    console.log("updatee====width", Math.round(up_width));
                    console.log("update=====crp_size", Math.round(crp_size));
                    newfilePath = filePath.replace(/.png|.jpg/, '');
                    newfilePath = newfilePath + '_crop_img.png';
                    // console.log(filePath);
                    // console.log(newfilePath);
                    objimg['imageFilePath'] = newfilePath;
                    tmparry.push(objimg);
                    let command_crop = 'convert ' + filePath + ' -crop ' + escape(up_width + 'X' + Number(pageHeight) + '+' + crp_size + '+' + 0) + ' ' + newfilePath;
                    console.log("crop cmd====================", command_crop);
                    let cropimgoutput = yield this.terminalCoomandOfline(command_crop);
                    //  console.log("doneeeeeeeeeeeeeeeeeeeeeeeeeeeeeee==========================");
                }
                //console.log("line==================>>>>");
                //console.log("imagesPath-------new-", tmparry);
                imagesPathaaray = tmparry;
                //console.log("imagesPath-------new-secondddd", imagesPathaaray);
                let outputData = { "imagesPathaaray": imagesPathaaray, "uplodeStatus": true, 'statusCode': '200' };
                // let outputData = { "imagesPathaaray":imagesPathaaray,"uplodeStatus": true, 'statusCode': '200' };
                let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'authorization': token, 'content-type': "application/json" };
                //  let headers = { 'authorization': body['token'], 'content-type': "application/json", "selectedorgid": body['selectedorgid'] };
                //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
                var options = {
                    method: 'POST',
                    url: pdfServerUrl + "/gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                // console.log("options------------", options);
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     console.log("--------------err in res", error);
                //     // console.log("body---responce", body);
                //     //console.log("---res",response);
                // });
                ///////////////////////////////////////////////////////
                // let self=this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
                console.log("finishhhhhhhhhhh===========");
            }
            catch (err) {
                console.log("errrrrrrrrrr", err);
            }
        });
    }
    //started on 5 march 2021
    //start

    extractTableDataloop(data) {


        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            let extractTableDataOutputArray = [];
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                // return new Promise(function (resolve, reject) {
                //     return __awaiter(this, void 0, void 0, function* () {

                for (let ind = 0; ind < data.length; ind++) {
                    let fileData = data[ind];
                    let docFeatures = !util_1.isNullOrUndefined(fileData.docFeatures) && fileData.docFeatures.length > 0 ? fileData.docFeatures : [];
                    let tableBounding = !util_1.isNullOrUndefined(fileData.tblBounding) && fileData.tblBounding.length > 0 ? fileData.tblBounding : [];
                    let lines = !util_1.isNullOrUndefined(fileData.Lines) && fileData.Lines.length > 0 ? fileData.Lines : [];
                    let csvInfoArray = [];
                    csvInfoArray = !util_1.isNullOrUndefined(fileData['csvInfoArray']) ? fileData['csvInfoArray'] : [];
                    let headers1 = config.tableHeaderScanning;
                    csvInfoArray.push({ data: docFeatures, headers: headers1, entity: 'invoice', fileRefNum: fileData.obj.fileRefNum });
                    fileData['csvInfoArray'] = csvInfoArray;
                    let index = 0;
                    console.log("1")
                    async.eachSeries(tableBounding, function (list, cb) {
                        if (!util_1.isNullOrUndefined(list.bbox) && list.bbox.length > 0) {
                            let tble = [];
                            console.log("2")
                            lines.every((line) => {
                                let cnt = 0;
                                console.log("3")
                                line.forEach((row) => {
                                    if (row.topY >= list.bbox[1] && row.bottomY <= list.bbox[3]) {
                                        console.log("4")
                                        cnt++;
                                    }
                                    console.log("5")
                                });
                                console.log("6")
                                if (cnt > 3) {
                                    console.log("7")
                                    tble.push(line);
                                    return false;
                                }
                                else {
                                    console.log("8")
                                    return true;
                                }
                            });
                            console.log("9")
                            fileData['tableData'] = tble;
                            self.extractTableFeatures(fileData, function (err, fileObj) {
                                if (err) {
                                    console.log("10")
                                    reject(err)
                                    // throw err;
                                }
                                else {
                                    console.log("11")
                                    csvInfoArray = !util_1.isNullOrUndefined(fileData['csvInfoArray']) ? fileData['csvInfoArray'] : [];
                                    let headers2 = Object.keys(fileData.tableFeatures[0]);
                                    index++;
                                    csvInfoArray.push({ data: fileData.tableFeatures, headers: headers2, entity: 'table', fileRefNum: fileData.obj.fileRefNum + '-' + index });
                                    fileData['csvInfoArray'] = csvInfoArray;
                                }
                            });
                        }
                        else {
                            console.log("12")
                        }
                    }, function (err, data) {
                        if (err) {
                            console.log("13")
                            throw err;
                        }
                        else {
                            console.log("14")
                            logger.info('Files features generated successfully');
                            extractTableDataOutputArray.push(fileData);

                        }
                        console.log("15")
                    });
                    console.log("16")
                }
                console.log("17 out")
                resolve(extractTableDataOutputArray)
                // });
            }));
        });
    }
    extractFeaturesAugment(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                req.body.input.return ? '' : res.send({ status: 0 });
                let self = this;
                logger.info('Inside of extract invoice features');
                // let complete = false;
                let body = req.body;
                let ruleObjOutputArray = [];
                let token = req.body.token;
                let botId = req.body.botId;
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;
                /*Extract features if invoice*/
                // let tableBorder = {};
                // let top = 0;
                // let bottom = 0;
                let ruleObjInputArray = req.body.input.ruleObj;
                // fs.writeFileSync('/home/user/Music/PDFtest/extractFeatures_input.json', JSON.stringify(ruleObjInputArray));
                if (!util_1.isNullOrUndefined(ruleObjInputArray)) {
                    console.time("extractFeaturesTotalTime")
                    ruleObjOutputArray = yield self.extractFeaturesloopForAugment(ruleObjInputArray)
                    console.timeEnd("extractFeaturesTotalTime")
                    const formatMemoryUsage = (data) => `${Math.round(data / 1024 / 1024 * 100) / 100} MB`
                    const memoryData = process.memoryUsage()

                    const memoryUsage = {
                        rss: `${formatMemoryUsage(memoryData.rss)} -> Resident Set Size - total memory allocated for the process execution`,
                        heapTotal: `${formatMemoryUsage(memoryData.heapTotal)} -> total size of the allocated heap`,
                        heapUsed: `${formatMemoryUsage(memoryData.heapUsed)} -> actual memory used during the execution`,
                        external: `${formatMemoryUsage(memoryData.external)} -> V8 external memory`,
                    }

                    // console.log(memoryUsage)
                    let outputData = { "extractFeatures": ruleObjOutputArray, "uploadStatus": true, 'statusCode': '200' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     //console.log("body---responce",body);
                    //     //console.log("---res",response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    if (req.body.input.return)
                        return outputData;
                    else
                        yield self.ioWrite(options)


                    ///////////////////////////////////////////////////////
                }
                else {
                    logger.error("#extractFeatures==>Internal server Error");
                    let outputData = { "extractFeatures": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = "#extractFeatures==>Internal server Error";
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     // console.log("body---responce", body);
                    //     // console.log("---res", response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;

                    ///////////////////////////////////////////////////////
                    yield self.ioWrite(options)
                }
            }
            catch (e) {
                logger.error("Nothing get featuresssss----------Inside catch", e);
                let outputData = { "extractFeatures": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = e.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
            }
        })
    }


    extractFeaturesloopForAugment(ruleObjInputArray) {

        return __awaiter(this, void 0, void 0, function* () {
            let ruleObjOutputArray = []
            let tableBorder = {};
            let top = 0;
            let bottom = 0;
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let self = this;
                console.log("Total Pages--->", ruleObjInputArray.length)
                let iterationCount = 0;
                for (let index = 0; index < ruleObjInputArray.length; index++) {
                    let ruleObj = ruleObjInputArray[index];
                    let lines = ruleObj.Lines;
                    let pageWidth = ruleObj.pageWidth;
                    let pageHeight = ruleObj.pageHeight;
                    let lineWithCombineWords = [];
                    let lineWordsWithoutTable = [];
                    // for (let i = 0; i < lines.length; i++) {
                    //     lineWithCombineWords.push(this.combineLineWords(lines[i], lines));
                    // }
                    lineWithCombineWords = lines;
                    lineWithCombineWords = self.colonSplitter(lineWithCombineWords);
                    lineWordsWithoutTable = lineWithCombineWords.filter(lineWithCombineWords => {
                        if (lineWithCombineWords.length > 0) {
                            return !(lineWithCombineWords[0].topY >= top && lineWithCombineWords[0].bottomY <= bottom)
                        }
                    })
                    let tmp = 1;
                    for (let i = 0; i < lineWordsWithoutTable.length; i++) {
                        lineWordsWithoutTable[i].forEach(function (list, index) {
                            list['index'] = tmp++;
                        });
                    }
                    let features;
                    // console.log('Documnettypeeeeeee==============BASkya', ruleObj.obj.documentType);
                    if (ruleObj.obj.documentType === 'Clinical') {
                        // console.log('--------------doc_type===========is clincall');
                        features = yield self.extractInvoiceFeatures(ruleObj.lineWithCombineWordsNew, pageWidth, pageHeight, ruleObj.obj.documentType);
                    }
                    else {
                        // console.log('--------------doc_type===========is not clincall');
                        features = yield self.extractInvoiceFeatures(lineWordsWithoutTable, pageWidth, pageHeight, ruleObj.obj.documentType);
                    }
                    let featurestmp = [];
                    console.log("--->", index);
                    let nLength = features.length;
                    for (let i = 0; i < nLength; i++) {
                        let element2 = features[i];
                        let top = false, right = false, bottom = false, left = false;
                        for (let j = 0; j < nLength; j++) {
                            let element = features[j];
                            iterationCount++;
                            if (element2.index == element.TOP_index) {
                                element['TOP_TopMarginRelative'] = element2.TopMarginRelative;
                                element['TOP_LeftMarginRelative'] = element2.LeftMarginRelative;
                                element['TOP_RightMarginRelative'] = element2.RightMarginRelative;
                                element['TOP_BottomMarginRelative'] = element2.BottomMarginRelative;
                                element['TOP_VerticalPositionRelative'] = element2.VerticalPositionRelative;
                                element['TOP_HorizontalPositionRelative'] = element2.HorizontalPositionRelative;
                                element['TOP_linewhitespace'] = element2.linewhitespace;
                                element['TOP_PositionOnLine'] = element2.PositionOnLine;
                                element['TOP_LineSize'] = element2.LineSize;
                                element['TOP_HasDate'] = element2.HasDate;
                                top = true;
                            }
                            if (element2.index == element.BOTTOM_index) {
                                element['BOTTOM_TopMarginRelative'] = element2.TopMarginRelative;
                                element['BOTTOM_LeftMarginRelative'] = element2.LeftMarginRelative;
                                element['BOTTOM_RightMarginRelative'] = element2.RightMarginRelative;
                                element['BOTTOM_BottomMarginRelative'] = element2.BottomMarginRelative;
                                element['BOTTOM_VerticalPositionRelative'] = element2.VerticalPositionRelative;
                                element['BOTTOM_HorizontalPositionRelative'] = element2.HorizontalPositionRelative;
                                element['BOTTOM_linewhitespace'] = element2.linewhitespace;
                                element['BOTTOM_PositionOnLine'] = element2.PositionOnLine;
                                element['BOTTOM_LineSize'] = element2.LineSize;
                                element['BOTTOM_HasDate'] = element2.HasDate;
                                bottom = true;
                            }
                            if (element2.index == element.LEFT_index) {
                                element['LEFT_TopMarginRelative'] = element2.TopMarginRelative;
                                element['LEFT_LeftMarginRelative'] = element2.LeftMarginRelative;
                                element['LEFT_RightMarginRelative'] = element2.RightMarginRelative;
                                element['LEFT_BottomMarginRelative'] = element2.BottomMarginRelative;
                                element['LEFT_VerticalPositionRelative'] = element2.VerticalPositionRelative;
                                element['LEFT_HorizontalPositionRelative'] = element2.HorizontalPositionRelative;
                                element['LEFT_linewhitespace'] = element2.linewhitespace;
                                element['LEFT_PositionOnLine'] = element2.PositionOnLine;
                                element['LEFT_LineSize'] = element2.LineSize;
                                element['LEFT_HasDate'] = element2.HasDate;
                                left = true;
                            }
                            if (element2.index == element.RIGHT_index) {
                                element['RIGHT_TopMarginRelative'] = element2.TopMarginRelative;
                                element['RIGHT_LeftMarginRelative'] = element2.LeftMarginRelative;
                                element['RIGHT_RightMarginRelative'] = element2.RightMarginRelative;
                                element['RIGHT_BottomMarginRelative'] = element2.BottomMarginRelative;
                                element['RIGHT_VerticalPositionRelative'] = element2.VerticalPositionRelative;
                                element['RIGHT_HorizontalPositionRelative'] = element2.HorizontalPositionRelative;
                                element['RIGHT_linewhitespace'] = element2.linewhitespace;
                                element['RIGHT_PositionOnLine'] = element2.PositionOnLine;
                                element['RIGHT_LineSize'] = element2.LineSize;
                                element['RIGHT_HasDate'] = element2.HasDate;
                                right = true;
                            }
                            if (top && bottom && left && right) {
                                // console.log("I index : ",i,"J index : ",j);
                                break;
                            }
                        }
                    }
                    ruleObj['docFeatures'] = features;
                    delete ruleObj['Lines'];
                    delete ruleObj['combineWords'];
                    delete ruleObj['raw'];
                    delete ruleObj['sortedWords'];


                    ruleObjOutputArray.push(ruleObj);
                    // console.timeEnd("ExtractFeatures")
                }
                console.log("Total Iterations---->", iterationCount);
                resolve(ruleObjOutputArray)
            }));
        });
    }

    combineLinesloop(fileArrayData, imageFlow) {
        return __awaiter(this, void 0, void 0, function* () {
            let combileLinesArrayNew = []
            let self = this;
            fileArrayData = JSON.parse(JSON.stringify(fileArrayData));
            console.log(" --- BEFORE SCANFIELD MONGO CALL --- ");
            let scanData = yield scanField.findOne({ isDeleted: false, documentType: fileArrayData[0]["obj"]["documentType"] });

            return yield new Promise(function (resolve, reject) {
                return __awaiter(this, void 0, void 0, function* () {
                    console.log("BEFORE FORLOOP CALL");
                    for (let index = 0; index < fileArrayData.length; index++) {
                        console.log(" --- --- INSIDE FOR FIRST LOOP ---- ", index);
                        let fileData = fileArrayData[index];
                        if (!util_1.isNullOrUndefined(scanData)) {
                            let tempArray = [];
                            fileData.combineWords = fileData.combineWords.filter(a => a.Name)
                            fileData.combineWords.forEach(a=>a['ocrConfidence'] = a['confidence'])
                            for (let i = 0; i < fileData.combineWords.length; i++) {
                                // if (fileData.pageWidth - fileData.combineWords[i].rightX > 5) {
                                tempArray.push(fileData.combineWords[i]);
                                // }
                            }
                            fileData.combineWords = tempArray;
                            let itemData = _.groupBy(fileData.combineWords, 'pageNo');
                            let keys = Object.keys(itemData);
                            let sortedLines = [];
                            let sortedLinesN=[];
                            console.log(" ---- ---- INSIDE FOR SECOND FOR LOOP ----- -- ")
                            for (const lin of keys) {
                                let bags = itemData[lin];
                                if (!imageFlow) {
                                    bags.sort(function (a, b) {
                                        return a["topY"] - b["topY"];
                                    });
                                    self.formLines(bags, sortedLines,sortedLinesN, 0.59)
                                } else {
                                    bags.sort(function (a, b) {
                                        return a["topY"] - b["topY"];
                                    });
                                    self.formLines(bags, sortedLines,sortedLinesN, 0.5)
                                }
                                // bags.sort(function (a, b) {
                                //     return a["topY"] - b["topY"] || a["leftX"] - b["leftX"];
                                // });
                                // let multiline = bags[0]["Name"];
                                // multiline = multiline.match(/\n/g);
                                // if (multiline) {
                                //     bags.splice(0, 1);
                                // }
                                // let topY = bags[0].topY, bottomY = bags[0].bottomY, leftX = bags[0].leftX;
                                // let len = bags.length;
                                // let line = [];
                                // let firstWord = self.findFirstWord(bags, bags[0]);
                                // if (firstWord.length > 0) {
                                //     firstWord = _.sortBy(firstWord, 'leftX');
                                //     firstWord.every(function (item) {
                                //         if (leftX >= item.leftX) {
                                //             line.push(item);
                                //             leftX = item.leftX;
                                //             bottomY = item.bottomY;
                                //             topY = item.topY;
                                //             bags = _.without(bags, _.findWhere(bags, { Name: item.Name, rightX: item.rightX, leftX: item.leftX, topY: item.topY, bottomY: item.bottomY }));
                                //             return false;
                                //         }
                                //         else {
                                //             return true;
                                //         }
                                //     });
                                // }
                                // else {
                                //     line.push(bags[0]);
                                //     bags.splice(0, 1);
                                // }
                                // let lineArray;
                                // let j = 0;
                                // while (bags.length > 0) {
                                //     j++;
                                //     lineArray = self.findNextLines(bags, topY, bottomY, leftX);
                                //     lineArray = _.sortBy(lineArray, 'leftX');
                                //     lineArray.every(function (item) {
                                //         if (leftX <= item.leftX) {
                                //             if (line.length > 0) {
                                //                 line.push(item);
                                //             }
                                //             leftX = item.leftX;
                                //             bottomY = item.bottomY > bottomY ? item.bottomY : bottomY;
                                //             bags = _.without(bags, _.findWhere(bags, { Name: item.Name, rightX: item.rightX, leftX: item.leftX, topY: item.topY, bottomY: item.bottomY }));
                                //             return false;
                                //         }
                                //         else {
                                //             return true;
                                //         }
                                //     });
                                //     if (bags.length == 0) {
                                //         sortedLines.push(line);
                                //     }
                                //     if (lineArray.length === 0) {
                                //         sortedLines.push(line);
                                //         bags.sort(function (a, b) {
                                //             return a["topY"] - b["topY"] || a["leftX"] - b["leftX"];
                                //         });
                                //         topY = bags[0].topY;
                                //         bottomY = bags[0].bottomY;
                                //         leftX = bags[0].leftX;
                                //         len = bags.length;
                                //         line = [];
                                //         let firstWord = self.findFirstWord(bags, bags[0]);
                                //         if (firstWord.length > 0) {
                                //             firstWord = _.sortBy(firstWord, 'leftX');
                                //             firstWord.every(function (item) {
                                //                 if (leftX >= item.leftX) {
                                //                     line.push(item);
                                //                     leftX = item.leftX;
                                //                     bottomY = item.bottomY;
                                //                     topY = item.topY;
                                //                     bags = _.without(bags, _.findWhere(bags, { Name: item.Name, rightX: item.rightX, leftX: item.leftX, topY: item.topY, bottomY: item.bottomY }));
                                //                     return false;
                                //                 }
                                //                 else {
                                //                     return true;
                                //                 }
                                //             });
                                //         }
                                //         else {
                                //             line.push(bags[0]);
                                //             bags.splice(0, 1);
                                //         }
                                //     }
                                // }
                            }
                            console.log(" ---- ---- AFTER FOR SECOND FOR LOOP ----- -- ")
                            logger.info('Lines created successfully');
                            let sortedLinesNew = JSON.parse(JSON.stringify(sortedLines));
                            let sortedLinesNewN = JSON.parse(JSON.stringify(sortedLinesN));
                            let lineWithCombineWords = [];
                            let lineWithCombineWordsNew = [];
                            var tableHeaders = [];
                            var tableHeadersW = [];
                            console.log(" ---- ---- BEFORE FOR THIRD FOR LOOP ----- -- ")
                            for (var k in scanData.tableMapping) {
                                tableHeadersW.push(k);
                                k = k.toLocaleUpperCase();
                                k = k.replace(/\s+/g, '');
                                tableHeaders.push(k);
                            }
                            console.log(" ---- ---- AFTER FOR THIRD FOR LOOP ----- -- ")
                            console.log(" ---- ---- BEFORE FOR FOURTH FOR LOOP ----- -- ")
                            // for (let i = 0; i < sortedLines.length; i++) {
                            //     lineWithCombineWords=sortedLines;
                            //     lineWithCombineWordsNew.push(self.combineTableHeaders(sortedLinesNew[i], tableHeaders));
                            // }
                            lineWithCombineWords = sortedLinesNew;
                            lineWithCombineWordsNew = sortedLinesNewN;

                            console.log(" ---- ---- AFTER FOR FOURTH FOR LOOP ----- -- ")
                            fileData['Lines'] = sortedLines;
                            fileData['lineWithCombineWords'] = lineWithCombineWords;
                            fileData['lineWithCombineWordsNew'] = lineWithCombineWordsNew;
                            delete fileData.combineWords;
                            let csvInfoArray = [];
                            fileData['csvInfoArray'] = csvInfoArray;
                            combileLinesArrayNew.push(fileData);
                        }
                        console.log("END FIRST LOOP ", index)
                    };
                    if (!util_1.isNullOrUndefined(combileLinesArrayNew) && combileLinesArrayNew.length > 0) {
                        resolve(combileLinesArrayNew);
                    }
                });
            });
        });
    }
    formLines(bags, sortedLines,sortedLinesN, threshold) {
        bags = bags.filter(a => !/^(\s|)+$/.test(a.Name) && !a.Name.includes('---'))
        let self=this;
        let reachedLast=false;
        for (let i = 0; i < bags.length; i++) {
            if (bags[i].Name != "") {
                let firstWord = bags[i];
                let line = [];
                let lineN = [];
                if (/^[0-9]+[,.0-9\s]+[0-9]+/.test(firstWord.Name)) {
                    let splitWords = firstWord.Name.split(/^[0-9]+[,.0-9\s]+[0-9]+/);
                    let word = firstWord.Name.match(/^[0-9]+[,.0-9\s]+[0-9]+/)
                    if (splitWords.length > 1 && splitWords[1].trim() != "" && splitWords[1] != "%" && splitWords.length == 2 && [".","]"].indexOf(splitWords[1])==-1) {
                        let length = firstWord.Name.length;
                        let diff = firstWord.rightX - firstWord.leftX;
                        let pixelPerLetter = diff / length;
                        let firstWordLength = word[0].length;
                        let firstWordRightX = (firstWord.leftX + (pixelPerLetter * firstWordLength)) - 2;
                        //    let secondWordLength=splitWords[1].length;
                        let secondWordLeftX = firstWordRightX + 2
                        let obj1 = {
                            Name: word[0],
                            bottomY: firstWord.bottomY,
                            leftX: firstWord.leftX,
                            pageNo: firstWord.pageNo,
                            rightX: firstWordRightX - 2,
                            topY: firstWord.topY
                        };
                        let obj2 = {
                            Name: splitWords[1],
                            bottomY: firstWord.bottomY,
                            leftX: secondWordLeftX,
                            pageNo: firstWord.pageNo,
                            rightX: firstWord.rightX,
                            topY: firstWord.topY
                        };
                        line.push(obj1);
                        line.push(obj2);
                        lineN.push(obj1);
                        lineN.push(obj2);

                    } else {
                        line.push(firstWord);
                        lineN.push(firstWord);

                    }

                } else {
                    // line.push(firstWord);
                    lineN.push(firstWord);
                    self.splitWordss(firstWord,line)
                }
                // bags[i]['combined']=true;
                for (let j = i + 1; j < bags.length; j++) {
                    let nextWord = bags[j];
                    if (((firstWord.bottomY - firstWord.topY) * threshold < firstWord.bottomY - nextWord.topY) && ((nextWord.bottomY < firstWord.bottomY && firstWord.topY <= nextWord.bottomY) || (nextWord.bottomY > firstWord.bottomY && firstWord.bottomY >= nextWord.topY) || (nextWord.bottomY == firstWord.bottomY))) {
                        if (/^[0-9]+[,.0-9\s]+[0-9]+/.test(nextWord.Name)) {
                            let splitWords = nextWord.Name.split(/^[0-9]+[,.0-9\s]+[0-9]+/);
                            let word = nextWord.Name.match(/^[0-9]+[,.0-9\s]+[0-9]+/)
                            if (splitWords.length > 1 && splitWords[1].trim() != "" && splitWords[1] != "%" && splitWords.length == 2 && [".","]"].indexOf(splitWords[1])==-1) {
                                let length = nextWord.Name.length;
                                let diff = nextWord.rightX - nextWord.leftX;
                                let pixelPerLetter = diff / length;
                                let firstWordLength = word[0].length;
                                let firstWordRightX = (nextWord.leftX + (pixelPerLetter * firstWordLength)) - 2;
                                //    let secondWordLength=splitWords[1].length;
                                let secondWordLeftX = firstWordRightX + 2
                                let obj1 = {
                                    Name: word[0],
                                    bottomY: nextWord.bottomY,
                                    leftX: nextWord.leftX,
                                    pageNo: nextWord.pageNo,
                                    rightX: firstWordRightX - 2,
                                    topY: nextWord.topY
                                };
                                let obj2 = {
                                    Name: splitWords[1],
                                    bottomY: nextWord.bottomY,
                                    leftX: secondWordLeftX,
                                    pageNo: nextWord.pageNo,
                                    rightX: nextWord.rightX,
                                    topY: nextWord.topY
                                };
                                line.push(obj1);
                                line.push(obj2);
                                lineN.push(obj1);
                                lineN.push(obj2);

                            } else if (nextWord.Name.indexOf("|") > -1 && threshold == 0.5) {
                                let splitWords = nextWord.Name.split("|");
                                if (splitWords.length > 1 && splitWords[1].trim() != "" && splitWords[0].trim() != "" && splitWords.length == 2) {
                                    let length = nextWord.Name.length;
                                    let diff = nextWord.rightX - nextWord.leftX;
                                    let pixelPerLetter = diff / length;
                                    let firstWordLength = splitWords[0].length;
                                    let firstWordRightX = (nextWord.leftX + (pixelPerLetter * firstWordLength)) - 2;
                                    //    let secondWordLength=splitWords[1].length;
                                    let secondWordLeftX = firstWordRightX + 2
                                    let obj1 = {
                                        Name: splitWords[0],
                                        bottomY: nextWord.bottomY,
                                        leftX: nextWord.leftX,
                                        pageNo: nextWord.pageNo,
                                        rightX: firstWordRightX - 2,
                                        topY: nextWord.topY
                                    };
                                    let obj2 = {
                                        Name: splitWords[1],
                                        bottomY: nextWord.bottomY,
                                        leftX: secondWordLeftX,
                                        pageNo: nextWord.pageNo,
                                        rightX: nextWord.rightX,
                                        topY: nextWord.topY
                                    };
                                    line.push(obj1);
                                    line.push(obj2);
                                    lineN.push(obj1);
                                    lineN.push(obj2);
                                } else {
                                    line.push(nextWord);
                                    lineN.push(nextWord);

                                }

                            } else {
                                line.push(nextWord);
                                lineN.push(nextWord);
                            }

                        } else {
                            // line.push(nextWord);
                            lineN.push(nextWord);
                            self.splitWordss(nextWord,line)
                        }
                        //    bags[j]['combined']=true;
                    } else {
                        line.sort((a, b) => a["leftX"] - b["leftX"]);
                        sortedLines.push(line);
                        lineN.sort((a, b) => a["leftX"] - b["leftX"]);
                        sortedLinesN.push(lineN);
                        i = j - 1;
                        break;
                    }

                    if(j==bags.length-1 && line.length>0 && !reachedLast){
                        line.sort((a, b) => a["leftX"] - b["leftX"]);
                        sortedLines.push(line);
                        lineN.sort((a, b) => a["leftX"] - b["leftX"]);
                        sortedLinesN.push(lineN);
                        // i = j - 2;
                        // break
                        console.log("reached last---------------------------");
                        reachedLast=true;
                    }
                
            }
            if (i == bags.length - 1 && !reachedLast) {
                line.sort((a, b) => a["leftX"] - b["leftX"]);
                sortedLines.push(line);
                lineN.sort((a, b) => a["leftX"] - b["leftX"]);
                sortedLinesN.push(lineN);
            }
            } else {
                // bags[i]['combined']=true;
            }
        }
        console.log("hi---------")

    }
    splitWordss(element,line){
        if (/\s/.test(element.Name)) {
            let splitWords = element.Name.split(/\s/);
            if (splitWords.length > 1 && splitWords[1].trim() != "" && splitWords[0].trim() != "" && splitWords.length == 2) {
                let length = element.Name.length;
                let diff = element.rightX - element.leftX;
                let pixelPerLetter = diff / length;
                let elementLength = splitWords[0].length;
                let elementRightX = (element.leftX + (pixelPerLetter * elementLength));
                //    let secondWordLength=splitWords[1].length;
                let secondWordLeftX = elementRightX + pixelPerLetter;
                let obj1 = {
                    Name: splitWords[0],
                    bottomY: element.bottomY,
                    leftX: element.leftX,
                    pageNo: element.pageNo,
                    rightX: elementRightX,
                    topY: element.topY
                };
                let obj2 = {
                    Name: splitWords[1],
                    bottomY: element.bottomY,
                    leftX: secondWordLeftX,
                    pageNo: element.pageNo,
                    rightX: element.rightX,
                    topY: element.topY
                };
                line.push(obj1);
                line.push(obj2);
            } else {
                let allow = true;
                let length = element.Name.length;
                let diff = element.rightX - element.leftX;
                let pixelPerLetter = diff / length;
                let lastRightX = -1;
                for (let index = 0; index < splitWords.length; index++) {
                    const ele = splitWords[index];
                    // if (scanD.data.tableStart.indexOf(ele) > -1) {
                        allow = false;
                        if (index == 0) {
                            let obj = {
                                Name: splitWords[index],
                                bottomY: element.bottomY,
                                leftX: element.leftX,
                                pageNo: element.pageNo,
                                rightX: (element.leftX + (pixelPerLetter * splitWords[index].length)),
                                topY: element.topY
                            };
                            line.push(obj);
                            lastRightX = (element.leftX + (pixelPerLetter * splitWords[index].length));
                        } else if (index == splitWords.length - 1) {
                            let obj = {
                                Name: splitWords[index],
                                bottomY: element.bottomY,
                                leftX: (element.rightX - (pixelPerLetter * splitWords[index].length)),
                                pageNo: element.pageNo,
                                rightX: element.rightX,
                                topY: element.topY
                            };
                            line.push(obj);
                        } else {
                            let obj = {
                                Name: splitWords[index],
                                bottomY: element.bottomY,
                                leftX: lastRightX+pixelPerLetter,
                                pageNo: element.pageNo,
                                rightX: (lastRightX+pixelPerLetter+ (pixelPerLetter * splitWords[index].length)),
                                topY: element.topY
                            };
                            line.push(obj);
                            lastRightX = (lastRightX+pixelPerLetter+ (pixelPerLetter * splitWords[index].length));
                        }

                    // }

                }
                if (allow) {
                    line.push(element);
                }
            }

        } else {
            line.push(element);
        }
    }
    extractFeaturesloop(ruleObjInputArray) {

        return __awaiter(this, void 0, void 0, function* () {
            let ruleObjOutputArray = []
            let tableBorder = {};
            let top = 0;
            let bottom = 0;
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let self = this;
                for (let index = 0; index < ruleObjInputArray.length; index++) {
                    let ruleObj = ruleObjInputArray[index];
                    let lines = ruleObj.Lines;
                    let pageWidth = ruleObj.pageWidth;
                    let pageHeight = ruleObj.pageHeight;
                    let lineWithCombineWords = [];
                    let lineWordsWithoutTable = [];
                    // for (let i = 0; i < lines.length; i++) {
                    //     lineWithCombineWords.push(this.combineLineWords(lines[i], lines));
                    // }
                    lineWithCombineWords = lines;
                    lineWithCombineWords = self.colonSplitter(lineWithCombineWords);
                    lineWordsWithoutTable = lineWithCombineWords.filter(lineWithCombineWords => {
                        if (lineWithCombineWords.length > 0) {
                            return !(lineWithCombineWords[0].topY >= top && lineWithCombineWords[0].bottomY <= bottom)
                        }
                    })
                    let tmp = 1;
                    for (let i = 0; i < lineWordsWithoutTable.length; i++) {
                        lineWordsWithoutTable[i].forEach(function (list, index) {
                            list['index'] = tmp++;
                        });
                    }
                    let features;
                    // console.log('Documnettypeeeeeee==============BASkya', ruleObj.obj.documentType);
                    if (ruleObj.obj.documentType === 'Clinical') {
                        // console.log('--------------doc_type===========is clincall');
                        features = yield self.extractInvoiceFeatures(ruleObj.lineWithCombineWordsNew, pageWidth, pageHeight, ruleObj.obj.documentType);
                    }
                    else {
                        // console.log('--------------doc_type===========is not clincall');
                        features = yield self.extractInvoiceFeatures(lineWordsWithoutTable, pageWidth, pageHeight, ruleObj.obj.documentType);
                    }
                    let featurestmp = [];
                    featurestmp.push(features);
                    featurestmp[0].forEach(element2 => {
                        features.forEach(element => {
                            if (element2.index == element.TOP_index) {
                                element['TOP_TopMarginRelative'] = element2.TopMarginRelative;
                                element['TOP_LeftMarginRelative'] = element2.LeftMarginRelative;
                                element['TOP_RightMarginRelative'] = element2.RightMarginRelative;
                                element['TOP_BottomMarginRelative'] = element2.BottomMarginRelative;
                                element['TOP_VerticalPositionRelative'] = element2.VerticalPositionRelative;
                                element['TOP_HorizontalPositionRelative'] = element2.HorizontalPositionRelative;
                                element['TOP_linewhitespace'] = element2.linewhitespace;
                                element['TOP_PositionOnLine'] = element2.PositionOnLine;
                                element['TOP_LineSize'] = element2.LineSize;
                                element['TOP_HasDate'] = element2.HasDate;
                            }
                            if (element2.index == element.BOTTOM_index) {
                                element['BOTTOM_TopMarginRelative'] = element2.TopMarginRelative;
                                element['BOTTOM_LeftMarginRelative'] = element2.LeftMarginRelative;
                                element['BOTTOM_RightMarginRelative'] = element2.RightMarginRelative;
                                element['BOTTOM_BottomMarginRelative'] = element2.BottomMarginRelative;
                                element['BOTTOM_VerticalPositionRelative'] = element2.VerticalPositionRelative;
                                element['BOTTOM_HorizontalPositionRelative'] = element2.HorizontalPositionRelative;
                                element['BOTTOM_linewhitespace'] = element2.linewhitespace;
                                element['BOTTOM_PositionOnLine'] = element2.PositionOnLine;
                                element['BOTTOM_LineSize'] = element2.LineSize;
                                element['BOTTOM_HasDate'] = element2.HasDate;
                            }
                            if (element2.index == element.LEFT_index) {
                                element['LEFT_TopMarginRelative'] = element2.TopMarginRelative;
                                element['LEFT_LeftMarginRelative'] = element2.LeftMarginRelative;
                                element['LEFT_RightMarginRelative'] = element2.RightMarginRelative;
                                element['LEFT_BottomMarginRelative'] = element2.BottomMarginRelative;
                                element['LEFT_VerticalPositionRelative'] = element2.VerticalPositionRelative;
                                element['LEFT_HorizontalPositionRelative'] = element2.HorizontalPositionRelative;
                                element['LEFT_linewhitespace'] = element2.linewhitespace;
                                element['LEFT_PositionOnLine'] = element2.PositionOnLine;
                                element['LEFT_LineSize'] = element2.LineSize;
                                element['LEFT_HasDate'] = element2.HasDate;
                            }
                            if (element2.index == element.RIGHT_index) {
                                element['RIGHT_TopMarginRelative'] = element2.TopMarginRelative;
                                element['RIGHT_LeftMarginRelative'] = element2.LeftMarginRelative;
                                element['RIGHT_RightMarginRelative'] = element2.RightMarginRelative;
                                element['RIGHT_BottomMarginRelative'] = element2.BottomMarginRelative;
                                element['RIGHT_VerticalPositionRelative'] = element2.VerticalPositionRelative;
                                element['RIGHT_HorizontalPositionRelative'] = element2.HorizontalPositionRelative;
                                element['RIGHT_linewhitespace'] = element2.linewhitespace;
                                element['RIGHT_PositionOnLine'] = element2.PositionOnLine;
                                element['RIGHT_LineSize'] = element2.LineSize;
                                element['RIGHT_HasDate'] = element2.HasDate;
                            }
                        });
                    });
                    ruleObj['docFeatures'] = features;
                    ruleObjOutputArray.push(ruleObj);


                }
                resolve(ruleObjOutputArray)
            }));
        });
    }

    saveDocTrainDataloop(data, imagePath_parser) {

        return __awaiter(this, void 0, void 0, function* () {

            let masterDocumentCsvData;
            let trainingObj;
            let filePath;
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let self = this;
                // let prmArr = [];
let bulk = docTraining.collection.initializeUnorderedBulkOp();
                for (let index = 0; index < data.length; index++) {
                    masterDocumentCsvData = [];
                    trainingObj = {};
                    let ruleObj = data[index];

                    if (!util_1.isNullOrUndefined(imagePath_parser)) {
                        filePath = imagePath_parser[index].imageFilePath;
                    }
                    else {
                        filePath = ruleObj.obj.filePath;
                    }

                    if (!util_1.isNullOrUndefined(ruleObj) && !util_1.isNullOrUndefined(ruleObj.docFeatures)) {
                        ruleObj.docFeatures.forEach(csvData => {
                            let csvDataObj = csvData;
                            csvDataObj['pageNo'] = index;
                            masterDocumentCsvData.push(csvDataObj);
                        });
                        trainingObj['isDeleted'] = false;
                        trainingObj['documentCsvData'] = masterDocumentCsvData;
                        trainingObj['documentType'] = ruleObj.obj.documentType;
                        trainingObj['fileRefNum'] = ruleObj.obj.fileRefNum;
                        trainingObj['userId'] = ruleObj.obj.userId;
                        trainingObj['subscriberId'] = ruleObj.obj.subscriberId;
                        trainingObj['orgId'] = ruleObj.obj.orgId;

                        
                        bulk.find({ fileRefNum: ruleObj.obj.fileRefNum,documentType: 
                            ruleObj.obj.documentType,
                            filePath: filePath}).
                            update({ $set: {
                                fileRefNum: ruleObj.obj.fileRefNum,
                                documentType: ruleObj.obj.documentType,
                                userId: ruleObj.obj.userId,
                                subscriberId: ruleObj.obj.subscriberId,
                                orgId: ruleObj.obj.orgId,
                                documentCsvData: masterDocumentCsvData,
                                isDeleted: false,
                                fileName: ruleObj.obj.fileName,
                                filePath: filePath
                            } }, { upsert: true });
                    }

                    else {
                        logger.error("Save_DocTrain==>Dacument Training Data not Saved...!!!");
                    }

if(index==data.length-1){
                        const result = yield bulk.execute();
                        // console.log(`${result.nInserted} documents inserted-`);
                }
                }
                // yield Promise.all(prmArr);
                resolve("done!")

            }));
        });
    }

    saveDocTrainData2loop(data, imagePath_parser, fieldDetectionData) {

        return __awaiter(this, void 0, void 0, function* () {

            let masterDocumentCsvData;
            let trainingObj;
            let filePath;
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let self = this;
                // let prmArr = [];
let bulk = docTraining.collection.initializeUnorderedBulkOp();
                for (let index = 0; index < fieldDetectionData.length; index++) {
                    masterDocumentCsvData = [];
                    trainingObj = {};
                    let ruleObj = data[index];
                    let ruleObj1 = fieldDetectionData[index];

                    if (!util_1.isNullOrUndefined(imagePath_parser)) {
                        filePath = imagePath_parser[index].imageFilePath;
                    }
                    else {
                        filePath = ruleObj.obj.filePath;
                    }

                    // if (!util_1.isNullOrUndefined(ruleObj) && !util_1.isNullOrUndefined(ruleObj.docFeatures)) {
                    if (!util_1.isNullOrUndefined(ruleObj) && !util_1.isNullOrUndefined(ruleObj1)) {
                        ruleObj1.forEach(csvData => {
                            let csvDataObj = csvData;
                            csvDataObj['pageNo'] = index;
                            masterDocumentCsvData.push(csvDataObj);
                        });
                        trainingObj['isDeleted'] = false;
                        trainingObj['documentCsvData'] = masterDocumentCsvData;
                        trainingObj['documentType'] = ruleObj.obj.documentType;
                        trainingObj['fileRefNum'] = ruleObj.obj.fileRefNum;
                        trainingObj['userId'] = ruleObj.obj.userId;
                        trainingObj['subscriberId'] = ruleObj.obj.subscriberId;
                        trainingObj['orgId'] = ruleObj.obj.orgId;
                        
                        bulk.find({ fileRefNum: ruleObj.obj.fileRefNum,documentType: 
                            ruleObj.obj.documentType,
                            filePath: filePath}).
                            update({ $set: {
                                fileRefNum: ruleObj.obj.fileRefNum,
                                documentType: ruleObj.obj.documentType,
                                userId: ruleObj.obj.userId,
                                subscriberId: ruleObj.obj.subscriberId,
                                orgId: ruleObj.obj.orgId,
                                documentCsvData: masterDocumentCsvData,
                                isDeleted: false,
                                fileName: ruleObj.obj.fileName,
                                filePath: filePath
                            } }, { upsert: true });
                    }
                    else {
                        logger.error("Save_DocTrain==>Dacument Training Data not Saved...!!!");
                    }

if(index==data.length-1){
                        const result = yield bulk.execute();
                        // console.log(`${result.nInserted} documents inserted-`);
                    }

                }

                // yield Promise.all(prmArr);
                resolve("done!")

            }));
        });
    }



    combinedFunctions(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let self = this;
                res.send({ status: 0 })
                let body = req.body;
                logger.info("<-------------------------In COMBINED FUNCTION CALLS----------------------->");
                let eventId = body.input.eventId;
                let projectId = body.projectId;
                let botId = body.botId;
                let token = body.token;
                let iterationId = body.iterationId;
                let saveDocTrainData = {};
                let runTrainingForInvoice = {};
                console.log("18--->", body.input.functionArray)
                // let functions = JSON.parse(body.input.functionArray);
                let functions = body.input.functionArray

                let response = body.input;
                let i_size;

                req.body.input.return = true;

                let stopG = false;
                if (!util_1.isNullOrUndefined(req.body.input.imageFlow) && (req.body.input.imageFlow === true || req.body.input.imageFlow)) {
                    stopG = true;
                }
                if (!stopG && functions.indexOf("getsortedLines") != -1) {
                    req.body.input.fileData = response.INPUT ? response.INPUT : req.body.input.fileData;

                    let pl_start = performance.now();
                    try { i_size = JSON.stringify(req.body.input).length } catch (e) { i_size = 0 };

                    response = yield self.getsortedLines(req, res);
                    response['OUTPUT'] = response.getSortedLines;

                    let pl_end = performance.now();
                    yield this.commonFunctions.performanceLog(req.body.input.eventId, req.body.iterationId, 'getsortedLines', pl_start, pl_end, i_size, pl_end - pl_start)
                }
                if (functions.indexOf("combineLines") != -1) {
                    req.body.input.fileData = response.getSortedLines ? response.getSortedLines : (response.INPUT ? response.INPUT : req.body.input.fileData);

                    let pl_start = performance.now();
                    try { i_size = JSON.stringify(req.body.input).length } catch (e) { i_size = 0 };

                    response = yield self.combineLines(req, res);
                    response['OUTPUT'] = response.combineLines;

                    let pl_end = performance.now();
                    yield this.commonFunctions.performanceLog(req.body.input.eventId, req.body.iterationId, 'combineLines', pl_start, pl_end, i_size, pl_end - pl_start)

                }
                if (functions.indexOf("extractFeatures") != -1) {
                    req.body.input.ruleObj = response.combineLines ? response.combineLines : (response.INPUT ? response.INPUT : req.body.input.ruleObj);

                    let pl_start = performance.now();
                    try { i_size = JSON.stringify(req.body.input).length } catch (e) { i_size = 0 };

                    response = yield self.extractFeatures(req, res);
                    response['OUTPUT'] = response.extractFeatures;

                    let pl_end = performance.now();
                    yield this.commonFunctions.performanceLog(req.body.input.eventId, req.body.iterationId, 'extractFeatures', pl_start, pl_end, i_size, pl_end - pl_start)

                }
                if (functions.indexOf("saveDocTrainData") != -1) {
                    req.body.input.ruleObj = response.extractFeatures ? response.extractFeatures : req.body.input.ruleObj;

                    let pl_start = performance.now();
                    try { i_size = JSON.stringify(req.body.input).length } catch (e) { i_size = 0 };

                    req.body.input.imagePath = response.imagePngPath ? response.imagePngPath : req.body.input.imagePath;
                    response = yield self.saveDocTrainData(req, res);
                    response['OUTPUT'] = response.saveDocTrainData;
                    saveDocTrainData = response.saveDocTrainData;
                    let pl_end = performance.now();
                    yield this.commonFunctions.performanceLog(req.body.input.eventId, req.body.iterationId, 'saveDocTrainData', pl_start, pl_end, i_size, pl_end - pl_start)

                }
                // if(functions.indexOf("identifyTable")!=-1)
                // {
                //     req.body.input.ruleObj = response.saveDocTrainData ? response.saveDocTrainData : {};

                //     let pl_start = performance.now();
                //     try{ i_size = JSON.stringify(req.body.input).length }catch(e){ i_size = 0 };

                //     response = yield self.identifyTable(req,res);
                //     response['OUTPUT'] = response.identifyTable;

                //     let pl_end = performance.now();
                //     yield this.commonFunctions.performanceLog(req.body.input.eventId,req.body.iterationId ,'identifyTable',pl_start,pl_end, i_size, pl_end - pl_start)

                // }
                if (functions.indexOf("extractTableData") != -1) {
                    let identifyTable = [];
                    for (let index = 0; index < req.body.input.ruleObj.length; index++) {
                        let ruleObj = req.body.input.ruleObj[index];
                        ruleObj['newTable'] = [];
                        ruleObj['tableStart'] = [];
                        ruleObj['tableEnd'] = [];
                        ruleObj['tableMapping'] = {};
                        ruleObj['tableHeaders'] = [];
                        ruleObj['tableBoundry'] = {};
                        ruleObj['tableData'] = [];
                        identifyTable.push(ruleObj);
                    }

                    // req.body.input.ruleObj = response.identifyTable ? response.identifyTable : {};
                    req.body.input.ruleObj = identifyTable ? identifyTable : {};
                    let pl_start = performance.now();
                    try { i_size = JSON.stringify(req.body.input).length } catch (e) { i_size = 0 };

                    response = yield self.extractTableData(req, res);
                    response['OUTPUT'] = response.extractTableData;

                    let pl_end = performance.now();
                    yield this.commonFunctions.performanceLog(req.body.input.eventId, req.body.iterationId, 'extractTableData', pl_start, pl_end, i_size, pl_end - pl_start)

                }
                if (functions.indexOf("genrateCsv") != -1) {
                    req.body.input.ruleObj = response.extractTableData ? response.extractTableData : {};

                    let pl_start = performance.now();
                    try { i_size = JSON.stringify(req.body.input).length } catch (e) { i_size = 0 };

                    response = yield self.genrateCsv(req, res);
                    response['OUTPUT'] = response.genrateCsv;

                    let pl_end = performance.now();
                    yield this.commonFunctions.performanceLog(req.body.input.eventId, req.body.iterationId, 'genrateCsv', pl_start, pl_end, i_size, pl_end - pl_start)

                }
                if (functions.indexOf("runTrainingForInvoice") != -1) {
                    req.body.input.ruleObj = response.genrateCsv ? response.genrateCsv : {};
                    // req.body.input.ruleObj = saveDocTrainData ? saveDocTrainData : {};

                    let pl_start = performance.now();
                    try { i_size = JSON.stringify(req.body.input).length } catch (e) { i_size = 0 };

                    response = yield self.runTrainingForInvoiceNew(req, res);
                    response['OUTPUT'] = response.runTrainingForInvoice;
                    runTrainingForInvoice = response.runTrainingForInvoice;
                    req.body['ruleId'] = response['ruleId']
                    let pl_end = performance.now();
                    yield this.commonFunctions.performanceLog(req.body.input.eventId, req.body.iterationId, 'runTrainingForInvoice', pl_start, pl_end, i_size, pl_end - pl_start)

                }
                if (functions.indexOf("identifyTable") != -1) {
                    req.body.input.ruleObj = saveDocTrainData ? saveDocTrainData : {};
                    req.body['templateId'] = response['templateId'];
                    req.body['isTmp'] = response['isTmp'];
                    let pl_start = performance.now();
                    try { i_size = JSON.stringify(req.body.input).length } catch (e) { i_size = 0 };

                    response = yield self.identifyTable(req, res);
                    response['OUTPUT'] = response.identifyTable;

                    let pl_end = performance.now();
                    yield this.commonFunctions.performanceLog(req.body.input.eventId, req.body.iterationId, 'identifyTable', pl_start, pl_end, i_size, pl_end - pl_start)

                }
                if (functions.indexOf("prepareFormData") != -1) {
                    req.body.input.ruleObj = runTrainingForInvoice ? runTrainingForInvoice : {};

                    let pl_start = performance.now();
                    try { i_size = JSON.stringify(req.body.input).length } catch (e) { i_size = 0 };

                    response = yield self.prepareFormData(req, res);
                    response['OUTPUT'] = response.prepareFormData;

                    let pl_end = performance.now();
                    yield this.commonFunctions.performanceLog(req.body.input.eventId, req.body.iterationId, 'prepareFormData', pl_start, pl_end, i_size, pl_end - pl_start)

                }
                if (functions.indexOf("prepareCreateSave") != -1) {
                    req.body.input.ruleObj = response.prepareFormData ? response.prepareFormData : {};

                    let pl_start = performance.now();
                    try { i_size = JSON.stringify(req.body.input).length } catch (e) { i_size = 0 };

                    response = yield self.prepareCreateSave(req, res);
                    response['OUTPUT'] = response.prepareCreateSave;

                    let pl_end = performance.now();
                    yield this.commonFunctions.performanceLog(req.body.input.eventId, req.body.iterationId, 'prepareCreateSave', pl_start, pl_end, i_size, pl_end - pl_start)

                }
                // if(functions.indexOf("multiPageArray")!=-1)
                // {
                //     req.body.input.ruleObj = response.prepareCreateSave ? response.prepareCreateSave : {};

                //     let pl_start = performance.now();
                //     try{ i_size = JSON.stringify(req.body.input).length }catch(e){ i_size = 0 };

                //     response = yield self.multiPageArray(req,res);
                //     response['OUTPUT'] = response.multiPageArray;

                //     let pl_end = performance.now();
                //     yield this.commonFunctions.performanceLog(req.body.input.eventId,req.body.iterationId ,'multiPageArray',pl_start,pl_end, i_size, pl_end - pl_start)

                // }
                if (functions.indexOf("saveObjectData") != -1) {
                    // req.body.input.ruleObj = response.multiPageArray ? response.multiPageArray : {};
                    req.body.input.ruleObj = response.prepareCreateSave ? response.prepareCreateSave : {};

                    let pl_start = performance.now();
                    try { i_size = JSON.stringify(req.body.input).length } catch (e) { i_size = 0 };

                    response = yield self.saveObjNew(req, res);
                    response['OUTPUT'] = response.saveObjectData;
                    response['Vendor_Name'] = response.saveObjectData['Vendor_Name'] ? response.saveObjectData['Vendor_Name'] : "";
                    response['Invoice_Number'] = response.saveObjectData['Invoice_Number'] ? response.saveObjectData['Invoice_Number'] : "";
                    response['Invoice_Date'] = response.saveObjectData['Invoice_Date'] ? response.saveObjectData['Invoice_Date'] : "";
                    response['InvoiceTotalAmount'] = response.saveObjectData['InvoiceTotalAmount'] ? response.saveObjectData['InvoiceTotalAmount'] : "";
                    response['tally_status'] = response.saveObjectData['tally_status'] ? response.saveObjectData['tally_status'] : "";
                    let pl_end = performance.now();
                    yield this.commonFunctions.performanceLog(req.body.input.eventId, req.body.iterationId, 'saveObjectData', pl_start, pl_end, i_size, pl_end - pl_start)

                }



                let outputData = response;

                let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': token, 'content-type': "application/json" };
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                // let self=this;

                yield self.ioWrite(options);
            }
            catch (err) {
                console.log("combinedFunctions errrrrrrrrrr", err);
                logger.error("#combinedFunctions==>Inside catch");
                let outputData = { "getSortedLines": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = err.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);
            }
        });
    };
    preMlFunctions(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let self = this;
                 if(!req.body.input.jsonRespond) {
                res.send({ status: 0 })
                }
                let body = req.body;
                logger.info("<-------------------------In COMBINED FUNCTION CALLS----------------------->");
                let eventId = body.input.eventId;
                let projectId = body.projectId;
                let botId = body.botId;
                let token = body.token;
                let iterationId = body.iterationId;
                let saveDocTrainData = {};
                let runTrainingForInvoice = {};
                console.log("18--->", body.input.functionArray)
                // let functions = JSON.parse(body.input.functionArray);
                let functions = body.input.functionArray

                let response = body.input;
                let combineLines = response.combineLines;
                let i_size;

                req.body.input.return = true;

                let stopG = false;
                if (!util_1.isNullOrUndefined(req.body.input.imageFlow) && (req.body.input.imageFlow === true || req.body.input.imageFlow)) {
                    stopG = true;
                }
                if (!stopG && functions.indexOf("getsortedLines") != -1) {
                    req.body.input.fileData = response.INPUT ? response.INPUT : req.body.input.fileData;

                    let pl_start = performance.now();
                    try { i_size = JSON.stringify(req.body.input).length } catch (e) { i_size = 0 };

                    response = yield self.getsortedLines(req, res);
                    response['OUTPUT'] = response.getSortedLines;
                }
                if (functions.indexOf("combineLines") != -1) {
                    req.body.input.fileData = response.getSortedLines ? response.getSortedLines : (response.INPUT ? response.INPUT : req.body.input.fileData);

                    response = yield self.combineLines(req, res);
                    response['OUTPUT'] = response.combineLines;

                }
                if (functions.indexOf("extractFeatures") != -1) {
                    req.body.input.ruleObj = response.combineLines ? response.combineLines : (response.INPUT ? response.INPUT : req.body.input.ruleObj);

                    response = yield self.extractFeatures(req, res);
                    response['OUTPUT'] = response.extractFeatures;
                    req.body.input.ruleObj = response.extractFeatures;

                }
                if (functions.indexOf("saveDocTrainData") != -1) {
                    req.body.input.ruleObj = response.extractFeatures ? response.extractFeatures : req.body.input.ruleObj;

                    req.body.input.imagePath = response.imagePngPath ? response.imagePngPath : req.body.input.imagePath;
                    response = yield self.saveDocTrainData(req, res);
                    response['OUTPUT'] = response.saveDocTrainData;
                    saveDocTrainData = response.saveDocTrainData;

                }
                if (functions.indexOf("extractTableData") != -1) {
                    let identifyTable = [];
                    for (let index = 0; index < req.body.input.ruleObj.length; index++) {
                        let ruleObj = req.body.input.ruleObj[index];
                        ruleObj['newTable'] = [];
                        ruleObj['tableStart'] = [];
                        ruleObj['tableEnd'] = [];
                        ruleObj['tableMapping'] = {};
                        ruleObj['tableHeaders'] = [];
                        ruleObj['tableBoundry'] = {};
                        ruleObj['tableData'] = [];
                        identifyTable.push(ruleObj);
                    }

                    // req.body.input.ruleObj = response.identifyTable ? response.identifyTable : {};
                    req.body.input.ruleObj = identifyTable ? identifyTable : {};

                    response = yield self.extractTableData(req, res);
                    response['OUTPUT'] = response.extractTableData;

                }
                if (functions.indexOf("genrateCsv") != -1) {
                    // req.body.input.ruleObj = response.extractTableData ? response.extractTableData : {};

                    response = yield self.genrateCsv(req, res);
                    response['OUTPUT'] = response.genrateCsv;

                }
                if (functions.indexOf("runTrainingForInvoice") != -1) {
                    req.body.input.ruleObj = response.genrateCsv ? response.genrateCsv : {};

                    response = yield self.runTrainingForInvoicePreML(req, res);
                    response['saveDocTrainData'] = saveDocTrainData ? saveDocTrainData : {};
                    //this is for identifyTable in postML functions
                    console.log("Response from runTrainingForInvoicePreML-----", response)
                }

                let outputData = response;
                outputData['combineLines'] = combineLines;

                let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': token, 'content-type': "application/json" };
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                // let self=this;

                let result = yield self.ioWrite(options,req.body.input);
                if(req.body.input.jsonRespond){ res.send(result)}
            }
            catch (err) {
                console.log("combinedFunctions errrrrrrrrrr", err);
                logger.error("#combinedFunctions==>Inside catch");
                let outputData = { "getSortedLines": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = err.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);
            }
        });
    }
    postMlFunctions(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let self = this;
                res.send({ status: 0 })
                let body = req.body;
                logger.info("<-------------------------In COMBINED FUNCTION CALLS----------------------->");
                let eventId = body.input.eventId;
                let projectId = body.projectId;
                let botId = body.botId;
                let token = body.token;
                let iterationId = body.iterationId;
                let runTrainingForInvoice = {};
                console.log("18--->", body.input.functionArray)
                // let functions = JSON.parse(body.input.functionArray);
                let functions = body.input.functionArray

                let response = body.input;

                req.body.input.return = true;

                if (functions.indexOf("runTrainingForInvoice") != -1) {
                    console.time("runTrainingForInvoicePostML")
                    response = yield self.runTrainingForInvoicePostML(req, res);
                    response['OUTPUT'] = response.runTrainingForInvoice;
                    runTrainingForInvoice = response.runTrainingForInvoice;
                    req.body['ruleId'] = response['ruleId']
                    console.timeEnd("runTrainingForInvoicePostML")

                }
                if (functions.indexOf("identifyTable") != -1) {
                    console.time("identifyTable")
                    req.body.input.ruleObj = req.body.input.saveDocTrainData ? req.body.input.saveDocTrainData : {};
                    req.body['templateId'] = response['templateId'];
                    req.body['isTmp'] = response['isTmp'];

                    response = yield self.identifyTable(req, res);
                    response['OUTPUT'] = response.identifyTable;
                    response['templateName'] = response.templateName;
                    console.timeEnd("identifyTable")

                }
                if (functions.indexOf("prepareFormData") != -1) {
                    console.time("prepareFormData")
                    if (response.identifyTable.length == runTrainingForInvoice.length) {
                        for (let i = 0, len = response.identifyTable.length; i < len; i++) {
                            response.identifyTable[i]['invoiceObject'] = runTrainingForInvoice[i]['invoiceObject'];
                            console.log("------------", response.identifyTable[i]['invoiceObject'].length)
                        }
                    }
                    req.body.input.ruleObj = response.identifyTable ? response.identifyTable : {};

                    response = yield self.prepareFormData(req, res);
                    response['OUTPUT'] = response.prepareFormData;
                    console.timeEnd("prepareFormData")

                }
                if (functions.indexOf("prepareCreateSave") != -1) {
                    console.time("prepareCreateSave")

                    req.body.input.ruleObj = response.prepareFormData ? response.prepareFormData : {};

                    response = yield self.prepareCreateSave(req, res);
                    response['OUTPUT'] = response.prepareCreateSave;
                    console.timeEnd("prepareCreateSave")

                }
                // if(functions.indexOf("multiPageArray")!=-1)
                // {
                //     req.body.input.ruleObj = response.prepareCreateSave ? response.prepareCreateSave : {};

                //     let pl_start = performance.now();
                //     try{ i_size = JSON.stringify(req.body.input).length }catch(e){ i_size = 0 };

                //     response = yield self.multiPageArray(req,res);
                //     response['OUTPUT'] = response.multiPageArray;

                //     let pl_end = performance.now();
                //     yield this.commonFunctions.performanceLog(req.body.input.eventId,req.body.iterationId ,'multiPageArray',pl_start,pl_end, i_size, pl_end - pl_start)

                // }
                if (functions.indexOf("saveObjectData") != -1) {
                    console.time("saveObjectData")

                    // req.body.input.ruleObj = response.multiPageArray ? response.multiPageArray : {};
                    req.body.input.ruleObj = response.prepareCreateSave ? response.prepareCreateSave : {};
                    req.body['templateName'] = response['templateName'];

                    response = yield self.saveObjNew(req, res);
                    response['OUTPUT'] = response.saveObjectData;
                    response['ruleId'] = response.saveObjectData['ruleId'];
                    response['Vendor_Name'] = response.saveObjectData['Vendor_Name'] ? response.saveObjectData['Vendor_Name'] : "";
                    response['Invoice_Number'] = response.saveObjectData['Invoice_Number'] ? response.saveObjectData['Invoice_Number'] : "";
                    response['Invoice_Date'] = response.saveObjectData['Invoice_Date'] ? response.saveObjectData['Invoice_Date'] : "";
                    response['InvoiceTotalAmount'] = response.saveObjectData['InvoiceTotalAmount'] ? response.saveObjectData['InvoiceTotalAmount'] : "";
                    response['tally_status'] = response.saveObjectData['tally_status'] ? response.saveObjectData['tally_status'] : "";
                    console.timeEnd("saveObjectData")

                }

                let outputData = response;

                let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': token, 'content-type': "application/json" };
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                // let self=this;

                yield self.ioWrite(options);
            }
            catch (err) {
                console.log("combinedFunctions errrrrrrrrrr", err);
                logger.error("#combinedFunctions==>Inside catch");
                let outputData = { "getSortedLines": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = err.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);
            }
        });
    }
    getsortedLines(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log("/////////////////////// i am inside/////////////////////////////////////");
            try {
                req.body.input.return ? '' : res.send({ status: 0 });
                let self = this;
                let body = req.body;
                logger.info("in get sorted lines");
                let getSortedLinesOutput = [];
                let a = body.input.a;
                let eventId = body.input.eventId;
                let projectId = body.projectId;
                let botId = body.botId;
                let token = body.token;
                let iterationId = body.iterationId;
                let refNum = body.input.fileRefNum;
                // fs.writeFileSync('/var/www/cuda-fs/getsorted_input.json', JSON.stringify(req.body.input.fileData));
                // let mClient = yield MongoClient.connect(config.mongoConnection);
                // let dbName = config.mongoConnection.split('/');
                // let db = yield mClient.db(dbName[dbName.length - 1]);
                let data = yield (db.createDynamicModel('fileuploadhistories')).findOne({ fileRefNum: refNum });
                data = JSON.parse(JSON.stringify(data))
                let oid = data["orgId"];
                let obj = {};
                let fileDataNew = {};
                if (!util_1.isNullOrUndefined(body.input.fileData)) {
                    for (let index = 0; index < body.input.fileData.length; index++) {
                        let filePath = data["imagesPath"][index].imageFilePath;
                        obj["filePath"] = filePath;
                        obj['documentType'] = data["documentType"];
                        obj["fileRefNum"] = refNum;
                        obj["orgId"] = data["orgId"];
                        obj["userId"] = data["userId"];
                        obj["subscriberId"] = data["subscriberId"];
                        obj["fileName"] = data["fileName"];
                        //  obj["imagesPath"]=data.imagesPath[index][imageFilePath];
                        let fileData = body.input.fileData[index];
                        fileDataNew["obj"] = obj;
                        fileDataNew['raw'] = fileData;
                        fileDataNew['pageHeight'] = fileData[0].pageHeight * (Number(a));
                        fileDataNew['pageWidth'] = fileData[0].pageWidth * (Number(a));
                        fileDataNew['fileRefNum'] = refNum;
                        console.log('Inside Get Sorted Lines');
                        // let lineWords = resp['textAnnotations'];
                        let sortedWords;
                        let lines = this.processWordsNew(fileData, a);
                        sortedWords = JSON.parse(JSON.stringify(lines));
                        sortedWords.sort(function (a, b) {
                            return a["pageNo"] - b["pageNo"] || a["topY"] - b["topY"];
                        });
                        fileDataNew['sortedWords'] = sortedWords;
                        fileDataNew['combineWords'] = lines;
                        getSortedLinesOutput.push(fileDataNew);
                        fileDataNew = {};
                        obj = {};
                    }
                    let outputData = { "getSortedLines": getSortedLinesOutput, "uploadStatus": true, 'statusCode': '200' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     //    console.log("--------------err in res",error);
                    //     //     resolve(response)
                    //     //     console.log("body---responce",body);
                    //     //     console.log("---res",response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    if (req.body.input.return)
                        return outputData;
                    else
                        yield self.ioWrite(options);


                    ///////////////////////////////////////////////////////
                }
                else {
                    logger.error("#getSortedLines==>Internal server Error");
                    let outputData = { "getSortedLines": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    taskData['exception'] = "fileData is undefined";
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     // console.log("body---responce", body);
                    //     // console.log("---res", response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    if (req.body.input.return)
                        return outputData;
                    else
                        yield self.ioWrite(options);

                    ///////////////////////////////////////////////////////
                }
            }
            catch (err) {
                console.log("errrrrrrrrrr", err);
                logger.error("#getSortedLines==>Inside catch");
                let outputData = { "getSortedLines": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = err.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
            }
        });
    }
    combineLines(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            let i_size;
            try { i_size = JSON.stringify(req.body.input).length; } catch (e) { i_size = 0 };
            let pl_start = performance.now();
            try {
                req.body.input.return ? '' : res.send({ status: 0 });
                let self = this;

                logger.warn(" --- --- ---- INSIDE COMBINE LINE FUNCTION  --- ---- ----- ------- ");

                let combileLinesArrayNew = [];
                let body = req.body;
                let token = req.body.token;
                let fileArrayData = req.body.input.fileData;
                //fs.writeFileSync('/home/user/Music/PDFtest/combineLines_input.json', JSON.stringify(fileArrayData));
                let botId = req.body.botId;
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;
                let options = {};
                let headers = {};
                let taskData = {};
                let outputData = {};
                let imageFlow = req.body.input.imageFlow

                if (!util_1.isNullOrUndefined(fileArrayData)) {
                    console.info("WELCOME TO FILE_ARRAY_DATA FUNCTION CALL");

                    combileLinesArrayNew = yield self.combineLinescall(fileArrayData, imageFlow);

                    console.warn("AFTER combineLinescall FUNCTION CALL");

                    if (!util_1.isNullOrUndefined(combileLinesArrayNew) && combileLinesArrayNew.length > 0) {
                        console.warn("INSIDE IF CONDITION WITH VALID COMBINE LINES DATA  ---- >>> LENGTH ----- >> ", combileLinesArrayNew.length);
                        outputData = { "combineLines": combileLinesArrayNew, "combineLData": req.body.input.fileData, "uploadStatus": true, 'statusCode': '200' };
                        taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                        headers = { 'Authorization': token, 'content-type': "application/json" };
                        options = {
                            method: 'POST',
                            url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                            headers: headers,
                            body: taskData,
                            json: true
                        };
                        // yield self.requestApi(options);
                        ///////////////////////////////////////////////////////
                        // let self=this;
                        if (req.body.input.return)
                            return outputData;
                        else
                            yield self.ioWrite(options)


                        ///////////////////////////////////////////////////////
                        console.warn("BOT INPUT OUTPUT API CALL FROM COMBINES");
                    } else {
                        console.error("--- INSIDE ELSE CONDITION NOT AN VALID COMBINE LINES DATA ---");
                        outputData = { "combineLines": null, "uploadStatus": true, 'statusCode': '202' };
                        taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                        headers = { 'Authorization': token, 'content-type': "application/json" };
                        taskData['exception'] = "NOT AN VALID COMBINE LINES DATA ";
                        options = {
                            method: 'POST',
                            url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                            headers: headers,
                            body: taskData,
                            json: true
                        };
                        // yield self.requestApi(options);
                        ///////////////////////////////////////////////////////
                        // let self=this;
                        if (req.body.input.return)
                            return outputData;
                        else
                            yield self.ioWrite(options)

                        ///////////////////////////////////////////////////////
                        console.error("BOT INPUT OUTPUT API CALL FROM COMBINES");

                    }


                } else {
                    console.error("--- ---- ERROR IN COMBINELINES AS NOT DATA IN FILEDATA FOUND --- ---- ----- ");
                    let outputData = { "combineLines": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = "ERROR IN COMBINELINES AS NOT DATA IN FILEDATA FOUND";
                    options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    // yield self.requestApi(options);
                    ///////////////////////////////////////////////////////
                    // let self=this;

                    yield self.ioWrite(options)

                    ///////////////////////////////////////////////////////
                    console.error("BOT INPUT OUTPUT API CALL FROM COMBINES");
                }
            }
            catch (e) {
                let self = this;
                let outputData = { "combineLines": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = e.toString();
                let options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                // yield self.requestApi(options);
                ///////////////////////////////////////////////////////
                // let self=this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
                console.error("BOT INPUT OUTPUT API CALL FROM COMBINES IN CATCH BLOCK", e);
            }
            let pl_end = performance.now();
            this.commonFunctions.performanceLog(req.body.input.eventId, req.body.iterationId, 'combineLines', pl_start, pl_end, i_size, pl_end - pl_start)
        });
    }


    combineLinescall(data, imageFlow) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            return yield new Promise(function (resolve, reject) {
                return __awaiter(this, void 0, void 0, function* () {
                    console.log("INSIDE PROMISE FUNCTION FOR COMBINELINESCALL FUNCTION");
                    let objData = yield self.combineLinesloop(data, imageFlow);
                    console.log("AFTER PROMISE FUNCTION CALL COMBINESLINESLOOP CALL");
                    if (!util_1.isNullOrUndefined(objData) && objData.length > 0) {
                        resolve(objData);
                    }
                });
            });
        });
    };


    extractFeatures(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                req.body.input.return ? '' : res.send({ status: 0 });
                let self = this;
                logger.info('Inside of extract invoice features');
                // let complete = false;
                let body = req.body;
                let ruleObjOutputArray = [];
                let token = req.body.token;
                let botId = req.body.botId;
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;
                /*Extract features if invoice*/
                // let tableBorder = {};
                // let top = 0;
                // let bottom = 0;
                let ruleObjInputArray = req.body.input.ruleObj;
                // fs.writeFileSync('/home/user/Music/PDFtest/extractFeatures_input.json', JSON.stringify(ruleObjInputArray));
                if (!util_1.isNullOrUndefined(ruleObjInputArray)) {
                    ruleObjOutputArray = yield self.extractFeaturesloop(ruleObjInputArray)

                    let outputData = { "extractFeatures": ruleObjOutputArray, "uploadStatus": true, 'statusCode': '200' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     //console.log("body---responce",body);
                    //     //console.log("---res",response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    if (req.body.input.return)
                        return outputData;
                    else
                        yield self.ioWrite(options)


                    ///////////////////////////////////////////////////////
                }
                else {
                    logger.error("#extractFeatures==>Internal server Error");
                    let outputData = { "extractFeatures": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = "#extractFeatures==>Internal server Error";
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     // console.log("body---responce", body);
                    //     // console.log("---res", response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;

                    ///////////////////////////////////////////////////////
                    yield self.ioWrite(options)
                }
            }
            catch (e) {
                logger.error("Nothing get featuresssss----------Inside catch", e);
                let outputData = { "extractFeatures": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = e.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
            }
        })
    }
    saveDocTrainData(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                req.body.input.return ? '' : res.send({ status: 0 });
                logger.info('Inside of Save Doc trainDataaa');
                let self = this;
                // let complete = false;
                let body = req.body;
                let token = req.body.token;
                let botId = req.body.botId;
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;

                let imagePath_parser = req.body.input.imagePath;
                let trainingObj;
                let filePath;
                // fs.writeFileSync("/var/www/cuda-fs/savedoctraindata_input.json", JSON.stringify(req.body));
                if (!util_1.isNullOrUndefined(req.body.input.ruleObj)) {

                    let dataNew = yield self.saveDocTrainDataloop(req.body.input.ruleObj, imagePath_parser)


                    let outputData = { "saveDocTrainData": req.body.input.ruleObj, "uploadStatus": true, 'statusCode': '200' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     //console.log("body---responce",body);
                    //     //console.log("---res",response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    if (req.body.input.return)
                        return outputData;
                    else
                        yield self.ioWrite(options)


                    ///////////////////////////////////////////////////////

                }
                else {
                    logger.error("#saveDocTrainData==>Internal server Error");
                    let outputData = { "saveDocTrainData": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = "#saveDocTrainData==>Internal server Error";
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     // console.log("body---responce", body);
                    //     // console.log("---res", response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    yield self.ioWrite(options);


                    ///////////////////////////////////////////////////////
                }
            }
            catch (e) {
                logger.error("In catch#Save_DocTrain==>Dacument Training Data not Saved...!!! inside catch", e);
                let outputData = { "saveDocTrainData": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = e.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
            }
        });
    }
    saveDocTrainData2(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                res.send({ status: 0 });
                logger.info('Inside of Save Doc trainDataaa2');
                let self = this;
                // let complete = false;
                // fs.writeFileSync("/home/user/Music/PDFtest/savedoctraindata2_input.json", JSON.stringify(req.body));
                let token = req.body.token;
                let botId = req.body.botId;
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;
                let masterDocumentCsvData;
                let fieldDetectionData = req.body.input.fieldDetectionData;
                let imagePath_parser = req.body.input.imagePath;
                let trainingObj;
                let filePath;
                // fs.writeFileSync("/home/user/Music/PDFtest/savedoctraindata2_input.json", JSON.stringify(req.body));
                if (!util_1.isNullOrUndefined(fieldDetectionData)) {
                    let dataNew = yield self.saveDocTrainData2loop(req.body.input.ruleObj, imagePath_parser, fieldDetectionData)

                    let outputData = { "saveDocTrainData2": req.body.input.ruleObj, "uploadStatus": true, 'statusCode': '200' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     //console.log("body---responce",body);
                    //     //console.log("---res",response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    yield self.ioWrite(options);


                    ///////////////////////////////////////////////////////

                }
                else {
                    logger.error("#saveDocTrainData2==>Internal server Error");
                    let outputData = { "saveDocTrainData2": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = "#saveDocTrainData2==>Internal server Error";
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     // console.log("body---responce", body);
                    //     // console.log("---res", response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    yield self.ioWrite(options);


                    ///////////////////////////////////////////////////////
                }
            }
            catch (e) {
                logger.error("In catch#Save_DocTrain2==>Dacument Training Data not Saved...!!! inside catch", e);
                let outputData = { "saveDocTrainData2": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = e.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
            }
        });
    }

    identifyTable(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // fs.writeFileSync('/var/www/cuda-fs/identifyObj.txt', JSON.stringify(req.body));
                let self = this;
                // let imgArr=["img13.png","img14.png"]
                let imgArr = [];
                let tablesMaster = [];
                let multiTable = [];
                let templateName = "";
                let columnCordinates = [];
                let lastColumnCordinates = [];
                let previousLines=[];
                let tableobjectsCordinatesMaster=[];
                let tableEndCordinates=[];
                let singleLenthTableStartInd=[];
                // imgArr=["img13.png","img14.png"]
                for (let index = 0; index < req.body.input.ruleObj.length; index++) {
                    let ele = req.body.input.ruleObj[index];
                    imgArr.push(ele.obj.filePath);
                }
                // let url="http://localhost:4545/table-detection/api";
                let url = config.pdfServerUrl + "table-detection/api"
                var optionsD = {
                    method: 'POST',
                    url: url,
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: {
                        "image": imgArr
                    },
                    json: true
                };
                let tableStarty = 0;
                let tableEndY = 0;
                let tableColumns = [];
                // let response = yield self.getTableCordinates(optionsD);
                let response = {};
                // if (req.detectTable) {
                // response=req['mlResponse']
                // response=req['data']=[]
                // }else{
                // response = yield self.getTableCordinates(optionsD);
                // }
                if (!util_1.isNullOrUndefined(response['data']) && !util_1.isNullOrUndefined(response['data']['tableCordinates']) && response['data']['tableCordinates'].length > 0) {
                    // tableStarty=response['data']['tableCordinates'][0]['ymin'];
                    // tableEndY=response['data']['tableCordinates'][0]['ymax'];
                }
                // if (!util_1.isNullOrUndefined(response['data']) && !util_1.isNullOrUndefined(response['data']['tableStructureCordinates']) &&  response['data']['tableStructureCordinates'].length>0) {
                //     tableColumns=self.getTableColumns(response);
                // }
                if (req.detectTable) {

                } else {
                    req.body.input.return ? '' : res.send({ status: 0 });

                    let ruleObjCpy = [];
                    for (let i = 0; i < req.body.input.ruleObj.length; i++) {
                        let ruleO = {
                            "obj": req.body.input.ruleObj[i].obj,
                            "pageHeight": req.body.input.ruleObj[i].pageHeight,
                            "pageWidth": req.body.input.ruleObj[i].pageWidth,
                            "fileRefNum": req.body.input.ruleObj[i].fileRefNum,
                            "lineWithCombineWords": req.body.input.ruleObj[i].lineWithCombineWords,
                            "lineWithCombineWordsNew": req.body.input.ruleObj[i].lineWithCombineWordsNew,
                            "mlResponse": response
                        }
                        ruleObjCpy.push(JSON.parse(JSON.stringify(ruleO)));
                    }
                    sortedLine.insertMany([{ ruleObj: ruleObjCpy }], function (err, data) {

                        if (err) {
                            // console.log(err)
                        } else {
                            console.log("---")
                        }
                    })
                }
                logger.info('Inside identify table');
                let token = req.body.token;
                let identifyTableOutputArray = [];
                let botId = req.body.botId;
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;
                let multiTableFlg = false;
                if (!util_1.isNullOrUndefined(req.body.input.ruleObj)) {

                    let ruleObj = req.body.input.ruleObj[0];
                    ruleObj.lineWithCombineWordsNew = ruleObj.lineWithCombineWordsNew.filter(function (x) { return x.length; });
                    // yield scanField.findOne({ isDeleted: false, documentType: ruleObj.obj.documentType }, function (err, scanData) {
                    //     if (err) {
                    //         throw err;
                    //     }
                    //     else {
                    let scanD = yield self.getScanFieldData(ruleObj.obj.documentType);
                    // if(!util_1.isNullOrUndefined(scanD.data) && !util_1.isNullOrUndefined(scanD.data.fields)){
                    //     let tableName="";
                    //       for(let item of scanD.data.fields){
                    //           if(tableName!="" && item.tableName!="" && tableName!=item.tableName){
                    //             multiTableFlg=true;
                    //           }
                    //           if(item.tableName!="" && tableName==""){
                    //             tableName=item.tableName
                    //           }
                    //       }
                    // }
                    // req.body['templateId']="6453bbfe9650fa4e7daf2f02";
                    // req.body['templateId'] = "656d5521ef8961af955701cc";
                    console.log("before templateD found-----------------------------------------------------", req.body.templateId, '---', req.body.isTmp);
                    if (!util_1.isNullOrUndefined(req.body.templateId) && !/\s/.test(String(req.body.templateId)) && req.body.templateId != '') {
                        let templateD = yield self.getTemplateData(req.body['templateId']);
                        if (!util_1.isNullOrUndefined(templateD.data) && !util_1.isNullOrUndefined(templateD.data.allowGarbage)) {
                            scanD.data.allowGarbage = templateD.data.allowGarbage;
                        }
                        if (!util_1.isNullOrUndefined(templateD.data) && !util_1.isNullOrUndefined(templateD.data.tableMapping) && Object.keys(templateD.data.tableMapping).length > 0 || 
                        (!util_1.isNullOrUndefined(templateD.data) && util_1.isNullOrUndefined(templateD.data.tableMapping) && !util_1.isNullOrUndefined(templateD.data['multiTable']) && templateD.data['multiTable'].length > 0)) {
                            console.log("templateD found-----------------------------------------------------", templateD.data.templateName);
                            scanD.data.tableMapping = templateD.data.tableMapping;
                            scanD.data.tableStart = templateD.data.tableStart;
                            scanD.data.tableEnd = templateD.data.tableEnd;
                            scanD.data.heading = templateD.data.tableHeading;
                            scanD.data.combined = templateD.data.combined;
                            scanD.data['tableSubHeaders'] = templateD.data.tableSubHeaders;
                            scanD.data['startsWith'] = templateD.data.startsWith;
                            scanD.data['endsWith'] = templateD.data.endsWith;
                            scanD.data['defaultTableSubHeader'] = templateD.data.defaultTableSubHeader;
                            scanD.data['columnCordinates'] = templateD.data.columnCordinates;
                            scanD.data['upperRowCountMerge'] = templateD.data.upperRowCountMerge;
                            scanD.data['subHeaderBreakWords'] = templateD.data.subHeaderBreakWords;
                            scanD.data['tableStartSubHeader'] = templateD.data.tableStartSubHeader;
                            scanD.data['currencyRegex'] = templateD.data.currencyRegex;
                            scanD.data['horizontalTable'] = templateD.data.horizontalTable;
                            scanD.data['subTableHeaders'] = templateD.data.subTableHeaders;
                            scanD.data['verticalTable'] = templateD.data.verticalTable;
                            scanD.data['subTableHeadersPattern'] = templateD.data.subTableHeadersPattern;
                            scanD.data['masterTableHorizontal'] = templateD.data.masterTableHorizontal;
                            scanD.data['subTableStart'] = templateD.data.subTableStart;
                            scanD.data['subTableEnd'] = templateD.data.subTableEnd;
                            templateName = templateD.data.templateName;
                            if (!util_1.isNullOrUndefined(templateD.data['multiTable']) && templateD.data['multiTable'].length > 0) {
                                scanD.data.tableMapping={};
                                scanD.data.tableStart=[];
                                scanD.data.tableEnd=[];
                                multiTableFlg = true;
                                scanD.data['multiTable'] = templateD.data.multiTable;
                                let mergedMapping = {};
                                let mergedStart = [];
                                let mergedEnd = [];
                                templateD.data['multiTable'].forEach((table,index) => {
                                    mergedMapping = { ...mergedMapping, ...table.tableMapping };
                                    if (!util_1.isNullOrUndefined(table.tableStart)) {
                                        if(table.tableStart.length==1){
                                            singleLenthTableStartInd.push(table.tableStart[0]);
                                        }
                                        table.tableStart.forEach(element => {
                                            if (!mergedStart.includes(element)) {
                                                mergedStart.push(element);
                                            }
                                        });
                                    }
                                    if (!util_1.isNullOrUndefined(table.tableEnd)) {
                                        table.tableEnd.forEach(element => {
                                            if (!mergedEnd.includes(element)) {
                                                mergedEnd.push(element);
                                            }
                                        });
                                    }

                                });
                                scanD.data.tableStart = mergedStart;
                                scanD.data.tableMapping = mergedMapping;
                                scanD.data.tableEnd = mergedEnd;
                            }
                        }
                    }
                    if (scanD.status == 1) {
                        throw err;
                    }
                    let scanData = scanD.data;
                    if (req.detectTable && (Object.keys(req.tableMapping).length != 0 || Object.keys(req.multiTable).length != 0)) {
                        scanData.tableMapping = req.tableMapping;      // if from fornt end mapping is provided then that mapping is used
                        scanData.tableStart = req.tableStart;
                        scanData.tableEnd = [];
                        if (req.tableEnd.length > 0) {
                            scanData.tableEnd.push(req.tableEnd);
                        }
                        if (!util_1.isNullOrUndefined(req['multiTable']) && req['multiTable'].length > 0) {
                            scanData.tableMapping={};
                            scanData.tableStart=[];
                            scanData.tableEnd=[];
                            multiTableFlg = true;
                            scanData['multiTable'] = req.multiTable;
                            let mergedMapping = {};
                            let mergedStart = [];
                            let mergedEnd = [];
                            req['multiTable'].forEach((table,index) => {
                                mergedMapping = { ...mergedMapping, ...table.tableMapping };
                                if (!util_1.isNullOrUndefined(table.tableStart)) {
                                    if(table.tableStart.length==1){
                                        singleLenthTableStartInd.push(table.tableStart[0]);
                                    }
                                    table.tableStart.forEach(element => {
                                        if (!mergedStart.includes(element)) {
                                            mergedStart.push(element);
                                        }
                                    });
                                }

                                if (!util_1.isNullOrUndefined(table.tableEnd)) {
                                    table.tableEnd.forEach(element => {
                                        if (!mergedEnd.includes(element)) {
                                            mergedEnd.push(element);
                                        }
                                    });
                                }

                            });
                            scanData.tableStart = mergedStart;
                            scanData.tableMapping = mergedMapping;
                            scanData.tableEnd = mergedEnd;
                        }
                        if (!util_1.isNullOrUndefined(req['startsWith']) && req['startsWith'].length > 0) {
                            scanD.data['startsWith'] = req['startsWith'];
                        }
                        if (!util_1.isNullOrUndefined(req['endsWith']) && req['endsWith'].length > 0) {
                            scanD.data['endsWith'] = req['endsWith'];
                        }
                    }
                    if (util_1.isNullOrUndefined(scanData['multiTable']) || (!util_1.isNullOrUndefined(scanData['multiTable']) && scanData['multiTable'].length == 0)) {
                        let temp = scanData.tableStart.filter(function (x) { return x.length > 4; })
                        if (!util_1.isNullOrUndefined(temp) && temp.length > 4) {
                            scanData.tableStart = temp;
                        }
                    }
                    // scanData['startsWith']=["Ship"]
                    // scanData['endsWith']=["MUMBAI"] 
                    req.body.input.scanData = scanData;

                    if (req.body.input.useMapping && req.body.input.useMapping == true || req.body.input.useMapping == "true") {

                        let tableByLines = yield self.getTableFromLines(req.body.input);

                        if (tableByLines != 1) {
                            let outputData = { "identifyTable": tableByLines, "uploadStatus": true, 'statusCode': '200' };
                            let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                            let headers = { 'Authorization': token, 'content-type': "application/json" };
                            var options = {
                                method: 'POST',
                                url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                                headers: headers,
                                body: taskData,
                                json: true
                            };
                            process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                            if (req.detectTable) {
                            } else {
                                if (req.body.input.return)
                                    return outputData;
                                else
                                    yield self.ioWrite(options)
                            }
                            return 0;
                        }

                    }
                    let lastHeaders = [];
                    let contTable = false;
                    let idx = 0;
                    if (!util_1.isNullOrUndefined(req.currentPageNo)) {
                        idx = req.currentPageNo;
                    } else {
                        // idx=self.findStartOfTable(req,scanData);
                        let request = Object.assign({}, req)
                        // idx = self.findStartOfTable(request, scanData);
                    }
                    if (idx != 0) {
                        for (let index = 0; index < idx; index++) {
                            ruleObj = req.body.input.ruleObj[index];
                            identifyTableOutputArray.push(ruleObj);
                        }
                    }
                    if (!util_1.isNullOrUndefined(scanData.tableMapping)) {
                        console.log("mapping -----------------------------------------------------", JSON.stringify(scanData.tableMapping));
                    }
                    let remaining = []
                    let cord = [];
                    let tableobjectsCordinates=[];
                    for (let index = 0; index < req.body.input.ruleObj.length; index++) {
                        previousLines=[];
                        let horizontalLines = [];
                        let subTableLinesR = [];
                        let tableName = "";
                        let pageNumber="";
                        logger.info('Scanning fields data found successfully in IdentiffyTable');
                        if (!util_1.isNullOrUndefined(response['data']) && !util_1.isNullOrUndefined(response['data'][index]) && !util_1.isNullOrUndefined(response['data'][index]['tableStructureCordinates']) && response['data'][index]['tableStructureCordinates'].length > 0) {

                            tableColumns = self.getTableColumns(response['data'][index]);
                            console.log("tableColumns found-------------------------------->", JSON.stringify(tableColumns))
                        }
                        ruleObj = req.body.input.ruleObj[index];
                        if(ruleObj.obj.filePath){
                            let selectedPathArr=ruleObj.obj.filePath.split("/");
                            let selectedPath=selectedPathArr[selectedPathArr.length-1];
                            const regex = /_(\d+)\.png$/;
                            const match = regex.exec(selectedPath);
    
                            if (match && match[1]) {
                                pageNumber = match[1];
                                // console.log(`Page Number: ${pageNumber}`);
                              }
                        }
                        let path = ruleObj.obj.filePath.replace(/\_\d+\.png/, ".pdf")
                        if (path != "") {
                            cord = yield self.extractLines(path);
                            if ((!util_1.isNullOrUndefined(cord) && cord.length == 0) || util_1.isNullOrUndefined(cord)) {
                                console.log("-------------------vertical lines not found--------------------------------------------->");
                            } else {
                                console.log("-------------------vertical lines found--------------------------------------------->");
                            }
                        }
                        let perc = 1;
                        if ((!util_1.isNullOrUndefined(ruleObj.lineWithCombineWordsNew[0]) && !util_1.isNullOrUndefined(ruleObj.lineWithCombineWordsNew[0][0]['imageName'])) || scanD.data['masterTableHorizontal']) {
                            perc = 1
                            for (let i = 0; i < ruleObj.lineWithCombineWordsNew.length; i++) {
                                let line = ruleObj.lineWithCombineWordsNew[i];
                                let tempLine = [];
                                for (let index = 0; index < line.length; index++) {
                                    let element = line[index];
                                    let all = true;
                                    if (!util_1.isNullOrUndefined(scanD.data['currencyRegex']) && scanD.data['currencyRegex'] != "") {
                                        var currencyPattern = new RegExp(scanD.data['currencyRegex']);
                                        if (currencyPattern.test(element.Name)) {
                                            all = false;
                                        }
                                    }
                                    if (scanD.data['masterTableHorizontal'] && element.Name.length > 3) {
                                        let spAR = [];
                                        for (let index = 0; index < scanData.tableStart.length; index++) {
                                            const head = scanData.tableStart[index];
                                            spAR = element.Name.split(head);
                                        }
                                        if (spAR.length > 1 && spAR[1].trim() != "") {
                                            all = true;
                                        } else {
                                            all = false;
                                        }

                                    }
                                    if (/\s/.test(element.Name) && all) {
                                        let splitWords = element.Name.split(/\s/);
                                        if (splitWords.length > 1 && splitWords[1].trim() != "" && splitWords[0].trim() != "" && splitWords.length == 2) {
                                            let length = element.Name.length;
                                            let diff = element.rightX - element.leftX;
                                            let pixelPerLetter = diff / length;
                                            let elementLength = splitWords[0].length;
                                            let elementRightX = (element.leftX + (pixelPerLetter * elementLength)) - 2;
                                            //    let secondWordLength=splitWords[1].length;
                                            let secondWordLeftX = elementRightX + 2
                                            let obj1 = {
                                                Name: splitWords[0],
                                                bottomY: element.bottomY,
                                                leftX: element.leftX,
                                                pageNo: element.pageNo,
                                                rightX: elementRightX - 2,
                                                topY: element.topY
                                            };
                                            let obj2 = {
                                                Name: splitWords[1],
                                                bottomY: element.bottomY,
                                                leftX: secondWordLeftX,
                                                pageNo: element.pageNo,
                                                rightX: element.rightX,
                                                topY: element.topY
                                            };
                                            tempLine.push(obj1);
                                            tempLine.push(obj2);
                                        } else {
                                            let allow = true;
                                            let length = element.Name.length;
                                            let diff = element.rightX - element.leftX;
                                            let pixelPerLetter = diff / length;
                                            let lastRightX = -1;
                                            for (let index = 0; index < splitWords.length; index++) {
                                                const ele = splitWords[index];
                                                if (scanD.data.tableStart.indexOf(ele) > -1 || scanD.data['masterTableHorizontal']) {
                                                    allow = false;
                                                    if (index == 0) {
                                                        let obj = {
                                                            Name: splitWords[index],
                                                            bottomY: element.bottomY,
                                                            leftX: element.leftX,
                                                            pageNo: element.pageNo,
                                                            rightX: (element.leftX + (pixelPerLetter * splitWords[index].length)) - 2,
                                                            topY: element.topY
                                                        };
                                                        tempLine.push(obj);
                                                        lastRightX = (element.leftX + (pixelPerLetter * splitWords[index].length));
                                                    } else if (index == splitWords.length - 1) {
                                                        let obj = {
                                                            Name: splitWords[index],
                                                            bottomY: element.bottomY,
                                                            leftX: (element.rightX - (pixelPerLetter * splitWords[index].length)) + 2,
                                                            pageNo: element.pageNo,
                                                            rightX: element.rightX,
                                                            topY: element.topY
                                                        };
                                                        tempLine.push(obj);
                                                    } else {
                                                        let obj = {
                                                            Name: splitWords[index],
                                                            bottomY: element.bottomY,
                                                            leftX: lastRightX,
                                                            pageNo: element.pageNo,
                                                            rightX: (lastRightX + (pixelPerLetter * splitWords[index].length)) - 2,
                                                            topY: element.topY
                                                        };
                                                        tempLine.push(obj);
                                                        lastRightX = (lastRightX + (pixelPerLetter * splitWords[index].length));
                                                    }

                                                }

                                            }
                                            if (allow) {
                                                tempLine.push(element);
                                            }
                                        }

                                    } else {
                                        tempLine.push(element);
                                    }

                                }
                                ruleObj.lineWithCombineWordsNew[i] = tempLine;
                            }
                        }


                        let tableStartData = [];
                        let tableEndData = [];
                        let tableMapping = {};
                        let lastTopY = 0;
                        let height = 0;
                        let TableArray = [];
                        let lineArray = [];
                        let newLineflag = true;
                        let tableHeaders = [];
                        let tableHeadersW = [];
                        let tableHeadersNew = [];
                        let tableHeadersOrg = [];
                        let tableEnds = [];
                        let lastVal = "";
                        let validRows = [];
                        let startsWith = [];
                        let endsWith = [];
                        for (var k in scanData.tableMapping) {
                            tableHeadersW.push(k);
                            k = k.toLocaleUpperCase();
                            k = k.replace(/\s+/g, '');
                            tableHeaders.push(k);
                        }
                        if (!util_1.isNullOrUndefined(scanData.tableEnd)) {
                            for (let index = 0; index < scanData.tableEnd.length; index++) {
                                k = scanData.tableEnd[index];
                                k = k.toLocaleUpperCase();
                                k = k.replace(/\s+/g, '');
                                tableEnds.push(k);
                            }
                        } else {
                            scanData.tableEnd = [];
                        }
                        if (!util_1.isNullOrUndefined(scanData.startsWith)) {
                            for (let index = 0; index < scanData.startsWith.length; index++) {
                                k = scanData.startsWith[index];
                                k = k.toLocaleUpperCase();
                                k = k.replace(/\s+/g, '');
                                startsWith.push(k);
                            }
                        }
                        if (!util_1.isNullOrUndefined(scanData.endsWith)) {
                            for (let index = 0; index < scanData.endsWith.length; index++) {
                                k = scanData.endsWith[index];
                                k = k.toLocaleUpperCase();
                                k = k.replace(/\s+/g, '');
                                endsWith.push(k);
                            }
                        }
                        for (var k in scanData.tableMapping) {
                            tableHeadersW.push(k);
                            k = k.toLocaleUpperCase();
                            k = k.replace(/\s+/g, '');
                            k = k.replace(/[^a-zA-Z ]/g, "");
                            tableHeadersNew.push(k);
                        }
                        for (var k in scanData.tableMapping) {
                            tableHeadersW.push(k);
                            k = k.replace(/\s+/g, '');
                            k = k.replace(/[^a-zA-Z ]/g, "");
                            tableHeadersOrg.push(k);
                        }
                        if (!util_1.isNullOrUndefined(scanD.data['tableSubHeaders'])) {
                            for (let index = 0; index < scanD.data['tableSubHeaders'].length; index++) {
                                let k = scanD.data['tableSubHeaders'][index];
                                k = k.toLocaleUpperCase();
                                k = k.replace(/\s+/g, '');
                                tableHeadersNew.push(k);
                                tableHeaders.push(k);
                                tableHeadersOrg.push(k.replace(/[^a-zA-Z ]/g, ""));
                            }
                            // scanD.data['allowGarbage']=true;
                        }
                        if (!util_1.isNullOrUndefined(scanD.data['subHeaderBreakWords'])) {
                            for (let index = 0; index < scanD.data['subHeaderBreakWords'].length; index++) {

                                for (let key in scanD.data['subHeaderBreakWords'][index]) {
                                    if (scanD.data['subHeaderBreakWords'][index][key]['start'] != "") {
                                        let k = scanD.data['subHeaderBreakWords'][index][key]['start'];
                                        k = k.toLocaleUpperCase();
                                        k = k.replace(/\s+/g, '');
                                        tableHeadersNew.push(k);
                                        tableHeaders.push(k);
                                        tableHeadersOrg.push(k.replace(/[^a-zA-Z ]/g, ""));
                                    }

                                }
                                for (let key in scanD.data['subHeaderBreakWords'][index]) {
                                    if (scanD.data['subHeaderBreakWords'][index][key]['end'] != "") {
                                        let k = scanD.data['subHeaderBreakWords'][index][key]['end'];
                                        k = k.toLocaleUpperCase();
                                        k = k.replace(/\s+/g, '');
                                        tableHeadersNew.push(k);
                                        tableHeaders.push(k);
                                        tableHeadersOrg.push(k.replace(/[^a-zA-Z ]/g, ""));
                                    }
                                }



                            }
                        }
                        /////////////////////////////////////////////////////////////////////////////////////////
                        let additionalInfoTable = [];

                        additionalInfoTable = self.extractInfo(ruleObj);

                        for (let i = 0; i < ruleObj.lineWithCombineWordsNew.length; i++) {
                            let line = ruleObj.lineWithCombineWordsNew[i];
                            // let count=0;
                            let newLine = [];
                            for (let j = 0; j < line.length; j++) {
                                let obj = line[j];
                                let diff = obj.rightX - obj.leftX;
                                let wordLength = obj.Name.length;
                                let pixelPerWord = diff / wordLength;
                                pixelPerWord = (pixelPerWord + (pixelPerWord / 2))
                                for (let k = j + 1; k < line.length; k++) {
                                    let nextObj = line[k];
                                    let wordDiff = nextObj.leftX - obj.rightX;
                                    for (let m = 0; m < tableHeaders.length; m++) {
                                        let newName = obj.Name + " " + nextObj.Name;
                                        newName = newName.toLocaleUpperCase();
                                        newName = newName.replace(/\s+/g, '');
                                        newName = newName.replace(/[^a-zA-Z0-9\/\.\&\(\)\#@$-%]/g, "");

                                        if ((tableHeaders[m].includes(newName) || tableHeadersNew[m].includes(newName)) & newName.length > 2) {
                                            if (!/(\d)[(\,)(\.)]/.test(obj.Name.replace(/\)/g, '')) && !/(\d)[(\,)(\.)]/.test(nextObj.Name.replace(/\)/g, '')) && !(/^[^a-zA-Z0-9/&¥@$%]+$/.test(obj.Name) || /^[^a-zA-Z0-9/&¥@$#-%]+$/.test(nextObj.Name))) {
                                                wordDiff = 0;
                                            }
                                        }
                                    }
                                    if (wordDiff - 3 < pixelPerWord) {

                                        let allow = false;
                                        for (let m = 0; m < tableHeaders.length; m++) {
                                            let newName = obj.Name + " " + nextObj.Name;
                                            newName = newName.toLocaleUpperCase();
                                            newName = newName.replace(/\s+/g, '');
                                            newName = newName.replace(/[^a-zA-Z0-9\/\.\&\(\)\#@$-%]/g, "");

                                            if (((self.matchStr(tableHeaders, newName) && obj.Name.length>1 && nextObj.Name.length>1) || tableHeaders[m].includes(newName) || tableHeadersNew[m].includes(newName) || tableHeaders[m].includes(newName.replace(/[&\/-]/,""))) & newName.length > 2) {
                                                if (!/(\d)[(\,)(\.)]/.test(obj.Name.replace(/\)/g, '')) && !/(\d)[(\,)(\.)]/.test(nextObj.Name.replace(/\)/g, '')) && !(/^[^a-zA-Z0-9/&¥@$%]+$/.test(obj.Name) || /^[^a-zA-Z0-9/&¥@$#-%()]+$/.test(nextObj.Name))) {
                                                    allow = true;
                                                }
                                            }
                                            if(["/","&","-"].indexOf(nextObj.Name.trim())>-1 && m==tableHeaders.length-1 && !allow){

                                                if(k < line.length-1){
                                                     let nextObj=line[k+1];
                                                     let newName = obj.Name + " " + nextObj.Name;
                                                     newName = newName.toLocaleUpperCase();
                                                     newName = newName.replace(/\s+/g, '');
                                                     newName = newName.replace(/[^a-zA-Z0-9\/\.\&\(\)\#@$-%]/g, "");
                                                     for (let m = 0; m < tableHeaders.length; m++) {
                                                        if ((tableHeaders[m].includes(newName) || tableHeadersNew[m].includes(newName)) & newName.length > 2) {
                                                            allow = true;
                                                        }
                                                    }
                                                     
                                                }

                                            }
                                        }
                                        if(!allow){
                                            for (let m = 0; m < tableEnds.length; m++) {
                                                let newName = obj.Name + " " + nextObj.Name;
                                                newName = newName.toLocaleUpperCase();
                                                newName = newName.replace(/\s+/g, '');
                                                if ((self.matchStr(tableEnds, newName) || tableEnds[m].includes(newName)) && newName.length > 3) {
                                                    allow = true;
                                                }
                                            }
                                            for (let m = 0; m < startsWith.length; m++) {
                                                let newName = obj.Name + " " + nextObj.Name;
                                                newName = newName.toLocaleUpperCase();
                                                newName = newName.replace(/\s+/g, '');
                                                if ((self.matchStr(startsWith, newName) || startsWith[m].includes(newName)) && newName.length > 3) {
                                                    allow = true;
                                                }
                                            }
                                            for (let m = 0; m < endsWith.length; m++) {
                                                let newName = obj.Name + " " + nextObj.Name;
                                                newName = newName.toLocaleUpperCase();
                                                newName = newName.replace(/\s+/g, '');
                                                if ((self.matchStr(endsWith, newName) || endsWith[m].includes(newName)) && newName.length > 3) {
                                                    allow = true;
                                                }
                                            }
                                        }

                                        if (!allow && /^[0-9]+[,.0-9\s]+[0-9]+\.$/.test(obj.Name) && (/^[0-9]+\]$/.test(nextObj.Name) || /^[0-9]+$/.test(nextObj.Name))) {
                                            obj.Name = obj.Name + nextObj.Name;
                                            obj.Name = obj.Name.replace(/\:+/g, '');
                                            obj.rightX = nextObj.rightX;
                                            j = j + 1;
                                        }
                                        if (!allow && /^[0-9]+[,.0-9\s]+[0-9]+$/.test(obj.Name) && /\;$/.test(nextObj.Name)) {
                                            nextObj.Name = "";
                                        }
                                        if (allow && nextObj.Name != ":" && nextObj.Name != "|" && obj.Name != "|") {
                                            obj.Name = obj.Name + " " + nextObj.Name;
                                            obj.Name = obj.Name.replace(/\:+/g, '');
                                            obj.rightX = nextObj.rightX;
                                            obj['header'] = true;
                                            j = j + 1;
                                        } else {
                                            if (!util_1.isNullOrUndefined(ruleObj.lineWithCombineWordsNew[0]) && util_1.isNullOrUndefined(ruleObj.lineWithCombineWordsNew[0][0]['imageName'])) {
                                                if (!allow && /^[a-zA-Z\s]+$/.test(obj.Name) && nextObj.Name == "-") {
                                                    obj.Name = obj.Name + ' ' + nextObj.Name;
                                                    obj.Name = obj.Name.replace(/\:+/g, '');
                                                    obj.rightX = nextObj.rightX;
                                                    j = j + 1;
                                                } else if (!allow && /^[a-zA-Z\s]+$/.test(nextObj.Name) && /[a-zA-Z]+\s\-$/.test(obj.Name)) {
                                                    obj.Name = obj.Name + ' ' + nextObj.Name;
                                                    obj.Name = obj.Name.replace(/\:+/g, '');
                                                    obj.rightX = nextObj.rightX;
                                                    j = j + 1;
                                                } else {
                                                    break;
                                                }
                                            } else {
                                                break;
                                            }
                                        }


                                    } else {
                                        break;
                                    }

                                }
                                if (newLine.length > 0 && obj['header']) {
                                    newLine[0]['header'] = true;
                                }
                                newLine.push(obj);

                            }
                            ruleObj.lineWithCombineWordsNew[i] = newLine;

                        }

                        let tempLineCombineWords = [];
                        let startFound = false;
                        let endFound = false;
                        for (let i = 0; i < ruleObj.lineWithCombineWordsNew.length; i++) {
                            let line = ruleObj.lineWithCombineWordsNew[i];
                            let allow = true;
                            for (let j = 0; j < line.length; j++) {
                                let obj = line[j];
                                if (!util_1.isNullOrUndefined(scanD.data['startsWith']) && (scanD.data['startsWith'].indexOf(obj['Name']) > -1 || self.checkInd(scanD.data['startsWith'], obj['Name']))) {
                                    startFound = true;
                                }
                                if (!util_1.isNullOrUndefined(scanD.data['endsWith']) && (scanD.data['endsWith'].indexOf(obj['Name']) > -1 || self.checkInd(scanD.data['endsWith'], obj['Name']))) {
                                    endFound = true;
                                }
                                if (!util_1.isNullOrUndefined(scanD.data['startsWith']) && (scanD.data['startsWith'].indexOf(obj['Name']) > -1 || self.checkInd(scanD.data['startsWith'], obj['Name'])) &&

                                    !util_1.isNullOrUndefined(scanD.data['endsWith']) && (scanD.data['endsWith'].indexOf(obj['Name']) > -1 || self.checkInd(scanD.data['endsWith'], obj['Name']))) {
                                    allow = false;
                                }

                                if (startFound && !endFound) {
                                    allow = false;
                                }
                                if (startFound && endFound) {
                                    allow = false;
                                }
                            }
                            if (allow) {
                                tempLineCombineWords.push(line);
                            }
                            if (endFound) {
                                startFound = false;
                                endFound = false;
                            }
                        }
                        if (tempLineCombineWords.length > 0) {
                            ruleObj.lineWithCombineWordsNew = tempLineCombineWords;
                        }
                        // for (let i = 0; i < ruleObj.lineWithCombineWordsNew.length; i++) {
                        //     let line = ruleObj.lineWithCombineWordsNew[i];
                        //     // let count=0;
                        //     let newLine = [];
                        //     for (let j = 0; j < line.length; j++) {
                        //         let obj = line[j];
                        //         let diff = obj.rightX - obj.leftX;
                        //         let wordLength = obj.Name.length;
                        //         let pixelPerWord = diff / wordLength;
                        //         pixelPerWord = (pixelPerWord + (pixelPerWord / 2))
                        //         for (let k = j + 1; k < line.length; k++) {
                        //             let nextObj = line[k];
                        //             let wordDiff = nextObj.leftX - obj.rightX;
                        //             if (wordDiff < pixelPerWord) {
                        //                 let allow = false;
                        //                 for (let m = 0; m < tableHeaders.length; m++) {
                        //                     let newName = obj.Name + " " + nextObj.Name;
                        //                     newName = newName.toLocaleUpperCase();
                        //                     newName = newName.replace(/\s+/g, '');
                        //                     newName = newName.replace(/[^a-zA-Z ]/g, "");
                        //                     if ((tableHeaders[m].includes(newName) || tableHeadersNew[m].includes(newName)) & newName.length > 3) {
                        //                         if (!(/^[^a-zA-Z]+$/.test(obj.Name) || /^[^a-zA-Z]+$/.test(nextObj.Name))) {
                        //                             allow = true;
                        //                         }
                        //                     }
                        //                 }
                        //                 if (allow) {
                        //                     obj.Name = obj.Name + " " + nextObj.Name;
                        //                     obj.rightX = nextObj.rightX;
                        //                     j = j + 1;
                        //                 }
                        //             }

                        //         }
                        //         newLine.push(obj);

                        //     }
                        //     ruleObj.lineWithCombineWordsNew[i] = newLine;

                        // }

                        ////////////////////////////////////////////////////////////////////////////////////////    

                        let lineWithCombineWordsNew = 0;
                        let lineWithCombineWords = 0;
                        let headIndex = -1;
                        let headIndexes = [];
                        for (let i = 0; i < ruleObj.lineWithCombineWordsNew.length; i++) {
                            let line = ruleObj.lineWithCombineWordsNew[i];
                            let count = 0;
                            for (let j = 0; j < line.length; j++) {
                                let k = (line[j].Name.toLocaleUpperCase()).replace(/\s+/g, '');
                                if (tableHeaders.indexOf(k) != -1 && !(/\d+\,+\d+/.test(lastVal)) && !(/\d+\,+\d+/.test(line[j].Name)) && /\s+/.test(line[j].Name)) {
                                    lineWithCombineWordsNew = lineWithCombineWordsNew + 1;
                                }
                                if (tableHeaders.indexOf(k) != -1 && !(/\d+\,+\d+/.test(lastVal)) && !(/\d+\,+\d+/.test(line[j].Name))) {
                                    count = count + 1;
                                    if (count > 3 && count == line.length - 1) {
                                        lineWithCombineWordsNew = 100;
                                        // headIndex = i;
                                    }
                                }
                            }
                        }
                        for (let i = 0; i < ruleObj.lineWithCombineWords.length; i++) {
                            let line = ruleObj.lineWithCombineWords[i];
                            let count = 0;
                            for (let j = 0; j < line.length; j++) {
                                let k = (line[j].Name.toLocaleUpperCase()).replace(/\s+/g, '');
                                if (tableHeaders.indexOf(k) != -1 && !(/\d+\,+\d+/.test(lastVal)) && !(/\d+\,+\d+/.test(line[j].Name)) && /\s+/.test(line[j].Name)) {
                                    lineWithCombineWords = lineWithCombineWords + 1;
                                }
                                if (tableHeaders.indexOf(k) != -1 && !(/\d+\,+\d+/.test(lastVal)) && !(/\d+\,+\d+/.test(line[j].Name))) {
                                    count = count + 1;
                                    headIndexes.push(i);
                                    if (count > 3 && (count / line.length) > 0.65) {
                                        if (headIndex == -1) {
                                            headIndex = i;
                                        }
                                    }
                                }
                            }
                        }
                        // if (lineWithCombineWords >= lineWithCombineWordsNew) {
                        // ruleObj.lineWithCombineWordsNew = ruleObj.lineWithCombineWords;
                        // }
                        /////////////////////////////////////////////////////////////////
                        for (let i = 0; i < ruleObj.lineWithCombineWordsNew.length; i++) {
                            let line = ruleObj.lineWithCombineWordsNew[i];
                            if (i < ruleObj.lineWithCombineWordsNew.length - 1) {
                                for (let a = 0; a < line.length; a++) {
                                    let currentObj = line[a];
                                    for (let c = i + 1; c < ruleObj.lineWithCombineWordsNew.length; c++) {
                                        let nextLine = ruleObj.lineWithCombineWordsNew[c];
                                        if (c - i > 0 && c - i < 7) {
                                            break;
                                        }
                                        for (let b = 0; b < nextLine.length; b++) {
                                            let nextObj = nextLine[b];
                                            let newName = currentObj.Name + " " + nextObj.Name;
                                            for (let m = 0; m < tableHeaders.length; m++) {
                                                newName = newName.toLocaleUpperCase();
                                                newName = newName.replace(/\s+/g, '');
                                                newName = newName.replace(/[^a-zA-Z0-9]/g, "");
                                                let allow = false;
                                                if (!(/^[^a-zA-Z]+$/.test(currentObj.Name) || /^[^a-zA-Z()]+$/.test(nextObj.Name))) {
                                                    allow = true;
                                                }
                                                if (allow) {
                                                    let newNameOrg = currentObj.Name + " " + nextObj.Name;
                                                    newNameOrg = newNameOrg.replace(/\s+/g, '');
                                                    newNameOrg = newNameOrg.replace(/[^a-zA-Z0-9]/g, "");
                                                    if (!tableHeadersOrg[m].includes(newNameOrg)) {
                                                        allow = false;
                                                    }
                                                }
                                                if (!((nextObj.rightX > currentObj.leftX && nextObj.leftX < currentObj.rightX) || (nextObj.leftX == currentObj.leftX) || (nextObj.rightX == currentObj.rightX))) {
                                                    allow = false;
                                                }
                                                if (nextObj.Name == ".") {
                                                    allow = false;
                                                }
                                                if ((tableHeaders[m].includes(newName) || tableHeadersNew[m].includes(newName)) & newName.length > 3 && c - i < 6 && allow && !/^\d+$/.test(nextLine[0]['Name']) && !/\d+$/.test(nextLine[nextLine.length - 1]['Name'])) {
                                                    currentObj['allowMerge'] = true;
                                                    nextObj['allowMerge'] = true;
                                                    line[0]['allowMerge'] = true;
                                                    nextLine[0]['allowMerge'] = true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        // for (let i = 0; i < ruleObj.lineWithCombineWordsNew.length; i++) {
                        //     let line = ruleObj.lineWithCombineWordsNew[i];
                        //     if (i < ruleObj.lineWithCombineWordsNew.length - 2) {
                        //         for (let a = 0; a < line.length; a++) {
                        //             let currentObj = line[a];
                        //             let nextLine = ruleObj.lineWithCombineWordsNew[i + 2];
                        //             for (let b = 0; b < nextLine.length; b++) {
                        //                 let nextObj = nextLine[b];
                        //                 let newName = currentObj.Name + " " + nextObj.Name;
                        //                 for (let m = 0; m < tableHeaders.length; m++) {
                        //                     newName = newName.toLocaleUpperCase();
                        //                     newName = newName.replace(/\s+/g, '');
                        //                     newName = newName.replace(/[^a-zA-Z0-9]/g, "");
                        //                     let allow = false;
                        //                     if (!(/^[^a-zA-Z]+$/.test(currentObj.Name) || /^[^a-zA-Z]+$/.test(nextObj.Name))) {
                        //                         allow = true;
                        //                     }
                        //                     if (allow) {
                        //                         let newNameOrg = currentObj.Name + " " + nextObj.Name;
                        //                         newNameOrg = newNameOrg.replace(/\s+/g, '');
                        //                         newNameOrg = newNameOrg.replace(/[^a-zA-Z0-9]/g, "");
                        //                         if (!tableHeadersOrg[m].includes(newNameOrg)) {
                        //                             allow = false;
                        //                         }
                        //                     }
                        //                     if (!((nextObj.rightX > currentObj.leftX && nextObj.leftX < currentObj.rightX) || (nextObj.leftX == currentObj.leftX) || (nextObj.rightX == currentObj.rightX))) {
                        //                         allow = false;
                        //                     }
                        //                     if (nextObj.Name == ".") {
                        //                         allow = false;
                        //                     }
                        //                     if ((tableHeaders[m].includes(newName) || tableHeadersNew[m].includes(newName)) & newName.length > 3 && allow && !/^\d+$/.test(nextLine[0]['Name']) && !/\d+$/.test(nextLine[nextLine.length - 1]['Name'])) {
                        //                         currentObj['allowMerge'] = true;
                        //                         nextObj['allowMerge'] = true;
                        //                         let prevLine = ruleObj.lineWithCombineWordsNew[i + 1];
                        //                         if (prevLine.length > 0) {
                        //                             prevLine[0]['allowMerge'] = true;
                        //                         }
                        //                         line[0]['allowMerge'] = true;
                        //                         nextLine[0]['allowMerge'] = true;
                        //                     }
                        //                 }
                        //             }
                        //         }
                        //     }
                        // }
                        ////////////////////////////////////////////////////////////////
                        for (let i = 0; i < ruleObj.lineWithCombineWordsNew.length; i++) {
                            let line = ruleObj.lineWithCombineWordsNew[i];
                            ////////////////////////////////////////////////////////////////////////////////////
                            let allowMerge = false;
                            let currentLineAllowMerge = false;
                            if (i > 0) {
                                let lastLine = ruleObj.lineWithCombineWordsNew[i - 1];
                                if (lastLine && lastLine[0] && lastLine[0]['allowMerge'] && line && line[0] && line[0]['allowMerge']) {
                                    allowMerge = true;
                                }
                                if (line && line[0] && line[0]['allowMerge']) {
                                    currentLineAllowMerge = true;
                                }
                            }

                            ///////////////////////////////////////////////////////////////////////////////////
                            for (let j = 0; j < line.length; j++) {
                                if (j == 0) {
                                    if (lastTopY > 0) {
                                        height = line[j].bottomY - line[j].topY;
                                        let val = (line[j].topY - lastTopY);
                                        if (val < 0) {
                                            let k = (line[j].Name.toLocaleUpperCase()).replace(/\s+/g, '');
                                            let newLastVal = (lastVal.toLocaleUpperCase()).replace(/\s+/g, '');
                                            let chk = self.chkConcat(line, TableArray, tableHeaders)
                                            if (((Math.abs(val)) / 2) > height) {
                                                newLineflag = true;
                                                if (chk || allowMerge) {
                                                    if (currentLineAllowMerge && !allowMerge) {
                                                        newLineflag = true;
                                                    } else {
                                                        newLineflag = false;
                                                    }
                                                }
                                            } else {
                                                newLineflag = false;
                                                if(ruleObj.lineWithCombineWordsNew.length>1){
                                                  let lastLine=ruleObj.lineWithCombineWordsNew[i-1];
                                                  for (let index = 0; index < lastLine.length; index++) {
                                                    let element = lastLine[index];
                                                    for (let l = 0; l < tableHeaders.length; l++) {
                                                        const ele = tableHeaders[l];
                                                        let newName = element["Name"].toLocaleUpperCase();
                                                        newName = newName.replace(/\s+/g, '');
                                                        newName = newName.replace(/[^a-zA-Z0-9]/g, "");
                                                        if(newName.length>2 && ele.includes(newName) && headIndex == i){
                                                            allowMerge=true;
                                                            break;
                                                        }
                                                    }
                                                    
                                                  }
                                                }
                                                if (headIndex == i && !allowMerge && headIndexes.indexOf(i - 1) == -1) {
                                                    newLineflag = true;;
                                                }
                                                if (!allowMerge && /(\d)[(\,)(\.)]/.test(lastVal.replace(/\)/g, ''))) {
                                                    newLineflag = true;
                                                }
                                                if (i > 0 && headIndexes.indexOf(i - 1) != -1 && headIndexes.indexOf(i) != -1) {
                                                    newLineflag = false;
                                                }
                                                if (line.length == 1 && line[0]['Name'] == ".") {
                                                    newLineflag = true;
                                                }
                                                // if(i>0 && i<ruleObj.lineWithCombineWordsNew.length-1 && headIndexes.indexOf(i-1)==-1 && headIndexes.indexOf(i)==-1 && headIndexes.indexOf(i+1)==-1){
                                                //     newLineflag = true;;
                                                // }
                                                // if (!chk) {
                                                //     newLineflag = true;
                                                // }
                                                // if (!chk && line[j].Name && tableHeaders.indexOf(line[j].Name.toLocaleUpperCase().replace(/\s+/g, '') > -1)) {
                                                //     newLineflag = true;
                                                // }
                                                // else {
                                                //     newLineflag = false;
                                                // }
                                            }
                                        } else {
                                            if ((i > 0 && ruleObj.lineWithCombineWordsNew[i - 1].length > 0 && ruleObj.lineWithCombineWordsNew[i - 1][0].Name.trim() == "" && ruleObj.lineWithCombineWordsNew[i - 1].length == 1)
                                                || (!isNaN(ruleObj.lineWithCombineWordsNew[i][0].Name))) {
                                                if (!allowMerge) {
                                                    newLineflag = true;
                                                } else {
                                                    if (currentLineAllowMerge && !allowMerge) {
                                                        newLineflag = true;
                                                    } else {
                                                        newLineflag = false;
                                                    }
                                                }
                                            } else {
                                                let k = (line[j].Name.toLocaleUpperCase()).replace(/\s+/g, '');
                                                let chk = self.chkConcat(line, TableArray, tableHeaders)
                                                if ((Math.round((val / height) * 100) <= 45 && tableHeaders.indexOf(k) == -1 && !(/^\d+$/.test(lastVal)) && !(/\d+\,+\d+|\d+\.+\d+/.test(lastVal)) && !(/^\$\d+/.test(lastVal)) && !(/\d+\,+\d+/.test(line[j].Name)) && !/(\d)[(\,)(\.)]/.test(lastVal.replace(/\)/g, ''))) || chk) {
                                                    let newLastVal = (lastVal.toLocaleUpperCase()).replace(/\s+/g, '');
                                                    if (!chk && !allowMerge) {
                                                        newLineflag = true;
                                                    } else {
                                                        if (currentLineAllowMerge && !allowMerge) {
                                                            newLineflag = true;
                                                        } else {
                                                            newLineflag = false;
                                                        }
                                                    }
                                                } else {
                                                    if (!allowMerge) {
                                                        newLineflag = true;
                                                    } else {
                                                        if (currentLineAllowMerge && !allowMerge) {
                                                            newLineflag = true;
                                                        } else {
                                                            newLineflag = false;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                if (j == line.length - 1) {
                                    if (line[j].bottomY < line[0].bottomY) {
                                        lastTopY = line[j].bottomY;
                                        lastVal = line[j].Name;
                                    } else {
                                        lastTopY = line[0].bottomY;
                                        lastVal = line[j].Name;
                                    }
                                }
                                // lineArray.push(line[j].Name)
                                lineArray.push(line[j]);
                            }
                            // if (currentLineAllowMerge && !allowMerge) {
                            //     newLineflag = true;
                            // } else if(allowMerge && currentLineAllowMerge) {
                            //     newLineflag = false;
                            // }else{
                            //     newLineflag = true;
                            // }
                            if (newLineflag) {
                                TableArray.push(lineArray);
                                lineArray = [];
                            } else {
                                let arr = JSON.parse(JSON.stringify(TableArray[TableArray.length - 1]));
                                let result = self.findOverLapping(arr, lineArray, tableHeaders, scanD);
                                if (!result.duplicateFound) {
                                    TableArray[TableArray.length - 1] = result.arr;
                                    if (!util_1.isNullOrUndefined(result['lineE']) && result['lineE'].length > 0) {
                                        TableArray.push(result['lineE']);
                                    }
                                    lineArray = [];
                                } else {
                                    TableArray.push(lineArray);
                                    lineArray = [];
                                }
                            }
                        }
                        for (let i = 0; i < TableArray.length; i++) {
                            // let line = TableArray[i];
                            TableArray[i].sort(function (a, b) {
                                return a.leftX - b.leftX;
                            });

                            // for (let j = 0; j < TableArray[i].length - 1; j++) {
                            //     if (TableArray[i][j].rightX >= TableArray[i][j + 1].leftX) {
                            //       // Swap elements if rightX is greater than or equal to the next leftX
                            //       [TableArray[i][j], TableArray[i][j + 1]] = [TableArray[i][j + 1], TableArray[i][j]];
                            //     }
                            // }
                        }

                        let tableStart = scanData.tableStart;
                        let tableEnd = scanData.tableEnd;
                        let upperCaseStart = tableStart.map(function (value) {
                            value = !util_1.isNullOrUndefined(value) ? value : "";
                            return value.replace(/\s/g, '').toUpperCase();
                        });
                        let upperCaseStartSinleLength = singleLenthTableStartInd.map(function (value) {
                            value = !util_1.isNullOrUndefined(value) ? value : "";
                            return value.replace(/\s/g, '').toUpperCase();
                        });
                        let upperCaseEnd = tableEnd.map(function (value) {
                            return value.replace(/\s/g, '').toUpperCase();
                        });
                        // console.log("tableArray---", JSON.stringify(TableArray))
                        let tables = [];
                        let count = 0;
                        let countEnd = 0;
                        let startIndex = -1;
                        let endIndex = 0;
                        let tablesFinal = [];
                        let multiTables = [];
                        let newEndIndex = -1;
                        let mlCordinates = {
                            // bottomY:2466
                        }
                        let headerIdexes = [];
                        if (!util_1.isNullOrUndefined(scanD.data['tableStartSubHeader']) && scanD.data['tableStartSubHeader'].length > 0) {
                            upperCaseStart = [];
                            upperCaseStart = scanD.data['tableStartSubHeader'].map(function (value) {
                                value = !util_1.isNullOrUndefined(value) ? value : "";
                                return value.replace(/\s/g, '').toUpperCase();
                            });
                        }
                        let singleHeader=false;
                        for (let i = 0; i < TableArray.length; i++) {
                            let line = TableArray[i];
                            // let names =_.pluck(line, 'Name')
                            count = 0;
                            countEnd = 0;
                            let tableStarts = []
                            let sameStartEnd=false;
                            for (let j = 0; j < line.length; j++) {
                                let length = 3
                                if (line[j].Name.indexOf(".") > -1) {
                                    length = 3;
                                }
                                let startMatched=false;
                                if ((self.matchStart(tableStart, line[j].Name.replace(/@@n|:/g, '')) || upperCaseStart.indexOf(line[j].Name.replace(/@@n|\s|:/g, "").toUpperCase()) > -1) && line[j].Name.length > length || (!util_1.isNullOrUndefined(scanD.data['tableStartSubHeader']) && scanD.data['tableStartSubHeader'].length > 0 &&
                                    self.matchStart(scanD.data['tableStartSubHeader'], line[j].Name.replace(/@@n/g, '')))) {
                                    //console.log('start----------------------------@@@@@@@@@@@@@@@@@@');
                                    if (tableStarts.indexOf(line[j].Name) == -1) {
                                        tableStarts.push(line[j].Name)
                                    }
                                    if (tableStarty != 0 && tableEndY != 0 && (tableStarty <= line[j]['topY'] && tableEndY >= line[j]['bottomY'])) {
                                        startMatched=true;
                                        count++;
                                        tableStartData.push(line[j].Name);

                                        if(upperCaseStartSinleLength.indexOf(line[j].Name.replace(/@@n|\s|:/g, "").toUpperCase())>-1 && util_1.isNullOrUndefined(line[j]['singleHeader'])){
                                            count=count+1;
                                            let all=false;
                                            line.forEach((obj) => {

                                                if(/\:/.test(obj.Name)){
                                                    all=true;
                                                }
                                            
                                            })
                                            if(all){
                                                singleHeader=true;
                                                line[j]['singleHeader']=true;
                                            }
                                        }
                                    } else if (tableStarty == 0 || tableEndY == 0) {
                                        startMatched=true;
                                        count++;
                                        tableStartData.push(line[j].Name);
                                        if (scanD.data['masterTableHorizontal']) {
                                            count++;
                                        }
                                        if(upperCaseStartSinleLength.indexOf(line[j].Name.replace(/@@n|\s|:/g, "").toUpperCase())>-1 && util_1.isNullOrUndefined(line[j]['singleHeader'])){
                                            count=count+1;
                                            let all=false;
                                            line.forEach((obj) => {

                                                if(/\:/.test(obj.Name)){
                                                    all=true;
                                                }
                                            
                                            })
                                            if(all){
                                                singleHeader=true;
                                                line[j]['singleHeader']=true;
                                            }

                                        }
                                    }
                                    if (util_1.isNullOrUndefined(line[0].continue)) {
                                        columnCordinates = [];
                                    }
                                }
                                if (self.matchEnd(tableEnd, line[j].Name.replace(/@@n/g, '')) || upperCaseEnd.indexOf(line[j].Name.replace(/@@n|\s/g, "").toUpperCase()) > -1 || line[j].Name.toUpperCase().indexOf('HEREBY') > -1 || line[j].Name.toUpperCase().indexOf('HANDLING & DELIVERY CHARGES') > -1 ||
                                    line[j].Name.toUpperCase().indexOf('HANDLING &') > -1 || line[j].Name.toUpperCase().indexOf('TOTAL AMOUNT IN WORDS') > -1) {
                                    //console.log('end----------------------------@@@@@@@@@@@@@@@@@@');
                                    if (tableStarty != 0 && tableEndY != 0 && (tableStarty >= line[j]['topY'] && tableEndY <= line[j]['bottomY'])) {
                                        countEnd++;
                                        ///////////////////////////////////////////////////////////
                                        if (countEnd > 0 && countEnd<2 && startIndex != i && tableEndData.indexOf(line[j].Name)==-1) {
                                            if(startMatched){
                                                sameStartEnd=true;
                                            }
                                            let tableEndObj={}
                                            tableEndObj['leftX']=line[j].leftX;
                                            tableEndObj['rightX']=line[j].rightX;
                                            tableEndObj['topY']=line[j].topY;
                                            tableEndObj['bottomY']=line[j].bottomY;
                                            tableEndObj['Name']=line[j].Name;
                                            tableEendObj['pageNo']=pageNumber;
                                            tableEndCordinates.push(tableEndObj);
                                        }
                                        //////////////////////////////////////////////////////////
                                        tableEndData.push(line[j].Name);
                                        if(singleHeader){
                                            singleHeader=false
                                        }
                                    } else if ((tableStarty == 0 || tableEndY == 0) && startIndex != -1 && !(i-startIndex<2 && j<line.length-1 && /\:$/.test(line[j+1].Name))) {
                                        countEnd++;
                                        /////////////////////////////////////////////////////
                                        if (countEnd > 0 && countEnd<2 && startIndex != i && tableEndData.indexOf(line[j].Name)==-1) {
                                            if(startMatched){
                                                sameStartEnd=true;
                                            }
                                            let tableEndObj={}
                                            tableEndObj['leftX']=line[j].leftX;
                                            tableEndObj['rightX']=line[j].rightX;
                                            tableEndObj['topY']=line[j].topY;
                                            tableEndObj['bottomY']=line[j].bottomY;
                                            tableEndObj['Name']=line[j].Name;
                                            tableEndObj['pageNo']=pageNumber;
                                            tableEndCordinates.push(tableEndObj);
                                        }
                                        ////////////////////////////////////////////////////
                                        tableEndData.push(line[j].Name);
                                        if(singleHeader){
                                            singleHeader=false
                                        }

                                    } else if(singleHeader){
                                        if(count>1){
                                            if (tablesFinal.length > 0) {
                                                multiTables.push(tablesFinal);
                                            }
                                            tablesFinal = [];
                                            // tablesFinal.push(line);
                                            // startIndex = i;
                                        }else{
                                            singleHeader=false
                                            countEnd++;
                                            tableEndData.push(line[j].Name);
                                        }

                                    }
                                }

                                if (!util_1.isNullOrUndefined(mlCordinates.bottomY) && mlCordinates.bottomY < line[j].topY && startIndex != -1) {
                                    countEnd = 2;
                                }
                                if(count==1 && startIndex == -1 && j == line.length-1 && tableStartData.length>0){
                                    if(/\:$/.test(tableStartData[0]) && i < TableArray.length-1 && tableStartData[0].length>3){
                                        let nextLine=TableArray[i+1]
                                        if(nextLine.length==1){
                                            for (let index = 0; index < nextLine.length; index++) {
                                                let element = nextLine[index];
                                                if(element.Name.length>3 && upperCaseStart.indexOf(element.Name.replace(/@@n|\s|:/g, "").toUpperCase()) > -1){
                                                    count++;
                                                    tableStartData.push(element.Name);
                                                    line[0]['singleHeader']=true;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            if (count > 1 && startIndex == -1) {
                                // console.log('table found----------------------------@@@@@@@@@@@@@@@@@@', i);
                                startIndex = i;
                                if(i>0){
                                    previousLines.push(TableArray[i-1]);
                                }
                                if (tableStarts.length > 1 && headerIdexes.indexOf(i) == -1) {
                                    headerIdexes.push(i);
                                }
                                // columnCordinates=[];
                            } else if (!singleHeader && count > 1 && headerIdexes.length > 0 && !(!util_1.isNullOrUndefined(scanD.data['tableStartSubHeader']) && scanD.data['tableStartSubHeader'].length > 0) &&
                                !(!util_1.isNullOrUndefined(scanD.data['subTableStart']) && scanD.data['subTableStart'].length > 0)) {
                                if (headerIdexes.length > 0) {
                                    if (!(TableArray[startIndex].length == line.length && TableArray[startIndex]['pageNo'] == line['pageNo'])) {
                                        if(sameStartEnd){
                                            if (tablesFinal.length > 0) {
                                                multiTables.push(tablesFinal);
                                            }
                                        }
                                        startIndex = i;
                                        if (tableStarts.length > 1 && headerIdexes.indexOf(i) == -1) {
                                            headerIdexes.push(i);
                                        }
                                        tablesFinal = [];
                                        // tableEndCordinates.push(line)

                                    }
                                }
                            }
                            if (countEnd > 0 && startIndex != i) {
                                // console.log('table end found----------------------------@@@@@@@@@@@@@@@@@@', i);
                                endIndex = i;
                                startIndex = -1;
                                if (tablesFinal.length > 0) {
                                    multiTables.push(tablesFinal);
                                }
                                tablesFinal = [];
                                // tableEndCordinates.push(line)
                                if (newEndIndex == -1) {
                                    newEndIndex = i;
                                }
                            }
                            if (startIndex > -1) {
                                tablesFinal.push(line);
                            }
                        }
                        if (multiTables.length == 0 && tablesFinal.length > 0) {
                            multiTables.push(tablesFinal);
                        } else if (tablesFinal.length > 0) {
                            multiTables.push(tablesFinal);
                        }
                        if (((tableEndData.length == 0) || (multiTableFlg && multiTables.length!=tableEndData.length)) && index < req.body.input.ruleObj.length - 1) {
                            if (req.body.input.ruleObj[index + 1].lineWithCombineWordsNew && req.body.input.ruleObj[index + 1].lineWithCombineWords && tablesFinal[0]) {
                                let header = JSON.parse(JSON.stringify(tablesFinal[0]))
                                req.body.input.ruleObj[index + 1].lineWithCombineWordsNew.unshift(header)
                                if (header.length > 0) {
                                    header[0]['continue'] = true;
                                }
                                req.body.input.ruleObj[index + 1].lineWithCombineWords.unshift(header)
                            }
                        }
                        //console.log('---------------------------------------------------------------------');
                        let TableObject = [];
                        let obj;
                        if (multiTables.length == 0 && newEndIndex > -1 && !(!util_1.isNullOrUndefined(scanD.data['tableStartSubHeader']) && scanD.data['tableStartSubHeader'].length > 0)) {
                            TableArray.splice(newEndIndex, TableArray.length - 1);
                            TableArray.splice(0, 0, lastHeaders);
                            multiTables = [TableArray];
                            contTable = true;
                        } else {
                            contTable = false;
                        }
                        let multi=false;
                        if (!util_1.isNullOrUndefined(scanD.data['multiTable']) && scanD.data['multiTable'].length > 0) {
                            multi=true;
                        }
                        if (multiTables.length > 0 && multiTables[0].length > 0 && multiTables.length < 2 && !multi) {
                            // tables=multiTables[0];
                            let tab = multiTables[0];
                            // if (!util_1.isNullOrUndefined(scanD.data['tableStartSubHeader']) && scanD.data['tableStartSubHeader'].length > 0 && tab.length > 1) {
                            //     tab.unshift(tab[1])
                            // }
                            let headers = tab[0];
                            lastHeaders = headers;

                            //For Duplicate Column Names
                            if (ruleObj && ruleObj.obj && ruleObj.obj.documentType == "Balance_Sheet") {
                                //For Duplicate Column Names
                                let hKeys = [];
                                for (let i of lastHeaders) {
                                    if (hKeys.includes(i.Name)) {
                                        count++;
                                        i.Name = i.Name + i.Name;
                                    }
                                    hKeys.push(i.Name);
                                }
                            }

                            if (additionalInfoTable.length > 0 && headers.length < tableStart.length) {
                                self.fixTableHeaders(headers, multiTables[0], upperCaseStart);
                            }
                            tables = self.mergeTableRows(multiTables[0], scanData.tableMapping);
                            //  let headers = this.combineTableHeaders(tables[0])
                            let length = 0
                            if (tab.length > 2) {
                                length = tab[2].length;
                            }
                            if (tab.length == 2) {
                                length = tab[1].length;
                            }
                            // for (let k = 0; k < headers.length; k++) {
                            //     headers[k].Name = headers[k].Name.replace(/\./g, ' ');
                            // }
                            headers = headers.filter(function (x) { return x['Name'] != "%"; })
                            // console.log("headers--------------------------", headers);
                            // console.log("tablemapping----------------------", tableMapping);
                            // console.log("scandata.tablemapinggg---------------", scanData.tableMapping);
                            let returnObj;
                            if (!util_1.isNullOrUndefined(scanData.multiTable) && scanData.multiTable.length > 0) {
                                let bestMatchingTable = null;
                                let maxMatches = -1;

                                scanData.multiTable.forEach(table => {
                                    let matches = 0;
                                    if(!util_1.isNullOrUndefined(table.tableMapping)){
                                        Object.keys(table.tableMapping).forEach(key => {
                                            if (headers.some(header => header.Name === key)) {
                                                matches++;
                                            }
                                        });
                                    }
                                    if (matches > maxMatches) {
                                        maxMatches = matches;
                                        bestMatchingTable = table;
                                    }
                                });
                                // scanData.tableMapping=bestMatchingTable['tableMapping']
                                tableName = bestMatchingTable['tableName'];
                                returnObj = self.mapTableHeaders(headers, tableMapping, bestMatchingTable['tableMapping'], length, req.body.templateId);
                            } else {
                                returnObj = self.mapTableHeaders(headers, tableMapping, scanData.tableMapping, length, req.body.templateId);
                            }
                            // let returnObj = self.mapTableHeaders(headers, tableMapping, scanData.tableMapping, length, req.body.templateId);
                            let finalHeaders = returnObj.finalHeaders;
                            // console.log("finalheaders========", JSON.stringify(finalHeaders));
                            if (contTable && lastHeaders.length > 0) {
                                finalHeaders = lastHeaders;
                            }
                            finalHeaders = finalHeaders.filter(function (x) { return x['Name'] != ""; })
                            if (!util_1.isNullOrUndefined(scanData.heading) && !util_1.isNullOrUndefined(req.body.input.templateId)) {
                                if (!util_1.isNullOrUndefined(scanData.combined) && scanData.combined.length == 2) {
                                    let findCombInd = multiTables[0][0].findIndex(el => new RegExp(scanData.combined[0]).test(el.Name) && new RegExp(scanData.combined[1]).test(el.Name))
                                    if (findCombInd != -1) {
                                        let findComb = multiTables[0][0][findCombInd]
                                        let midpoint = (findComb['leftX'] + findComb['rightX']) / 2
                                        let obj1 = { 'Name': scanData.combined[0], 'leftX': findComb['leftX'], 'rightX': midpoint - 2, 'topY': findComb['topY'], 'bottomY': findComb['bottomY'] }
                                        let obj2 = { 'Name': scanData.combined[1], 'leftX': midpoint + 2, 'rightX': findComb['rightX'], 'topY': findComb['topY'], 'bottomY': findComb['bottomY'] }
                                        multiTables[0][0] = [...multiTables[0][0].slice(0, findCombInd), obj1, obj2, ...multiTables[0][0].slice(findCombInd + 1)]
                                    }
                                }
                                let headersfinal = multiTables[0][0].filter(el => new RegExp(scanData.heading.join('|'), 'i').test(el.Name))
                                if (multiTables[0][0].length == scanData.heading.length && headersfinal.length != 0) {
                                    headersfinal = multiTables[0][0]
                                }

                                if (scanData.heading.length == headersfinal.length) {
                                    finalHeaders = headersfinal.map((el, i) => { el.Name = scanData.heading[i]; return el })
                                }
                            }
                            let lastValidRow = false;
                            // tables=self.findOverLappings(JSON.parse(JSON.stringify(tables)));
                            // let columnCordinates=[];
                            //////////////////////////////////////////////////////////////////////////
                            if (!util_1.isNullOrUndefined(ruleObj.lineWithCombineWords[0]) && !util_1.isNullOrUndefined(ruleObj.lineWithCombineWords[0][0]['imageName']) && tables.length > 0) {
                                finalHeaders = headers.filter(function (x) { return x.Name != "|" && x.Name != "]" && !x.Name.includes('---') && x.Name != "'"; });
                                tables[0] = tables[0].filter(function (x) { return x.Name != "|" && x.Name != "]" && !x.Name.includes('---') && x.Name != "'"; });
                            }
                            self.concatWords(tables, finalHeaders, perc, tableHeaders, tableHeadersNew, scanD, ruleObj)
                            columnCordinates = self.findCordinates(finalHeaders, tables, lastColumnCordinates, headerIdexes, scanD.data['tableSubHeaders'], cord);
                            let amountFound;
                            let validRowLength = 0;
                            let subTableLinesIndexes = [];
                            let horizontalTableLines = -1;
                            let startN = 1;
                            let lastRowLength = -1;
                            if (scanD.data['masterTableHorizontal']) {
                                startN = 0;
                            }
                            for (let i = startN; i < tables.length; i++) {  //TOSEE TOMORROW
                                let allowPush = true;
                                let line = tables[i];
                                let subHaderFound;
                                if (i < tables.length - 1 && !util_1.isNullOrUndefined(scanD.data['tableSubHeaders']) && scanD.data['tableSubHeaders'].length > 0) {
                                    let subHaderFoundR = self.checkIfsubHeader(scanD.data['tableSubHeaders'], tables, i);
                                    if (subHaderFoundR['subHaderFound']) {
                                        if (i == subHaderFoundR['ind']) {
                                            subHaderFound = true;
                                            lastValidRow = true;
                                        } else {
                                            subHaderFound = false;
                                        }
                                    }
                                }

                                if (!util_1.isNullOrUndefined(scanD.data['subTableHeaders']) && scanD.data['subTableHeaders'].length > 0) {

                                    for (let index = 0; index < line.length; index++) {
                                        let element = line[index];
                                        if (scanD.data['subTableHeaders'].indexOf(element.Name) > -1) {
                                            allowPush = false;
                                            subTableLinesIndexes.push(i);
                                        }
                                        if (scanD.data['subTableHeaders'].indexOf(element.Name) > -1 && scanD.data['subTableHeaders'].indexOf(element.Name) == 0) {
                                            if (scanD.data['horizontalTable']) {
                                                let subTableLines = [];
                                                subTableLines.push(line);
                                                for (let j = i + 1; j < i + scanD.data['subTableHeaders'].length; j++) {
                                                    let nextLine = tables[j];
                                                    if (!util_1.isNullOrUndefined(nextLine)) {
                                                        subTableLines.push(nextLine);
                                                    }
                                                }
                                                let subTable = [];
                                                for (let i = 0; i < subTableLines.length; i++) {
                                                    let line = subTableLines[i];
                                                    let header = "";
                                                    for (let j = 0; j < line.length; j++) {
                                                        let obj = {};
                                                        let element = line[j];
                                                        if (scanD.data['subTableHeaders'].indexOf(element.Name) > -1) {
                                                            if (scanD.data['tableMapping'][line[j].Name]) {
                                                                header = scanD.data['tableMapping'][line[j].Name];
                                                            } else {
                                                                header = line[j].Name;
                                                            }
                                                        } else if (i == 0) {
                                                            obj[header] = line[j].Name;
                                                            subTable.push(JSON.parse(JSON.stringify(obj)));
                                                        } else {
                                                            if (!util_1.isNullOrUndefined(subTable[j - 1])) {
                                                                subTable[j - 1][header] = line[j].Name
                                                            }
                                                        }

                                                    }

                                                }
                                                if (!util_1.isNullOrUndefined(TableObject[TableObject.length - 1])) {
                                                    TableObject[TableObject.length - 1]['subTable'] = subTable;
                                                }

                                            }
                                        }

                                    }

                                }

                                if ((!util_1.isNullOrUndefined(scanD.data['subTableHeadersPattern']) && scanD.data['subTableHeadersPattern'] != "" && scanD.data['verticalTable']) || (!util_1.isNullOrUndefined(scanD.data['subTableStart']) && scanD.data['subTableStart'].length > 0)) {
                                    count = 0;
                                    for (let index = 0; index < line.length; index++) {
                                        let element = line[index];
                                        var subTableHeadersPattern = new RegExp(scanD.data['subTableHeadersPattern']);

                                        if (!util_1.isNullOrUndefined(scanD.data['subTableStart']) && scanD.data['subTableStart'].length > 0) {
                                            if (scanD.data['subTableStart'].indexOf(element.Name) > -1) {
                                                count = count + 1;
                                            }
                                        } else {
                                            if (subTableHeadersPattern.test(element.Name)) {
                                                count = count + 1;
                                            }
                                        }

                                    }
                                    let perc = (count / line.length) * 100
                                    let all = false;


                                    if (count > 0 && !(!util_1.isNullOrUndefined(scanD.data['subTableStart']) && scanD.data['subTableStart'].length > 0)) {
                                        if (i < tables.length - 1 && line.length == tables[i + 1].length && line[line.length - 1].rightX > tables[i + 1][tables[i + 1].length - 1].leftX) {
                                            all = true;
                                        }
                                    }


                                    if ((perc > 80 || all) && subTableLinesIndexes.indexOf(i) == -1) {
                                        allowPush = false;
                                        let subTableLines = [];
                                        subTableLines.push(line);
                                        subTableLinesR.push(line);
                                        subTableLinesIndexes.push(i);
                                        let headerLength = line.length;
                                        let tableEnd = false;
                                        for (let j = i + 1; j < tables.length; j++) {
                                            let nextLine = tables[j];
                                            if (!util_1.isNullOrUndefined(nextLine)) {
                                                let allow = self.findIfBelongsToTable(tables[i], nextLine);
                                                if (((headerLength == nextLine.length || (j < tables.length - 1 && headerLength == tables[j + 1].length)) && line[line.length - 1].rightX > nextLine[nextLine.length - 1].leftX) || (!util_1.isNullOrUndefined(scanD.data['subTableEnd']) && scanD.data['subTableEnd'].length > 0) || (allow)) {

                                                    if (!util_1.isNullOrUndefined(scanD.data['subTableEnd']) && scanD.data['subTableEnd'].length > 0) {

                                                        for (let i = 0; i < nextLine.length; i++) {
                                                            const element = nextLine[i];
                                                            if (scanD.data['subTableEnd'].indexOf(element.Name.replace(/\:/, "")) > -1) {
                                                                tableEnd = true;
                                                            }

                                                        }
                                                    }
                                                    if (tableEnd) {
                                                        break;
                                                    }
                                                    subTableLinesIndexes.push(j);
                                                    subTableLines.push(nextLine);
                                                    subTableLinesR.push(nextLine);
                                                } else {
                                                    break;
                                                }

                                            }
                                        }
                                        let header = subTableLines[0];
                                        let returnObj = self.mapTableHeaders(header, tableMapping, scanData.tableMapping, length, req.body.templateId);
                                        headers = returnObj.finalHeaders;
                                        let obj = {};
                                        let subTable = [];
                                        let validRowLength = 0;
                                        let amountFound;
                                        let lastValidRow = false;
                                        let lastRowLength = -1;
                                        self.concatWords(subTableLines, header, perc, tableHeaders, tableHeadersNew, scanD, ruleObj)
                                        let columnCordinates = self.findCordinates(header, subTableLines, [], [], scanD.data['tableSubHeaders'], []);
                                        for (let i = 1; i < subTableLines.length; i++) {
                                            let line = subTableLines[i];
                                            let subHaderFound;
                                            let subHaderFoundR = self.checkIfsubHeader(scanD.data['tableSubHeaders'], subTableLines, i);
                                            if (subHaderFoundR['subHaderFound']) {
                                                if (i == subHaderFoundR['ind']) {
                                                    subHaderFound = true;
                                                    lastValidRow = true;
                                                } else {
                                                    subHaderFound = false;
                                                }
                                            }
                                            let objDa = self.createTablbeObject(header, line, scanData, [], scanD.data['tableSubHeaders'], JSON.parse(JSON.stringify(lastValidRow)), subHaderFound, scanD, columnCordinates, validRows, i, amountFound, validRowLength, lastRowLength,null);
                                            lastRowLength = line.length;
                                            obj = objDa['obj'];
                                            for (var k in obj) {
                                                if (k.indexOf("|") > -1 && !(/\|$/.test(k))) {
                                                    let splitArr = k.split("|");
                                                    if (splitArr.length == 3) {
                                                        obj[k] = obj[k].replace(/\s-/gi, '-');
                                                        let splitValArr = obj[k].trim().split(/\s/);
                                                        if (splitValArr.length == 3) {
                                                            delete obj[k];
                                                            obj[splitArr[0].trim()] = splitValArr[0];
                                                            obj[splitArr[1].trim()] = splitValArr[1];
                                                            for (let index = 2; index < splitValArr.length; index++) {
                                                                if (index == 2) {
                                                                    obj[splitArr[2].trim()] = splitValArr[index];
                                                                } else {
                                                                    obj[splitArr[2].trim()] = obj[splitArr[2].trim()] + " " + splitValArr[index];
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            lastValidRow = objDa['lastValidRow'];
                                            columnCordinates = objDa['columnCordinates'];
                                            amountFound = objDa['amountFound'];
                                            validRowLength = objDa['validRowLength'];
                                            if (objDa['subHearderRow'] && !util_1.isNullOrUndefined(scanD.data['tableSubHeaders']) && scanD.data['tableSubHeaders'].length > 0 && !(!util_1.isNullOrUndefined(scanD.data['tableStartSubHeader']) && scanD.data['tableStartSubHeader'].length > 0)) {
                                                for (var k in obj) {
                                                    if (!util_1.isNullOrUndefined(subTable[subTable.length - 1])) {
                                                        if (!util_1.isNullOrUndefined(subTable[subTable.length - 1][k]) && subTable[subTable.length - 1][k].replace(/[\s]/gi, '') != obj[k].replace(/[\s]/gi, '')) {
                                                            subTable[subTable.length - 1][k] = subTable[subTable.length - 1][k] + " " + obj[k];
                                                        } else {
                                                            subTable[subTable.length - 1][k] = subTable[subTable.length - 1][k]
                                                        }
                                                    }
                                                }
                                            } else {
                                                subTable.push(obj);
                                            }
                                        }
                                        if (!util_1.isNullOrUndefined(TableObject[TableObject.length - 1])) {
                                            TableObject[TableObject.length - 1]['subTable'] = subTable;
                                        }

                                    }
                                }
                                let objDa;
                                if (subTableLinesIndexes.indexOf(i) > -1) {
                                    allowPush = false;
                                    objDa = self.createTablbeObject(finalHeaders, line, scanData, tableColumns, scanD.data['tableSubHeaders'], JSON.parse(JSON.stringify(lastValidRow)), subHaderFound, scanD, [], validRows, i, amountFound, validRowLength, lastRowLength,null);
                                } else {
                                    objDa = self.createTablbeObject(finalHeaders, line, scanData, tableColumns, scanD.data['tableSubHeaders'], JSON.parse(JSON.stringify(lastValidRow)), subHaderFound, scanD, columnCordinates, validRows, i, amountFound, validRowLength, lastRowLength,null);
                                }
                                // let objDa = self.createTablbeObject(finalHeaders, line, scanData, tableColumns, scanD.data['tableSubHeaders'], JSON.parse(JSON.stringify(lastValidRow)), subHaderFound, scanD, columnCordinates, validRows, i, amountFound, validRowLength);
                                obj = objDa['obj'];
                                lastColumnCordinates = JSON.parse(JSON.stringify(columnCordinates));
                                if (scanD.data['masterTableHorizontal'] && subTableLinesIndexes.indexOf(i) == -1) {
                                    let key = "";
                                    obj = {}
                                    let doneHeaders = [];
                                    for (let i = 0; i < line.length; i++) {
                                        const element = line[i];
                                        const keys = Object.keys(scanD.data['tableMapping']);
                                        let all = false;
                                        for (let index = 0; index < keys.length; index++) {
                                            const ele = keys[index];
                                            if (scanD.data['tableMapping'][ele] == element['Name']) {
                                                all = true;
                                                doneHeaders.push(ele);
                                            }

                                        }
                                        if ((keys.indexOf(element['Name'].replace(/\:/, "")) > -1 || all) && !/\d/.test(element['Name'])) {
                                            if (!util_1.isNullOrUndefined(scanD.data['tableMapping'][element['Name'].replace(/\:/, "")])) {
                                                obj[scanD.data['tableMapping'][element['Name'].replace(/\:/, "")]] = "";
                                                key = scanD.data['tableMapping'][element['Name'].replace(/\:/, "")];
                                            } else {
                                                obj[element['Name']] = "";
                                                key = element['Name'];
                                            }
                                        } else if (key != "" && !/^\d$/.test(element['Name'])) {
                                            obj[key] = obj[key] + " " + line[i]['Name'].replace(/\:/, "");
                                        }

                                    }
                                    if (key == "") {
                                        allowPush = false;
                                    } else {

                                        if (!util_1.isNullOrUndefined(scanD.data['subHeaderBreakWords']) && scanD.data['subHeaderBreakWords'].length > 0) {
                                            let objDa = self.createTablbeObject(finalHeaders, line, scanData, [], scanD.data['tableStart'], true, true, scanD, [], validRows, i, amountFound, -1, lastRowLength,null);
                                            for (var k in objDa['obj']) {
                                                if (scanD.data['tableStart'].indexOf(k) > -1 && doneHeaders.indexOf(k) == -1) {
                                                    obj[k] = objDa['obj'][k];
                                                }
                                            }
                                        }


                                        if ((horizontalTableLines > -1 && i - horizontalTableLines == 1)) {
                                            for (var k in obj) {
                                                if (!util_1.isNullOrUndefined(TableObject[TableObject.length - 1])) {
                                                    if (util_1.isNullOrUndefined(TableObject[TableObject.length - 1][k])) {
                                                        TableObject[TableObject.length - 1][k] = obj[k];
                                                    }
                                                }
                                            }
                                            allowPush = false;
                                        }
                                        if (horizontalTableLines == -1 || i - horizontalTableLines != 1) {
                                            horizontalLines = [];
                                            tablesFinal[0] = line;
                                        }
                                        horizontalTableLines = i;
                                        horizontalLines.push(line);
                                    }
                                }
                                for (let key in obj) {
                                    if (/^[a-zA-Z]+$/.test(key) && obj.hasOwnProperty(key)) {
                                        if (key === obj[key]) {
                                            allowPush = false;
                                        }
                                    }
                                }
                                if (objDa['subHearderRow'] && !util_1.isNullOrUndefined(scanD.data['tableSubHeaders']) && scanD.data['tableSubHeaders'].length > 0 && !(!util_1.isNullOrUndefined(scanD.data['tableStartSubHeader']) && scanD.data['tableStartSubHeader'].length > 0) && allowPush &&
                                    !(!util_1.isNullOrUndefined(scanD.data['masterTableHorizontal']) && scanD.data['masterTableHorizontal'])) {
                                    allowPush = false;
                                    for (var k in obj) {
                                        if (!util_1.isNullOrUndefined(TableObject[TableObject.length - 1])) {
                                            if (!util_1.isNullOrUndefined(TableObject[TableObject.length - 1][k]) && TableObject[TableObject.length - 1][k].replace(/[\s]/gi, '') != obj[k].replace(/[\s]/gi, '')) {
                                                TableObject[TableObject.length - 1][k] = TableObject[TableObject.length - 1][k] + " " + obj[k];
                                            } else {
                                                TableObject[TableObject.length - 1][k] = TableObject[TableObject.length - 1][k]
                                            }
                                        }
                                    }
                                }
                                lastRowLength = line.length;
                                lastValidRow = objDa['lastValidRow'];
                                columnCordinates = objDa['columnCordinates'];
                                amountFound = objDa['amountFound'];
                                validRowLength = objDa['validRowLength'];
                                if (!util_1.isNullOrUndefined(obj['newHeaders'])) {
                                    finalHeaders = obj['newHeaders'];
                                } else {
                                    let countt = 0;
                                    let index = 0;
                                    for (let k = 0; k < finalHeaders.length; k++) {
                                        let a = finalHeaders[k];
                                        if (!util_1.isNullOrUndefined(obj[a.Name]) && obj[a.Name].trim() !== '') {
                                            countt++;
                                            index = k;
                                        }
                                    }
                                    if (subTableLinesIndexes.length == 0 && !util_1.isNullOrUndefined(finalHeaders[index]) && !util_1.isNullOrUndefined(TableObject[TableObject.length - 1]) && !util_1.isNullOrUndefined(TableObject[TableObject.length - 1][finalHeaders[index].Name]) && countt == 1 && TableObject.length > 0 && TableObject[TableObject.length - 1][finalHeaders[index].Name].length > obj[finalHeaders[index].Name]) {
                                        let newObj = {};
                                        newObj = TableObject[TableObject.length - 1];
                                        newObj[finalHeaders[index].Name] = newObj[finalHeaders[index].Name] + ' ' + obj[finalHeaders[index].Name];
                                        TableObject[TableObject.length - 1] = newObj;
                                    } else if (allowPush) {
                                        TableObject.push(obj);
                ///////////////////////////////////////////////////////
                let ob={}
                for (let index = 0; index < line.length; index++) {
                    const item = line[index];

                    if(Object.keys(ob).length === 0){
                        if(ruleObj.obj.filePath){
                            let selectedPathArr=ruleObj.obj.filePath.split("/");
                            let selectedPath=selectedPathArr[selectedPathArr.length-1];
                            const regex = /_(\d+)\.png$/;
                            const match = regex.exec(selectedPath);
    
                            if (match && match[1]) {
                                const pageNumber = match[1];
                                ob['pageNo']=match[1];
                                // console.log(`Page Number: ${pageNumber}`);
                              }
                        }

                       ob['leftX']=item.leftX;
                       ob['rightX']=item.rightX;
                       ob['topY']=item.topY;
                       ob['bottomY']=item.bottomY;
                       ob['tableName']=tableName
                    }else{
                        if(util_1.isNullOrUndefined(ob['pageNo'])){
                            if(ruleObj.obj.filePath){
                                let selectedPathArr=ruleObj.obj.filePath.split("/");
                                let selectedPath=selectedPathArr[selectedPathArr.length-1];
                                const regex = /_(\d+)\.png$/;
                                const match = regex.exec(selectedPath);
        
                                if (match && match[1]) {
                                    const pageNumber = match[1];
                                    ob['pageNo']=match[1];
                                    // console.log(`Page Number: ${pageNumber}`);
                                  }
                            }
                        }
                        ob['leftX']= ob['leftX']>item['leftX']? item['leftX']:ob['leftX'];
                        ob['rightX']= ob['rightX']<item['rightX']? item['rightX']:ob['rightX'];
                        ob['topY']= ob['topY']>item['topY']? item['topY']:ob['topY'];
                        ob['bottomY']= ob['bottomY']<item['bottomY']? item['bottomY']:ob['bottomY'];
                    }
                }
                tableobjectsCordinates.push(ob);
                /////////////////////////////////////////////////////////
                                    }
                                }

                            }
                            if (TableObject.length == 0) {
                                obj = {};
                                for (let i = 0; i < finalHeaders.length; i++) {
                                    let a = finalHeaders[i];
                                    obj[a.Name] = '';
                                }
                                if (finalHeaders.length > 0) {
                                    TableObject.push(obj);
                                }
                            }
                            
                        } else {
                            // multiTable = self.getMultiTables(multiTables, ruleObj, scanData, scanD, lastHeaders, additionalInfoTable, tables, tableMapping, req, contTable, perc, tableHeaders, tableHeadersNew, lastColumnCordinates, headerIdexes, cord, columnCordinates, tableColumns, validRows, obj, TableObject);
                            let arr = self.getMultiTables(multiTables, ruleObj, scanData, scanD, lastHeaders, additionalInfoTable, tables, tableMapping, req, contTable, perc, tableHeaders, tableHeadersNew, lastColumnCordinates, headerIdexes, cord, columnCordinates, tableColumns, validRows, obj, TableObject,previousLines,tableStart,tableobjectsCordinatesMaster,index);
                            if(!util_1.isNullOrUndefined(arr) && arr.length>0){
                                multiTable=multiTable.concat(arr);
                            }
                        }
                        // ruleObj['identifyTable']={}
                        // if(req.detectTable){
                        // }else{
                        if (scanD.data['masterTableHorizontal']) {
                            for (let i = 0; i < TableObject.length; i++) {
                                const element = TableObject[i];
                                if (util_1.isNullOrUndefined(element['subTable']) && i == TableObject.length - 1 && index < req.body.input.ruleObj.length - 1) {
                                    if (index < req.body.input.ruleObj.length - 1) {
                                        let header = JSON.parse(JSON.stringify(tablesFinal[0]))
                                        // req.body.input.ruleObj[index + 1].lineWithCombineWords[0] = header;
                                        if (horizontalLines.length > 0) {

                                            for (let m = horizontalLines.length - 1; m > -1; m--) {
                                                const element = horizontalLines[m];
                                                if (m == horizontalLines.length - 1) {
                                                    req.body.input.ruleObj[index + 1].lineWithCombineWords[0] = element;
                                                } else {
                                                    req.body.input.ruleObj[index + 1].lineWithCombineWords.unshift(element)
                                                }
                                            }

                                        } else {
                                            req.body.input.ruleObj[index + 1].lineWithCombineWords[0] = header;
                                        }
                                    }
                                }
                                if (headerIdexes.length == 1 && headerIdexes[0] == 0 && index < req.body.input.ruleObj.length - 1) {
                                    if (horizontalLines.length > 0) {
                                        if (subTableLinesR.length > 0) {
                                            // req.body.input.ruleObj[index + 1].lineWithCombineWords.unshift(subTableLinesR[0])
                                            req.body.input.ruleObj[index + 1].lineWithCombineWords[0] = subTableLinesR[0];

                                        }
                                        for (let m = horizontalLines.length - 1; m > -1; m--) {
                                            const element = horizontalLines[m];
                                            req.body.input.ruleObj[index + 1].lineWithCombineWords.unshift(element)
                                        }

                                    }
                                }

                            }
                        }
                        console.log("table found before processs-------", JSON.stringify(TableObject));
                        let table_headers = [];
                        if (TableObject.length > 0) {
                            let headerKeys = Object.keys(TableObject[0]);
                            for (let index = 0; index < headerKeys.length; index++) {
                                let element = headerKeys[index];
                                if (/\s+\|\s+/.test(element)) {
                                    let vals = element.split(/\s+\|\s+/);
                                    for (let i = 0; i < vals.length; i++) {
                                        let ele = vals[i];
                                        table_headers.push(ele);
                                    }
                                } else {
                                    table_headers.push(element);
                                }
                            }
                        }
                        let resultArr = self.extractTables(TableObject);
                        let finalResultArray = [];
                        if (!util_1.isNullOrUndefined(resultArr)) {
                            for (let i = 0; i < resultArr.length; i++) {
                                let tempArray = self.filterTableObjects(resultArr[i]);
                                if (tempArray.length > 0) {
                                    finalResultArray.push(tempArray);
                                }
                            }
                        }

                        if (remaining.length > 0) {
                            additionalInfoTable = [...remaining, ...additionalInfoTable]
                            remaining = []
                        }
                        for (let i = 0; i < finalResultArray.length; i++) {
                            let tempArray = self.filterTableObjects(finalResultArray[i]);
                            tempArray = self.processTableObjects(JSON.parse(JSON.stringify(tempArray)), scanData.allowGarbage, scanD, validRows,tableobjectsCordinates,null);
                            tempArray=tempArray['newTableArray'];

                            if (!util_1.isNullOrUndefined(additionalInfoTable[i]) && tempArray.length > 0) {
                                additionalInfoTable[i]['lineItems'] = JSON.parse(JSON.stringify(tempArray));
                            }
                        }
                        if (finalResultArray.length < additionalInfoTable.length) {
                            remaining = additionalInfoTable.splice(finalResultArray.length)
                        }
                        // TableObject = self.processTableObjects(TableObject, scanData.allowGarbage, scanD, validRows);
                        let result = self.processTableObjects(TableObject, scanData.allowGarbage, scanD, validRows,tableobjectsCordinates,null);
                        TableObject=result['newTableArray'];
                        if (multiTable.length == 0) {
                            tableobjectsCordinates=result['fArrCordinates']
                            let tmpOb={}
                            tmpOb[tableName]=tableobjectsCordinates;
                            tableobjectsCordinatesMaster.push(tmpOb);
                        }
                        

                        // }
                        if (req.detectTable) {
                            // req['newTable'] = TableObject;
                            req['TableArray'] = TableArray;
                            req['additionalInfoTable'] = additionalInfoTable;
                            let obj = {
                            }
                            obj[index] = TableObject
                            req['newTablesW'].push(obj)
                        }
                        console.log("table found-------", JSON.stringify(TableObject));
                        // let table_headers= [];
                        for (let i = 0; i < TableObject.length; i++) {
                            let obj = TableObject[i];
                            //    table_headers = Object.keys(obj);
                            for (var key in obj) {
                                if (key.includes("|")) {
                                    delete obj[key];
                                }
                            }
                            var allEmpty = Object.values(obj).every(value => value.trim() === "");;

                            if (allEmpty) {
                                console.log("All keys are empty.");
                            } else {
                                tablesMaster.push(obj);
                            }
                        }
                        if (TableObject.length > 0 && multiTables.length > 0 && multiTables.length < 2 && multiTableFlg) {
                            if (multiTable.length == 0) {
                                let obj = {};
                                obj[tableName] = TableObject;
                                obj['keys'] = Object.keys(TableObject[0]);
                                multiTable.push(obj);
                            } else {
                                let Keys = multiTable[multiTable.length - 1]['keys'];
                                let latestKeys = Object.keys(TableObject[0]);
                                if (Keys.length == latestKeys.length) {
                                    let lastRecordKeys = Object.keys(multiTable[multiTable.length - 1]);
                                    for (let i = 0; i < lastRecordKeys.length; i++) {
                                        if (lastRecordKeys[i].includes(tableName)) {
                                            multiTable[multiTable.length - 1][lastRecordKeys[i]] = multiTable[multiTable.length - 1][lastRecordKeys[i]].concat(TableObject);
                                        }
                                    }
                                } else {
                                    let obj = {};
                                    obj[tableName] = TableObject;
                                    obj['keys'] = Object.keys(TableObject[0]);
                                    multiTable.push(obj);
                                }
                            }
                        }

                        if (req.detectTable) {
                            req['newTable'] = tablesMaster;
                            req['table_headers'] = table_headers;
                            if (tablesMaster.length > 0) {
                                req['table_headers'] = Object.keys(tablesMaster[0]);
                            }
                            if (multiTable.length > 0) {
                                const mergedData = self.mergeArrayByKey(multiTable);
                                const tableobjectsCord = self.mergeArrayByKey(tableobjectsCordinatesMaster);
                                for (let index = 0; index < mergedData.length; index++) {
                                    let element = mergedData[index];
                                    for(let tableName in element){
                                        if (element.hasOwnProperty(tableName)) {
                                            let blankCount = element[tableName].filter(obj => {
                                                return Object.values(obj).every(value => value == "");
                                              }).length;
                                              if(element[tableName].length-blankCount>0){
                                                element[tableName] = element[tableName].filter(obj => {
                                                    return Object.values(obj).some(value => value != "");
                                                  });
                                              }else if(element[tableName].length-blankCount==0 && blankCount>1){
                                                element[tableName]=[element[tableName][0]]
                                              }
                                        }
                                    }
                                    
                                }
                                req['multiTable'] = mergedData;
                                req['tableCordinates']={}
                                req['tableCordinates']['tableobjectsCordinatesMaster']=tableobjectsCord;
                                req['tableCordinates']['tableEndCordinates']=tableEndCordinates;
                                // req['multiTable'] = multiTable;
                            }else{
                                const tableobjectsCord = self.mergeArrayByKey(tableobjectsCordinatesMaster);
                                req['tableCordinates']={}
                                req['tableCordinates']['tableobjectsCordinatesMaster']=tableobjectsCord;
                                req['tableCordinates']['tableEndCordinates']=tableEndCordinates;
                            }
                        }
                        if (TableObject.length == 0 && lastHeaders.length > 0) {
                            lastHeaders = [];
                        }
                        ruleObj['newTable'] = tablesMaster;
                        ruleObj['tableStart'] = tableStartData;
                        ruleObj['tableEnd'] = tableEndData;
                        ruleObj['tableMapping'] = tableMapping;
                        ruleObj['table_headers'] = table_headers;
                        ruleObj['tableHeaders'] = [];
                        ruleObj['tableBoundry'] = {};
                        ruleObj['tableData'] = [];
                        ruleObj['additionalInfoTable'] = additionalInfoTable;
                        identifyTableOutputArray.push(ruleObj);

                        if (index == req.body.input.ruleObj.length - 1) {
                            const newData = multiTable.map(table => {
                                const newTable = { ...table };
                                delete newTable.keys;
                                return newTable;
                            });
                            const mergedData = self.mergeArrayByKey(newData);
                            const tableobjectsCord = self.mergeArrayByKey(tableobjectsCordinatesMaster);
                            for (let index = 0; index < mergedData.length; index++) {
                                let element = mergedData[index];
                                for(let tableName in element){
                                    if (element.hasOwnProperty(tableName)) {
                                        let blankCount = element[tableName].filter(obj => {
                                            return Object.values(obj).every(value => value == "");
                                          }).length;
                                          if(element[tableName].length-blankCount>0){
                                            element[tableName] = element[tableName].filter(obj => {
                                                return Object.values(obj).some(value => value != "");
                                              });
                                          }else if(element[tableName].length-blankCount==0 && blankCount>1){
                                            element[tableName]=[element[tableName][0]]
                                          }
                                    }
                                }
                                
                            }
                            identifyTableOutputArray[0]['multiTable'] = mergedData
                            identifyTableOutputArray[0]['tableCordinates']={}
                            identifyTableOutputArray[0]['tableCordinates']['tableobjectsCordinatesMaster']=tableobjectsCord;
                            identifyTableOutputArray[0]['tableCordinates']['tableEndCordinates']=tableEndCordinates;
                            console.log("mergedData----------------------->",mergedData)
                        }
                    }
                    // }

                    let outputData = { "identifyTable": identifyTableOutputArray, templateName: templateName, "uploadStatus": true, 'statusCode': '200' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    if (req.detectTable) {
                    } else {
                        if (req.body.input.return)
                            return outputData;
                        else
                            yield self.ioWrite(options)
                    }

                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     //console.log("body---responce",body);
                    //     //console.log("---res",response);
                    // });
                    // });
                    // }

                }
                else {
                    logger.error("#identifyTable==>Internal server Error");
                    let outputData = { "identifyTable": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = "#identifyTable==>Internal server Error";
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     // console.log("body---responce", body);
                    //     // console.log("---res", response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    if (req.detectTable) {
                    } else {
                        yield self.ioWrite(options);
                    }


                    ///////////////////////////////////////////////////////
                }
            }
            catch (e) {
                logger.error("#identify table==>", e);
                let outputData = { "identifyTable": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = e.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
            }
        });
    }
    mergeArrayByKey(arr) {
        const result = {};
        arr.forEach((obj) => {
            const key = Object.keys(obj)[0];
            if (result[key]) {
                result[key] = result[key].concat(obj[key]);
            } else {
                result[key] = obj[key];
            }
        });

        // Convert the result to an array of objects
        const mergedArray = Object.keys(result).map((key) => ({ [key]: result[key] }));
        return mergedArray;
    }
    getMultiTables(multiTables, ruleObj, scanData, scanD, lastHeaders, additionalInfoTable, tables, tableMapping, req, contTable, perc, tableHeaders, tableHeadersNew, lastColumnCordinates, headerIdexes, cord, columnCordinates, tableColumns, validRows, obj, TableObject,previousLines,tableStart,tableobjectsCordinatesMaster,pageIndex) {
        // tables=multiTables[0];
        let self = this;
        let multiTablesObject = [];
        let tableobjectsCordinates=[]
        let tableName = "";
        if(multiTables.length>1 && !util_1.isNullOrUndefined(multiTables[0][0]) && !util_1.isNullOrUndefined(multiTables[0][0][0]) && !util_1.isNullOrUndefined(multiTables[0][0][0]['tableName'])){
            if(multiTables[0].length==1){
                multiTables.shift();
            }
        }
        for (let n=0;n<multiTables.length;n++) {
            let allowToPush=true;
            let item=multiTables[n];
            let prevLine=[];
            if(!util_1.isNullOrUndefined(multiTables[n])){
                prevLine=previousLines[n]
            }
            TableObject = [];
            tableobjectsCordinates=[];
            let tab = item;
            // if (!util_1.isNullOrUndefined(scanD.data['tableStartSubHeader']) && scanD.data['tableStartSubHeader'].length > 0 && tab.length > 1) {
            //     tab.unshift(tab[1])
            // }
            let headers = tab[0];
            lastHeaders = headers;
            // let count=0;
            // for (let index = 0; index < scanData.tableStart.length; index++) {
            //     let value = scanData.tableStart[index];
            //     for (let i = 0; i < headers.length; i++) {
            //         if (value === headers[i].Name.replace(":", "") && (/\:$/.test(headers[i].Name) || 
            //         (i<headers.length-1 && /\:$/.test(headers[i+1].Name)))) {
            //             count=count+1;
            //             if(headers[0]['singleHeader']){
            //                 count=count+1;
            //             }
            //         }
            //     }
            // }
            if(headers[0]['singleHeader']){

                console.log("horizontal Table found-------@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@----------------------------------")
                TableObject=self.getHorizontalTable(scanData,item);
                if(TableObject.length>0){
                   let keys=Object.keys(TableObject[0]);
                   if(keys.length>1){
                    for (let i = 0; i < keys.length; i++) {
                        tableobjectsCordinates=[]
                        let tableObjs=[];
                        let ky = keys[i];
                        let bestMatchingTable = null;
                        if (!util_1.isNullOrUndefined(scanData.multiTable) && scanData.multiTable.length > 0) {
                            scanData.multiTable.forEach(table => {
                                let matches = 0;
                                if (!util_1.isNullOrUndefined(table.tableMapping)) {
                                    Object.keys(table.tableMapping).forEach(key => {
                                        if (ky == key) {
                                            matches++;
                                        }
                                    });
                                }
                              if(matches>0){
                                bestMatchingTable=table;
                              }
                            });
                            if(!util_1.isNullOrUndefined(bestMatchingTable)){
                                tableName = bestMatchingTable['tableName'];
                                if (!util_1.isNullOrUndefined(scanData.cordinates) && scanData.cordinates.length > 0) {
                                    scanData.cordinates.forEach(cord => {
                                        if(cord.header==ky){
                                            let ob={
                                                "pageNo":"0",
                                                "leftX":cord['leftX'],
                                                "rightX":cord['rightX'],
                                                "topY":cord['topY'],
                                                "bottomY":cord['bottomY'],
                                                "tableName":tableName
                                            }
                                            if(ruleObj.obj.filePath){
                                                let selectedPathArr=ruleObj.obj.filePath.split("/");
                                                let selectedPath=selectedPathArr[selectedPathArr.length-1];
                                                const regex = /_(\d+)\.png$/;
                                                const match = regex.exec(selectedPath);
                        
                                                if (match && match[1]) {
                                                    const pageNumber = match[1];
                                                    ob['pageNo']=match[1];
                                                    // console.log(`Page Number: ${pageNumber}`);
                                                  }
                                            }
                                            tableobjectsCordinates.push(ob);
                                            let tmpOb={}
                                            tmpOb[tableName]=tableobjectsCordinates;
                                            tableobjectsCordinatesMaster.push(tmpOb);
    
                                        }
                                    })
                                }
                                
                            }
                        }

                        let obj={};
                        for (let index = 0; index < TableObject.length; index++) {
                            let element = TableObject[index];
                            for (const key in element) {

                                if(ky==key){
                                    if(!util_1.isNullOrUndefined(bestMatchingTable) && !util_1.isNullOrUndefined(bestMatchingTable['rowStartWith'])){
        
                                        for (const column in bestMatchingTable['rowStartWith']) {
            
                                            if(key==column){
            
                                                let regexString = bestMatchingTable['rowStartWith'][column];
                                                // regexString="\\b"+regexString+"(?:\\s.*?(?=\\b\\d+ \\d+|$))?"
                                                let regex = new RegExp(regexString, "g");
                                                let str = element[key];
                                                let arr = str.match(regex);
                                                if(!util_1.isNullOrUndefined(arr)){
                                                    obj[key]=arr;
                                                }else{
                                                    obj[key]=str;
                                                }
                                            }
            
                                        }
            
                                    }
                                    let finalObj={};
                                    // let tableObjs=[]
                                    for (const key in obj) {
                                        if(!util_1.isNullOrUndefined(obj[key])){
                                           if(typeof obj[key]=='string'){
                                            if(tableObjs.length>0){
                                                for (let index = 0; index < tableObjs.length; index++) {
                                                    let row = tableObjs[index];
                                                    if(util_1.isNullOrUndefined(row[key])){
                                                        row[key]=obj[key];
                                                        break;
                                                    }else if(index == tableObjs.length-1){
                                                        finalObj={};
                                                        finalObj[key]=obj[key];
                                                        tableObjs.push(finalObj)
                                                        break;
                                                    }
                                                }
                                            }else{
                                                finalObj={};
                                                finalObj[key]=obj[key];
                                                tableObjs.push(finalObj)
                                                
                                            }
                                           }else{
                                            for(let item of obj[key]){
                                                if(tableObjs.length>0){
                                                    for (let index = 0; index < tableObjs.length; index++) {
                                                        let row = tableObjs[index];
                                                        if(util_1.isNullOrUndefined(row[key])){
                                                            row[key]=item;
                                                            break;
                                                        }else if(index == tableObjs.length-1){
                                                            finalObj={};
                                                            finalObj[key]=item;
                                                            tableObjs.push(finalObj)
                                                            break;
                                                        }
                                                    }
                                                }else{
                                                    finalObj={};
                                                    finalObj[key]=item;
                                                    tableObjs.push(finalObj)
                                                    
                                                }
                                                
                                               }
                                           }
                                           
                                        }
                                        
                                    }
                                    
                                }
                          
                                
                            }
                            
                            
                        }
 

                        if(tableObjs.length>0){
                            tableObjs = tableObjs.filter(obj => obj !== undefined && obj !== null);
                            let ob = {}
                            ob[tableName] = tableObjs;
                            ob['keys'] = Object.keys(tableObjs[0]);
                            multiTablesObject.push(ob);        
                        }
                    }



                   }else{
                    let bestMatchingTable = null;
                    let ky="";
                    if(!util_1.isNullOrUndefined(keys) && !util_1.isNullOrUndefined(keys[0])){
                       ky = keys[0];
                    }
                    if (!util_1.isNullOrUndefined(scanData.multiTable) && scanData.multiTable.length > 0) {
                        let maxMatches = -1;
            
                        scanData.multiTable.forEach(table => {
                            let matches = 0;
                            if (!util_1.isNullOrUndefined(table.tableMapping)) {
                                Object.keys(table.tableMapping).forEach(key => {
                                    if (headers.some(header => header.Name.replace(/\:/,"") == key)) {
                                        matches++;
                                    }
                                });
                            }
                            if (matches > maxMatches) {
                                maxMatches = matches;
                                bestMatchingTable = table;
                            }
                        });
                        tableName = bestMatchingTable['tableName'];
                        if (!util_1.isNullOrUndefined(scanData.cordinates) && scanData.cordinates.length > 0) {
                            scanData.cordinates.forEach(cord => {
                                if(cord.header==ky){
                                    let ob={
                                        "pageNo":"0",
                                        "leftX":cord['leftX'],
                                        "rightX":cord['rightX'],
                                        "topY":cord['topY'],
                                        "bottomY":cord['bottomY'],
                                        "tableName":tableName
                                    }
                                    if(ruleObj.obj.filePath){
                                        let selectedPathArr=ruleObj.obj.filePath.split("/");
                                        let selectedPath=selectedPathArr[selectedPathArr.length-1];
                                        const regex = /_(\d+)\.png$/;
                                        const match = regex.exec(selectedPath);
                
                                        if (match && match[1]) {
                                            const pageNumber = match[1];
                                            ob['pageNo']=match[1];
                                            // console.log(`Page Number: ${pageNumber}`);
                                          }
                                    }
                                    tableobjectsCordinates.push(ob);
                                    let tmpOb={}
                                    tmpOb[tableName]=tableobjectsCordinates;
                                    tableobjectsCordinatesMaster.push(tmpOb);

                                }
                            })
                        }
                    }
                    let obj={};
                    for (let index = 0; index < TableObject.length; index++) {
                        let element = TableObject[index];
                        for (const key in element) {
    
                            if(!util_1.isNullOrUndefined(bestMatchingTable) && !util_1.isNullOrUndefined(bestMatchingTable['rowStartWith'])){
    
                                for (const column in bestMatchingTable['rowStartWith']) {
    
                                    if(key==column){
    
                                        let regexString = bestMatchingTable['rowStartWith'][column];
                                        // regexString="\\b"+regexString+"(?:\\s.*?(?=\\b\\d+ \\d+|$))?"
                                        let regex = new RegExp(regexString, "g");
                                        let str = element[key];
                                        let arr = str.match(regex);
                                        if(!util_1.isNullOrUndefined(arr)){
                                            obj[key]=arr;
                                        }else{
                                            obj[key]=str;
                                        }
                                    }
    
                                }
    
                            }
                        }
                        
                        
                    }
                    let finalObj={};
                    let tableObjs=[]
                    for (const key in obj) {
                        if(!util_1.isNullOrUndefined(obj[key])){
                           if(typeof obj[key]=='string'){
                            if(tableObjs.length>0){
                                for (let index = 0; index < tableObjs.length; index++) {
                                    let row = tableObjs[index];
                                    if(util_1.isNullOrUndefined(row[key])){
                                        row[key]=obj[key];
                                        break;
                                    }else if(index == tableObjs.length-1){
                                        finalObj={};
                                        finalObj[key]=obj[key];
                                        tableObjs.push(finalObj)
                                        break;
                                    }
                                }
                            }else{
                                finalObj={};
                                finalObj[key]=obj[key];
                                tableObjs.push(finalObj)
                                
                            }
                           }else{
                            for(let item of obj[key]){
                                if(tableObjs.length>0){
                                    for (let index = 0; index < tableObjs.length; index++) {
                                        let row = tableObjs[index];
                                        if(util_1.isNullOrUndefined(row[key])){
                                            row[key]=item;
                                            break;
                                        }else if(index == tableObjs.length-1){
                                            finalObj={};
                                            finalObj[key]=item;
                                            tableObjs.push(finalObj)
                                            break;
                                        }
                                    }
                                }else{
                                    finalObj={};
                                    finalObj[key]=item;
                                    tableObjs.push(finalObj)
                                    
                                }
                                
                               }
                           }
                           
                        }
                        
                    }
                    if(tableObjs.length>0){
                        TableObject=tableObjs;
                    }
                    if(TableObject.length>0){
                        // if(!util_1.isNullOrUndefined(bestMatchingTable) && !util_1.isNullOrUndefined(bestMatchingTable['splitColumns']) && bestMatchingTable['splitColumns']){
                        //     TableObject = TableObject.filter(obj => obj !== undefined && obj !== null);
                        //     let keys = Object.keys(TableObject[0]);                    
                        //     let result = keys.map(key => TableObject.map(({ [key]: _, ...rest }) => rest));
                        //     for(let tableOb of result){
                        //         let ob = {}
                        //         const filteredData = tableOb.filter(obj => Object.keys(obj).length !== 0);
                        //         // console.log(filteredData)
                        //         if(filteredData.length>0){
                        //             let firstRow=filteredData[0];
                        //             for(let key in firstRow){
                        //                 let tableName = key;
                        //                 ob[tableName] = filteredData;
                        //                 ob['keys'] = Object.keys(filteredData[0]);
                        //                 multiTablesObject.push(ob);
                        //             }
                        //         }
                        //     }
                        // }else{
                            TableObject = TableObject.filter(obj => obj !== undefined && obj !== null);
                            let ob = {}
                            ob[tableName] = TableObject;
                            ob['keys'] = Object.keys(TableObject[0]);
                            multiTablesObject.push(ob);
                        // }
    
                    }
                   }
                }

            }else{
                            //For Duplicate Column Names
               
            if (ruleObj && ruleObj.obj && ruleObj.obj.documentType == "Balance_Sheet") {
                //For Duplicate Column Names
                let hKeys = [];
                for (let i of lastHeaders) {
                    if (hKeys.includes(i.Name)) {
                        count++;
                        i.Name = i.Name + i.Name;
                    }
                    hKeys.push(i.Name);
                }
            }

            if (additionalInfoTable.length > 0 && headers.length < tableStart.length) {
                self.fixTableHeaders(headers, item, upperCaseStart);
            }
            tables = self.mergeTableRows(item, scanData.tableMapping);
            //  let headers = this.combineTableHeaders(tables[0])
            let length = 0
            if (tab.length > 2) {
                length = tab[2].length;
            }
            if (tab.length == 2) {
                length = tab[1].length;
            }
            // for (let k = 0; k < headers.length; k++) {
            //     headers[k].Name = headers[k].Name.replace(/\./g, ' ');
            // }
            headers = headers.filter(function (x) { return x['Name'] != "%"; })
            // console.log("headers--------------------------", headers);
            // console.log("tablemapping----------------------", tableMapping);
            // console.log("scandata.tablemapinggg---------------", scanData.tableMapping);
            let returnObj;
            let duplicate=false;
            let bestMatchingTable = null;
            let bestMatchingTables=[];
            if (!util_1.isNullOrUndefined(scanData.multiTable) && scanData.multiTable.length > 0) {
                let maxMatches = -1;
                scanData.multiTable.forEach(table => {
                    let matches = 0;
                    if (!util_1.isNullOrUndefined(table.tableMapping)) {
                        // Object.keys(table.tableMapping).forEach(key => {
                        //     if (headers.some(header => header.Name == key)) {
                        //         matches++;
                        //     }
                        // });
                        let arr=Object.keys(table.tableMapping);
                        if(arr.length>0){
                            for (let index = 0; index < headers.length; index++) {
                                const element = headers[index];
                                if(self.matchStr(arr,element.Name)){
                                    matches++;
                                }
                                
                            }
                        }


                    }
                    if (matches > maxMatches) {
                        maxMatches = matches;
                        bestMatchingTable = table;
                        bestMatchingTables.push(table)
                    }else if(matches >1 && matches == maxMatches){
                        duplicate=true;
                        bestMatchingTables.push(table)

                    }
                });
                // scanData.tableMapping=bestMatchingTable['tableMapping']
                tableName = bestMatchingTable['tableName'];
                let bestMatch=null;
                let matched=false;
                if(prevLine && prevLine.length>0 && !util_1.isNullOrUndefined(bestMatchingTable['rTableName']) && bestMatchingTable['rTableName']!=""){

                    
                    // scanData.multiTable.forEach(table => {
                    //     let namesArr=table['tableName'].split(/\s/);
                    //     let count=0;
                    //     prevLine.forEach(ele => {
                    //        if(namesArr.indexOf(ele.Name.replace(":", ""))>-1){
                    //         count=count+1
                    //        }
                    //     })
                    //     if(count>1){
                    //         tableName=table['tableName'];
                    //         bestMatch=table;
                    //         bestMatchingTable=table;
                    //     }
                    // })
                    
                    bestMatchingTables.forEach(bstMatchingTab => {
                        prevLine.forEach(ele => {
                            if(bstMatchingTab['rTableName']==ele.Name.replace(":", "")){
                                matched=true;
                                bestMatch=bstMatchingTab;
                            }
                            if(!util_1.isNullOrUndefined(bstMatchingTab['rTableName'])){
                                let namesArr=bstMatchingTab['rTableName'].split(/\s/);
                                let count=0;
                                prevLine.forEach(ele => {
                                   if(namesArr.indexOf(ele.Name.replace(":", ""))>-1){
                                    count=count+1
                                   }
                                })
                                if(count>1){
                                    matched=true;
                                    bestMatch=bstMatchingTab;
                                }
                            }
    
                        })
                    })


                    

                }
                console.log("bestMatchTable-----------",JSON.stringify(bestMatchingTable));
                if(!matched && util_1.isNullOrUndefined(bestMatch) && !util_1.isNullOrUndefined(bestMatchingTable['rTableName'])  && bestMatchingTable['rTableName']!=""){
                    if(!util_1.isNullOrUndefined(req.body.input.ruleObj[pageIndex]) && !util_1.isNullOrUndefined(req.body.input.ruleObj[pageIndex].lineWithCombineWordsNew[0]) && 
                    !util_1.isNullOrUndefined(req.body.input.ruleObj[pageIndex].lineWithCombineWordsNew[0][0]['tableName'])){
                        tableName=req.body.input.ruleObj[pageIndex].lineWithCombineWordsNew[0][0]['tableName'];
                        console.log("----------assign name",req.body.input.ruleObj[pageIndex].lineWithCombineWordsNew[0][0]['tableName'])
                    }
                }else if(bestMatchingTable['rTableName']!="" && !util_1.isNullOrUndefined(bestMatch)){
                    tableName=bestMatch['tableName']
                }

                if(n==0 && n==multiTables.length-1){
                    if(!util_1.isNullOrUndefined(req.body.input.ruleObj[pageIndex]) && !util_1.isNullOrUndefined(req.body.input.ruleObj[pageIndex].lineWithCombineWordsNew[0]) && 
                    !util_1.isNullOrUndefined(req.body.input.ruleObj[pageIndex].lineWithCombineWordsNew[0][0]['tableName'])){
                        // tableName=req.body.input.ruleObj[pageIndex].lineWithCombineWordsNew[0][0]['tableName'];
                    }
                    if(!util_1.isNullOrUndefined(req.body.input.ruleObj[pageIndex + 1])){
                        req.body.input.ruleObj[pageIndex + 1].lineWithCombineWordsNew[0][0]['tableName']=tableName;
                    } 
                }else if(n==multiTables.length-1){
                    if(!util_1.isNullOrUndefined(req.body.input.ruleObj[pageIndex + 1])){
                        req.body.input.ruleObj[pageIndex + 1].lineWithCombineWordsNew[0][0]['tableName']=tableName;
                    }        
                }else if(n==0){
                    if(!util_1.isNullOrUndefined(req.body.input.ruleObj[pageIndex]) && !util_1.isNullOrUndefined(req.body.input.ruleObj[pageIndex].lineWithCombineWordsNew[0]) && 
                    !util_1.isNullOrUndefined(req.body.input.ruleObj[pageIndex].lineWithCombineWordsNew[0][0]['tableName'])){
                        // tableName=req.body.input.ruleObj[pageIndex].lineWithCombineWordsNew[0][0]['tableName'];
                    } 
                }
                scanData.multiTable.forEach(table => {
                    if(!util_1.isNullOrUndefined(table.tableNameMapping) && Object.keys(table.tableNameMapping).length != 0){

                        if(!util_1.isNullOrUndefined(table.tableNameMapping[tableName])){
                            tableName=table.tableNameMapping[tableName];
                        }
                               
                    }
                })
                
                returnObj = self.mapTableHeaders(headers, tableMapping, bestMatchingTable['tableMapping'], length, req.body.templateId);
            } else {
                returnObj = self.mapTableHeaders(headers, tableMapping, scanData.tableMapping, length, req.body.templateId);
            }
            if(!allowToPush){
                if(n==multiTables.length-1){
                    if(!util_1.isNullOrUndefined(req.body.input.ruleObj[pageIndex + 1])){
                        req.body.input.ruleObj[pageIndex + 1].lineWithCombineWordsNew.shift()
                    }
                }
                continue;
            }
            // let returnObj = self.mapTableHeaders(headers, tableMapping, scanData.tableMapping, length, req.body.templateId);
            let finalHeaders = returnObj.finalHeaders;
            // console.log("finalheaders========", JSON.stringify(finalHeaders));
            if (contTable && lastHeaders.length > 0) {
                finalHeaders = lastHeaders;
            }
            finalHeaders = finalHeaders.filter(function (x) { return x['Name'] != ""; })
            if (!util_1.isNullOrUndefined(scanData.heading) && !util_1.isNullOrUndefined(req.body.input.templateId)) {
                if (!util_1.isNullOrUndefined(scanData.combined) && scanData.combined.length == 2) {
                    let findCombInd = item[0].findIndex(el => new RegExp(scanData.combined[0]).test(el.Name) && new RegExp(scanData.combined[1]).test(el.Name))
                    if (findCombInd != -1) {
                        let findComb = item[0][findCombInd]
                        let midpoint = (findComb['leftX'] + findComb['rightX']) / 2
                        let obj1 = { 'Name': scanData.combined[0], 'leftX': findComb['leftX'], 'rightX': midpoint - 2, 'topY': findComb['topY'], 'bottomY': findComb['bottomY'] }
                        let obj2 = { 'Name': scanData.combined[1], 'leftX': midpoint + 2, 'rightX': findComb['rightX'], 'topY': findComb['topY'], 'bottomY': findComb['bottomY'] }
                        item[0] = [...item[0].slice(0, findCombInd), obj1, obj2, ...item[0].slice(findCombInd + 1)]
                    }
                }
                let headersfinal = item[0].filter(el => new RegExp(scanData.heading.join('|'), 'i').test(el.Name))
                if (item[0].length == scanData.heading.length && headersfinal.length != 0) {
                    headersfinal = item[0]
                }

                if (scanData.heading.length == headersfinal.length) {
                    finalHeaders = headersfinal.map((el, i) => { el.Name = scanData.heading[i]; return el })
                }
            }
            let lastValidRow = false;
            // tables=self.findOverLappings(JSON.parse(JSON.stringify(tables)));
            // let columnCordinates=[];
            //////////////////////////////////////////////////////////////////////////
            if (!util_1.isNullOrUndefined(ruleObj.lineWithCombineWords[0]) && !util_1.isNullOrUndefined(ruleObj.lineWithCombineWords[0][0]['imageName']) && tables.length > 0) {
                finalHeaders = headers.filter(function (x) { return x.Name != "|" && x.Name != "]" && !x.Name.includes('---') && x.Name != "'"; });
                tables[0] = tables[0].filter(function (x) { return x.Name != "|" && x.Name != "]" && !x.Name.includes('---') && x.Name != "'"; });
            }
            self.concatWords(tables, finalHeaders, perc, tableHeaders, tableHeadersNew, scanD, ruleObj)
            columnCordinates = self.findCordinates(finalHeaders, tables, lastColumnCordinates, headerIdexes, scanD.data['tableSubHeaders'], cord);
            let amountFound;
            let validRowLength = 0;
            let subTableLinesIndexes = [];
            let horizontalTableLines = -1;
            let startN = 1;
            let lastRowLength = -1;
            if (scanD.data['masterTableHorizontal']) {
                startN = 0;
            }

            for (let i = startN; i < tables.length; i++) {  //TOSEE TOMORROW
                let allowPush = true;
                let line = tables[i];
                let subHaderFound;
                if (i < tables.length - 1 && !util_1.isNullOrUndefined(scanD.data['tableSubHeaders']) && scanD.data['tableSubHeaders'].length > 0) {
                    let subHaderFoundR = self.checkIfsubHeader(scanD.data['tableSubHeaders'], tables, i);
                    if (subHaderFoundR['subHaderFound']) {
                        if (i == subHaderFoundR['ind']) {
                            subHaderFound = true;
                            lastValidRow = true;
                        } else {
                            subHaderFound = false;
                        }
                    }
                }

                if (!util_1.isNullOrUndefined(scanD.data['subTableHeaders']) && scanD.data['subTableHeaders'].length > 0) {

                    for (let index = 0; index < line.length; index++) {
                        let element = line[index];
                        if (scanD.data['subTableHeaders'].indexOf(element.Name) > -1) {
                            allowPush = false;
                            subTableLinesIndexes.push(i);
                        }
                        if (scanD.data['subTableHeaders'].indexOf(element.Name) > -1 && scanD.data['subTableHeaders'].indexOf(element.Name) == 0) {
                            if (scanD.data['horizontalTable']) {
                                let subTableLines = [];
                                subTableLines.push(line);
                                for (let j = i + 1; j < i + scanD.data['subTableHeaders'].length; j++) {
                                    let nextLine = tables[j];
                                    if (!util_1.isNullOrUndefined(nextLine)) {
                                        subTableLines.push(nextLine);
                                    }
                                }
                                let subTable = [];
                                for (let i = 0; i < subTableLines.length; i++) {
                                    let line = subTableLines[i];
                                    let header = "";
                                    for (let j = 0; j < line.length; j++) {
                                        let obj = {};
                                        let element = line[j];
                                        if (scanD.data['subTableHeaders'].indexOf(element.Name) > -1) {
                                            if (scanD.data['tableMapping'][line[j].Name]) {
                                                header = scanD.data['tableMapping'][line[j].Name];
                                            } else {
                                                header = line[j].Name;
                                            }
                                        } else if (i == 0) {
                                            obj[header] = line[j].Name;
                                            subTable.push(JSON.parse(JSON.stringify(obj)));
                                        } else {
                                            if (!util_1.isNullOrUndefined(subTable[j - 1])) {
                                                subTable[j - 1][header] = line[j].Name
                                            }
                                        }

                                    }

                                }
                                if (!util_1.isNullOrUndefined(TableObject[TableObject.length - 1])) {
                                    TableObject[TableObject.length - 1]['subTable'] = subTable;
                                }

                            }
                        }

                    }

                }

                if ((!util_1.isNullOrUndefined(scanD.data['subTableHeadersPattern']) && scanD.data['subTableHeadersPattern'] != "" && scanD.data['verticalTable']) || (!util_1.isNullOrUndefined(scanD.data['subTableStart']) && scanD.data['subTableStart'].length > 0)) {
                    count = 0;
                    for (let index = 0; index < line.length; index++) {
                        let element = line[index];
                        var subTableHeadersPattern = new RegExp(scanD.data['subTableHeadersPattern']);

                        if (!util_1.isNullOrUndefined(scanD.data['subTableStart']) && scanD.data['subTableStart'].length > 0) {
                            if (scanD.data['subTableStart'].indexOf(element.Name) > -1) {
                                count = count + 1;
                            }
                        } else {
                            if (subTableHeadersPattern.test(element.Name)) {
                                count = count + 1;
                            }
                        }

                    }
                    let perc = (count / line.length) * 100
                    let all = false;


                    if (count > 0 && !(!util_1.isNullOrUndefined(scanD.data['subTableStart']) && scanD.data['subTableStart'].length > 0)) {
                        if (i < tables.length - 1 && line.length == tables[i + 1].length && line[line.length - 1].rightX > tables[i + 1][tables[i + 1].length - 1].leftX) {
                            all = true;
                        }
                    }


                    if ((perc > 80 || all) && subTableLinesIndexes.indexOf(i) == -1) {
                        allowPush = false;
                        let subTableLines = [];
                        subTableLines.push(line);
                        subTableLinesR.push(line);
                        subTableLinesIndexes.push(i);
                        let headerLength = line.length;
                        let tableEnd = false;
                        for (let j = i + 1; j < tables.length; j++) {
                            let nextLine = tables[j];
                            if (!util_1.isNullOrUndefined(nextLine)) {
                                let allow = self.findIfBelongsToTable(tables[i], nextLine);
                                if (((headerLength == nextLine.length || (j < tables.length - 1 && headerLength == tables[j + 1].length)) && line[line.length - 1].rightX > nextLine[nextLine.length - 1].leftX) || (!util_1.isNullOrUndefined(scanD.data['subTableEnd']) && scanD.data['subTableEnd'].length > 0) || (allow)) {

                                    if (!util_1.isNullOrUndefined(scanD.data['subTableEnd']) && scanD.data['subTableEnd'].length > 0) {

                                        for (let i = 0; i < nextLine.length; i++) {
                                            const element = nextLine[i];
                                            if (scanD.data['subTableEnd'].indexOf(element.Name.replace(/\:/, "")) > -1) {
                                                tableEnd = true;
                                            }

                                        }
                                    }
                                    if (tableEnd) {
                                        break;
                                    }
                                    subTableLinesIndexes.push(j);
                                    subTableLines.push(nextLine);
                                    subTableLinesR.push(nextLine);
                                } else {
                                    break;
                                }

                            }
                        }
                        let header = subTableLines[0];
                        let returnObj = self.mapTableHeaders(header, tableMapping, scanData.tableMapping, length, req.body.templateId);
                        headers = returnObj.finalHeaders;
                        let obj = {};
                        let subTable = [];
                        let validRowLength = 0;
                        let amountFound;
                        let lastValidRow = false;
                        let lastRowLength = -1;
                        self.concatWords(subTableLines, header, perc, tableHeaders, tableHeadersNew, scanD, ruleObj)
                        let columnCordinates = self.findCordinates(header, subTableLines, [], [], scanD.data['tableSubHeaders'], []);
                        for (let i = 1; i < subTableLines.length; i++) {
                            let line = subTableLines[i];
                            let subHaderFound;
                            let subHaderFoundR = self.checkIfsubHeader(scanD.data['tableSubHeaders'], subTableLines, i);
                            if (subHaderFoundR['subHaderFound']) {
                                if (i == subHaderFoundR['ind']) {
                                    subHaderFound = true;
                                    lastValidRow = true;
                                } else {
                                    subHaderFound = false;
                                }
                            }
                            let objDa = self.createTablbeObject(header, line, scanData, [], scanD.data['tableSubHeaders'], JSON.parse(JSON.stringify(lastValidRow)), subHaderFound, scanD, columnCordinates, validRows, i, amountFound, validRowLength, lastRowLength,null);
                            lastRowLength = line.length;
                            obj = objDa['obj'];
                            for (var k in obj) {
                                if (k.indexOf("|") > -1 && !(/\|$/.test(k))) {
                                    let splitArr = k.split("|");
                                    if (splitArr.length == 3) {
                                        obj[k] = obj[k].replace(/\s-/gi, '-');
                                        let splitValArr = obj[k].trim().split(/\s/);
                                        if (splitValArr.length == 3) {
                                            delete obj[k];
                                            obj[splitArr[0].trim()] = splitValArr[0];
                                            obj[splitArr[1].trim()] = splitValArr[1];
                                            for (let index = 2; index < splitValArr.length; index++) {
                                                if (index == 2) {
                                                    obj[splitArr[2].trim()] = splitValArr[index];
                                                } else {
                                                    obj[splitArr[2].trim()] = obj[splitArr[2].trim()] + " " + splitValArr[index];
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            lastValidRow = objDa['lastValidRow'];
                            columnCordinates = objDa['columnCordinates'];
                            amountFound = objDa['amountFound'];
                            validRowLength = objDa['validRowLength'];
                            if (objDa['subHearderRow'] && !util_1.isNullOrUndefined(scanD.data['tableSubHeaders']) && scanD.data['tableSubHeaders'].length > 0 && !(!util_1.isNullOrUndefined(scanD.data['tableStartSubHeader']) && scanD.data['tableStartSubHeader'].length > 0)) {
                                for (var k in obj) {
                                    if (!util_1.isNullOrUndefined(subTable[subTable.length - 1])) {
                                        if (!util_1.isNullOrUndefined(subTable[subTable.length - 1][k]) && subTable[subTable.length - 1][k].replace(/[\s]/gi, '') != obj[k].replace(/[\s]/gi, '')) {
                                            subTable[subTable.length - 1][k] = subTable[subTable.length - 1][k] + " " + obj[k];
                                        } else {
                                            subTable[subTable.length - 1][k] = subTable[subTable.length - 1][k]
                                        }
                                    }
                                }
                            } else {
                                subTable.push(obj);
                            }
                        }
                        if (!util_1.isNullOrUndefined(TableObject[TableObject.length - 1])) {
                            TableObject[TableObject.length - 1]['subTable'] = subTable;
                        }

                    }
                }
                let objDa;
                if (subTableLinesIndexes.indexOf(i) > -1) {
                    allowPush = false;
                    objDa = self.createTablbeObject(finalHeaders, line, scanData, tableColumns, scanD.data['tableSubHeaders'], JSON.parse(JSON.stringify(lastValidRow)), subHaderFound, scanD, [], validRows, i, amountFound, validRowLength, lastRowLength,bestMatchingTable);
                } else {
                    objDa = self.createTablbeObject(finalHeaders, line, scanData, tableColumns, scanD.data['tableSubHeaders'], JSON.parse(JSON.stringify(lastValidRow)), subHaderFound, scanD, columnCordinates, validRows, i, amountFound, validRowLength, lastRowLength,bestMatchingTable);
                }
                // let objDa = self.createTablbeObject(finalHeaders, line, scanData, tableColumns, scanD.data['tableSubHeaders'], JSON.parse(JSON.stringify(lastValidRow)), subHaderFound, scanD, columnCordinates, validRows, i, amountFound, validRowLength);
                obj = objDa['obj'];
                lastColumnCordinates = JSON.parse(JSON.stringify(columnCordinates));
                if (scanD.data['masterTableHorizontal'] && subTableLinesIndexes.indexOf(i) == -1) {
                    let key = "";
                    obj = {}
                    let doneHeaders = [];
                    for (let i = 0; i < line.length; i++) {
                        const element = line[i];
                        const keys = Object.keys(scanD.data['tableMapping']);
                        let all = false;
                        for (let index = 0; index < keys.length; index++) {
                            const ele = keys[index];
                            if (scanD.data['tableMapping'][ele] == element['Name']) {
                                all = true;
                                doneHeaders.push(ele);
                            }

                        }
                        if ((keys.indexOf(element['Name'].replace(/\:/, "")) > -1 || all) && !/\d/.test(element['Name'])) {
                            if (!util_1.isNullOrUndefined(scanD.data['tableMapping'][element['Name'].replace(/\:/, "")])) {
                                obj[scanD.data['tableMapping'][element['Name'].replace(/\:/, "")]] = "";
                                key = scanD.data['tableMapping'][element['Name'].replace(/\:/, "")];
                            } else {
                                obj[element['Name']] = "";
                                key = element['Name'];
                            }
                        } else if (key != "" && !/^\d$/.test(element['Name'])) {
                            obj[key] = obj[key] + " " + line[i]['Name'].replace(/\:/, "");
                        }

                    }
                    if (key == "") {
                        allowPush = false;
                    } else {

                        if (!util_1.isNullOrUndefined(scanD.data['subHeaderBreakWords']) && scanD.data['subHeaderBreakWords'].length > 0) {
                            let objDa = self.createTablbeObject(finalHeaders, line, scanData, [], scanD.data['tableStart'], true, true, scanD, [], validRows, i, amountFound, -1, lastRowLength,null);
                            for (var k in objDa['obj']) {
                                if (scanD.data['tableStart'].indexOf(k) > -1 && doneHeaders.indexOf(k) == -1) {
                                    obj[k] = objDa['obj'][k];
                                }
                            }
                        }


                        if ((horizontalTableLines > -1 && i - horizontalTableLines == 1)) {
                            for (var k in obj) {
                                if (!util_1.isNullOrUndefined(TableObject[TableObject.length - 1])) {
                                    if (util_1.isNullOrUndefined(TableObject[TableObject.length - 1][k])) {
                                        TableObject[TableObject.length - 1][k] = obj[k];
                                    }
                                }
                            }
                            allowPush = false;
                        }
                        if (horizontalTableLines == -1 || i - horizontalTableLines != 1) {
                            horizontalLines = [];
                            tablesFinal[0] = line;
                        }
                        horizontalTableLines = i;
                        horizontalLines.push(line);
                    }
                }
                for (let key in obj) {
                    if (/^[a-zA-Z]+$/.test(key) && obj.hasOwnProperty(key)) {
                        if (key === obj[key]) {
                            allowPush = false;
                        }
                    }
                }
                if (objDa['subHearderRow'] && !util_1.isNullOrUndefined(scanD.data['tableSubHeaders']) && scanD.data['tableSubHeaders'].length > 0 && !(!util_1.isNullOrUndefined(scanD.data['tableStartSubHeader']) && scanD.data['tableStartSubHeader'].length > 0) && allowPush &&
                    !(!util_1.isNullOrUndefined(scanD.data['masterTableHorizontal']) && scanD.data['masterTableHorizontal'])) {
                    allowPush = false;
                    for (var k in obj) {
                        if (!util_1.isNullOrUndefined(TableObject[TableObject.length - 1])) {
                            if (!util_1.isNullOrUndefined(TableObject[TableObject.length - 1][k]) && TableObject[TableObject.length - 1][k].replace(/[\s]/gi, '') != obj[k].replace(/[\s]/gi, '')) {
                                TableObject[TableObject.length - 1][k] = TableObject[TableObject.length - 1][k] + " " + obj[k];
                            } else {
                                TableObject[TableObject.length - 1][k] = TableObject[TableObject.length - 1][k]
                            }
                        }
                    }
                }
                lastRowLength = line.length;
                lastValidRow = objDa['lastValidRow'];
                columnCordinates = objDa['columnCordinates'];
                amountFound = objDa['amountFound'];
                validRowLength = objDa['validRowLength'];
                if (!util_1.isNullOrUndefined(obj['newHeaders'])) {
                    finalHeaders = obj['newHeaders'];
                } else {
                    let countt = 0;
                    let index = 0;
                    for (let k = 0; k < finalHeaders.length; k++) {
                        let a = finalHeaders[k];
                        if (!util_1.isNullOrUndefined(obj[a.Name]) && obj[a.Name].trim() !== '') {
                            countt++;
                            index = k;
                        }
                    }
                    if (subTableLinesIndexes.length == 0 && !util_1.isNullOrUndefined(finalHeaders[index]) && !util_1.isNullOrUndefined(TableObject[TableObject.length - 1]) && !util_1.isNullOrUndefined(TableObject[TableObject.length - 1][finalHeaders[index].Name]) && countt == 1 && TableObject.length > 0 && TableObject[TableObject.length - 1][finalHeaders[index].Name].length > obj[finalHeaders[index].Name]) {
                        let newObj = {};
                        newObj = TableObject[TableObject.length - 1];
                        newObj[finalHeaders[index].Name] = newObj[finalHeaders[index].Name] + ' ' + obj[finalHeaders[index].Name];
                        TableObject[TableObject.length - 1] = newObj;
                    } else if (allowPush) {
                        TableObject.push(obj);
                                        ///////////////////////////////////////////////////////
                let ob={}
                for (let index = 0; index < line.length; index++) {
                    const item = line[index];

                    if(Object.keys(ob).length === 0){
                        if(ruleObj.obj.filePath){
                            let selectedPathArr=ruleObj.obj.filePath.split("/");
                            let selectedPath=selectedPathArr[selectedPathArr.length-1];
                            const regex = /_(\d+)\.png$/;
                            const match = regex.exec(selectedPath);
    
                            if (match && match[1]) {
                                const pageNumber = match[1];
                                ob['pageNo']=match[1];
                                // console.log(`Page Number: ${pageNumber}`);
                              }
                        }

                       ob['leftX']=item.leftX;
                       ob['rightX']=item.rightX;
                       ob['topY']=item.topY;
                       ob['bottomY']=item.bottomY;
                       ob['tableName']=tableName
                    }else{
                        if(util_1.isNullOrUndefined(ob['pageNo'])){
                            if(ruleObj.obj.filePath){
                                let selectedPathArr=ruleObj.obj.filePath.split("/");
                                let selectedPath=selectedPathArr[selectedPathArr.length-1];
                                const regex = /_(\d+)\.png$/;
                                const match = regex.exec(selectedPath);
        
                                if (match && match[1]) {
                                    const pageNumber = match[1];
                                    ob['pageNo']=match[1];
                                    // console.log(`Page Number: ${pageNumber}`);
                                  }
                            }
                        }
                        ob['leftX']= ob['leftX']>item['leftX']? item['leftX']:ob['leftX'];
                        ob['rightX']= ob['rightX']<item['rightX']? item['rightX']:ob['rightX'];
                        ob['topY']= ob['topY']>item['topY']? item['topY']:ob['topY'];
                        ob['bottomY']= ob['bottomY']<item['bottomY']? item['bottomY']:ob['bottomY'];
                    }
                }
                tableobjectsCordinates.push(ob);
                /////////////////////////////////////////////////////////
                    }
                }

            }
            if (TableObject.length == 0) {
                obj = {};
                for (let i = 0; i < finalHeaders.length; i++) {
                    let a = finalHeaders[i];
                    obj[a.Name] = '';
                }
                if (finalHeaders.length > 0) {
                    TableObject.push(obj);
                }
            }
            // TableObject = self.processTableObjects(TableObject, scanData.allowGarbage, scanD, validRows,tableobjectsCordinates);
            // let result = self.processTableObjects(TableObject, scanData.allowGarbage, scanD, validRows,tableobjectsCordinates,bestMatchingTable);
            // TableObject=result['newTableArray'];
            // tableobjectsCordinates=result['fArrCordinates']
            if(TableObject.length>0){

                if(!util_1.isNullOrUndefined(bestMatchingTable) && !util_1.isNullOrUndefined(bestMatchingTable['tableStart']) && bestMatchingTable['tableStart'].length==1){
                    TableObject = TableObject.filter(obj => obj !== undefined && obj !== null);
                    let keys = Object.keys(TableObject[0]);                    
                    let result = keys.map(key => TableObject.map(({ [key]: _, ...rest }) => rest));
                    for(let tableOb of result){
                        let ob = {}
                        let filteredData = tableOb.filter(obj => Object.keys(obj).length !== 0);
                        // console.log(filteredData)
                        if(filteredData.length>0){
                            let firstRow=filteredData[0];
                            for(let key in firstRow){
                                let tableName = key;
                                let tableM=null;
                                scanData.multiTable.forEach(table => {
                                  if(table['tableStart'].indexOf(key)>-1){
                                    tableName=table['tableName']
                                    tableM=table
                                  }
                                });

                                if(!util_1.isNullOrUndefined(tableM)){
                                    // if(!util_1.isNullOrUndefined(tableM) && !util_1.isNullOrUndefined(tableM['rowStartWith'])){
        
                                        let result = self.processTableObjects(filteredData, scanData.allowGarbage, scanD, validRows,tableobjectsCordinates,tableM);
                                        filteredData=result['newTableArray'];
                                    // }
                                }
                                ob[tableName] = filteredData;
                                // ob['keys'] = Object.keys(filteredData[0]);
                                if(!util_1.isNullOrUndefined(filteredData[0]) && filteredData.length>0){
                                    let tmpOb={}
                                    tmpOb[tableName]=tableobjectsCordinates;
                                    tableobjectsCordinatesMaster.push(tmpOb);
                                }
                                if(!util_1.isNullOrUndefined(filteredData[0])){
                                    ob['keys'] = Object.keys(filteredData[0]);
                                }else{
                                    ob['keys'] = [];
                                }
                                multiTablesObject.push(ob);
                            }
                        }
                    }
                }else{
                    let result = self.processTableObjects(TableObject, scanData.allowGarbage, scanD, validRows,tableobjectsCordinates,bestMatchingTable);
                    TableObject=result['newTableArray'];
                    tableobjectsCordinates=result['fArrCordinates']
                    TableObject = TableObject.filter(obj => obj !== undefined && obj !== null);
                    let ob = {}
                    ob[tableName] = TableObject;
                    // console.log(tableName,"table-----------------------",JSON.stringify(TableObject));
                    // ob['keys'] = Object.keys(TableObject[0]);
                    if(!util_1.isNullOrUndefined(TableObject[0])){
                        ob['keys'] = Object.keys(TableObject[0]);
                    }else{
                        ob['keys'] = [];
                    }
                    multiTablesObject.push(ob);
                    let tmpOb={}
                    tmpOb[tableName]=tableobjectsCordinates;
                    tableobjectsCordinatesMaster.push(tmpOb);
                }
                // TableObject = TableObject.filter(obj => obj !== undefined && obj !== null);
                // let ob = {}
                // ob[tableName] = TableObject;
                // ob['keys'] = Object.keys(TableObject[0]);
                // multiTablesObject.push(ob);
            }
            // let tmpOb={}
            // tmpOb[tableName]=tableobjectsCordinates;
            // tableobjectsCordinatesMaster.push(tmpOb);
            }
 

        }

        return multiTablesObject;

    }
    getHorizontalTable(scanData,item){
        let tableOb=[];
        let obj={};
        let cordinates=[];
        let lastHeaders=[];

         for (let index = 0; index < item.length; index++) {

            let array = item[index];
            for (let k = 0; k < array.length; k++) {
                let element = array[k];
                if(scanData.tableStart.indexOf(element.Name.replace(/\:/,""))>-1 && (/\:$/.test(element.Name) || 
                (k<array.length-1 && /\:$/.test(array[k+1].Name)))){
                    if(util_1.isNullOrUndefined(obj[element.Name.replace(/\:$/,"")])){
                     obj[element.Name.replace(/\:$/,"")]=""
                     let coOb={
                       header:element.Name.replace(/\:$/,""),
                       leftX:element.rightX,
                       rightX:0,
                       topY:element.topY,
                       bottomY:element.bottomY
                     }
                     if(k==0){
                        lastHeaders=[]
                        lastHeaders.push(element.Name.replace(/\:$/,""));
                     }else{
                        lastHeaders.push(element.Name.replace(/\:$/,""));
                     }
                     for (let j = k+1; j < array.length; j++) {
                         let ele = array[j];
                         if(scanData.tableStart.indexOf(ele.Name.replace(/\:$/,""))==-1){
                             if(!/\:$/.test(ele.Name)){
                                obj[element.Name.replace(/\:$/,"")]=obj[element.Name.replace(/\:$/,"")]+" "+ele.Name;
                             }
                             ele['mark']=true;
                             if(j==array.length-1){
                                coOb['rightX']=ele.rightX;
                                coOb['bottomY']=ele.bottomY;
                                cordinates.push(coOb);
                             }
                         }else{
                            coOb['rightX']=ele.rightX;
                            coOb['bottomY']=ele.bottomY;
                            cordinates.push(coOb);
                             break;
                         }
                         
                     }
     
                    }
                 }else{
                    if(util_1.isNullOrUndefined(element['mark'])){

                        for (let i = 0; i < cordinates.length; i++) {
                            let cord = cordinates[i];
                            if(cord.leftX<element.leftX && cord.rightX>=element.rightX && lastHeaders.indexOf(cord.header)>-1){
                                obj[cord.header]=obj[cord.header]+" "+element.Name;
                                // cord['bottomY']=element.bottomY;

                            }
                            
                        }

                    }

                 }
            }

            


         }
         tableOb.push(obj);
         scanData['cordinates']=cordinates;
        return tableOb;
    }
    extractLines(pdf_path) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                // Path to your Python script
                // console.log(execSync('python3 --version').toString());

                // const pythonScript = '/home/user/Downloads/scanningProject/msme-vat-node/uae-vat-node/lines.py';
                // pdf_path = '/home/user/Desktop/readFile/1.pdf';
                const pythonScript = './lines.py';
                const command = `python3 ${pythonScript} ${pdf_path}`;
            
                exec(command, (error, stdout, stderr) => {
                  if (error) {
                    // console.error(`Error: ${error.message}`);
                    // reject(error);
                    // return;
                    resolve([]);
                  }
                  console.log('Raw Output:',stdout);

                  try {
                    // Parse the output as JSON (assuming the Python script returns JSON)
                    stdout = stdout.replace(/'([^']+)'/g, '"$1"');
                    const lines = JSON.parse(stdout);
            
                    // Access the vertical lines
                    const verticalLines = lines;
            
                    // Resolve the Promise with the vertical lines
                    resolve(verticalLines);
                  } catch (parseError) {
                    // console.error(`Error parsing JSON: ${parseError.message}`);
                    reject(parseError);
                  }
                });
              });
        });
        
      }
    findIfBelongsToTable(header,nextLine){
        let count=0;
        for (let index = 0; index < header.length; index++) {
            let a = header[index];
            for (let i = 0; i < nextLine.length; i++) {
                let b = nextLine[i];
                if((b.rightX > a.leftX && b.leftX < a.rightX)){
                    count=count+1
                    break;
                }
            }
            
        }
        let perc=(count/nextLine.length)*100;
        if(perc==100 && nextLine.length<=header.length && nextLine.length>1){
           return true;
        }

        return false;
    }
    findCordinates(finalHeaders, tables, lastColumnCordinates, headerIndexes,tableSubHeaders,cord) {
        let self = this;
        let columnCordinates = [];
        for (let i = 0; i < finalHeaders.length; i++) {
            let a = finalHeaders[i];
            let matched = false;
            for (let j = 1; j < tables.length; j++) {
                let line = tables[j];
                for (let k = 0; k < line.length; k++) {
                    let b = line[k];
                    if ((b.rightX > a.leftX && b.leftX < a.rightX)) {
                        let result = self.findMultiOverLapp(a, b, finalHeaders);
                        if(!util_1.isNullOrUndefined(tableSubHeaders)&& tableSubHeaders.indexOf(b.Name.replace(/\:/g, ''))>-1){
                            result.allow=false;
                        }
                        if(a.leftX<b.leftX && result.overLapPerc<2){
                            result.allow=false;
                        }
                        if (result.allow) {
                            matched = true;
                            let obj = {
                                "header": a['Name'],
                                leftX: b.leftX < a.leftX && result.overLapPerc > 6 ? b.leftX : a.leftX,
                                rightX: b.rightX > a.rightX && result.overLapPerc > 6 ? b.rightX : a.rightX
                            }
                            if (util_1.isNullOrUndefined(columnCordinates[i])) {
                                columnCordinates.push(obj);
                            } else {
                                if (columnCordinates[i]['rightX'] < b.rightX) {
                                    columnCordinates[i]['rightX'] = b.rightX;
                                }
                                if (columnCordinates[i]['leftX'] > b.leftX) {
                                    columnCordinates[i]['leftX'] = b.leftX;
                                }
                            }
                        }
                    }
                }
            }
            if (!matched) {
                let obj = {
                    "header": a['Name'],
                    leftX: a.leftX,
                    rightX: a.rightX
                }
                if (headerIndexes.length == 1 && headerIndexes[0] == 0) {
                    for (let index = 0; index < lastColumnCordinates.length; index++) {
                        let element = lastColumnCordinates[index];
                        if (obj['header'] == element.header) {
                            obj['leftX'] = element.leftX
                            obj['rightX'] = element.rightX

                        }
                    }
                }
                if (util_1.isNullOrUndefined(columnCordinates[i])) {
                    columnCordinates.push(obj);
                }
            }
        }
        if(!util_1.isNullOrUndefined(cord) && cord.length>0){
            let bottomY=0;
            let Arr=[];
            for (let index = 0; index < finalHeaders.length; index++) {
                let element = finalHeaders[index];
                for (let index = 0; index < cord.length; index++) {
                    let elementI = cord[index];
                    if((elementI.topY<=element.topY) && (elementI.bottomY>=element.bottomY) ){
                        bottomY=elementI.bottomY;
                        if(util_1.isNullOrUndefined(elementI['pushed'])){
                            Arr.push(elementI);
                            elementI['pushed']=true;
                        }
                    }
                }
                
            }
             if(Arr.length>0){
                for (let i = 0; i < finalHeaders.length; i++) {
                    let element = finalHeaders[i];
                    for (let index = 0; index < Arr.length; index++) {
                        let elementI = Arr[index];
                        if(i < finalHeaders.length-1 && elementI.rightX>=element.rightX && finalHeaders[i+1].leftX>=elementI.rightX){
                            for (let j = 0; j < columnCordinates.length; j++) {
                                let head = columnCordinates[j];
                                if(head['header']==element['Name']){
                                    head['rightX']=elementI.rightX-1;
                                }
                            }
                        }
                        if(i > 0 && elementI.leftX<=element.leftX && finalHeaders[i-1].rightX<=elementI.leftX){
                            for (let j = 0; j < columnCordinates.length; j++) {
                                let head = columnCordinates[j];
                                if(head['header']==element['Name']){
                                    head['leftX']=elementI.leftX+1;
                                }
                            }
                        }
                    }
                }
             }
        }
        return columnCordinates;
    }
    matchStart(tableStart, Name) {
        let self = this;
        for (let j = 0; j < tableStart.length; j++) {
            let start = tableStart[j];
            let similarity = self.similarity(start, Name)
            if (similarity > 0.80) {
                return true;
            } else if (start.length > 3 && Name.includes(start)) {
                return true;
            }

        }
        return false;
    }
    matchEnd(tableEnd, Name) {
        let self = this;
        for (let j = 0; j < tableEnd.length; j++) {
            let end = tableEnd[j];
            let similarity = self.similarity(end, Name)

            if (similarity > 0.80) {
                return true;
            } else if (end.length > 3 && Name.includes(end)) {
                return true;
            }

        }
        return false;
    }
    matchStr(arr, Name) {
        let self = this;
        for (let j = 0; j < arr.length; j++) {
            let start = arr[j];
            let similarity = self.similarity(start, Name)
            if (similarity > 0.80) {
                return true;
            }

        }
        return false;
    }
    concatWords(tables, headers, perc, tableHeaders, tableHeadersNew, scanD, ruleObj) {
        let self = this;
        for (let i = 1; i < tables.length; i++) {
            // let count=0;
            if (!util_1.isNullOrUndefined(ruleObj.lineWithCombineWords[0]) && !util_1.isNullOrUndefined(ruleObj.lineWithCombineWords[0][0]['imageName'])) {
                tables[i] = tables[i].filter(function (x) { return x.Name != "|" && x.Name != "]" && !x.Name.includes('---') && x.Name != "'"; });
            }
            let line = tables[i];
            let newLine = [];
            for (let j = 0; j < line.length; j++) {
                let obj = line[j];
                let diff = obj.rightX - obj.leftX;
                let wordLength = obj.Name.length;
                let pixelPerWord = diff / wordLength;
                pixelPerWord = (pixelPerWord + (pixelPerWord / 2))
                for (let k = j + 1; k < line.length; k++) {
                    let nextObj = line[k];
                    let wordDiff = nextObj.leftX - obj.rightX;
                    if (nextObj.Name == ":" || /^\:/.test(nextObj.Name)) {
                        wordDiff = 0;
                    }
                    if (wordDiff - 3 < pixelPerWord && util_1.isNullOrUndefined(line[0].header)) {

                        if (wordDiff <= (diff / wordLength) * perc && ((/US\$$/.test(obj.Name) && /(\d)[(\,)(\.)]/.test(nextObj.Name)) || !/(\d)[(\,)(\.)]/.test(nextObj.Name) || /^\(.+\)$/.test(nextObj.Name) || /^\:\(.+\)$/.test(nextObj.Name)) && nextObj.Name != "|" && obj.Name != "|" &&
                            !/^\|/.test(nextObj.Name.trim()) && !/^\{/.test(nextObj.Name) && !/\d\s\d/.test(obj.Name) && !/^\'/.test(nextObj.Name)) {
                            let firstName = obj.Name.toLocaleUpperCase();
                            firstName = firstName.replace(/\s+/g, '');
                            firstName = firstName.replace(/\:+/g, '');
                            let secondName = nextObj.Name.toLocaleUpperCase();
                            secondName = secondName.replace(/\s+/g, '');
                            secondName = secondName.replace(/\:+/g, '');
                            let allow = true;
                            allow = self.checkIfBelongsTOSameHeader(obj, nextObj, headers);
                            for (let m = 0; m < tableHeaders.length; m++) {
                                let header = tableHeaders[m].replace(/\:+/g, '');
                                let headerNew = tableHeadersNew[m].replace(/\:+/g, '');
                                if (((firstName.length > 3 || secondName.length > 3) && (firstName != "" && secondName != "" && !/^\d+$/.test(firstName) && !/^\d+$/.test(secondName) && ((firstName.length > 3 && (header.includes(firstName) || headerNew.includes(firstName))) || (secondName.length > 3 && (header.includes(secondName) || headerNew.includes(secondName))))))) {
                                    allow = false;
                                }
                            }
                            if(nextObj.Name.indexOf("(")==-1 && nextObj.Name.indexOf(")")>-1){
                                let lastOpenBracketIndex = obj.Name.lastIndexOf('(');
                                let lastCloseBracketIndex = obj.Name.lastIndexOf(')');
                                if (lastOpenBracketIndex > lastCloseBracketIndex) {
                                    allow = true;
                                }
                            }
                            if (!util_1.isNullOrUndefined(scanD.data['columnCordinates']) && scanD.data['columnCordinates'].length > 0) {
                                allow = false;
                            }
                            if (!util_1.isNullOrUndefined(scanD.data['tableSubHeaders']) && scanD.data['tableSubHeaders'].length > 0) {
                                if (scanD.data['tableSubHeaders'].indexOf(firstName) > -1 && firstName.length > 2) {
                                    allow = false;
                                }
                            }
                            if (allow) {
                                if (/^\-/.test(nextObj.Name) || /\-$/.test(obj.Name) || /^\:/.test(nextObj.Name) || /\:$/.test(obj.Name)) {
                                    obj.Name = obj.Name + nextObj.Name;
                                } else {
                                    obj.Name = obj.Name + " " + nextObj.Name;
                                }

                                obj.rightX = nextObj.rightX;
                                j = j + 1;
                            } else {
                                break;
                            }

                        } else {
                            let allow = self.checkIfBelongsTOSameHeader(obj, nextObj, headers);
                            if (wordDiff < 1 && /(\d)[(\,)(\.)]/.test(nextObj.Name) && allow) {
                                obj.Name = obj.Name + nextObj.Name;
                                obj.rightX = nextObj.rightX;
                                j = j + 1;
                            }else if(allow && nextObj.Name.indexOf("(")==-1 && nextObj.Name.indexOf(")")>-1){
                                let lastOpenBracketIndex = obj.Name.lastIndexOf('(');
                                let lastCloseBracketIndex = obj.Name.lastIndexOf(')');
                                if (lastOpenBracketIndex > lastCloseBracketIndex) {
                                    obj.Name = obj.Name +" "+ nextObj.Name;
                                    obj.rightX = nextObj.rightX;
                                    j = j + 1;
                                }else{
                                    break;
                                }
                            } else {
                                break;
                            }
                        }


                    } else {
                        break;
                    }

                }
                newLine.push(obj);

            }
            tables[i] = newLine;

        }
    }
    checkIfBelongsTOSameHeader(currentObj, nextObj, headers) {
        let header = "";
        let header1 = "";
        let overLap = [];
        for (let index = 0; index < headers.length; index++) {
            let a = headers[index];
            if ((currentObj.rightX > a.leftX && currentObj.leftX < a.rightX)) {
                // header=a;
                let overlap = a.rightX - currentObj.leftX;
                if (currentObj.leftX < a.leftX) {
                    overlap = currentObj.rightX - a.leftX
                }
                let dist = currentObj.rightX - currentObj.leftX;
                let overLapPerc = (overlap / dist) * 100
                let ob = {
                    element: a.Name,
                    overLapPerc: overLapPerc
                }
                overLap.push(ob);
            }
        }
        if (overLap.length > 0) {
            overLap.sort(function (a, b) {
                return a.overLapPerc - b.overLapPerc;
            });
            header = overLap[overLap.length - 1]['element'];
        }

        overLap = [];
        for (let index = 0; index < headers.length; index++) {
            let a = headers[index];
            if ((nextObj.rightX > a.leftX && nextObj.leftX < a.rightX)) {
                // header1=a;
                let overlap = a.rightX - nextObj.leftX;
                if (nextObj.leftX < a.leftX) {
                    overlap = nextObj.rightX - a.leftX
                }
                let dist = nextObj.rightX - nextObj.leftX;
                let overLapPerc = (overlap / dist) * 100
                let ob = {
                    element: a.Name,
                    overLapPerc: overLapPerc
                }
                overLap.push(ob);
            }
        }
        if (overLap.length > 0) {
            overLap.sort(function (a, b) {
                return a.overLapPerc - b.overLapPerc;
            });
            header1 = overLap[overLap.length - 1]['element'];
        }
        if (header == "" || header1 == "") {
            return true
        } else if (header != header1) {
            return false
        }
        return true;
    }
    checkInd(array, Name) {
        for (let index = 0; index < array.length; index++) {
            const row = array[index];
            if (Name.length > 3 && Name.includes(row)) {
                return true;
            }
        }

        return false;
    }
    checkIfsubHeader(tableSubHeaders, array, i) {
        let self = this;
        for (let index = i; index < array.length; index++) {
            const row = array[index];

            for (let j = 0; j < row.length; j++) {
                const element = row[j];
                let oI = self.findIndex(tableSubHeaders, element.Name);
                if (oI > -1) {
                    return { subHaderFound: true, ind: index };
                }
            }

        }

        return { subHaderFound: null, ind: -1 };
    }
    findIndex(subRowHeaders, Name) {

        for (let o = 0; o < subRowHeaders.length; o++) {
            if (Name.indexOf(subRowHeaders[o]) > -1) {
                return o;
            }
        }

        return -1;
    }
    fixTableHeaders(headers, tables, upperCaseStart) {
        let self = this;
        for (let i = 0; i < tables.length; i++) {
            let row = tables[i];
            let length = upperCaseStart.length - 1;
            if (length == row.length) {
                for (let j = 0; j < row.length; j++) {
                    if (upperCaseStart.indexOf(row[j].Name.replace(/\s/g, '').toUpperCase()) > -1) {
                        let matched = false;
                        for (let k = 0; k < headers.length; k++) {
                            let similarity = self.similarity(headers[k].Name, row[j].Name)
                            if (similarity > 0.85) {
                                matched = true;
                            }
                        }
                        if (!matched) {
                            let obj = JSON.parse(JSON.stringify(row[j]));
                            obj['topY'] = headers[0]['topY'];
                            obj['bottomY'] = headers[0]['bottomY'];
                            headers.splice(j, 0, obj);
                        }
                    }
                }
            }
        }
    }
    extractInfo(ruleObj) {
        let petiantObj = {};
        let petiantArr = [];
        let TableArray = ruleObj.lineWithCombineWordsNew;
        let TableArray2 = ruleObj.lineWithCombineWords
        let res = []
        let flag = true
        for (let i = 0; i < TableArray.length; i++) {
            //let next = TableArray[i+1]
            if (TableArray[i].length > 0 && TableArray[i + 1] && TableArray[i + 1].length > 0 && TableArray[i]['bottomY'] && TableArray[i + 1][0]['bottomY'] && TableArray[i + 1][0].bottomY < TableArray[i][0]['bottomY'] && TableArray[i + 1][0].topY > TableArray[i][0]['topY']) {
                let newLine = [...TableArray[i], ...TableArray[i + 1]]
                if (TableArray.length === TableArray2.length) {
                    newLine = [...TableArray[i], ...TableArray2[i + 1]]
                }
                flag = false
                newLine = newLine.sort((a, b) => a.leftX - b.leftX)
                newLine = newLine.reduce((final, el) => {
                    if (final && final[final.length - 1] && Math.abs(el['leftX'] - final[final.length - 1]['rightX']) < 15) {
                        let newObj = { 'Name': final[final.length - 1]['Name'] + ' ' + el['Name'], leftX: final[final.length - 1].leftX, rightX: el['rightX'], topY: el['topY'], bottomY: el['bottomY'] }
                        newObj = Object.assign(el, newObj)
                        final[final.length - 1] = newObj
                    } else {
                        final.push(el)
                    }
                    return final
                }, [])
                res.push(newLine)
            } else {
                if (flag) {
                    res.push(TableArray[i])
                } else {
                    flag = true
                    res.push([])
                }
            }
        }
        TableArray = res;
        for (let i = 0; i < TableArray.length; i++) {
            let mateched = false;
            let row = TableArray[i];
            if (row.length > 0) {
                for (let j = 0; j < row.length; j++) {
                    if (/Pat.{4} Name/.test(row[j].Name)) {
                        row[j].Name = row[j].Name.replace(/Pat.{4} Name/, 'Patient Name')
                    }
                    if (/.{1}nsured Name/.test(row[j].Name)) {
                        row[j].Name = row[j].Name.replace(/.{1}nsured Name/, 'Insured Name')
                    }
                    if (/NP.{1}:/.test(row[j].Name)) {
                        row[j].Name = row[j].Name.replace(/NP.{1}/, 'NPI')
                    }
                    if (/\w+\;\s\w+|\w+\;\w+|\w+;.{0,5}\w+|\w+\s*;$/.test(row[j].Name)) {
                        row[j].Name = row[j].Name.replace(';', ':')
                    }
                    if (row[j + 1] && row[j].Name && /Patient/.test(row[j].Name) && /^Name:/i.test(row[j + 1].Name)) {
                        row[j].Name = row[j].Name + ' ' + row[j + 1].Name
                    }
                    if (row[j].Name.includes('Insured Name')) {
                        mateched = true;
                        let val = row[j].Name.split("Insured Name");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Insured Name'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Insured Name'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Insured Name'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Insured Name'] = row[j + 1].Name;
                            } else {
                                petiantObj['Insured Name'] = "";
                            }
                        }
                        if (petiantObj['Insured Name'] && petiantObj['Insured Name'] != "") {
                            let name = petiantObj['Insured Name'].trim().split(/\s+/)
                            if (name.length == 2) {
                                petiantObj['Insured First Name'] = name[0]
                                petiantObj['Insured Last Name'] = name[1]
                                petiantObj['Insured Middle Name'] = ''
                            } else if (name.length == 3) {
                                petiantObj['Insured First Name'] = name[0]
                                petiantObj['Insured Last Name'] = name[2]
                                petiantObj['Insured Middle Name'] = name[1]
                            } else {
                                petiantObj['Insured First Name'] = petiantObj['Insured Name']
                                petiantObj['Insured Last Name'] = ''
                                petiantObj['Insured Middle Name'] = ''
                            }
                        }
                    } else if (row[j].Name.includes('Service Provider')) {
                        mateched = true;
                        let val = row[j].Name.split("Service Provider");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Service Provider'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Service Provider'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Service Provider'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Service Provider'] = row[j + 1].Name;
                            } else {
                                petiantObj['Service Provider'] = "";
                            }
                        }
                        if (petiantObj['Service Provider'] && petiantObj['Service Provider'] != "") {
                            let name = petiantObj['Service Provider'].trim().split(/\s+/)
                            if (name.length == 2) {
                                petiantObj['Service Provider First Name'] = name[0]
                                petiantObj['Service Provider Last Name'] = name[1]
                                petiantObj['Service Provider Middle Name'] = ''
                            } else if (name.length == 3) {
                                petiantObj['Service Provider First Name'] = name[0]
                                petiantObj['Service Provider Last Name'] = name[2]
                                petiantObj['Service Provider Middle Name'] = name[1]
                            } else {
                                petiantObj['Service Provider First Name'] = petiantObj['Service Provider']
                                petiantObj['Service Provider Last Name'] = ''
                                petiantObj['Service Provider Middle Name'] = ''
                            }
                        }
                    } else if (row[j].Name.includes('Member ID')) {
                        mateched = true;
                        let val = row[j].Name.split("Member ID");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Member ID'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Member ID'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Member ID'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Member ID'] = row[j + 1].Name;
                            } else {
                                petiantObj['Member ID'] = "";
                            }
                        }
                    } else if (row[j].Name.includes('Claim No:')) {
                        mateched = true;
                        let val = row[j].Name.split("Claim No:");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Claim No:'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Claim No:'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Claim No:'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Claim No:'] = row[j + 1].Name;
                            } else {
                                petiantObj['Claim No:'] = "";
                            }
                        }
                    } else if (row[j].Name.includes('PCN')) {
                        mateched = true;
                        let val = row[j].Name.split("PCN");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['PCN'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['PCN'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['PCN'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['PCN'] = row[j + 1].Name;
                            } else {
                                petiantObj['PCN'] = "";
                            }
                        }
                    } else if (row[j].Name.includes('Provider ID')) {
                        mateched = true;
                        let val = row[j].Name.split("Provider ID");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Provider ID'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Provider ID'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Provider ID'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Provider ID'] = row[j + 1].Name;
                            } else {
                                petiantObj['Provider ID'] = "";
                            }
                        }
                    } else if (row[j].Name.includes('NPI')) {
                        mateched = true;
                        let val = row[j].Name.split("NPI");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['NPI'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['NPI'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['NPI'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['NPI'] = row[j + 1].Name;
                            } else {
                                petiantObj['NPI'] = "";
                            }
                        }
                    } else if (row[j].Name.includes('Group') && Object.keys(petiantObj).length != 0) {
                        mateched = true;
                        let val = row[j].Name.split("Group");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Group'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Group'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Group'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Group'] = row[j + 1].Name;
                            } else {
                                petiantObj['Group'] = "";
                            }
                        }
                        petiantArr.push(petiantObj);
                        petiantObj = {};
                    } else if (row[j].Name.includes('Patient Name')) {
                        mateched = true;
                        let val = row[j].Name.split("Patient Name");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Patient Name'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Patient Name'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Patient Name'] = "";
                                if (!util_1.isNullOrUndefined(TableArray[i + 1]) && TableArray[i + 1].length == 1 && TableArray[i + 1][0].leftX > row[j]['rightX'] && TableArray[i + 1][0].rightX < row[j + 1]['leftX'] && TableArray[i + 1][0].topY > row[j]['topY'] && TableArray[i + 1][0].bottomY < row[j]['bottomY']) {
                                    petiantObj['Patient Name'] = TableArray[i + 1][0].Name
                                }
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Patient Name'] = row[j + 1].Name;
                            } else {
                                petiantObj['Patient Name'] = "";
                            }
                        }
                        if (petiantObj['Patient Name'] && petiantObj['Patient Name'] != "") {
                            let name = petiantObj['Patient Name'].trim().split(/\s+/)
                            if (name.length == 2) {
                                petiantObj['Patient First Name'] = name[0]
                                petiantObj['Patient Last Name'] = name[1]
                                petiantObj['Patient Middle Name'] = ''
                            } else if (name.length == 3) {
                                petiantObj['Patient First Name'] = name[0]
                                petiantObj['Patient Last Name'] = name[2]
                                petiantObj['Patient Middle Name'] = name[1]
                            } else {
                                petiantObj['Patient First Name'] = petiantObj['Patient Name']
                                petiantObj['Patient Last Name'] = ''
                                petiantObj['Patient Middle Name'] = ''
                            }
                        }
                    } else if (row[j].Name.includes('Patient Number')) {
                        mateched = true;
                        let val = row[j].Name.split("Patient Number");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Patient Number'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Patient Number'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Patient Number'] = "";

                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Patient Number'] = row[j + 1].Name;
                            } else {
                                petiantObj['Patient Number'] = "";
                            }
                        }
                    } else if (row[j].Name.includes('Claim Number')) {
                        mateched = true;
                        let val = row[j].Name.split("Claim Number");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Claim Number'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Claim Number'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Claim Number'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Claim Number'] = row[j + 1].Name;
                            } else {
                                petiantObj['Claim Number'] = "";
                            }
                        }
                    } else if (row[j].Name.includes('Check Number') && Object.keys(petiantObj).length != 0) {
                        mateched = true;
                        let val = row[j].Name.split("Check Number");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Check Number'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Check Number'] = val[1];
                        } else {

                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Check Number'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Check Number'] = row[j + 1].Name;
                            } else {
                                petiantObj['Check Number'] = "";
                            }
                        }
                        petiantArr.push(petiantObj);
                        petiantObj = {};
                    } else if (row[j].Name.includes('Chock Number') && Object.keys(petiantObj).length != 0) {
                        mateched = true;
                        let val = row[j].Name.split("Chock Number");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Check Number'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Check Number'] = val[1];
                        } else {

                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Check Number'] = "";
                            } else {
                                petiantObj['Check Number'] = row[j + 1].Name;
                            }
                            petiantObj['Check Number'] = row[j + 1].Name;
                        }
                        petiantArr.push(petiantObj);
                        petiantObj = {};
                    } else if (row[j].Name.includes('Sponsor Number')) {
                        mateched = true;
                        let val = row[j].Name.split("Sponsor Number");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Sponsor Number'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Sponsor Number'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Sponsor Number'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Sponsor Number'] = row[j + 1].Name;
                            } else {
                                petiantObj['Sponsor Number'] = "";
                            }
                        }
                    } else if (row[j].Name.includes('Provider')) {
                        mateched = true;
                        let val = row[j].Name.split("Provider");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Provider'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Provider'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Provider'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Provider'] = row[j + 1].Name;
                            } else {
                                petiantObj['Provider'] = "";
                            }
                        }
                        if (petiantObj['Provider'] && petiantObj['Provider'] != "") {
                            let name = petiantObj['Provider'].trim().split(/\s+/)
                            if (name.length == 2) {
                                petiantObj['Provider First Name'] = name[0]
                                petiantObj['Provider Last Name'] = name[1]
                                petiantObj['Provider Middle Name'] = ''
                            } else if (name.length == 3) {
                                petiantObj['Provider First Name'] = name[0]
                                petiantObj['Provider Last Name'] = name[2]
                                petiantObj['Provider Middle Name'] = name[1]
                            } else {
                                petiantObj['Provider First Name'] = name
                                petiantObj['Provider Last Name'] = ''
                                petiantObj['Provider Middle Name'] = ''
                            }
                        }
                    } else if (row[j].Name.includes('Patient Acct')) {
                        mateched = true;
                        let val = row[j].Name.split("Patient Acct");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Patient Acct'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0 && val[1].split('').pop() != ':') {
                            petiantObj['Patient Acct'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Patient Acct'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Patient Acct'] = row[j + 1].Name;
                            } else {
                                petiantObj['Patient Acct'] = "";
                            }
                        }
                        if (/#/.test(petiantObj['Patient Acct'])) {
                            petiantObj['Patient Acct'] = petiantObj['Patient Acct'].replace(/#.{1}/, '')
                        }
                    } else if (row[j].Name.includes('Claim Number')) {
                        mateched = true;
                        let val = row[j].Name.split("Claim Number");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Claim Number'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Claim Number'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Claim Number'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Claim Number'] = row[j + 1].Name;
                            } else {
                                petiantObj['Claim Number'] = "";
                            }
                        }
                    } else if (row[j].Name.includes('Claim Number')) {
                        mateched = true;
                        let val = row[j].Name.split("Claim Number");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Claim Number'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Claim Number'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Claim Number'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Claim Number'] = row[j + 1].Name;
                            } else {
                                petiantObj['Claim Number'] = "";
                            }
                        }
                    } else if (row[j].Name.includes('Patient Name')) {
                        mateched = true;
                        let val = row[j].Name.split("Patient Name");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Patient Name'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Patient Name'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Patient Name'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Patient Name'] = row[j + 1].Name;
                            } else {
                                petiantObj['Patient Name'] = "";
                            }
                        }
                        if (petiantObj['Patient Name'] && petiantObj['Patient Name'] != "") {
                            let name = petiantObj['Patient Name'].trim().split(/\s+/)
                            if (name.length == 2) {
                                petiantObj['Patient First Name'] = name[0]
                                petiantObj['Patient Last Name'] = name[1]
                                petiantObj['Patient Middle Name'] = ''
                            } else if (name.length == 3) {
                                petiantObj['Patient First Name'] = name[0]
                                petiantObj['Patient Last Name'] = name[2]
                                petiantObj['Patient Middle Name'] = name[1]
                            } else {
                                petiantObj['Patient First Name'] = petiantObj['Patient Name']
                                petiantObj['Patient Last Name'] = ''
                                petiantObj['Patient Middle Name'] = ''
                            }
                        }
                        if (petiantObj['Member Number']) {
                            petiantArr.push(petiantObj);
                            petiantObj = {};
                        }

                    } else if (row[j].Name.includes('Member Number')) {
                        mateched = true;
                        let val = row[j].Name.split("Member Number");
                        if (/\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j].Name)) {
                            let dat = row[j].Name.split(":")
                            petiantObj['Member Number'] = dat[1];
                        } else if (val.length == 2 && val[1] != ":" && val.join('').length > 0) {
                            petiantObj['Member Number'] = val[1];
                        } else {
                            if (!util_1.isNullOrUndefined(row[j + 1]) && /\w+\:\s\w+|\w+\:\w+|\w+:.{0,5}\w+/.test(row[j + 1].Name)) {
                                petiantObj['Member Number'] = "";
                            } else if (!util_1.isNullOrUndefined(row[j + 1])) {
                                petiantObj['Member Number'] = row[j + 1].Name;
                            } else {
                                petiantObj['Member Number'] = "";
                            }
                        }
                        if (petiantObj['Patient Name']) {
                            petiantArr.push(petiantObj);
                            petiantObj = {};
                        }

                    } else if (/Network/i.test(row[j].Name)) {
                        petiantArr.push(petiantObj);
                        petiantObj = {};
                    }
                }
                if (mateched) {
                    TableArray[i][0]['delete'] = true;
                    TableArray2[i][0]['delete'] = true;

                }
            }
        }
        if (petiantArr.length == 0 && Object.keys(petiantObj).length > 0) {
            petiantArr.push(petiantObj);
        }
        TableArray = TableArray.filter(function (x) { return x[0] && util_1.isNullOrUndefined(x[0]['delete']); })
        TableArray2 = TableArray2.filter(function (x) { return x[0] && util_1.isNullOrUndefined(x[0]['delete']); })
        ruleObj.lineWithCombineWordsNew = TableArray;
        if (TableArray.length == TableArray2.length) {
            ruleObj.lineWithCombineWords = TableArray2;
        }
        //ruleObj.lineWithCombineWords=TableArray2;
        return petiantArr.filter(el => Object.keys(el).length > 0);
    }

    extractTables(TableObject) {
        try {
            let masterArr = [];
            let arr = [];
            for (let index = 0; index < TableObject.length; index++) {
                let obj = TableObject[index];
                let allow = true;
                for (var k in obj) {
                    if (obj[k].includes("Sub-total") || obj[k].includes("Claim Totals") || obj[k].includes("Total") || obj[k].includes("Alt Policy") || obj[k].includes('Provider:')) {
                        allow = false;
                    }
                }
                if (allow) {
                    arr.push(obj);
                } else {
                    masterArr.push(arr);
                    arr = [];
                }
            }
            // console.log(masterArr);
            if (arr.length > 0) {
                masterArr.push(arr);
            }
            return masterArr;

        } catch (e) {

        }
    }
    findStartOfTable(req, scanData) {
        try {
            let self = this;
            let pageNo = 0;
            let matchCountArray = []
            for (let index = 0; index < req.body.input.ruleObj.length; index++) {
                logger.info('Scanning fields data found successfully in IdentiffyTable');
                let ruleObj = req.body.input.ruleObj[index];
                let tableStartData = [];
                let tableEndData = [];
                let tableMapping = {};
                let lastTopY = 0;
                let height = 0;
                let TableArray = [];
                let lineArray = [];
                let newLineflag = true;
                let tableHeaders = [];
                let tableHeadersW = [];
                let lastVal = "";
                for (var k in scanData.tableMapping) {
                    tableHeadersW.push(k);
                    k = k.toLocaleUpperCase();
                    k = k.replace(/\s+/g, '');
                    tableHeaders.push(k);
                }
                /////////////////////////////////////////////////////////////////////////////////////////
                for (let i = 0; i < ruleObj.lineWithCombineWords.length; i++) {
                    let line = ruleObj.lineWithCombineWords[i];
                    // let count=0;
                    let newLine = [];
                    for (let j = 0; j < line.length; j++) {
                        let obj = line[j];
                        let diff = obj.rightX - obj.leftX;
                        let wordLength = obj.Name.length;
                        let pixelPerWord = diff / wordLength;
                        pixelPerWord = (pixelPerWord + (pixelPerWord / 2))
                        for (let k = j + 1; k < line.length; k++) {
                            let nextObj = line[k];
                            let wordDiff = nextObj.leftX - obj.rightX;
                            if (wordDiff < pixelPerWord) {

                                let allow = false;
                                for (let m = 0; m < tableHeaders.length; m++) {
                                    let newName = obj.Name + " " + nextObj.Name;
                                    newName = newName.toLocaleUpperCase();
                                    newName = newName.replace(/\s+/g, '');
                                    if (tableHeaders[m].includes(newName) && newName.length >= 3) {
                                        allow = true;
                                    }
                                }
                                if (allow) {
                                    obj.Name = obj.Name + " " + nextObj.Name;
                                    obj.rightX = nextObj.rightX;
                                    j = j + 1;
                                }


                            }

                        }
                        newLine.push(obj);

                    }
                    ruleObj.lineWithCombineWords[i] = newLine;

                }

                for (let i = 0; i < ruleObj.lineWithCombineWordsNew.length; i++) {
                    let line = ruleObj.lineWithCombineWordsNew[i];
                    // let count=0;
                    let newLine = [];
                    for (let j = 0; j < line.length; j++) {
                        let obj = line[j];
                        let diff = obj.rightX - obj.leftX;
                        let wordLength = obj.Name.length;
                        let pixelPerWord = diff / wordLength;
                        pixelPerWord = (pixelPerWord + (pixelPerWord / 2))
                        for (let k = j + 1; k < line.length; k++) {
                            let nextObj = line[k];
                            let wordDiff = nextObj.leftX - obj.rightX;
                            if (wordDiff < pixelPerWord) {
                                let allow = false;
                                for (let m = 0; m < tableHeaders.length; m++) {
                                    let newName = obj.Name + " " + nextObj.Name;
                                    newName = newName.toLocaleUpperCase();
                                    newName = newName.replace(/\s+/g, '');
                                    if (tableHeaders[m].includes(newName) && newName.length >= 3) {
                                        allow = true;
                                    }
                                }
                                if (allow) {
                                    obj.Name = obj.Name + " " + nextObj.Name;
                                    obj.rightX = nextObj.rightX;
                                    j = j + 1;
                                }
                            }

                        }
                        newLine.push(obj);

                    }
                    ruleObj.lineWithCombineWordsNew[i] = newLine;

                }

                ////////////////////////////////////////////////////////////////////////////////////////    

                let lineWithCombineWordsNew = 0;
                let lineWithCombineWords = 0;
                let headIndex = -1;
                for (let i = 0; i < ruleObj.lineWithCombineWordsNew.length; i++) {
                    let line = ruleObj.lineWithCombineWordsNew[i];
                    let count = 0;
                    for (let j = 0; j < line.length; j++) {
                        let k = (line[j].Name.toLocaleUpperCase()).replace(/\s+/g, '');
                        if (tableHeaders.indexOf(k) != -1 && !(/\d+\,+\d+/.test(lastVal)) && !(/\d+\,+\d+/.test(line[j].Name)) && /\s+/.test(line[j].Name)) {
                            lineWithCombineWordsNew = lineWithCombineWordsNew + 1;
                        }
                        if (tableHeaders.indexOf(k) != -1 && !(/\d+\,+\d+/.test(lastVal)) && !(/\d+\,+\d+/.test(line[j].Name))) {
                            count = count + 1;
                            if (count > 5 && count == line.length - 1) {
                                lineWithCombineWordsNew = 100;
                                headIndex = i;
                            }
                        }
                    }
                }
                for (let i = 0; i < ruleObj.lineWithCombineWords.length; i++) {
                    let line = ruleObj.lineWithCombineWords[i];
                    for (let j = 0; j < line.length; j++) {
                        let k = (line[j].Name.toLocaleUpperCase()).replace(/\s+/g, '');
                        if (tableHeaders.indexOf(k) != -1 && !(/\d+\,+\d+/.test(lastVal)) && !(/\d+\,+\d+/.test(line[j].Name)) && /\s+/.test(line[j].Name)) {
                            lineWithCombineWords = lineWithCombineWords + 1;
                        }
                    }
                }
                if (lineWithCombineWords >= lineWithCombineWordsNew) {
                    ruleObj.lineWithCombineWordsNew = ruleObj.lineWithCombineWords;
                }
                /////////////////////////////////////////////////////////////////
                for (let i = 0; i < ruleObj.lineWithCombineWordsNew.length; i++) {
                    let line = ruleObj.lineWithCombineWordsNew[i];
                    if (i < ruleObj.lineWithCombineWordsNew.length - 1) {
                        for (let a = 0; a < line.length; a++) {
                            let currentObj = line[a];
                            for (let c = i + 1; c < ruleObj.lineWithCombineWordsNew.length; c++) {
                                let nextLine = ruleObj.lineWithCombineWordsNew[c];
                                for (let b = 0; b < nextLine.length; b++) {
                                    let nextObj = nextLine[b];
                                    let newName = currentObj.Name + " " + nextObj.Name;
                                    for (let m = 0; m < tableHeaders.length; m++) {
                                        newName = newName.toLocaleUpperCase();
                                        newName = newName.replace(/\s+/g, '');
                                        if (tableHeaders[m].includes(newName) && newName.length >= 3 && c - i < 5) {
                                            currentObj['allowMerge'] = true;
                                            nextObj['allowMerge'] = true;
                                            line[0]['allowMerge'] = true;
                                            nextLine[0]['allowMerge'] = true;
                                        }
                                    }
                                }
                            }

                        }
                    }
                }
                for (let i = 0; i < ruleObj.lineWithCombineWordsNew.length; i++) {
                    let line = ruleObj.lineWithCombineWordsNew[i];
                    if (i < ruleObj.lineWithCombineWordsNew.length - 2) {
                        for (let a = 0; a < line.length; a++) {
                            let currentObj = line[a];
                            let nextLine = ruleObj.lineWithCombineWordsNew[i + 2];
                            for (let b = 0; b < nextLine.length; b++) {
                                let nextObj = nextLine[b];
                                let newName = currentObj.Name + " " + nextObj.Name;
                                for (let m = 0; m < tableHeaders.length; m++) {
                                    newName = newName.toLocaleUpperCase();
                                    newName = newName.replace(/\s+/g, '');
                                    if (tableHeaders[m].includes(newName) && newName.length >= 3) {
                                        currentObj['allowMerge'] = true;
                                        nextObj['allowMerge'] = true;
                                        let prevLine = ruleObj.lineWithCombineWordsNew[i + 1];
                                        prevLine[0]['allowMerge'] = true;
                                        line[0]['allowMerge'] = true;
                                        nextLine[0]['allowMerge'] = true;
                                    }
                                }
                            }
                        }
                    }
                }
                ////////////////////////////////////////////////////////////////
                for (let i = 0; i < ruleObj.lineWithCombineWordsNew.length; i++) {
                    let line = ruleObj.lineWithCombineWordsNew[i];
                    ////////////////////////////////////////////////////////////////////////////////////
                    let allowMerge = false;
                    let currentLineAllowMerge = false;
                    if (i > 0) {
                        let lastLine = ruleObj.lineWithCombineWordsNew[i - 1];
                        if (lastLine && lastLine[0] && lastLine[0]['allowMerge'] && line && line[0] && line[0]['allowMerge']) {
                            allowMerge = true;
                        }
                        if (line && line[0] && line[0]['allowMerge']) {
                            currentLineAllowMerge = true;
                        }

                    }

                    ///////////////////////////////////////////////////////////////////////////////////
                    for (let j = 0; j < line.length; j++) {
                        if (j == 0) {
                            if (lastTopY > 0) {
                                height = line[j].bottomY - line[j].topY;
                                let val = (line[j].topY - lastTopY);
                                if (val <= 0) {
                                    let k = (line[j].Name.toLocaleUpperCase()).replace(/\s+/g, '');
                                    let newLastVal = (lastVal.toLocaleUpperCase()).replace(/\s+/g, '');
                                    let chk = self.chkConcat(line, TableArray, tableHeaders)
                                    if (((Math.abs(val)) / 2) > height) {
                                        newLineflag = true;
                                        if (chk || allowMerge) {
                                            if (currentLineAllowMerge && !allowMerge) {
                                                newLineflag = true;
                                            } else {
                                                newLineflag = false;
                                            }
                                        }
                                    } else {
                                        newLineflag = false;
                                        if (headIndex == i && !allowMerge) {
                                            newLineflag = true;;
                                        }

                                        // if (!chk) {
                                        //     newLineflag = true;
                                        // }
                                        // if (!chk && line[j].Name && tableHeaders.indexOf(line[j].Name.toLocaleUpperCase().replace(/\s+/g, '') > -1)) {
                                        //     newLineflag = true;
                                        // }
                                        // else {
                                        //     newLineflag = false;
                                        // }
                                    }
                                } else {
                                    if ((i > 0 && ruleObj.lineWithCombineWordsNew[i - 1].length > 0 && ruleObj.lineWithCombineWordsNew[i - 1][0].Name.trim() == "" && ruleObj.lineWithCombineWordsNew[i - 1].length == 1)
                                        || (!isNaN(ruleObj.lineWithCombineWordsNew[i][0].Name))) {
                                        if (!allowMerge) {
                                            newLineflag = true;
                                        } else {
                                            if (currentLineAllowMerge && !allowMerge) {
                                                newLineflag = true;
                                            } else {
                                                newLineflag = false;
                                            }
                                        }
                                    } else {
                                        let k = (line[j].Name.toLocaleUpperCase()).replace(/\s+/g, '');
                                        let chk = self.chkConcat(line, TableArray, tableHeaders)
                                        if ((Math.round((val / height) * 100) <= 45 && tableHeaders.indexOf(k) == -1 && !(/\$+\d+/.test(lastVal)) && !(/\d+\,+\d+/.test(lastVal)) && !(/\d+\,+\d+/.test(line[j].Name))) || chk) {
                                            let newLastVal = (lastVal.toLocaleUpperCase()).replace(/\s+/g, '');
                                            if (!chk & tableHeaders.indexOf(newLastVal) > -1 && !allowMerge) {
                                                newLineflag = true;
                                            } else {
                                                if (currentLineAllowMerge && !allowMerge) {
                                                    newLineflag = true;
                                                } else {
                                                    newLineflag = false;
                                                }
                                            }
                                        } else {
                                            if (!allowMerge) {
                                                newLineflag = true;
                                            } else {
                                                if (currentLineAllowMerge && !allowMerge) {
                                                    newLineflag = true;
                                                } else {
                                                    newLineflag = false;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (j == line.length - 1) {
                            lastTopY = line[j].bottomY;
                            lastVal = line[j].Name;
                        }
                        // lineArray.push(line[j].Name)
                        lineArray.push(line[j]);
                    }
                    if (newLineflag) {
                        TableArray.push(lineArray);
                        lineArray = [];
                    } else {
                        let arr = JSON.parse(JSON.stringify(TableArray[TableArray.length - 1]));
                        let result = self.findOverLapping(arr, lineArray, tableHeaders, scanD);
                        if (!result.duplicateFound) {
                            TableArray[TableArray.length - 1] = result.arr;
                            if (!util_1.isNullOrUndefined(result['lineE']) && result['lineE'].length > 0) {
                                TableArray.push(result['lineE']);
                            }
                            lineArray = [];
                        } else {
                            TableArray.push(lineArray);
                            lineArray = [];
                        }
                    }
                }
                for (let i = 0; i < TableArray.length; i++) {
                    // let line = TableArray[i];
                    TableArray[i].sort(function (a, b) {
                        return a.leftX - b.leftX;
                    });
                }
                let tableStart = scanData.tableStart;
                let tableEnd = scanData.tableEnd;
                let upperCaseStart = tableStart.map(function (value) {
                    value = !util_1.isNullOrUndefined(value) ? value : "";
                    return value.replace(/\s/g, '').toUpperCase();
                });
                let upperCaseEnd = tableEnd.map(function (value) {
                    return value.replace(/\s/g, '').toUpperCase();
                });
                let tables = [];
                let count = 0;
                let countEnd = 0;
                let startIndex = -1;
                let endIndex = 0;
                let tablesFinal = [];
                let multiTables = [];
                let newEndIndex = -1;
                let mlCordinates = {
                    // bottomY:2466
                }
                for (let i = 0; i < TableArray.length; i++) {
                    let line = TableArray[i];
                    // let names =_.pluck(line, 'Name')
                    count = 0;
                    countEnd = 0;
                    for (let j = 0; j < line.length; j++) {
                        if (upperCaseStart.indexOf(line[j].Name.replace(/\s/g, '').toUpperCase()) > -1) {
                            //console.log('start----------------------------@@@@@@@@@@@@@@@@@@');
                            count++;
                            tableStartData.push(line[j].Name);
                        }
                        if (upperCaseEnd.indexOf(line[j].Name.replace(/\s/g, '').toUpperCase()) > -1 || line[j].Name.toUpperCase().indexOf('HEREBY') > -1 || line[j].Name.toUpperCase().indexOf('HANDLING & DELIVERY CHARGES') > -1 ||
                            line[j].Name.toUpperCase().indexOf('HANDLING &') > -1 || line[j].Name.toUpperCase().indexOf('TOTAL AMOUNT IN WORDS') > -1) {
                            //console.log('end----------------------------@@@@@@@@@@@@@@@@@@');
                            countEnd++;
                            tableEndData.push(line[j].Name);
                        }

                        if (!util_1.isNullOrUndefined(mlCordinates.bottomY) && mlCordinates.bottomY < line[j].topY && startIndex != -1) {
                            countEnd = 2;
                        }
                    }
                    if (count > 1 && startIndex == -1) {
                        // console.log('table found----------------------------@@@@@@@@@@@@@@@@@@', i);
                        startIndex = i;
                        let obj = {
                            pageNo: index,
                            count: count,
                        }
                        matchCountArray.push(obj);
                    }
                    if (countEnd > 0 && startIndex != i) {
                        // console.log('table end found----------------------------@@@@@@@@@@@@@@@@@@', i);
                        endIndex = i;
                        startIndex = -1;
                        if (tablesFinal.length > 0) {
                            multiTables.push(tablesFinal);
                        }
                        tablesFinal = [];
                        if (newEndIndex == -1) {
                            newEndIndex = i;
                        }
                    }
                    if (startIndex > -1) {
                        tablesFinal.push(line);
                    }
                }
            }
            matchCountArray.sort(function (a, b) {
                return a.count - b.count;
            });
            console.log("---", matchCountArray);
            if (matchCountArray.length > 0) {
                pageNo = matchCountArray[matchCountArray.length - 1].pageNo;
            }
            for (let i = 0; i < matchCountArray.length; i++) {
                if (matchCountArray[i].pageNo == pageNo) {
                    pageNo = matchCountArray[i].pageNo;
                    break;
                }
            }
            return pageNo;
        } catch (err) {
            // console.log(err)
            return 0
        }
    }
    getTableFromLines(inputRuleObj) {
        return __awaiter(this, void 0, void 0, function* () {
            const self = this;
            let identifyTableOutputArray = [];

            let scanData = inputRuleObj.scanData;
            let lineData;

            try {
                let fileRefNum = inputRuleObj.ruleObj[0].obj.fileRefNum;

                let data = yield db.collection('fileuploadhistories').findOne({ fileRefNum: fileRefNum });
                let filePath = JSON.parse(JSON.stringify(data))['filePath'];

                let jsonPath = config.path + fileRefNum + '_lines.json'
                let options = {
                    method: 'POST',
                    url: config.cudaprod + 'gibots-pyimg/getAllLines',
                    body: {
                        "pdfPath": filePath,
                        "jsonPath": jsonPath
                    },
                    json: true
                };

                console.warn(" -- -- CALLING PYTHON LINES API -- -- ");

                let con = yield self.requestApi(options);

                if (con && con['status'] == 0) {
                    console.log("-----Lines API success-----");
                    lineData = fs.readFileSync(jsonPath, 'utf8')
                    lineData = JSON.parse(lineData);
                }
                for (let p = 0, l = inputRuleObj.ruleObj.length; p < l; p++) {
                    let ruleObj = inputRuleObj.ruleObj[p];
                    let filePath = ruleObj.obj.filePath;
                    let pageHeight = ruleObj.obj.pageHeight;
                    let pageWidth = ruleObj.obj.pageWidth;
                    let pH = pageHeight, pW = pageWidth;

                    let tBoundingBox = [];
                    let tCellsData = [];

                    if (lineData[p]) {
                        let data = lineData[p];

                        let tableStart = scanData.tableStart;
                        let tableEnd = scanData.tableEnd;
                        let upperCaseStart = tableStart.map(function (value) {
                            value = !util_1.isNullOrUndefined(value) ? value : "";
                            return value.replace(/\s/g, '').toUpperCase();
                        });
                        let tableData = [];
                        let tableStartGot;
                        let tableMappingGot = {};
                        let tableHeaders;

                        try {

                            if (data.tables.length) {
                                for (let tab of data.tables) {
                                    let headerGot = false;
                                    let headers;
                                    if (tab.length > 1 && tab.filter(a => Array.isArray(a)).length == tab.length) {
                                        for (let i = 0; i < tab.length; i++) {
                                            if (i == 0) {
                                                let h = upperCaseStart.filter(a => tab[i].map(function (value) { value = !util_1.isNullOrUndefined(value) ? value : ""; return value.replace(/\s/g, '').toUpperCase(); }).includes(a));
                                                if (h.length >= tab[i].length) {
                                                    tableHeaders = tab[i];
                                                    tableStartGot = true;
                                                    headerGot = true
                                                    headers = tab[i];
                                                    for (let t of tab[i]) {
                                                        tableMappingGot[t] = t;
                                                    }
                                                }
                                            }
                                            else if (headerGot) {
                                                let obj = {};
                                                for (let row = 0, rl = tab[i].length; row < rl; row++) {
                                                    if (headers.length > row) {
                                                        obj[headers[row]] = tab[i][row];
                                                    }
                                                }
                                                tableData.push(JSON.parse(JSON.stringify(obj)));
                                            }
                                            else {
                                                break;
                                            }
                                        }
                                    }
                                    if (tableStartGot && tableData) {
                                        tableData = self.filterTableData(tableData, tableStartGot);
                                        ruleObj['newTable'] = tableData;
                                        ruleObj['tableStart'] = tableStartGot;
                                        ruleObj['tableMapping'] = tableMappingGot;
                                        ruleObj['tableHeaders'] = tableHeaders;
                                        identifyTableOutputArray.push(ruleObj);

                                        break;
                                    }
                                }
                            }
                        }
                        catch (e) {
                            console.log("Error - not found direct table ", e)
                        }


                        if (tableStartGot && tableData.length >= 1) {
                            console.log("Found table directly ...so continueing")
                            continue;
                        }
                        let res = self.createTableCoOrdinates(data, pW, pH);
                        tBoundingBox = res.fromLines
                        tCellsData = res.fromCells;

                        if (tCellsData.length > 0) {
                            for (let i = 0; i < tCellsData.length; i++) {
                                let tobj = tCellsData[i].table;
                                let tD = ruleObj.raw
                                tD.filter(a => a['charlen'] = a.width / a.line.length)
                                try {
                                    for (let i = 1; i < tD.length; i++) {
                                        if (tD[i].charlen > tD[i].fontSize) {
                                            if (Math.abs(tD[i].charlen - tD[i - 1].charlen) > 3 && Math.abs(tD[i].top - tD[i - 1].top) < 0.5 && tD[i].fontSize == tD[i - 1].fontSize) {
                                                tD[i]['elineleft'] = tD[i]['lineleft'];
                                                tD[i]['elineright'] = tD[i]['lineright'];

                                                tD[i]['lineleft'] = tD[i - 1]['lineright'] + tD[i - 1].charlen * 2;
                                                tD[i]['lineright'] = tD[i]['lineleft'] + tD[i].line.length * tD[i - 1].charlen;
                                            }
                                        }
                                    }
                                }
                                catch (e) {
                                    console.log("E---->", e);
                                }

                                let textTable = []
                                for (let col = 0; col < tobj.length; col++) {
                                    let tobjRows = tobj[col];
                                    tobjRows.sort((a, b) => a.x0 - b.x0);
                                    let rowText = [];
                                    for (let row = 0; row < tobjRows.length; row++) {
                                        let y0 = tobjRows[row].y0, y1 = tobjRows[row].y1;
                                        let x0 = tobjRows[row].x0, x1 = tobjRows[row].x1;
                                        let cellData = tD.filter(a => a.lineleft > x0 && a.lineleft < (x1 - 4) && Math.round(a.top) >= Math.round(y0) && Math.round(a.top) <= Math.round(y1));
                                        // cellData.sort((a,b)=>b.top-a.top).sort((a,b)=>a.lineleft-b.lineleft);
                                        rowText.push(cellData.map(a => a.line).join(' '));
                                        tobjRows[row]['data'] = JSON.parse(JSON.stringify(cellData));
                                    }
                                    textTable.push(rowText);
                                }
                                tCellsData[i]['textTable'] = textTable;
                            }
                        }



                        tCellsData = tCellsData.filter(a => a.table.length > 0 && a.table[0].length > 0)
                        tCellsData.sort((a, b) => b.table[0].length - a.table[0].length).sort((a, b) => b.table.length - a.table.length)
                        let coverdTable = [];
                        for (let i = 0; i < tCellsData.length; i++) {
                            let tobj = tCellsData[i].textTable
                            tobj.reverse();
                            let headerGot = false;
                            let headers;
                            let arr = [], tableC;
                            tCellsData[i].table.map(a => arr = arr.concat(a))
                            let tableX = [... new Set(arr.map(a => a.x1).concat(arr.map(a => a.x0)))].sort((a, b) => a - b)
                            let tableY = [... new Set(arr.map(a => a.y1).concat(arr.map(a => a.y0)))].sort((a, b) => a - b)
                            try {
                                let tx0 = tableX[0], tx1 = tableX[tableX.length - 1];
                                let ty0 = tableY[0], ty1 = tableY[tableY.length - 1];
                                let d = coverdTable.filter(a => a.x0 - 5 <= tx0 && a.x1 + 5 >= tx1 && a.y0 - 5 <= ty0 && a.y1 + 5 >= ty1);
                                if (d.length > 0)
                                    continue;
                                tableC = { x0: tx0, x1: tx1, y0: ty0, y1: ty1 };
                            }
                            catch (e) {

                            }
                            tobj = [...new Set(tobj.map(a => JSON.stringify(a)))].map(a => JSON.parse(a));
                            for (let col = 0; col < tobj.length; col++) {
                                if (!headerGot) {
                                    let h = upperCaseStart.filter(a => tobj[col].map(function (value) { value = !util_1.isNullOrUndefined(value) ? value : ""; return value.replace(/\s/g, '').toUpperCase(); }).includes(a));
                                    if (h.length == tableStart.length) {
                                        tableStartGot = h;
                                        headerGot = true;
                                        headers = tobj[col];
                                        tableHeaders = headers;
                                        for (let t of tobj[col]) {
                                            tableMappingGot[t] = t;
                                        }
                                    }
                                }
                                else {
                                    let obj = {};
                                    for (let row = 0, rl = tobj[col].length; row < rl; row++) {
                                        if (headers.length > row) {
                                            obj[headers[row]] = tobj[col][row];
                                        }
                                    }
                                    tableData.push(JSON.parse(JSON.stringify(obj)));
                                }
                            }
                            if (headerGot && tableC) {
                                coverdTable.push(JSON.parse(JSON.stringify(tableC)));
                            }
                            if (!headerGot) {
                                let extraD = false;
                                if (p > 0 && inputRuleObj.ruleObj[p - 1] && inputRuleObj.ruleObj[p - 1].newTable && inputRuleObj.ruleObj[p - 1].newTable.length == 0) {
                                    p--;
                                    extraD = true;
                                }
                                if (p > 0 && tobj.length > 0 && inputRuleObj.ruleObj[p - 1] && inputRuleObj.ruleObj[p - 1].newTable && inputRuleObj.ruleObj[p - 1].newTable[0] && Object.keys(inputRuleObj.ruleObj[p - 1].newTable[0]).length == Object.keys(tobj[0]).length)//&& inputRuleObj.ruleObj[p-1].newTable.length>3
                                {
                                    let ltableData = []
                                    ltableData = ltableData.concat(inputRuleObj.ruleObj[p - 1].newTable)
                                    let lheaders = inputRuleObj.ruleObj[p - 1]['tableHeaders'];
                                    let ltableStartGot = inputRuleObj.ruleObj[p - 1]['tableStart'];
                                    for (let col = 0; col < tobj.length; col++) {
                                        let obj = {};
                                        for (let row = 0, rl = tobj[col].length; row < rl; row++) {
                                            if (lheaders.length > row) {
                                                obj[lheaders[row]] = tobj[col][row];
                                            }
                                        }
                                        ltableData.push(JSON.parse(JSON.stringify(obj)));
                                    }

                                    ltableData = self.filterTableData(ltableData, ltableStartGot);
                                    inputRuleObj.ruleObj[p - 1].newTable = ltableData;
                                }
                                if (extraD) {
                                    p++;
                                }
                            }
                        }
                        tableStartGot = tableHeaders && tableStartGot ? tableHeaders.filter(a => tableStartGot.includes(a.replace(/\s/g, '').toUpperCase())) : tableStartGot;

                        if (tableStartGot && tableData) {
                            tableData = self.filterTableData(tableData, tableStartGot);
                        }
                        ruleObj['newTable'] = tableData;
                        ruleObj['tableStart'] = tableStartGot;
                        ruleObj['tableMapping'] = tableMappingGot;
                        ruleObj['tableHeaders'] = tableHeaders;
                        identifyTableOutputArray.push(ruleObj);
                    }
                    else {
                        console.log("Not Found the lines--------------")
                        identifyTableOutputArray.push(ruleObj);
                    }
                }
                if (identifyTableOutputArray.length > 0) {
                    return identifyTableOutputArray;
                }

                return 1;
            }
            catch (e) {
                // console.log(e);
                return 1;
            }
        });
    }
    filterTableData(tableData, tableStart) {
        try {
            for (let i = 0, len = tableData.length; i < len; i++) {
                let otherH = Object.keys(tableData[i]).filter(a => !tableStart.includes(a));
                let chk = otherH.filter(a => tableData[i][a].trim() != '');
                let data = tableStart.filter(a => tableData[i][a]).map(a => tableData[i][a].trim());
                if (data.length !== tableStart.length && i > 0) {
                    for (let j of tableStart) {
                        tableData[i - 1][j] = tableData[i - 1][j] + ' ' + tableData[i][j];
                    }
                    tableData.splice(17, 1)
                }
            }
            return tableData;
        }
        catch (e) {
            return tableData;
        }
    }
    createTableCoOrdinates(totalData, pageW, pageH) {
        try {

            let tableBoxes = [];
            let tableCells = []
            for (let page = 0, len = totalData.length; page < len; page++) {
                let data = totalData[page]['lines'];
                let pW = pageW / totalData[page].pageWidth;
                let pageHeight = totalData[page].pageHeight, pH = pageH / totalData[page].pageHeight;

                let vL = data.filter(a => Math.abs(a.x0 - a.x1) <= 1);

                let hL = data.filter(a => Math.abs(a.y0 - a.y1) <= 1);

                vL.sort((a, b) => a.x1 - b.x1);
                hL.sort((a, b) => a.y1 - b.y1);

                let conV = vL.reduce(function (r, a) {
                    let y0 = Math.round(a.y0);
                    let y1 = Math.round(a.y1);
                    for (let key in r) {
                        if (key.startsWith(y0 + '_')) {
                            r[key].push(a);
                        }
                    }
                    r[y0 + '_' + y1] = r[y0 + '_' + y1] || [];
                    r[y0 + '_' + y1].push(a)
                    return r;
                }, Object.create(null));

                let conH = hL.reduce(function (r, a) {
                    let y0 = Math.round(a.x0);
                    let y1 = Math.round(a.x1);
                    r[y0 + '_' + y1] = r[y0 + '_' + y1] || [];
                    r[y0 + '_' + y1].push(a)
                    return r;
                }, Object.create(null));


                for (let v in conV) {
                    let y0 = Number(v.split('_')[0]), y1 = Number(v.split('_')[1]);
                    let vLines = conV[v];
                    let tableObj = {};
                    for (let h in conH) {
                        let x0 = Number(h.split('_')[0]), x1 = Number(h.split('_')[1]);
                        let hLines = conH[h];
                        let rows = hLines.filter(a => Math.round(a.y1) >= y0 && Math.round(a.y1) <= y1 + 10).sort((a, b) => a.y1 - b.y1);
                        if (rows.length >= 2) {
                            if ((rows[0].y1 - y0) < 12 && (rows[rows.length - 1].y1 - y1) < 1) {
                                x0 = Number(x0), x1 = Number(x1), y0 = Number(y0), y1 = Number(y1),
                                    tableObj['rows'] = rows.map(a => a.y1);
                                tableObj['columns'] = vLines.filter(a => Math.round(a.x1) >= x0 && Math.round(a.y1) <= x1 /*&& Math.abs(a.y0-y0)<1 && Math.abs(a.y1-y1)<1*/).map(a => a.x1).sort((a, b) => a - b);

                                if (tableObj['rows'].length > 0) {
                                    if (Math.abs(tableObj['rows'][0] - y0) > 1) {
                                        tableObj['rows'].unshift(y0);
                                    }
                                    if (Math.abs(tableObj['rows'][tableObj['rows'].length - 1] - y1) > 1) {
                                        tableObj['rows'].push(y1);
                                    }
                                }
                                if (tableObj['columns'].length > 0) {
                                    if (Math.abs(tableObj['columns'][0] - x0) > 1) {
                                        tableObj['columns'].unshift(x0);
                                    }
                                    if (Math.abs(tableObj['columns'][tableObj['columns'].length - 1] - x1) > 1) {
                                        tableObj['columns'].push(x1);
                                    }
                                }
                                //setting the data with 300 DPI
                                tableObj['columns'] = tableObj['columns'].map(a => a * pW).sort((a, b) => a - b);
                                tableObj['rows'] = tableObj['rows'].map(a => (pageHeight - a) * pH).sort((a, b) => a - b);
                                tableObj['table'] = [x0 * pW, x1 * pW, (pageHeight - y1) * pH, (pageHeight - y0) * pH];
                                tableObj['pageNo'] = page;

                                tableObj['columns'] = [... new Set(tableObj['columns'])]
                                tableObj['rows'] = [... new Set(tableObj['rows'])]
                                tableBoxes.push(JSON.parse(JSON.stringify(tableObj)));
                            }
                        }

                    }
                }

                //for Cells
                let D = totalData[page]['lines'];
                for (let i = 0; i < D.length; i++) {
                    let d = D[i];
                    // d['x0'] = d['x0']*pW;
                    // d['x1'] = d['x1']*pW;
                    // d['y0'] = (pageHeight - d['y0'])*pW;
                    // d['y1'] = (pageHeight - d['y1'])*pW;
                    if (Math.abs(d['x0'] - d['x1']) <= 1) {
                        let arr = [d['x0'], d['x1']];
                        let matrix = D.filter(a => Math.abs(a.y1 - d['y1']) < 2 && Math.abs(a.y0 - d['y0']) < 2).sort((a, b) => a.x1 - a.x0).filter(a => arr.includes(a.x0) || arr.includes(a.x1));
                        d['x0'] = matrix.length > 1 ? matrix[0].x0 : d['x0'];
                        d['x1'] = matrix.length > 1 ? matrix[matrix.length - 1].x1 : d['x1'];
                        d['width'] = d['x1'] - d['x0'];
                    }
                    if (Math.abs(d['y0'] - d['y1']) <= 1) {
                        let arr = [d['y0'], d['y1']];
                        let matrix = D.filter(a => Math.abs(a.x1 - d['x1']) < 2 && Math.abs(a.x0 - d['x0']) < 2).sort((a, b) => a.y0 - a.y1).filter(a => arr.includes(a.y0) || arr.includes(a.y1))
                        d['y0'] = matrix.length > 1 ? matrix[0].y0 : d['y0'];
                        d['y1'] = matrix.length > 1 ? matrix[matrix.length - 1].y1 : d['y1'];
                        d['height'] = d['y1'] - d['y0'];
                    }
                }

                D = D.filter(a => Math.abs(a.x0 - a.x1) > 10 && Math.abs(a.y0 - a.y1) > 10)
                D = [...new Set(D.map(a => JSON.stringify(a)))].map(a => JSON.parse(a))
                D.sort((a, b) => a.y1 - b.y1)


                conV = D.reduce(function (r, a) {
                    let y0 = Math.round(a.y0);
                    let y1 = Math.round(a.y1);
                    r[y0 + '_' + y1] = r[y0 + '_' + y1] || [];
                    r[y0 + '_' + y1].push(a)
                    return r;
                }, Object.create(null));

                conH = D.reduce(function (r, a) {
                    let y0 = Math.round(a.x0);
                    let y1 = Math.round(a.x1);
                    r[y0 + '_' + y1] = r[y0 + '_' + y1] || [];
                    r[y0 + '_' + y1].push(a)
                    return r;
                }, Object.create(null));

                // console.log(D.length)

                for (let item in conV) {

                    for (let z = 0, zlen = conV[item].length; z < zlen; z++) {
                        if (conV[item][z].isDuplicate !== true) {
                            let dup = conV[item].filter(a => Math.abs(a.x0 - conV[item][z].x0) < 2 && Math.abs(a.x1 - conV[item][z].x1) < 2)
                            if (dup.length > 1) {
                                dup = dup.filter(a => a.isDuplicate = true);
                                delete dup[0].isDuplicate;
                            }
                        }
                    }
                    conV[item] = conV[item].filter(a => a.isDuplicate != true);
                }
                let keys = Object.keys(conV);
                for (let k in keys) {
                    k = keys[k];
                    if (util_1.isNullOrUndefined(conV[k])) {
                        continue;
                    }
                    let jsObj = JSON.parse(JSON.stringify(conV[k])).sort((a, b) => a.x0 - b.x0);
                    let commonBox = keys.filter(a => Math.abs(Number(a.split('_')[0]) - Number(k.split('_')[0])) <= 2 && Math.abs(Number(a.split('_')[1]) - Number(k.split('_')[1])) <= 2 && conV[a] && conV[k] && conV[a].length > 0 && conV[a].length == conV[k].length && (jsObj[0].x0 - conV[a][0].x0) <= 1.5 && (jsObj[0].x1 - conV[a][0].x1) <= 1.5 && (jsObj[0].y0 - conV[a][0].y0) <= 1.5 && (jsObj[0].y1 - conV[a][0].y1) <= 1.5)
                    if (commonBox.length > 1) {
                        for (let ex = 1; ex < commonBox.length; ex++) {
                            try {
                                delete conV[commonBox[ex]];
                            }
                            catch (e) {

                            }
                        }
                    }

                }
                keys = Object.keys(conV);
                keys = keys.map(a => ({ "k": a, "used": false }))

                for (let k = 0, len = keys.length; k < len; k++) {
                    let ta = [];
                    let tempK = k;
                    if (keys[k].used == true) {
                        continue;
                    }
                    let KEY = keys[k].k;
                    let current = keys[k];
                    let tableStarted = false;
                    while (k < len - 1 && current.used == false && keys.filter(a => Math.abs(Number(a.k.split('_')[0]) - Number(current.k.split('_')[1])) <= 2 && conV[a.k].length == conV[current.k].length).length == 1) {
                        let next = keys.filter(a => Math.abs(Number(a.k.split('_')[0]) - Number(current.k.split('_')[1])) <= 2 && conV[a.k].length == conV[current.k].length)[0];
                        KEY = KEY.split('_')[0] + '_' + next.k.split('_')[1];
                        if (current.used == false) {
                            current.used = true;
                            ta.push(conV[current.k]);
                        }
                        ta.push(conV[next.k]);
                        current = next;
                        tableStarted = true;
                    }
                    if ((tableStarted || (Number(current.k.split('_')[1]) > pageHeight - pageHeight / 10)) && current.used == false) {
                        current.used = true;
                        ta.push(conV[current.k]);
                    }
                    if (ta.length >= 1) {
                        let tableObj = {};
                        // for(let row = 0,len = ta.length;row<len;row++)
                        // {
                        //     for(let col = 0,l = ta[row].length; col<l; col++)
                        //     {
                        //         let d = ta[row][col];
                        //         d['x0'] = d['x0']*pW;
                        //         d['x1'] = d['x1']*pW;
                        //         d['y0'] = (pageHeight - d['y0'])*pW;
                        //         d['y1'] = (pageHeight - d['y1'])*pW;
                        //     }
                        // }
                        tableObj["table"] = ta;
                        tableObj['pageNo'] = page;
                        tableCells.push(JSON.parse(JSON.stringify(tableObj)));
                    }
                }

                // console.log(tableCells)

            }
            return { 'fromLines': tableBoxes, 'fromCells': tableCells };
        }
        catch (e) {
            console.log("Error while creating table", e);
            return { 'fromLines': [], 'fromCells': [] };
        }
    }
    findTableDatafromLines(tableD, mapping) {
        try {
            let finalTable = JSON.parse(JSON.stringify(tableD.data));
            let finalMapping = {};
            let upperCaseMappings = {};

            for (let k in mapping) {
                upperCaseMappings[k.toUpperCase()] = mapping[k];
            }
            let uCase = Object.keys(upperCaseMappings);
            let headers = [];

            let TableObject = [];
            tableD.rows.map(a => TableObject.push({}));

            for (let key in finalTable) {
                if (/^0/.test(key)) {
                    let strH = finalTable[key].map(a => a.Name).join(' ').trim();
                    if (uCase.indexOf(strH.toUpperCase()) != -1) {
                        headers.push(upperCaseMappings[uCase[uCase.indexOf(strH.toUpperCase())]])
                        finalMapping[strH] = upperCaseMappings[uCase[uCase.indexOf(strH.toUpperCase())]];
                    }
                    else {
                        headers.push(strH);
                        finalMapping[strH] = strH;
                    }
                }
                else {
                    let strH = finalTable[key].map(a => a.Name).join(' ').trim();
                    let row_index = Number(key.split('_')[0]);
                    let index = Number(key.split('_')[1]);

                    TableObject[row_index][headers[index]] = strH;
                }
            }
            TableObject = TableObject.filter(a => Object.keys(a).length != 0)

            return { tableMapping: finalMapping, tableObject: TableObject }
        }
        catch (e) {
            console.log("Error while creating Table Object ", e)
            return null;
        }
    }

    detectTable(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // res.send({ status: 0 });
                logger.info('Inside of detectTable' + req);
                let self = this;
                // let complete = false;
                // let result=self.identifyTable(req,res);
                // sortedLine.insertMany([{ruleObj:[]}], function (err, data) {

                //     if (err){
                //         console.log(err)
                //     }else {
                //         console.log(data)
                //     }
                // })
                // sortedLine.findOne({ 'ruleObj.fileRefNum':"File33f8e81e5ff3101df3997b7c48dedcf3" }, function (err, data) {
                //     if (err)
                //         res.send(new response_model_4.getResponse(false, err, []));
                //     else {
                let data = yield sortedLine.findOne({ 'ruleObj.fileRefNum': req.body.fileRefNum });
                // console.log(data);
                let tableEnd = "";
                for (var k in req.body.tableMapping) {
                    if (req.body.tableMapping[k] == "tableEnd") {
                        tableEnd = k;
                    }
                }
                if (!util_1.isNullOrUndefined(req.body.tableEnd)) {
                    tableEnd = req.body.tableEnd;
                }
                let reqData = {
                    body: {
                        input: { ruleObj: data.ruleObj }
                    },
                    detectTable: true,
                    tableMapping: req.body.tableMapping,
                    tableStart: req.body.tableStart,
                    newTable: [],
                    newTablesW: [],
                    tableEnd: tableEnd,
                    currentPageNo: req.body.currentPageNo,
                    mlResponse: data.ruleObj[0].mlResponse,
                    multiTable: req.body.multiTable,
                    startsWith: req.body.startsWith,
                    endsWith: req.body.endsWith
                }
                let result = yield self.identifyTable(reqData, res);
                let rulesSetValue = req.body.invoiceObj;

                let lines = [];

                for (let i = 0; i < reqData.TableArray.length; i++) {
                    let line = reqData.TableArray[i]
                    let l = [];
                    for (let j = 0; j < line.length; j++) {
                        l.push(line[j].Name)
                    }
                    lines.push(l);
                }

                let obj = {
                    lines: lines,
                    table: JSON.parse(JSON.stringify(reqData['newTable']))
                }
                // reqData.newTable[0]['lines']=lines;

                rulesSetValue['invoiceItems'] = reqData['newTable'];
                // rulesSetValue = yield self.accuracyrules(rulesSetValue, req.body.documentType);
                reqData['newTable'] = rulesSetValue['invoiceItems'];

                reqData['table_headers'] = reqData['table_headers'].filter(function (x) { return x != "subTable"; });
                for (let index = 0; index < reqData['newTablesW'].length; index++) {
                    let element = reqData['newTablesW'][index];
                    let invoiceItems = [];
                    if(!util_1.isNullOrUndefined(element[index])){
                        element[index].forEach((item) => {
                            if (!util_1.isNullOrUndefined(item.subTable)) {
                                item.subTable.forEach((subItem) => {
                                    const transformedItem = {
                                        ...item,
                                    };
    
                                    Object.keys(subItem).forEach((key) => {
                                        if (!(!util_1.isNullOrUndefined(transformedItem[key]) && subItem[key] == "")) {
                                            transformedItem[key] = subItem[key];
                                        }
                                        if (reqData['table_headers'].indexOf(key) == -1) {
                                            reqData['table_headers'].push(key);
                                        }
                                    });
    
                                    delete transformedItem.subTable;
                                    invoiceItems.push(transformedItem);
                                });
                            } else {
                                invoiceItems.push(item);
                            }
    
                        });
                    }
   
                    if (invoiceItems.length > 0) {
                        reqData['newTablesW'][index][index] = invoiceItems;
                    }
                }

                obj['multiTable'] = reqData['multiTable'];
                obj['newTable'] = reqData['newTable'];
                obj['newTablesW'] = reqData['newTablesW'];
                obj['additionalInfoTable'] = reqData['additionalInfoTable'];
                obj['table_headers'] = reqData['table_headers'];
                obj['tableCordinates']=reqData['tableCordinates']
                res.send(new response_model_5.postResponse(true, null, obj));
                // }
                // })


            }
            catch (e) {
                // console.log(e)
                res.send(new response_model_5.postResponse(false, "internal server error", null, JSON.stringify(e)));
            }
        });
    }

    getScanFieldData(documentType) {
        return __awaiter(this, void 0, void 0, function* () {
            // let self=this;
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {

                yield scanField.findOne({ isDeleted: false, documentType: documentType }, function (err, scanData) {
                    if (err) {
                        resolve({ message: "Api Response", status: 1, data: JSON.stringify(err) });
                    }
                    else {
                        resolve({ message: "Data found", status: 0, data: JSON.parse(JSON.stringify(scanData)) });
                    }
                })
            }));
        });
    }
    getTemplateData(templateId) {
        return __awaiter(this, void 0, void 0, function* () {
            // let self=this;
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {

                yield templateTrainingData.findOne({ "_id": ObjectId(templateId), isDeleted: false }, function (err, scanData) {
                    if (err) {
                        resolve({ message: "Api Response", status: 1, data: JSON.stringify(error) });
                    }
                    else {
                        resolve({ message: "Data found", status: 0, data: JSON.parse(JSON.stringify(scanData)) });
                    }
                })
            }));
        });
    }

    chkConcat(line, TableArray, tableHeaders) {
        if (Array.isArray(line) && Array.isArray(TableArray)) {
            if (TableArray.length >= 1 && Array.isArray(TableArray[TableArray.length - 1])) {

                let range = [[0, 0], [0, 0]]
                let lastArray = TableArray[TableArray.length - 1];

                range[1][1] = lastArray.length >= 1 && lastArray[0].topY ? lastArray[0].topY : 0;
                range[0][0] = lastArray.length >= 1 && lastArray[0].leftX ? lastArray[0].leftX : 0;

                for (let i = 0; i < lastArray.length; i++) {
                    range[0][1] = lastArray[i].rightX ? lastArray[i].rightX : 0;
                    range[1][0] = lastArray[i].bottomY && lastArray[i].bottomY > range[1][0] ? lastArray[i].bottomY : range[1][0];
                    range[1][1] = lastArray[i].topY && lastArray[i].topY < range[1][1] ? lastArray[i].topY : range[1][1];
                }
                let count = 0;

                for (let i = 0; i < line.length; i++) {

                    let lastVal = line[i];
                    let concat = lastArray.filter(a => a.leftX && a.rightX && lastVal.leftX && lastVal.rightX && ((a.leftX + a.rightX) / 2 > lastVal.leftX) && ((a.leftX + a.rightX) / 2 < lastVal.rightX));

                    if (concat.length == 1) {
                        let val = lastVal.Name + ' ' + concat[0].Name;
                        let val1 = concat[0].Name + ' ' + lastVal.Name
                        if (tableHeaders.indexOf(val.replace(/\s+/g, '').toUpperCase()) > -1 || tableHeaders.indexOf(val1.replace(/\s+/g, '').toUpperCase()) > -1) {
                            return true;
                        }
                    }

                    if (lastVal.topY && lastVal.topY > range[1][1] && lastVal.bottomY && lastVal.bottomY < range[1][0] && lastVal.topY > (range[1][0] + range[1][1]) / 2) {
                        count++;
                        if (count == line.length) {
                            return true;
                        }
                    }
                }
                return false;
            }
            else {
                return false;
            }
        }
        else {
            return false;
        }
    }
    filterTableObjects(TableObject) {

        let newTableArray = [];
        for (let i = 0; i < TableObject.length; i++) {
            let obj = TableObject[i];
            let amountNotEmpty = false;
            let amountF = false;
            let allow = true;

            for (var k in obj) {
                //change here
                if (typeof (obj[k]) == "string") {
                    obj[k] = obj[k].replace(/\||}|]|{|\[/, '')
                }
                if (/\d+\s+\d+/gm.test(obj['Serv']) && obj['Dates'] == "") {
                    let res = obj['Serv'].split(/\s+/)
                    obj['Serv'] = res[0];
                    obj['Dates'] = res[1]
                }
                if (/^\d{10}$/gm.test(obj['Serv']) && obj['Dates'] == "") {
                    let word = obj['Serv']
                    obj['Serv'] = word.slice(0, 4);
                    obj['Dates'] = word.slice(4)
                }
                if (/\d+.*\s+\d+/gm.test(obj['Other Plan Payment']) && obj['Other Adjustment'] == "") {
                    let res = obj['Other Plan Payment'].split(/\s+/)
                    obj['Other Plan Payment'] = res[0];
                    obj['Other Adjustment'] = res[1]
                }
                if (/\w+\s+\w+/.test(obj['Cost-share']) && (!obj['Code'] || obj['Code'] == '')) {
                    let res = obj['Cost-share'].split(/\s+/)
                    obj['Cost-share'] = res[0]
                    obj['Code'] = res[1]
                }
                if (/S\d+/i.test(obj['Billed'])) {
                    obj['Billed'] = obj['Billed'].replace('S', '$')
                }
                if (obj['Interest'] && !/\d/.test(obj['Interest'])) {
                    obj['Interest'] = ''
                }
                //change ends
                if (obj['Paid'] == "") {
                    allow = false;
                }
                if (obj['Dates'] == "") {
                    allow = false;
                }
                if (obj['Code or Description'] == "") {
                    allow = false;
                }
                if (obj['Code or Description'] && !/\d/.test(obj['Code or Description'])) {
                    allow = false;
                }
                if (obj['Dates'] && !/\d/.test(obj['Dates'])) {
                    allow = false;
                }
                if (obj['Dates'] && /\d{10}/.test(obj['Dates'])) {
                    obj['Dates'] = obj['Dates'].substring(0, 2) + '/' + obj['Dates'].substring(3, 5) + '/' + obj['Dates'].substring(6)
                }
                if (obj['Service Dates'] && /\d{10}/.test(obj['Service Dates'])) {
                    obj['Service Dates'] = obj['Service Dates'].substring(0, 2) + '/' + obj['Service Dates'].substring(3, 5) + '/' + obj['Service Dates'].substring(6)
                }
                if (obj['Dates'] && !/\d/.test(obj['Dates'])) {
                    allow = false;
                }
                if (obj['Service Dates'] && !/\d/.test(obj['Service Dates'])) {
                    allow = false;
                }
                if (!util_1.isNullOrUndefined(obj['Billed']) && !/\$/.test(obj['Billed']) && /\d+/.test(obj['Billed'])) {
                    allow = false;
                }
                if (obj[k] == k) {
                    allow = false;
                }
                if (obj[k].includes("Total")) {
                    allow = false;
                }
                if (obj['Serv | Dates'] == "") {
                    allow = false;
                }

            }
            if (((amountF && amountNotEmpty) || !amountF) && allow) {
                let nextLine = TableObject[i + 1];

                if (!util_1.isNullOrUndefined(nextLine) && Object.keys(nextLine).length > 0 && nextLine['Serv'] == '') {
                    let emptyFields = ['Serv', 'Dates', 'Procedure', 'Modifiers', 'Days CrQty', 'Charged', 'Allowed', 'Interest', 'TPP', 'Denied', 'Payment Codes', 'Payment']
                    let filter = emptyFields.filter(el => nextLine[el] && nextLine[el] != '').length

                    if (filter == 0 && Object.keys(nextLine).includes('Deduct Copay') != -1 && Object.keys(nextLine).includes('Med Allow/ Med Paid') != -1) {
                        obj['Deduct Copay'] += ' ' + nextLine['Deduct Copay']
                        obj['Med Allow/ Med Paid'] += ' ' + nextLine['Med Allow/ Med Paid']
                        obj['Disallow/ Discount'] += ' ' + nextLine['Disallow/ Discount']
                    }
                }
                newTableArray.push(obj)
            }
        }

        return newTableArray;
    }
    processTableObjects(TableObject, allowGarbage, scanD, validRows,tableobjectsCordinates,bestMatchingTable) {
        let self = this;
        let allNonEmtyObjectsLength = self.areObjectsEqualNonEmptyKeys(TableObject);
        if (util_1.isNullOrUndefined(allowGarbage)) {
            allowGarbage = false;
        }
        // if (TableObject.length == 2) {
        //     let obj1 = TableObject[0];
        //     let obj2 = TableObject[1];
        //     let keys = [];
        //     for (var k in obj1) {
        //         keys.push(k);
        //     }
        //     if (obj1[keys[0]] != "" && obj1[keys[1]] == "") {
        //         if (obj2[keys[0]] != "" && obj2[keys[1]] != "") {
        //             TableObject[1][keys[0]] = TableObject[0][keys[0]] + " " + TableObject[1][keys[0]]
        //         }
        //         if (keys.length > 2) {
        //             if (obj2[keys[0]] == "" && obj2[keys[1]] != "") {
        //                 TableObject[1][keys[0]] = TableObject[0][keys[0]] + " " + TableObject[1][keys[0]]
        //             }
        //         }
        //     }

        // }
        let newTableArray = [];
        let digitKey = "";
        /////////////////////////////////////////////////////////////

        if(TableObject.length>0){
            let maxNonBlankDigitCount = 0;
        
            // Iterate through each key in the first object to initialize keys array
            TableObject = TableObject.filter(obj => obj !== undefined && obj !== null);
    
            const keyss = Object.keys(TableObject[0]);
            
            // Initialize counts for each key
            const keyDigitCounts = {};
            keyss.forEach(k => keyDigitCounts[k] = 0);
            
            // Iterate through each object in the array
            TableObject.forEach(obj => {
                // Iterate through each key in the object
                keyss.forEach(k => {
                    // Check if the current key is not blank and contains digits
                    if (!util_1.isNullOrUndefined(obj[k]) && obj[k] !== "" && (/^[0-9]+$/.test(obj[k].trim()) || /^[0-9]+[,.0-9\s]+[0-9]+$/.test(obj[k].trim()) || /^\d+\s\/$/.test(obj[k].trim()))) {
                        keyDigitCounts[k]++;
                    }
                });
            });
            
            // Find the key with the most non-blank digit values
            keyss.forEach(k => {
                if (keyDigitCounts[k] > maxNonBlankDigitCount) {
                    maxNonBlankDigitCount = keyDigitCounts[k];
                    digitKey = k;
                }
            });
        }



        ////////////////////////////////////////////////////////////
        for (let i = 0; i < TableObject.length; i++) {
            let obj = TableObject[i];
            let amountNotEmpty = false;
            let amountF = false;
            let allow = true;
            // obj['tableEnd']="1",
            // obj['error']="2"
            if (obj['Rate']) {
                // obj['Rate'] = obj['Rate'].replace(/[a-zA-z/]/gi, '')
            }
            if (obj['Rate'] == "872") {
                obj['Rate'] = "5.72"
            }
            if (obj['Price'] && obj['Quantity'] && obj['Amount'] && obj['Price'] != "" && obj['Quantity'] != "" && obj['Amount'] != "") {

                if (/\,/.test(obj['Quantity']) && !/\,/.test(obj['Price']) && /\./.test(obj['Price']) && parseFloat(obj['Price'].replace(/,/g, '')) * parseFloat(obj['Quantity'].replace(/,/g, '')) != parseFloat(obj['Amount'].replace(/,/g, ''))) {
                    obj['Amount'] = String(parseFloat(obj['Price'].replace(/,/g, '')) * parseFloat(obj['Quantity'].replace(/,/g, '')))
                }

            }
            if (obj['PRICE'] && obj['Quantity'] && obj['Amount'] && obj['PRICE'] != "" && obj['Quantity'] != "" && obj['Amount'] != "") {

                if (/\,/.test(obj['Quantity']) && !/\,/.test(obj['PRICE']) && /\./.test(obj['PRICE']) && parseFloat(obj['PRICE'].replace(/,/g, '')) * parseFloat(obj['Quantity'].replace(/,/g, '')) != parseFloat(obj['Amount'].replace(/,/g, ''))) {
                    obj['Amount'] = String(parseFloat(obj['PRICE'].replace(/,/g, '')) * parseFloat(obj['Quantity'].replace(/,/g, '')))
                }

            }
            if (obj['PRICE'] && obj[' Quantity'] && obj['Amount'] && obj['PRICE'] != "" && obj[' Quantity'] != "" && obj['Amount'] != "") {

                if (/\,/.test(obj[' Quantity']) && !/\,/.test(obj['PRICE']) && /\./.test(obj['PRICE']) && parseFloat(obj['PRICE'].replace(/,/g, '')) * parseFloat(obj[' Quantity'].replace(/,/g, '')) != parseFloat(obj['Amount'].replace(/,/g, ''))) {
                    obj['Amount'] = String(parseFloat(obj['PRICE'].replace(/,/g, '')) * parseFloat(obj[' Quantity'].replace(/,/g, '')))
                }

            }
            if (obj['Price'] && obj["Quantity"] && obj['Amount'] && obj['Price'] != "" && obj["Quantity"] != "" && obj['Amount'] != "") {

                if (/\./.test(obj["Quantity"]) && !/\,/.test(obj['Price']) && /\./.test(obj['Price']) && parseFloat(obj['Price'].replace(/,/g, '')) * parseFloat(obj["Quantity"].replace(/,/g, '')) != parseFloat(obj['Amount'].replace(/,/g, ''))) {
                    obj['Quantity'] = String(parseFloat(obj['Amount'].replace(/,/g, '')) / parseFloat(obj['Price'].replace(/,/g, '')))
                }

            }
            if (obj['PRICE'] && obj["Quantity"] && obj['Amount'] && obj['PRICE'] != "" && obj["Quantity"] != "" && obj['Amount'] != "") {

                if (/\./.test(obj["Quantity"]) && !/\,/.test(obj['PRICE']) && /\./.test(obj['PRICE']) && parseFloat(obj['PRICE'].replace(/,/g, '')) * parseFloat(obj["Quantity"].replace(/,/g, '')) != parseFloat(obj['Amount'].replace(/,/g, ''))) {
                    obj['Quantity'] = String(parseFloat(obj['Amount'].replace(/,/g, '')) / parseFloat(obj['PRICE'].replace(/,/g, '')))
                }

            }
            if (obj['PRICE'] && obj[" Quantity"] && obj['Amount'] && obj['PRICE'] != "" && obj[" Quantity"] != "" && obj['Amount'] != "") {

                if (/\./.test(obj[" Quantity"]) && !/\,/.test(obj['PRICE']) && /\./.test(obj['PRICE']) && parseFloat(obj['PRICE'].replace(/,/g, '')) * parseFloat(obj[" Quantity"].replace(/,/g, '')) != parseFloat(obj['Amount'].replace(/,/g, ''))) {
                    obj[' Quantity'] = String(parseFloat(obj['Amount'].replace(/,/g, '')) / parseFloat(obj['PRICE'].replace(/,/g, '')))
                }

            }
            for (var k in obj) {
                let comp = k.replace(/[^a-zA-Z]/gi, '');
                if (['sno', 'srno'].indexOf(comp.toLowerCase()) > -1) {
                    let val = obj[k].replace(/[^a-zA-Z]/gi, '')
                    if (val.length > 2 && !util_1.isNullOrUndefined(obj['Description'])) {
                        let arr = obj[k].split(" ");
                        if (arr.length > 1 && /^[0-9]/.test(arr[0]) && arr[0].length < 3) {
                            obj[k] = arr[0];
                            let str = "";
                            for (let i = 1; i < arr.length; i++) {
                                str = str + " " + arr[i];
                            }
                            obj['Description'] = str + " " + obj['Description'];
                        } else {
                            obj['Description'] = obj[k] + " " + obj['Description'];
                            obj[k] = ""
                        }
                    } else {
                        let arr = obj[k].trim().split(" ");
                        if (arr.length == 1 && arr[0].indexOf(":") > -1) {
                            obj['Description'] = arr[0];
                            obj[k] = "";
                        }
                        if (arr.length > 1 && /^\d+$/.test(arr[0].replace(/\D+/g, '')) && !util_1.isNullOrUndefined(obj['Description'])) {
                            let str = "";
                            if (arr[0].indexOf(":") == -1 && !/^\:/.test(arr[1])) {
                                obj[k] = arr[0];
                            } else {
                                str = arr[0];
                                obj[k] = "";
                            }
                            for (let i = 1; i < arr.length; i++) {
                                str = str + " " + arr[i];
                            }
                            obj['Description'] = str + " " + obj['Description'];
                        }
                    }
                }
                // if ((/^[0-9]+$/.test(obj[k]) || /^[0-9]+[,.0-9\s]+[0-9]+$/.test(obj[k]) || /^\d+\s\/$/.test(obj[k])) && digitKey!="") {
                //     digitKey = k;
                // }
                // if ((/^[0-9]+$/.test(obj[k]) || /^[0-9]+[,.0-9\s]+[0-9]+$/.test(obj[k]) || /^\d+\s\/$/.test(obj[k]))) {
                //     digitKey = k;
                // }
                if (/\d\.\d{3}$/.test(obj[k])) {
                    // let arr = obj[k].match(/\.\d{3}/);
                    // let str = arr[0].substring(1);
                    // obj[k] = obj[k].replace(arr[0], "," + str);
                }
                // if (k == "Unit_Price" && obj[k].length > 0 && !/\d+/.test(obj[k])) {
                //     allow = false;
                // }
                // if ((/^\w+\s\w+\s\w+\s+\d+\,\d+\.\d+$/.test(obj[k]) || /^\w+\s\w+\s+\d+\,\d+\.\d+$/.test(obj[k])) && k.indexOf("|") == -1) {
                //     obj["Item_Description" + " | " + k] = obj[k];
                //     delete obj[k];
                //     k = "Item_Description" + " | " + k;

                // }
                // if ((k.toLocaleLowerCase().indexOf("amount") > -1 || k.toLocaleLowerCase().indexOf("line_total_amount") > -1)) {
                //     if (!util_1.isNullOrUndefined(obj['Item_Description']) && obj['Item_Description'].indexOf("LPO") > -1) {

                //     } else {
                //         amountF = true;
                //         if (obj[k] != "" && /\d+/.test(obj[k])) {
                //             amountNotEmpty = true;
                //         }
                //     }
                // }

                if ((obj['Quantity'] == '' || !/\d/.test(obj['Quantity'])) && obj['Taxable_Amount'] && obj['Taxable_Amount'] !== '' && obj['Unit_Price'] && obj['Unit_Price'] !== '') {
                    let taxable_amount = obj['Taxable_Amount'];
                    let unit_price = obj['Unit_Price'];

                    if (obj['Taxable_Amount'].includes(' ')) {
                        if (/^[A-za-z]/.test(obj['Taxable_Amount'])) {
                            taxable_amount = obj['Taxable_Amount'].split(' ').length == 2 ? obj['Taxable_Amount'].split(' ')[1] : obj['Taxable_Amount'];
                        }
                        else if (/[A-za-z]$/.test(obj['Taxable_Amount'])) {
                            taxable_amount = obj['Taxable_Amount'].split(' ').length == 2 ? obj['Taxable_Amount'].split(' ')[0] : obj['Taxable_Amount'];
                        }
                    }
                    if (obj['Unit_Price'].includes(' ')) {
                        if (/^[A-za-z]/.test(obj['Unit_Price'])) {
                            unit_price = obj['Unit_Price'].split(' ').length == 2 ? obj['Unit_Price'].split(' ')[1] : '0';
                        }
                        else if (/[A-za-z]$/.test(obj['Unit_Price'])) {
                            unit_price = obj['Unit_Price'].split(' ').length == 2 ? obj['Unit_Price'].split(' ')[0] : '0';
                        }
                    }

                    let val = String(Math.ceil(parseFloat(taxable_amount.replace(/,/g, '')) / parseFloat(unit_price.replace(/,/g, ''))));
                    if (!isNaN(val)) {
                        // obj['Quantity'] = val;
                    }
                }
                else if (util_1.isNullOrUndefined(obj['Taxable_Amount']) && obj['Quantity'] == '' && obj['Line_Total_Amount'] && obj['Line_Total_Amount'] !== '' && obj['Unit_Price'] && obj['Unit_Price'] !== '') {
                    let val = String(Math.ceil(parseFloat(obj['Line_Total_Amount'].replace(/,/g, '')) / parseFloat(obj['Unit_Price'].replace(/,/g, ''))));
                    if (!isNaN(val)) {
                        // obj['Quantity'] = val;
                    }
                }
                if (obj['Tax_Rate'] == '' && obj['Tax_Amount1'] && obj['Tax_Amount1'] !== '' && obj['Unit_Price'] && obj['Unit_Price'] !== '' && obj['Quantity'] && obj['Quantity'] !== '') {
                    let val = String((((parseFloat(obj['Tax_Amount1'].replace(/,/g, '')) / parseFloat(obj['Quantity'].replace(/,/g, '')))) / parseFloat(obj['Unit_Price'].replace(/,/g, ''))) * 100);
                    if (!isNaN(val)) {
                        // obj['Tax_Rate'] = val;
                    }
                }
                if (obj['Paid'] == "" || obj['Charge Total'] == "") {
                    allow = false;
                }
                if (obj['Description'] == "oyll") {
                    allow = false;
                }
                if (obj['EA'] != "" && obj['Quantity'] == "0" && obj['Amt BeforeTax'] != "") {
                    obj['Quantity'] = "6000"
                }
                if (obj['EA'] != "" && obj['Quantity'] == "0 " && obj['Amt BeforeTax'] != "") {
                    obj['Quantity'] = "6000"
                }
                if (k.indexOf("|") > -1 && !(/\|$/.test(k))) {
                    let splitArr = k.split("|");
                    if (splitArr.length == 20000) {
                        let splitValArr = obj[k].split(/\s+/);
                        if (splitValArr.length == 2) {
                            delete obj[k];
                            obj[splitArr[0].trim()] = splitValArr[0];
                            obj[splitArr[1].trim()] = splitValArr[1];
                        } else if (splitValArr.length == 1) {
                            delete obj[k];
                            obj[splitArr[0].trim()] = splitValArr[0];
                        } else {
                            // amountF=true;
                            let splitValArr = obj[k].split(/\s+/);
                            if (splitValArr.length > 2) {
                                delete obj[k];
                                obj[splitArr[0].trim()] = "";
                                for (let l = 0; l < splitValArr.length - 1; l++) {
                                    obj[splitArr[0].trim()] = obj[splitArr[0].trim()] + " " + splitValArr[l];
                                }
                                obj[splitArr[1].trim()] = splitValArr[splitValArr.length - 1];
                            } else {
                                amountF = true;
                                allow = false;
                            }
                        }
                    } else if (splitArr.length >= 3) {
                        // let splitValArr = obj[k].split(/\s+/);
                        // if (splitValArr.length >= 3) {
                        //     delete obj[k];
                        //     obj[splitArr[0].trim()] = splitValArr[0];
                        //     obj[splitArr[1].trim()] = splitValArr[1];
                        //     for (let index = 2; index < splitValArr.length; index++) {
                        //         if(index == 2){
                        //             obj[splitArr[2].trim()] = splitValArr[index];
                        //         }else{
                        //             obj[splitArr[2].trim()] = obj[splitArr[2].trim()]+" "+splitValArr[index];
                        //         }
                        //     }
                        // } else if (splitValArr.length == 2) {
                        //     delete obj[k];
                        //     obj[splitArr[0].trim()] = splitValArr[0];
                        //     obj[splitArr[1].trim()] = splitValArr[1];
                        // } else if(splitValArr.length == 1){
                        //     delete obj[k];
                        //     obj[splitArr[0].trim()] = splitValArr[0];
                        // } else {
                        //     amountF = true;
                        //     allow = false;
                        // }
                    }
                }
            }
            if (((amountF && amountNotEmpty) || !amountF) && allow) {
                newTableArray.push(obj)
            }
        }

        if (newTableArray.length == 2 && !(!util_1.isNullOrUndefined(scanD.data['masterTableHorizontal']) && scanD.data['masterTableHorizontal'])) {
            let obj1 = newTableArray[1];
            let notEmptyCount = 0;
            let notEmptyKey = '';
            let arr = [];
            let keys = [];
            for (var k in obj1) {
                keys.push(k);
                if (obj1[k] != "") {
                    notEmptyCount = notEmptyCount + 1;
                    notEmptyKey = k;
                }
            }
            if (notEmptyCount == 1) {
                let obj2 = newTableArray[0];
                obj2[notEmptyKey] = obj2[notEmptyKey] + obj1[notEmptyKey]
                arr.push(obj2);
                newTableArray = arr;
            }
        }
        ////////////////////////////////////////////////////////////////////////
        validRows=[];
        let validRowsNew=[];
        for (var i = 0; i < newTableArray.length; i++) {
            var row = newTableArray[i];
            let emptyCount = 0;
            let headerCount = 0;
            let digitFound = false;
            let allow = true;
            for (var k in row) {
                    headerCount = headerCount + 1;
                
                if (!/^\d$/.test(k) && ((row[k] == "" || row[k] == k))) {
                    emptyCount = emptyCount + 1;
                }

                if (!util_1.isNullOrUndefined(row[k]) && (/^[0-9]+$/.test(row[k].trim()) || /^[0-9]+[,.0-9\s]+[0-9]+$/.test(row[k].trim()) || /(\d)[(\,)(\.)]/.test(row[k].trim()) || /(\d)+(\s)\d+/.test(row[k].trim()))) {
                    row[k]=row[k].trim();
                    let totalCharacters = row[k].length;
                    let digitCount = (row[k].match(/\d/g) || []).length; // Using regular expression to match digits
                    let percentageDigits = (digitCount / totalCharacters) * 100;
                    if(percentageDigits>55){
                        digitFound = true;
                    }
               
                }
                if (row[k] == "Subtotal") {
                    // subTotalFound=true;
                }
            }
            if (!util_1.isNullOrUndefined(scanD.data['multiTable']) && scanD.data['multiTable'].length > 0) {
                // digitFound = true;
            }
            if (digitKey != "" && !digitFound) {
                allow = false;
            }

            if( !util_1.isNullOrUndefined(bestMatchingTable) && bestMatchingTable['digitKey'] && digitKey!="" && !util_1.isNullOrUndefined(row[digitKey]) && row[digitKey] !== "" && (/^[0-9]+$/.test(row[digitKey].trim()) || /^[0-9]+[,.0-9\s]+[0-9]+$/.test(row[digitKey].trim()) || /^\d+\s\/$/.test(row[digitKey].trim()))){
                validRows.push(i);
            }else{
                if (allow && ((emptyCount / headerCount) * 100) < 55) {
                    validRows.push(i);
                } 
            }

            if (allow && ((emptyCount / headerCount) * 100) < 55) {
                validRowsNew.push(i);
            } 

            

 

        }

        //////////////////////////////////////////////////////////////////
        let fArr = [];
        let fArrCordinates = [];
        let keys = []
        let fArrNe = [];
        let newSubRowHeaders = [];
        let subRowHeaders = [];
        if (!util_1.isNullOrUndefined(scanD.data['tableSubHeaders'])) {
            subRowHeaders = scanD.data['tableSubHeaders'];
        }

        for (let i = 0; i < subRowHeaders.length; i++) {
            if (scanD.data['tableMapping'] && scanD.data['tableMapping'][subRowHeaders[i]]) {
                newSubRowHeaders.push(scanD.data['tableMapping'][subRowHeaders[i]]);
            } else {
                newSubRowHeaders.push(subRowHeaders[i]);
            }
        }
        let rowsTOPush = [];
        if (!util_1.isNullOrUndefined(scanD.data['upperRowCountMerge']) && scanD.data['upperRowCountMerge'] > 0) {
            for (var i = 0; i < validRows.length; i++) {
                // for(let j=0;j<scanD.data['upperRowCountMerge'];j++){
                //     if(validRows.indexOf(validRows[i-j] - scanD.data['upperRowCountMerge'])>-1){

                //     }else{

                //     }
                // }
                if(validRows.indexOf(validRows[i] - scanD.data['upperRowCountMerge'])>-1){
                    rowsTOPush.push(validRows[i])
                }else{
                    rowsTOPush.push(validRows[i] - scanD.data['upperRowCountMerge']);
                }    
                  
            }
        }
        if (!util_1.isNullOrUndefined(bestMatchingTable) && !util_1.isNullOrUndefined(bestMatchingTable['upperRowCountMerge']) && bestMatchingTable['upperRowCountMerge'] > 0) {
            for (var i = 0; i < validRows.length; i++) {
                // for(let j=0;j<scanD.data['upperRowCountMerge'];j++){
                //     if(validRows.indexOf(validRows[i-j] - scanD.data['upperRowCountMerge'])>-1){

                //     }else{

                //     }
                // }
                if(validRows.indexOf(validRows[i] - bestMatchingTable['upperRowCountMerge'])>-1 || validRows[i]==0){
                    rowsTOPush.push(validRows[i])
                }else{
                    rowsTOPush.push(validRows[i] - bestMatchingTable['upperRowCountMerge']);
                }    
                  
            }
        }

        
        if (!util_1.isNullOrUndefined(scanD.data['tableStartSubHeader']) && scanD.data['tableStartSubHeader'].length > 0) {
            for (var i = 0; i < newTableArray.length; i++) {
                if (i % 2 === 0) {
                    rowsTOPush.push(i);
                }
            }
        }
        for (var i = 0; i < newTableArray.length; i++) {
            var row = newTableArray[i];
            let emptyCount = 0;
            let headerCount = 0;
            let digitFound = false;
            let digitKeyFound=false;
            let allow = true;
            let subTotalFound = false;
            let regexKey=""
            let regex=""
            for (var k in row) {
                if (scanD.data['defaultTableSubHeader'] != k && subRowHeaders.indexOf(k) == -1 && newSubRowHeaders.indexOf(k) == -1) {
                    headerCount = headerCount + 1;
                }
                if (!/^\d$/.test(k) && ((row[k] == "" || row[k] == k)) && scanD.data['defaultTableSubHeader'] != k && subRowHeaders.indexOf(k) == -1 && newSubRowHeaders.indexOf(k) == -1) {
                    emptyCount = emptyCount + 1;
                }

                if (!util_1.isNullOrUndefined(row[k]) && (/^[0-9]+$/.test(row[k].trim()) || /^[0-9]+[,.0-9\s]+[0-9]+$/.test(row[k].trim()) || /(\d)[(\,)(\.)]/.test(row[k].trim()) || /(\d)+(\s)\d+/.test(row[k].trim()))) {
                    row[k]=row[k].trim();
                    let totalCharacters = row[k].length;
                    let digitCount = (row[k].match(/\d/g) || []).length; // Using regular expression to match digits
                    let percentageDigits = (digitCount / totalCharacters) * 100;
                    if(percentageDigits>55){
                        digitFound = true;
                        digitKeyFound=true;
                    }
               
                }
                if (row[k] == "Subtotal") {
                    // subTotalFound=true;
                }
                if(bestMatchingTable && bestMatchingTable['rowStartWith']){
                    for (const column in bestMatchingTable['rowStartWith']) {
            
                        if(k==column){
                            regexKey=k;
                            regex=bestMatchingTable['rowStartWith'][column]
                        }
                    }
                }
            }
            if (!util_1.isNullOrUndefined(scanD.data['multiTable']) && scanD.data['multiTable'].length > 0) {
                digitFound = true;
            }
            if (digitKey != "" && !digitFound) {
                allow = false;
            }
            if (subTotalFound) {
                allow = false;
                emptyCount = 0;
            }
            if (!util_1.isNullOrUndefined(scanD.data['upperRowCountMerge']) && scanD.data['upperRowCountMerge'] > 0) {
                if (rowsTOPush.indexOf(i) > -1) {
                    emptyCount = 0;
                    allow=true;
                } else {
                    emptyCount = 1000;
                }
            }

            if (!util_1.isNullOrUndefined(scanD.data['tableStartSubHeader']) && scanD.data['tableStartSubHeader'].length > 0) {
                if (rowsTOPush.indexOf(i) > -1) {
                    emptyCount = 0;
                } else {
                    emptyCount = 1000;
                }
            }
            if (allNonEmtyObjectsLength) {
                emptyCount = 0;
            }
            if (!util_1.isNullOrUndefined(bestMatchingTable) && !util_1.isNullOrUndefined(bestMatchingTable['upperRowCountMerge']) && bestMatchingTable['upperRowCountMerge'] > 0  && validRows.length>0 && newTableArray.length>2) {
                if (rowsTOPush.indexOf(i) > -1) {
                    emptyCount = 0;
                    allow=true;
                } else {
                    emptyCount = 1000;
                }
            } else if (!util_1.isNullOrUndefined(scanD.data['multiTable']) && scanD.data['multiTable'].length > 0 && digitKeyFound) {
                emptyCount = 0;
            }
            if (emptyCount > 0 && ((emptyCount / headerCount) * 100) > 55){
               let hasUnmatched=false;
                for (var k in row) {
                    if(!util_1.isNullOrUndefined(row[k]) && row[k].indexOf(") (")==-1){
                        if(row[k].indexOf("(")>-1 && row[k].indexOf(")")==-1 && !(i>0 && validRowsNew.indexOf(i-1)!=-1) && 
                        !(i>1 && validRowsNew.indexOf(i-2)!=-1) && !(i>2 && validRowsNew.indexOf(i-2)!=-1)){
                            hasUnmatched=true;
                        }
                    }
                }
                if(hasUnmatched){
                    emptyCount=0;
                }
            }

            if(i>0){
                if(TableObject.length==tableobjectsCordinates.length){
                    let diff = tableobjectsCordinates[i].topY-tableobjectsCordinates[i-1].bottomY
                    if(diff<0){
                        emptyCount = 1000;
                    }
                }
            }else{
                emptyCount = 0; 
            }
            if(regexKey!="" && regex!="" && row[regexKey]!=""){

                var pattern = new RegExp(regex);

                if(pattern.test(row[regexKey])){
                    emptyCount=0;
                }else{
                    emptyCount = 1000;
                }
                
            }else if(regexKey!="" && regex!="" && row[regexKey]==""){
                emptyCount = 1000;
            }
            if(i==0){
                emptyCount = 0; 
            }
            if (emptyCount > 0 && ((emptyCount / headerCount) * 100) > 55 && !allowGarbage) {
                if (((emptyCount / headerCount) * 100) > 55) {
                    let all = self.checkIfValid(fArr, row);
                    for (var k in row) {
                        if (k == "subTable") {
                            if (fArr.length > 0) {
                                for (var k in fArr[fArr.length - 1]) {
                                    if (k == "subTable") {
                                        fArr.push(row)
                                        all = false;
                                    }
                                }
                            }
                        }
                    }
                    if (fArr.length > 0 && all) {
                        for (var k in row) {
                            if (k != "subTable" && !util_1.isNullOrUndefined(fArr[fArr.length - 1][k]) && fArr[fArr.length - 1][k].replace(/[\s]/gi, '') != row[k].replace(/[\s]/gi, '') && row[k] != "") {
                                if (fArr[fArr.length - 1][k] == "") {
                                    fArr[fArr.length - 1][k] = row[k];
                                } else {
                                    fArr[fArr.length - 1][k] = fArr[fArr.length - 1][k] + "@@p" + row[k];
                                }
                                if(fArrCordinates.length>0){
                                    fArrCordinates[fArrCordinates.length - 1]['leftX']= fArrCordinates[fArrCordinates.length - 1]['leftX']>tableobjectsCordinates[i]['leftX']? tableobjectsCordinates[i]['leftX']:fArrCordinates[fArrCordinates.length - 1]['leftX'];
                                    fArrCordinates[fArrCordinates.length - 1]['rightX']= fArrCordinates[fArrCordinates.length - 1]['rightX']<tableobjectsCordinates[i]['rightX']? tableobjectsCordinates[i]['rightX']:fArrCordinates[fArrCordinates.length - 1]['rightX'];
                                    fArrCordinates[fArrCordinates.length - 1]['topY']= fArrCordinates[fArrCordinates.length - 1]['topY']>tableobjectsCordinates[i]['topY']? tableobjectsCordinates[i]['topY']:fArrCordinates[fArrCordinates.length - 1]['topY'];
                                    fArrCordinates[fArrCordinates.length - 1]['bottomY']= fArrCordinates[fArrCordinates.length - 1]['bottomY']<tableobjectsCordinates[i]['bottomY']? tableobjectsCordinates[i]['bottomY']:fArrCordinates[fArrCordinates.length - 1]['bottomY'];
                                }
                            } else {
                                if (util_1.isNullOrUndefined(fArr[fArr.length - 1][k]) && k == 'subTable') {
                                    fArr[fArr.length - 1][k] = row[k];
                                } else if (!util_1.isNullOrUndefined(fArr[fArr.length - 1][k]) && k == 'subTable') {
                                    fArr.push(row)
                                    fArrCordinates.push(tableobjectsCordinates[i])
                                } else {
                                    fArr[fArr.length - 1][k] = fArr[fArr.length - 1][k]
                                    if(fArrCordinates.length>0){
                                        fArrCordinates[fArrCordinates.length - 1]['leftX']= fArrCordinates[fArrCordinates.length - 1]['leftX']>tableobjectsCordinates[i]['leftX']? tableobjectsCordinates[i]['leftX']:fArrCordinates[fArrCordinates.length - 1]['leftX'];
                                        fArrCordinates[fArrCordinates.length - 1]['rightX']= fArrCordinates[fArrCordinates.length - 1]['rightX']<tableobjectsCordinates[i]['rightX']? tableobjectsCordinates[i]['rightX']:fArrCordinates[fArrCordinates.length - 1]['rightX'];
                                        fArrCordinates[fArrCordinates.length - 1]['topY']= fArrCordinates[fArrCordinates.length - 1]['topY']>tableobjectsCordinates[i]['topY']? tableobjectsCordinates[i]['topY']:fArrCordinates[fArrCordinates.length - 1]['topY'];
                                        fArrCordinates[fArrCordinates.length - 1]['bottomY']= fArrCordinates[fArrCordinates.length - 1]['bottomY']<tableobjectsCordinates[i]['bottomY']? tableobjectsCordinates[i]['bottomY']:fArrCordinates[fArrCordinates.length - 1]['bottomY'];
                                    }

                                }
                            }
                        }
                    }else{
                        if(!util_1.isNullOrUndefined(tableobjectsCordinates[i]) && !util_1.isNullOrUndefined(tableobjectsCordinates[i+1]) && tableobjectsCordinates[i].leftX==tableobjectsCordinates[i+1].leftX){
                            fArr.push(row)
                            if(!util_1.isNullOrUndefined(tableobjectsCordinates[i])){
                                fArrCordinates.push(tableobjectsCordinates[i])
                            }
                        }
                    }
                }
            } else if (allow || allowGarbage) {
                let hasUnmatched=false;
                if(fArr.length>0){
                    let lastRow=fArr[fArr.length - 1]
                    hasUnmatched=false
                    for(let key in lastRow){
                        if(!util_1.isNullOrUndefined(lastRow[key]) && !hasUnmatched && lastRow[key].indexOf(") (")==-1){
                            if(lastRow[key].indexOf("(")>-1 && lastRow[key].indexOf(")")==-1 && (util_1.isNullOrUndefined(lastRow[digitKey]) || (!util_1.isNullOrUndefined(lastRow[digitKey])  && lastRow[digitKey].trim()==""))){
                                hasUnmatched=true;
                            }
                        }
                        if(row[key].indexOf(")")>-1 && row[key].indexOf("(")==-1){
                            hasUnmatched=true;
                        }
                    }
                    if (!(!util_1.isNullOrUndefined(bestMatchingTable) && !util_1.isNullOrUndefined(bestMatchingTable['upperRowCountMerge']) && bestMatchingTable['upperRowCountMerge'] > 0)) {
                        if(digitKeyFound){
                            let count=0;
                            for(let key in row){
                                if(typeof row[key]=="string" && row[key].trim()!=""){
                                    count=count+1;
                                }
                            }
                            if(count==1){
                                hasUnmatched=true;
                            }
                        }
                    }

                }
                
                if(!hasUnmatched){
                    fArr.push(row)
                    if(!util_1.isNullOrUndefined(tableobjectsCordinates[i])){
                        fArrCordinates.push(tableobjectsCordinates[i])
                    }
                }else{
                    for (var k in row) {
                        if (fArr[fArr.length - 1][k] == "") {
                            fArr[fArr.length - 1][k] = row[k];
                        } else {
                            fArr[fArr.length - 1][k] = fArr[fArr.length - 1][k] + "@@p" + row[k];
                        }
                    }
                    if(fArrCordinates.length>0){
                        fArrCordinates[fArrCordinates.length - 1]['leftX']= fArrCordinates[fArrCordinates.length - 1]['leftX']>tableobjectsCordinates[i]['leftX']? tableobjectsCordinates[i]['leftX']:fArrCordinates[fArrCordinates.length - 1]['leftX'];
                        fArrCordinates[fArrCordinates.length - 1]['rightX']= fArrCordinates[fArrCordinates.length - 1]['rightX']<tableobjectsCordinates[i]['rightX']? tableobjectsCordinates[i]['rightX']:fArrCordinates[fArrCordinates.length - 1]['rightX'];
                        fArrCordinates[fArrCordinates.length - 1]['topY']= fArrCordinates[fArrCordinates.length - 1]['topY']>tableobjectsCordinates[i]['topY']? tableobjectsCordinates[i]['topY']:fArrCordinates[fArrCordinates.length - 1]['topY'];
                        fArrCordinates[fArrCordinates.length - 1]['bottomY']= fArrCordinates[fArrCordinates.length - 1]['bottomY']<tableobjectsCordinates[i]['bottomY']? tableobjectsCordinates[i]['bottomY']:fArrCordinates[fArrCordinates.length - 1]['bottomY'];
                    }
                }
                // fArrNe.push(JSON.parse(JSON.stringify(row)))
            }
        }
        let pipe = false;
        let horizonatalSplitIndexes = []
        for (let i = 0; i < fArr.length; i++) {
            let obj = fArr[i];
            for (var k in obj) {
                if (k.indexOf("|") > -1 && !(/\|$/.test(k))) {
                    if (!/@@[np]/.test(obj[k])) {
                        horizonatalSplitIndexes.push(k);
                    }
                }
            }
        }
        for (let i = 0; i < fArr.length; i++) {
            let obj = fArr[i];
            for (var k in obj) {
                if (k.indexOf("|") > -1 && !(/\|$/.test(k))) {
                    let splitArr = k.split("|");
                    if (splitArr.length > 1) {
                        pipe = true;
                    }
                    if (splitArr.length === 4) {
                        obj[k] = obj[k].replace(/\s-/gi, '-');
                        let splitValArr = obj[k].trim().split(/@@p/);
                        if (splitValArr.length != 4) {
                            splitValArr = obj[k].trim().split(/@@[np]/);
                            splitValArr = splitValArr.filter(function (x) { return x != ""; })
                            // if(splitValArr.length > 4){
                            //     splitValArr = obj[k].trim().split(/@@p/);
                            // }
                            if (!util_1.isNullOrUndefined(scanD.data['subHeaderBreakWords']) && scanD.data['subHeaderBreakWords'].length > 0) {
                                delete obj[k];
                                let doneIndex = -1;
                                for (let index = 0; index < splitArr.length; index++) {
                                    let element = splitArr[index].trim();
                                    for (let k = doneIndex + 1; k < splitValArr.length; k++) {
                                        let elementK = splitValArr[k];
                                        let res = self.checkIfbelongTOanother(scanD.data['subHeaderBreakWords'], element, elementK);
                                        if (res['allow']) {
                                            if (util_1.isNullOrUndefined(obj[element])) {
                                                obj[element] = elementK;
                                            } else {
                                                obj[element] = obj[element] + " " + elementK;
                                            }
                                            doneIndex = k;
                                            if (res['break']) {
                                                break;
                                            }
                                        } else {
                                            break;
                                        }


                                    }

                                }
                                splitValArr = [];
                            }
                        }

                        if (splitValArr.length >= 4) {
                            delete obj[k];
                            obj[splitArr[0].trim()] = splitValArr[0];
                            obj[splitArr[1].trim()] = splitValArr[1];
                            obj[splitArr[2].trim()] = splitValArr[2];

                            for (let index = 3; index < splitValArr.length; index++) {
                                if (index === 3) {
                                    obj[splitArr[3].trim()] = splitValArr[index];
                                } else {
                                    obj[splitArr[3].trim()] += " " + splitValArr[index];
                                }
                            }
                        } else if (splitValArr.length === 3) {
                            delete obj[k];
                            obj[splitArr[0].trim()] = splitValArr[0];
                            obj[splitArr[1].trim()] = splitValArr[1];
                            obj[splitArr[2].trim()] = splitValArr[2];
                        } else if (splitValArr.length === 2) {
                            delete obj[k];
                            obj[splitArr[0].trim()] = splitValArr[0];
                            obj[splitArr[1].trim()] = splitValArr[1];
                        } else if (splitValArr.length === 1) {
                            delete obj[k];
                            obj[splitArr[0].trim()] = splitValArr[0];
                        } else if (!(!util_1.isNullOrUndefined(scanD.data['subHeaderBreakWords']) && scanD.data['subHeaderBreakWords'].length > 0)) {
                            obj[splitArr[0].trim()] = "";
                            obj[splitArr[1].trim()] = "";
                            obj[splitArr[2].trim()] = "";
                            obj[splitArr[3].trim()] = "";
                        }
                    } else if (splitArr.length == 3) {
                        obj[k] = obj[k].replace(/\s-/gi, '-');
                        let splitValArr = obj[k].trim().split(/@@p/);
                        if (splitValArr.length != 3) {
                            splitValArr = obj[k].trim().split(/@@[np]/);
                            splitValArr = splitValArr.filter(function (x) { return x != ""; })
                        }
                        if (horizonatalSplitIndexes.indexOf(k) != -1) {
                            splitValArr = obj[k].trim().split(/\s/);
                        }
                        if (splitValArr.length >= 3) {
                            delete obj[k];
                            obj[splitArr[0].trim()] = splitValArr[0];
                            obj[splitArr[1].trim()] = splitValArr[1];
                            for (let index = 2; index < splitValArr.length; index++) {
                                if (index == 2) {
                                    obj[splitArr[2].trim()] = splitValArr[index];
                                } else {
                                    obj[splitArr[2].trim()] = obj[splitArr[2].trim()] + " " + splitValArr[index];
                                }
                            }
                        } else if (splitValArr.length == 2) {
                            delete obj[k];
                            obj[splitArr[0].trim()] = splitValArr[0];
                            obj[splitArr[1].trim()] = splitValArr[1];
                        } else if (splitValArr.length == 1) {
                            delete obj[k];
                            obj[splitArr[0].trim()] = splitValArr[0];
                        } else {
                            obj[splitArr[0].trim()] = "";
                            obj[splitArr[1].trim()] = "";
                            obj[splitArr[2].trim()] = "";

                        }
                    } else if (splitArr.length == 2) {
                        let splitValArr = obj[k].trim().split(/@@p/);
                        if (splitValArr.length != 2) {
                            splitValArr = obj[k].trim().split(/@@[np]/);
                            splitValArr = splitValArr.filter(function (x) { return x != ""; })
                        }
                        if (horizonatalSplitIndexes.indexOf(k) != -1) {
                            splitValArr = obj[k].trim().split(/\s/);
                        }
                        obj[k] = obj[k].replace(/\s-/gi, '-');
                        if (splitValArr.length == 2) {
                            delete obj[k];
                            obj[splitArr[0].trim()] = splitValArr[0];
                            obj[splitArr[1].trim()] = splitValArr[1];
                        } else if (splitValArr.length == 1) {
                            delete obj[k];
                            obj[splitArr[0].trim()] = splitValArr[0];
                        } else {
                            // amountF=true;
                            let splitValArr = obj[k].split(/@@n/);
                            if (horizonatalSplitIndexes.indexOf(k) != -1) {
                                splitValArr = obj[k].trim().split(/\s/);
                            }
                            if (splitValArr.length > 2) {
                                delete obj[k];
                                obj[splitArr[0].trim()] = splitValArr[0];

                                for (let index = 1; index < splitValArr.length; index++) {
                                    if (index === 1) {
                                        obj[splitArr[1].trim()] = splitValArr[index];
                                    } else {
                                        obj[splitArr[1].trim()] += " " + splitValArr[index];
                                    }
                                }
                            } else {
                                delete obj[k];
                                obj[splitArr[0].trim()] = "";
                                obj[splitArr[1].trim()] = "";
                            }
                        }
                    }
                }
            }
        }
        let emptyTable = false;
        for (let i = 0; i < fArr.length; i++) {
            let obj = fArr[i];
            for (var k in obj) {

                if (!util_1.isNullOrUndefined(obj[k]) && typeof (obj[k]) == "string") {
                    obj[k] = obj[k].replace(/@@n/g, ' ');
                    obj[k] = obj[k].replace(/@@p/g, ' ');
                    obj[k] = obj[k].replace(/\s\/$/g, ' ');
                    obj[k] = obj[k].trim();
                }
                if (/@@n/.test(k)) {
                    emptyTable = true;
                }
            }
        }
        if (emptyTable) {
            fArr = [];
        }
        newTableArray = fArr;

        // if(pipe){
        //     newTableArray = fArrNe;
        // }
        return {newTableArray:newTableArray,fArrCordinates:fArrCordinates};
    }
    hasUnmatchedBrackets(str) {
        const stack = [];
        const openingBrackets = ['(', '[', '{'];
        const closingBrackets = [')', ']', '}'];
    
        for (let char of str) {
            if (openingBrackets.includes(char)) {
                stack.push(char);
            } else if (closingBrackets.includes(char)) {
                const lastOpeningBracket = stack.pop();
                const expectedOpeningBracket = openingBrackets[closingBrackets.indexOf(char)];
                if (lastOpeningBracket !== expectedOpeningBracket) {
                    return true; // Unmatched brackets found
                }
            }
        }
    
        return stack.length > 0; // If there are unmatched opening brackets left
    }
    areObjectsEqualNonEmptyKeys(arr) {
        if (!Array.isArray(arr) || arr.length === 0) {
          // If the input is not an array or is an empty array, return false
          return false;
        }
      
        const firstObjectKeys = Object.keys(arr[0]).filter(key => arr[0][key] !== '');
      
        for (let i = 1; i < arr.length; i++) {
          const currentObjectKeys = Object.keys(arr[i]).filter(key => arr[i][key] !== '');
      
          if (currentObjectKeys.length !== firstObjectKeys.length) {
            // If the current object has a different number of non-empty keys, return false
            return false;
          }
      
          // Check if all non-empty keys in the current object are the same as the first object
          for (const key of currentObjectKeys) {
            if (!firstObjectKeys.includes(key)) {
              return false;
            }
          }
        }
      
        // All objects have the same non-empty keys
        return true;
    }
    checkIfbelongTOanother(subHeaderBreakWords, element, elementK) {
        for (let index = 0; index < subHeaderBreakWords.length; index++) {
            let obj = subHeaderBreakWords[index];
            for (var k in obj) {
                if (obj[k]['start'] != "" && elementK.includes(obj[k]['start']) && k != element) {
                    return { allow: false, break: true };
                } else if (obj[k]['end'] != "" && elementK.includes(obj[k]['end'])) {
                    return { allow: true, break: true };
                }
            }
        }
        return { allow: true, break: false };
    }
    checkIfValid(fArr, row) {
        if (fArr.length > 0) {
            for (var k in row) {
                if (k != "subTable" && !util_1.isNullOrUndefined(fArr[fArr.length - 1][k]) && fArr[fArr.length - 1][k].replace(/[\s]/gi, '') != row[k].replace(/[\s]/gi, '') && fArr[fArr.length - 1][k].replace(/[\s]/gi, '') != ""
                    && row[k].replace(/[\s]/gi, '') != "") {
                        
                    let str = fArr[fArr.length - 1][k];
                    const totalChars = str.length;
                    let alphabetCount = 0;
                    let digitCount = 0;

                    for (const char of str) {
                        if (/[A-Za-z]/.test(char)) {
                            alphabetCount++;
                        } else if (/[0-9]/.test(char)) {
                            digitCount++;
                        }
                    }

                    const alphabetPercentage = (alphabetCount / totalChars) * 100;
                    const digitPercentage = (digitCount / totalChars) * 100;
                    let allow=true;
                    if(alphabetPercentage>digitPercentage && fArr[fArr.length - 1][k].length>3){
                        allow=false;
                    }
                    if (allow && /(\d)[(\,)(\.)]/.test(fArr[fArr.length - 1][k].trim()) && !/-$/.test(fArr[fArr.length - 1][k].trim()) && /(\d)[(\,)(\.)]/.test(row[k]) && !/\(.+\)/.test(row[k])) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    // processTableObjects(TableObject) {

    //     if (TableObject.length == 2) {
    //         //    for(let i=0;i<TableObject.length;i++){
    //         let obj1 = TableObject[0];
    //         let obj2 = TableObject[1];
    //         let keys = [];
    //         for (var k in obj1) {
    //             keys.push(k);
    //         }
    //         if (obj1[keys[0]] != "" && obj1[keys[1]] == "") {
    //             if (obj2[keys[0]] != "" && obj2[keys[1]] != "") {
    //                 TableObject[1][keys[0]] = TableObject[0][keys[0]] + " " + TableObject[1][keys[0]]
    //             }
    //             if (keys.length > 2) {
    //                 if (obj2[keys[0]] == "" && obj2[keys[1]] != "") {
    //                     TableObject[1][keys[0]] = TableObject[0][keys[0]] + " " + TableObject[1][keys[0]]
    //                 }
    //             }
    //         }

    //         //    }
    //     }
    //     let newTableArray = [];
    //     for (let i = 0; i < TableObject.length; i++) {
    //         let obj = TableObject[i];
    //         let amountNotEmpty = false;
    //         let amountF = false;
    //         let allow = true;
    //         for (var k in obj) {
    //             if (/\d\.\d{3}$/.test(obj[k])) {
    //                 let arr = obj[k].match(/\.\d{3}/);
    //                 let str = arr[0].substring(1);
    //                 obj[k] = obj[k].replace(arr[0], "," + str);
    //             }
    //             // if (k == "Unit_Price" && obj[k].length > 0 && !/\d+/.test(obj[k])) {
    //             //     allow = false;
    //             // }
    //             // if ((/^\w+\s\w+\s\w+\s+\d+\,\d+\.\d+$/.test(obj[k]) || /^\w+\s\w+\s+\d+\,\d+\.\d+$/.test(obj[k])) && k.indexOf("|") == -1) {
    //             //     obj["Item_Description" + " | " + k] = obj[k];
    //             //     delete obj[k];
    //             //     k = "Item_Description" + " | " + k;

    //             // }
    //             // if ((k.toLocaleLowerCase().indexOf("amount") > -1 || k.toLocaleLowerCase().indexOf("line_total_amount") > -1)) {
    //             //     if (!util_1.isNullOrUndefined(obj['Item_Description']) && obj['Item_Description'].indexOf("LPO") > -1) {

    //             //     } else {
    //             //         amountF = true;
    //             //         if (obj[k] != "" && /\d+/.test(obj[k])) {
    //             //             amountNotEmpty = true;
    //             //         }
    //             //     }
    //             // }

    //             if ((obj['Quantity'] == '' || !/\d/.test(obj['Quantity'])) && obj['Taxable_Amount'] && obj['Taxable_Amount'] !== '' && obj['Unit_Price'] && obj['Unit_Price'] !== '') {
    //                 let taxable_amount = obj['Taxable_Amount'];
    //                 let unit_price = obj['Unit_Price'];

    //                 if (obj['Taxable_Amount'].includes(' ')) {
    //                     if (/^[A-za-z]/.test(obj['Taxable_Amount'])) {
    //                         taxable_amount = obj['Taxable_Amount'].split(' ').length == 2 ? obj['Taxable_Amount'].split(' ')[1] : obj['Taxable_Amount'];
    //                     }
    //                     else if (/[A-za-z]$/.test(obj['Taxable_Amount'])) {
    //                         taxable_amount = obj['Taxable_Amount'].split(' ').length == 2 ? obj['Taxable_Amount'].split(' ')[0] : obj['Taxable_Amount'];
    //                     }
    //                 }
    //                 if (obj['Unit_Price'].includes(' ')) {
    //                     if (/^[A-za-z]/.test(obj['Unit_Price'])) {
    //                         unit_price = obj['Unit_Price'].split(' ').length == 2 ? obj['Unit_Price'].split(' ')[1] : '0';
    //                     }
    //                     else if (/[A-za-z]$/.test(obj['Unit_Price'])) {
    //                         unit_price = obj['Unit_Price'].split(' ').length == 2 ? obj['Unit_Price'].split(' ')[0] : '0';
    //                     }
    //                 }

    //                 let val = String(Math.ceil(parseFloat(taxable_amount.replace(/,/g, '')) / parseFloat(unit_price.replace(/,/g, ''))));
    //                 if (!isNaN(val)) {
    //                     // obj['Quantity'] = val;
    //                 }
    //             }
    //             else if (util_1.isNullOrUndefined(obj['Taxable_Amount']) && obj['Quantity'] == '' && obj['Line_Total_Amount'] && obj['Line_Total_Amount'] !== '' && obj['Unit_Price'] && obj['Unit_Price'] !== '') {
    //                 let val = String(Math.ceil(parseFloat(obj['Line_Total_Amount'].replace(/,/g, '')) / parseFloat(obj['Unit_Price'].replace(/,/g, ''))));
    //                 if (!isNaN(val)) {
    //                     // obj['Quantity'] = val;
    //                 }
    //             }
    //             if (obj['Tax_Rate'] == '' && obj['Tax_Amount1'] && obj['Tax_Amount1'] !== '' && obj['Unit_Price'] && obj['Unit_Price'] !== '' && obj['Quantity'] && obj['Quantity'] !== '') {
    //                 let val = String((((parseFloat(obj['Tax_Amount1'].replace(/,/g, '')) / parseFloat(obj['Quantity'].replace(/,/g, '')))) / parseFloat(obj['Unit_Price'].replace(/,/g, ''))) * 100);
    //                 if (!isNaN(val)) {
    //                     // obj['Tax_Rate'] = val;
    //                 }
    //             }
    //             if (k.indexOf("|") && !(/\|$/.test(k))) {
    //                 let splitArr = k.split("|");
    //                 if (splitArr.length == 2) {
    //                     let splitValArr = obj[k].split(/\s+/);
    //                     if (splitValArr.length == 2) {
    //                         delete obj[k];
    //                         obj[splitArr[0].trim()] = splitValArr[0];
    //                         obj[splitArr[1].trim()] = splitValArr[1];
    //                     } else {
    //                         // amountF=true;
    //                         let splitValArr = obj[k].split(/\s+/);
    //                         if (splitValArr.length > 2) {
    //                             delete obj[k];
    //                             obj[splitArr[0].trim()] = "";
    //                             for (let l = 0; l < splitValArr.length - 1; l++) {
    //                                 obj[splitArr[0].trim()] = obj[splitArr[0].trim()] + " " + splitValArr[l];
    //                             }
    //                             obj[splitArr[1].trim()] = splitValArr[splitValArr.length - 1];
    //                         } else {
    //                             amountF = true;
    //                             allow = false;
    //                         }
    //                     }
    //                 } else if (splitArr.length >= 3) {
    //                     let splitValArr = obj[k].split(/\s+/);
    //                     if (splitValArr.length >= 3) {
    //                         delete obj[k];
    //                         obj[splitArr[0].trim()] = splitValArr[0];
    //                         obj[splitArr[1].trim()] = splitValArr[1];
    //                         obj[splitArr[2].trim()] = splitValArr[2];
    //                     } else {
    //                         amountF = true;
    //                         allow = false;
    //                     }
    //                 }
    //             }
    //         }
    //         if (((amountF && amountNotEmpty) || !amountF) && allow) {
    //             newTableArray.push(obj)
    //         }
    //     }
    //     if (newTableArray.length == 2) {
    //         let obj1 = newTableArray[1];
    //         let notEmptyCount = 0;
    //         let notEmptyKey = '';
    //         let arr = [];
    //         let keys = [];
    //         for (var k in obj1) {
    //             keys.push(k);
    //             if (obj1[k] != "") {
    //                 notEmptyCount = notEmptyCount + 1;
    //                 notEmptyKey = k;
    //             }
    //         }
    //         if (notEmptyCount == 1) {
    //             let obj2 = newTableArray[0];
    //             obj2[notEmptyKey] = obj2[notEmptyKey] + obj1[notEmptyKey]
    //             arr.push(obj2);
    //             newTableArray = arr;
    //         }
    //     }
    //     return newTableArray;
    // }

    extractTableData(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            /*Get table data using marked bounding box*/
            try {
                req.body.input.return ? '' : res.send({ status: 0 });
                let self = this;
                logger.info('Inside extract table data from lines');
                // let complete = false;
                let extractTableDataOutputArray = [];
                let token = req.body.token;
                let botId = req.body.botId;
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;

                console.log("botid --->", botId)
                console.log("eventId ---->", eventId)
                console.log("projectId --->", projectId)
                console.log("111")
                if (!util_1.isNullOrUndefined(req.body.input.ruleObj)) {
                    console.log("222")
                    extractTableDataOutputArray = yield self.extractTableDataloop(req.body.input.ruleObj)
                    console.log("333")
                    let outputData = { "extractTableData": extractTableDataOutputArray, "uploadStatus": true, 'statusCode': '200' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    console.log("444")
                    console.log("url is ---->", config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite")
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     console.log("555")
                    //     console.log("--------------err in res", error);
                    //     // console.log("body---responce",body);
                    //     // console.log("---res",response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    if (req.body.input.return)
                        return outputData;
                    else
                        yield self.ioWrite(options)


                    ///////////////////////////////////////////////////////

                }
                else {
                    console.log("from else6666")
                    logger.error("#extractTableData==>Internal server Error");
                    let outputData = { "extractTableData": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = "#extractTableData==>Internal server Error";
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     // console.log("body---responce", body);
                    //     // console.log("---res", response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    if (req.body.input.return)
                        return outputData;
                    else
                        yield self.ioWrite(options)


                    ///////////////////////////////////////////////////////
                }
            }
            catch (err) {
                console.log("from catch 77777")
                logger.error('Failed for get Table OCR data - inside catch' + err);
                let outputData = { "extractTableData": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = err.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
            }
        });
    }
    genrateCsv(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                /*Generate csv*/
                req.body.input.return ? '' : res.send({ status: 0 });
                logger.info('Inside genrateCsv');
                let self = this;
                let token = req.body.token;
                let dam;
                let botId = req.body.botId;
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;
                if (!util_1.isNullOrUndefined(req.body.input.ruleObj)) {
                    for (let index = 0; index < req.body.input.ruleObj.length; index++) {
                        let ruleObj = req.body.input.ruleObj[index];
                        let filePath = ruleObj.obj.filePath;
                        for (const list of ruleObj.csvInfoArray) {
                            let data = list['data'];
                            let headers = config.tableHeaderScanning;
                            let fileRefNum = list['fileRefNum'];
                            let entity = list['entity'];

                            for (let abc of data) {
                                abc['fileRefNum'] = fileRefNum;
                                abc['filePath'] = filePath;
                                abc['fileName'] = filePath;
                            }
                            dam = yield self.csvGenerate(data, headers, fileRefNum, entity, filePath);
                            // console.log("UIUIUIUIUIUI--------", index);
                        }
                    }
                    let outputData = { "genrateCsv": req.body.input.ruleObj, "csvPath": dam, "uploadStatus": true, 'statusCode': '200' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     //console.log("--------------err in res",error);
                    //     //console.log("body---responce",body);
                    //     //console.log("---res",response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    if (req.body.input.return)
                        return outputData;
                    else
                        yield self.ioWrite(options)

                    ///////////////////////////////////////////////////////
                }
                else {
                    logger.error("#genrateCsv==>Internal server Error");
                    let outputData = { "genrateCsv": null, "csvPath": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = "#genrateCsv==>Internal server Error";
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     // console.log("body---responce", body);
                    //     // console.log("---res", response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    yield self.ioWrite(options);


                    ///////////////////////////////////////////////////////
                }
            }
            catch (e) {
                logger.error('#genrateCsv==>Inside catch', e);
                let outputData = { "genrateCsv": null, "csvPath": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = e.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
            }
        });
    }

    accuracyrules(invoiceObject, doctype) {
        try {
            console.log("Inside Accuracy Rules function");
            let invoiceKeys = [];
            // for (key in invoiceObject) {
            //     invoiceKeys.push(key);

            //     if (invoiceObject[key].toString().toLowerCase().includes('date')) {
            //         delete invoiceObject[key]
            //     }
            // }
            /////////////////////////////////////////////////////
            //-------------------------------------------------//
            if ((doctype == "GE_Doctype") && !util_1.isNullOrUndefined(invoiceObject['Invoice_Number'])) {
                invoiceObject['Invoice_Number'] = invoiceObject['Invoice_Number'].replace('$', 'S');
            }
            let headerlevelFields = ['InvoiceTotalAmount', 'Tax_Amount']
            for (let i = 0; i < headerlevelFields.length; i++) {
                if (!util_1.isNullOrUndefined(invoiceObject[headerlevelFields[i]])) {
                    let currency = /(\s[A-Z]{3,3}$)|(\s[A-Z]{3,3}\s)|(^[A-Z]{3,3}$)/
                    let currency1 = /(\$)|(USD)/
                    let currency2 = /(AED)/
                    let currency3 = /(INR)/
                    invoiceObject[headerlevelFields[i]] = invoiceObject[headerlevelFields[i]].toString();
                    if (invoiceObject[headerlevelFields[i]].match(currency) && invoiceObject[headerlevelFields[i]].match(currency).length >= 1) {
                        invoiceObject['Currency'] = invoiceObject[headerlevelFields[i]].match(currency)[0].trim();
                    }
                    else if (currency1.test(invoiceObject[headerlevelFields[i]])) {
                        invoiceObject['Currency'] = 'USD';
                    }
                    else if (currency2.test(invoiceObject[headerlevelFields[i]])) {
                        invoiceObject['Currency'] = 'AED';
                    }
                    else if (currency3.test(invoiceObject[headerlevelFields[i]])) {
                        invoiceObject['Currency'] = 'INR';
                    }
                }
            }

            if (!util_1.isNullOrUndefined(invoiceObject['Currency'])) {
                let currency = /(AED)|(AFI)|(AFD)|(AF)|(AD)/
                if (currency.test(invoiceObject['Currency'].toLowerCase()) || currency.test(invoiceObject['Currency'].toUpperCase())) {
                    invoiceObject['Currency'] = 'AED';
                }// Match Against Currency Code Table 
                // else if (invoiceObject['Currency'] == '' || !/^[A-Z]{3,3}$/.test(invoiceObject['Currency'])) {
                //     invoiceObject['Currency'] = 'AED';
                // }
            }

            let headerNumericalFields = ['Tax_Amount', 'InvoiceTotalAmount']

            for (let i = 0; i < headerNumericalFields.length; i++) {

                if (!util_1.isNullOrUndefined(invoiceObject[headerNumericalFields[i]])) {
                    invoiceObject[headerNumericalFields[i]] = invoiceObject[headerNumericalFields[i]].replace(/([a-zA-Z\n$\]\[\|\/\\\%-])/g, '').trim();
                    let lastthree = invoiceObject[headerNumericalFields[i]].substr(-3);
                    lastthree = lastthree.toString().replace(/(,)/g, ".");
                    // console.log(lastthree);
                    let firstNumeric = invoiceObject[headerNumericalFields[i]].slice(0, invoiceObject[headerNumericalFields[i]].length - 3);
                    firstNumeric = firstNumeric.toString().replace(/([a-zA-Z\n.:$\]\[\|\/\\\%,])/g, '').trim();
                    invoiceObject[headerNumericalFields[i]] = firstNumeric.concat(lastthree);
                    invoiceObject[headerNumericalFields[i]] = !util_1.isNullOrUndefined(invoiceObject[headerNumericalFields[i]]) && !isNaN(parseFloat(invoiceObject[headerNumericalFields[i]])) ? (invoiceObject[headerNumericalFields[i]]) : '';
                    invoiceObject[headerNumericalFields[i]] = invoiceObject[headerNumericalFields[i]].toString().trim();
                    invoiceObject[headerNumericalFields[i]] = invoiceObject[headerNumericalFields[i]].startsWith(".") ? invoiceObject[headerNumericalFields[i]].slice(1) : invoiceObject[headerNumericalFields[i]];
                    invoiceObject[headerNumericalFields[i]] = invoiceObject[headerNumericalFields[i]].endsWith(".") ? invoiceObject[headerNumericalFields[i]].slice(0, -1) : invoiceObject[headerNumericalFields[i]];
                    //invoiceObject[headerNumericalFields[i]] = invoiceObject[headerNumericalFields[i]].toString().replace(/([a-zA-Z\n.:\]\[\|\/\\\%,])/g, '').trim();
                    //invoiceObject[headerNumericalFields[i]] = !util_1.isNullOrUndefined(invoiceObject[headerNumericalFields[i]]) && !isNaN(parseFloat(invoiceObject[headerNumericalFields[i]])) ? parseFloat(invoiceObject[headerNumericalFields[i]]) : '';
                }
            }
            if (doctype !== "GE_Doctype") {
                if (!util_1.isNullOrUndefined(invoiceObject['Supplier_TRN'])) {
                    invoiceObject['Supplier_TRN'] = invoiceObject['Supplier_TRN'].toString().replace(/([a-zA-Z\n.,:;‘`"^{}\]\[\|\/\\\%,#-+~*@!()])/g, '').trim();
                    invoiceObject['Supplier_TRN'] = invoiceObject['Supplier_TRN'].toString().replace(/ /g, '').trim();
                    if (invoiceObject['Supplier_TRN'] == '100270983800003') {
                        let temp = invoiceObject['Supplier_TRN'];
                        invoiceObject['Supplier_TRN'] = invoiceObject['Customer_TRN'];
                        invoiceObject['Customer_TRN'] = temp;
                    }
                    else if (invoiceObject['Supplier_TRN'].length >= 30) {
                        let splits = invoiceObject['Supplier_TRN'].split('100270983800003');
                        splits[0] = (splits[0] == '') ? '100270983800003' : splits[0];
                        splits[1] = (splits[1] == '') ? '100270983800003' : splits[1];

                        if (splits.length == 2) {
                            //invoiceObject['Customer_TRN'] = splits[0].includes('100270983800003') ? splits[0] : splits[1];
                            invoiceObject['Supplier_TRN'] = !splits[0].includes('100270983800003') ? splits[0] : splits[1];
                        }
                    }
                    if (invoiceObject['Supplier_TRN'].length >= 30) {
                        invoiceObject['Supplier_TRN'] = invoiceObject['Supplier_TRN'].substr(-15);
                    }
                }


                if (!util_1.isNullOrUndefined(invoiceObject['Customer_TRN'])) {
                    invoiceObject['Customer_TRN'] = invoiceObject['Customer_TRN'].toString().replace(/([a-zA-Z\n.,:;‘`"^{}\]\[\|\/\\\%,#-+~*@!()])/g, '').trim();
                    invoiceObject['Customer_TRN'] = invoiceObject['Customer_TRN'].toString().replace(/ /g, '').trim();
                    if (invoiceObject['Customer_TRN'].length >= 30) {
                        let splits = invoiceObject['Customer_TRN'].split('100270983800003')
                        splits[0] = (splits[0] == '') ? '100270983800003' : splits[0];
                        splits[1] = (splits[1] == '') ? '100270983800003' : splits[1];

                        if (splits.length == 2) {
                            invoiceObject['Customer_TRN'] = splits[0].includes('100270983800003') ? splits[0] : splits[1];
                            //invoiceObject['Supplier_TRN'] = !splits[0].includes('100270983800003') ? splits[0] : splits[1];
                        }
                    }
                }
            }
            if (!util_1.isNullOrUndefined(invoiceObject['PO_Number'])) {
                let regex = /(PO NO|PO No.|PO No|Cust P.O.|Cust|P.O.|LPO#|LPO number #|PO|PO#|No.|LPO #|LPO #|LPO|Purchase Order|Order|-|#)/g;
                let regex1 = /(\s{0,}\d+|\d+)/g;
                let regex2 = /(AUH\/\d{0,}\/)|(TEC\/CPD\/)/;
                if ((invoiceObject['PO_Number'].match(regex) || invoiceObject['PO_Number'].match(regex1)) && !util_1.isNullOrUndefined(invoiceObject['PO_Number'].match(regex))) {
                    if (invoiceObject['PO_Number'].match(regex).length >= 1) {
                        let PO = !util_1.isNullOrUndefined(invoiceObject['PO_Number'].match(regex1)[0]) ? invoiceObject['PO_Number'].match(regex1)[0] : invoiceObject['PO_Number'];
                        invoiceObject['PO_Number'] = PO.replace(/(PO NO|PO No.|PO No|Cust P.O.|Cust|P.O.|LPO#|LPO number #|PO|PO#|No.|LPO #|LPO #|LPO|Purchase Order|Order|-|#)/g, '').trim()
                        invoiceObject['PO_Number'] = !util_1.isNullOrUndefined(invoiceObject['PO_Number']) ? invoiceObject['PO_Number'] : PO;
                    }
                }
                else if (invoiceObject['PO_Number'].match(regex2) && !util_1.isNullOrUndefined(invoiceObject['PO_Number'].match(regex2))) {
                    if (invoiceObject['PO_Number'].match(regex2).length >= 1) {
                        let PO = !util_1.isNullOrUndefined(invoiceObject['PO_Number'].match(regex2)[0]) ? invoiceObject['PO_Number'].match(regex2)[0] : invoiceObject['PO_Number'];
                        invoiceObject['PO_Number'] = invoiceObject['PO_Number'].replace(regex2, '').replace('/[#-]/g', '').trim()
                        invoiceObject['PO_Number'] = !util_1.isNullOrUndefined(invoiceObject['PO_Number']) ? invoiceObject['PO_Number'] : PO;
                    }
                }
                if ((doctype == "GE_Doctype")) {
                    if (invoiceObject['PO_Number'].indexOf("d") != -1) {
                        invoiceObject['PO_Number'] = invoiceObject['PO_Number'].substr(0, invoiceObject['PO_Number'].indexOf("d"));
                    }
                    if (invoiceObject['PO_Number'].indexOf("D") != -1) {
                        invoiceObject['PO_Number'] = invoiceObject['PO_Number'].substr(0, invoiceObject['PO_Number'].indexOf("D"));
                    }
                }
                invoiceObject['PO_Number'] = invoiceObject['PO_Number'].toString().trim();
                invoiceObject['PO_Number'] = invoiceObject['PO_Number'].startsWith(".") ? invoiceObject['PO_Number'].slice(1) : invoiceObject['PO_Number'];
                invoiceObject['PO_Number'] = invoiceObject['PO_Number'].endsWith(".") ? invoiceObject['PO_Number'].slice(0, -1) : invoiceObject['PO_Number'];

            }
            if (!util_1.isNullOrUndefined(invoiceObject['Invoice_Type']) && !util_1.isNullOrUndefined(invoiceObject['Invoice_Title']) && invoiceObject['Invoice_Type'] !== '') {
                invoiceObject['Invoice_Title'] = invoiceObject['Invoice_Type'];
            }
            if (doctype !== "GE_Doctype") {
                if (!util_1.isNullOrUndefined(invoiceObject['Invoice_Title'])) {
                    let credit = /(credit)|(Note)|(memo)/;
                    let prepayment = /(PRO-FORMA INVOICE)|(prepayment)|(proforma)|(PROFORMA)|(Performa)/;
                    if (credit.test(invoiceObject['Invoice_Title'].toLowerCase()) || credit.test(invoiceObject['Invoice_Title'].toUpperCase())) {
                        invoiceObject['Invoice_Type'] = 'CREDIT';
                    }
                    else if (prepayment.test(invoiceObject['Invoice_Title'].toLowerCase()) || prepayment.test(invoiceObject['Invoice_Title'].toUpperCase())) {
                        invoiceObject['Invoice_Type'] = 'PREPAYMENT';
                    }
                    else {
                        invoiceObject['Invoice_Type'] = 'STANDARD';
                    }
                }
                else {
                    invoiceObject['Invoice_Type'] = 'STANDARD';
                }
            }

            if (!util_1.isNullOrUndefined(invoiceObject['Invoice_Number'])) {
                let invoiceno = /(Invoice No)|(INVOICE NUMBER)|(Invoice No.)|(INVOIC)|(INVOICE)|(No.)|(No)|(Reference)|(Number)|(number)|(invoice)|(Inv.)|(\/ Date)/g
                if (invoiceno.test(invoiceObject['Invoice_Number']) || invoiceno.test(invoiceObject['Invoice_Number'].toLowerCase()) || invoiceno.test(invoiceObject['Invoice_Number'].toUpperCase())) {
                    invoiceObject['Invoice_Number'] = invoiceObject['Invoice_Number'].replace(invoiceno, '').trim();
                }
                invoiceObject['Invoice_Number'] = invoiceObject['Invoice_Number'].toString().trim();
                invoiceObject['Invoice_Number'] = invoiceObject['Invoice_Number'].startsWith(".") ? invoiceObject['Invoice_Number'].slice(1) : invoiceObject['Invoice_Number'];
                invoiceObject['Invoice_Number'] = invoiceObject['Invoice_Number'].endsWith(".") ? invoiceObject['Invoice_Number'].slice(0, -1) : invoiceObject['Invoice_Number'];


            }

            if (!util_1.isNullOrUndefined(invoiceObject['Invoice_Date'])) {
                let invoiceno = /(Date)|(INVOICE DATE)|(Invoice Date.)|(date)|(INVOICE)|(Performa)|(Proforma)|(Reference)|(date)(reference)/g
                if (invoiceno.test(invoiceObject['Invoice_Date'].toLowerCase()) || invoiceno.test(invoiceObject['Invoice_Date'].toUpperCase())) {
                    invoiceObject['Invoice_Date'] = invoiceObject['Invoice_Date'].replace(invoiceno, '').trim();
                }
            }

            if (!util_1.isNullOrUndefined(invoiceObject['Vendor_Name']) && (invoiceObject['Vendor_Name'] == '') && !util_1.isNullOrUndefined(!util_1.isNullOrUndefined(invoiceObject['Vendor_Name']))) {
                if (invoiceObject['Supplier_Address'].includes('LLC')) {
                    invoiceObject['Vendor_Name'] = invoiceObject['Supplier_Address'].substring(0, invoiceObject['Supplier_Address'].indexOf('LLC') + 3)
                }
                else if (invoiceObject['Supplier_Address'].includes('l.l.c')) {
                    invoiceObject['Vendor_Name'] = invoiceObject['Supplier_Address'].substring(0, invoiceObject['Supplier_Address'].indexOf('l.l.c') + 5)
                }
                else if (invoiceObject['Supplier_Address'].includes('llc')) {
                    invoiceObject['Vendor_Name'] = invoiceObject['Supplier_Address'].substring(0, invoiceObject['Supplier_Address'].indexOf('llc') + 3)
                }
            }

            /////////////////////////////////////////////////////
            //----------------Table level fields---------------//
            let NumericalFields = ['Unit_Price', 'Taxable_Amount', 'Tax_Amount1', 'Quantity', 'Line_Total_Amount', 'Unit_Price', 'Tax_Rate', 'Item_PO_Number']
            let standardAmount = ['Taxable_Amount', 'Tax_Amount1', 'Line_Total_Amount', 'Unit_Price']


            if (!util_1.isNullOrUndefined(invoiceObject.invoiceItems) && Array.isArray(invoiceObject.invoiceItems)) {
                let INVOICE_ITEMS = JSON.parse(JSON.stringify(invoiceObject.invoiceItems));
                if (Array.isArray(INVOICE_ITEMS)) {
                    invoiceObject.invoiceItems = [];
                    for (let index = 0; index < INVOICE_ITEMS.length; index++) {
                        let element = JSON.parse(JSON.stringify(INVOICE_ITEMS[index]));
                        let tableKeys = [];
                        let key;

                        //Discarding Rows---start
                        let discardRow = false;
                        let discardRegex = /('Total In')|('Total For')/;
                        let vatRegex = /(Value Added Tax :)|(VAT \(5%)|VAT (0%)/;
                        for (key in element) {
                            if (NumericalFields.includes(key) && NumericalFields.indexOf(key) > -1 && key !== 'Item_PO_Number') {
                                if (discardRegex.test(element[key])) {
                                    //discardRow = true;
                                    break;
                                }
                            }
                            // if (vatRegex.test(element[key]) && doctype !== "GE_Doctype") {
                            //     element[key] = !util_1.isNullOrUndefined(element[key]) ? element[key].toString().replace(/[a-zA-Z\]\[\|\/\\\%,]/g, '').trim() : '';
                            //     if (!isNaN(parseFloat(element[key]))) {
                            //         console.log("Fetching Tax_RATE..")
                            //         if (parseFloat(element[key]) > 0) {
                            //             invoiceObject['Tax_code'] = 'VAT_TWZ_DR';
                            //         }
                            //         else if ((!util_1.isNullOrUndefined(invoiceObject['Invoice_Title']) && invoiceObject['Invoice_Title'].includes('TAX')) || (!util_1.isNullOrUndefined(invoiceObject['Supplier_TRN']) && invoiceObject['Supplier_TRN'] == '')) {
                            //             invoiceObject['Tax_code'] = 'VAT_TEC_0';
                            //         }
                            //         else {
                            //             invoiceObject['Tax_code'] = 'VAT_OOS';
                            //         }
                            //     }
                            //     //discardRow = true;
                            // }
                        }

                        if (discardRow) {
                            continue;
                        }
                        //Discarding Rows---end


                        //clearing numerical Data
                        for (key in element) {
                            tableKeys.push(key);

                            // if (element[key].toString().toLowerCase().includes('date')) {
                            //     delete element[key]
                            // }
                            if (NumericalFields.includes(key) && NumericalFields.indexOf(key) > -1) {
                                if ((key == "Tax_Rate") && element[key].toString().includes("Not Applicable")) {
                                    console.log("element tax rate", element[key]);
                                    element[key] = 0;
                                    console.log("element tax rate", element[key]);
                                }
                                element[key] = !util_1.isNullOrUndefined(element[key]) ? element[key].toString().replace(/[\$a-zA-Z\]\[\|\/\\\%,-]/g, '').trim() : '';

                                // OCR issues handled for Decimal Values 
                                if (element[key].indexOf('.') !== element[key].lastIndexOf('.') && element[key].length > 4) {
                                    element[key] = element[key].substring(0, element[key].length - 3); //.replace('.', '')
                                    element[key] = !util_1.isNullOrUndefined(element[key]) && !isNaN(parseFloat(element[key])) ? parseFloat(element[key]) : '';
                                }
                                else if (standardAmount.includes(key) && standardAmount.indexOf(key) > -1 && !util_1.isNullOrUndefined(element[key]) && !element[key].includes('.')) {
                                    element[key] = element[key].length > 2 ? element[key].replace(/(\d\d)$/, '.$1') : element[key];
                                    element[key] = element[key].length > 2 ? element[key].replace(/[\/\-]/g, '') : element[key];
                                }
                                //element[key] = !util_1.isNullOrUndefined(element[key]) && !isNaN(parseFloat(element[key])) ? parseFloat(element[key]) : '';
                            }
                        }

                        //Discarding Rows---start
                        let numericalFieldsCount = 0;
                        let nonnumericFields = 0;
                        for (key in element) {
                            if (NumericalFields.includes(key) && NumericalFields.indexOf(key) > -1 && key !== 'Item_PO_Number') {
                                numericalFieldsCount++;
                                if (!util_1.isNullOrUndefined(element[key]) && !/\d/.test(element[key])) {
                                    nonnumericFields++;
                                }
                            }
                        }
                        if (numericalFieldsCount > 0) {
                            // if ((nonnumericFields == numericalFieldsCount) || (nonnumericFields > Math.round(numericalFieldsCount / 3))) {
                            //     discardRow = true;
                            //     continue;
                            // }
                        }
                        //Discarding Rows---start

                        for (let i = 0; i < NumericalFields.length; i++) {
                            element[NumericalFields[i]] = !util_1.isNullOrUndefined(element[NumericalFields[i]]) && !isNaN(parseFloat(element[NumericalFields[i]])) ? parseFloat(element[NumericalFields[i]]) : '';
                        }
                        //Quantity using formulae
                        if (NumericalFields.includes('Quantity')) { //&& (!util_1.isNullOrUndefined(element["Quantity"]) && isNaN(parseFloat(element["Quantity"])))) {
                            if (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && !util_1.isNullOrUndefined(element["Unit_Price"]) && !isNaN(parseFloat(element["Taxable_Amount"])) && !isNaN(parseFloat(element["Unit_Price"]))) {
                                element["Quantity"] = parseFloat(element["Taxable_Amount"]) / parseFloat(element["Unit_Price"]);
                                element["Quantity"] = !isNaN(element["Quantity"]) ? element["Quantity"] : '';
                                element["Quantity"] = !isNaN(element["Quantity"]) ? (Math.round(element["Quantity"])).toString() : '';
                                element["Quantity"] = element["Quantity"].trim();
                                element["Quantity"] = element["Quantity"].startsWith(".") ? element["Quantity"].slice(1) : element["Quantity"];
                                element["Quantity"] = element["Quantity"].endsWith(".") ? element["Quantity"].slice(0, -1) : element["Quantity"];

                            }
                        }
                        //Unit_Price using formulae
                        if (NumericalFields.includes('Unit_Price')) { //&& (!util_1.isNullOrUndefined(element["Unit_Price"]) && isNaN(parseFloat(element["Unit_Price"])))) {

                            if (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && !util_1.isNullOrUndefined(element["Quantity"]) && !isNaN(parseFloat(element["Taxable_Amount"])) && !isNaN(parseFloat(element["Quantity"]))) {
                                element["Unit_Price"] = parseFloat(element["Taxable_Amount"]) / parseFloat(element["Quantity"]);
                                element["Unit_Price"] = !isNaN(element["Unit_Price"]) ? element["Unit_Price"] : '';
                                element["Unit_Price"] = element["Unit_Price"].toString().trim();
                                element["Unit_Price"] = element["Unit_Price"].startsWith(".") ? element["Unit_Price"].slice(1) : element["Unit_Price"];
                                element["Unit_Price"] = element["Unit_Price"].endsWith(".") ? element["Unit_Price"].slice(0, -1) : element["Unit_Price"];

                            }
                        }
                        //Taxable_Amount using formulae
                        if (NumericalFields.includes('Taxable_Amount')) { //&& (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && isNaN(parseFloat(element["Taxable_Amount"])))) {

                            if (!util_1.isNullOrUndefined(element["Unit_Price"]) && !util_1.isNullOrUndefined(element["Quantity"]) && !isNaN(parseFloat(element["Unit_Price"])) && !isNaN(parseFloat(element["Quantity"]))) {
                                element["Taxable_Amount"] = parseFloat(element["Unit_Price"]) * parseFloat(element["Quantity"]);
                                element["Taxable_Amount"] = parseFloat(parseFloat(element["Taxable_Amount"]).toFixed(2));
                                element["Taxable_Amount"] = !isNaN(element["Taxable_Amount"]) ? element["Taxable_Amount"] : '';
                            }
                            else if (!util_1.isNullOrUndefined(element["Line_Total_Amount"]) && !util_1.isNullOrUndefined(element["Tax_Amount1"]) && !isNaN(parseFloat(element["Line_Total_Amount"])) && !isNaN(parseFloat(element["Tax_Amount1"]))) {
                                element["Taxable_Amount"] = parseFloat(element["Line_Total_Amount"]) - parseFloat(element["Tax_Amount1"]);
                                element["Taxable_Amount"] = parseFloat(parseFloat(element["Taxable_Amount"]).toFixed(2))
                                element["Taxable_Amount"] = !isNaN(element["Taxable_Amount"]) ? element["Taxable_Amount"] : '';
                            }
                            else if (!util_1.isNullOrUndefined(element["Tax_Rate"]) && !util_1.isNullOrUndefined(element["Line_Total_Amount"]) && !isNaN(parseFloat(element["Tax_Rate"])) && !isNaN(parseFloat(element["Line_Total_Amount"]))) {
                                element["Taxable_Amount"] = Math.round(parseFloat(element["Line_Total_Amount"]) / (1 + ((parseFloat(element["Tax_Rate"]) / 100))));
                                element["Taxable_Amount"] = parseFloat(parseFloat(element["Taxable_Amount"]).toFixed(2));
                                element["Taxable_Amount"] = !isNaN(element["Taxable_Amount"]) ? element["Taxable_Amount"] : '';
                            }
                            element["Taxable_Amount"] = !util_1.isNullOrUndefined(element["Taxable_Amount"]) ? element["Taxable_Amount"].toString().trim() : '';
                            element["Taxable_Amount"] = (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && element["Taxable_Amount"].startsWith(".")) ? element["Taxable_Amount"].slice(1) : element["Taxable_Amount"];
                            element["Taxable_Amount"] = (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && element["Taxable_Amount"].endsWith(".")) ? element["Taxable_Amount"].slice(0, -1) : element["Taxable_Amount"];
                        }
                        else if ((!util_1.isNullOrUndefined(element["Taxable_Amount"]) && (!util_1.isNullOrUndefined(element["Unit_Price"])) && (!util_1.isNullOrUndefined(element["Quantity"])))) {
                            if (!isNaN(parseFloat(element["Unit_Price"])) && !isNaN(parseFloat(element["Tax_Amount1"])) && !isNaN(parseFloat(element["Taxable_Amount"]))) {
                                let chk = parseFloat(element["Unit_Price"]) * parseFloat(element["Quantity"]);
                                if (chk !== parseFloat(element["Taxable_Amount"])) {
                                    let err = {
                                        "Taxable_Amount": "EX166 - Taxable_Amount is not matching with Unit_Price X Quantity"
                                    }
                                    if (!util_1.isNullOrUndefined(invoiceObject["error"]) && Array.isArray(invoiceObject["error"])) {
                                        invoiceObject["error"].push(err)
                                    }
                                    else {
                                        invoiceObject["error"] = [];
                                        invoiceObject["error"].push(err)
                                    }
                                }
                            }
                        }

                        //Tax_Amount1 using formulae
                        if (NumericalFields.includes('Tax_Amount1')) {// && (!util_1.isNullOrUndefined(element["Tax_Amount1"]) && isNaN(parseFloat(element["Tax_Amount1"])))) {

                            if (!util_1.isNullOrUndefined(element["Line_Total_Amount"]) && !util_1.isNullOrUndefined(element["Taxable_Amount"]) && !isNaN(parseFloat(element["Line_Total_Amount"])) && !isNaN(parseFloat(element["Taxable_Amount"]))) {
                                element["Tax_Amount1"] = parseFloat(element["Line_Total_Amount"]) - parseFloat(element["Taxable_Amount"]);
                                element["Tax_Amount1"] = parseFloat(parseFloat(element["Taxable_Amount1"]).toFixed(2));
                                element["Tax_Amount1"] = !isNaN(element["Tax_Amount1"]) ? element["Tax_Amount1"] : '';
                            }
                            else if (!util_1.isNullOrUndefined(element["Tax_Rate"]) && !util_1.isNullOrUndefined(element["Taxable_Amount"]) && !isNaN(parseFloat(element["Tax_Rate"])) && !isNaN(parseFloat(element["Taxable_Amount"]))) {
                                element["Tax_Amount1"] = (parseFloat(element["Tax_Rate"]) / 100) * parseFloat(element["Taxable_Amount"]);
                                element["Tax_Amount1"] = parseFloat(parseFloat(element["Taxable_Amount1"]).toFixed(2));
                                element["Tax_Amount1"] = !isNaN(element["Tax_Amount1"]) ? element["Tax_Amount1"] : '';
                            }
                            element["Tax_Amount1"] = !util_1.isNullOrUndefined(element["Tax_Amount1"]) ? element["Tax_Amount1"].toString().trim() : '';
                            element["Tax_Amount1"] = (!util_1.isNullOrUndefined(element["Tax_Amount1"]) && element["Tax_Amount1"].startsWith(".")) ? element["Tax_Amount1"].slice(1) : element["Tax_Amount1"];
                            element["Tax_Amount1"] = (!util_1.isNullOrUndefined(element["Tax_Amount1"]) && element["Tax_Amount1"].endsWith(".")) ? element["Tax_Amount1"].slice(0, -1) : element["Tax_Amount1"];

                        }

                        //Tazable_Amount Calculation
                        if (NumericalFields.includes('Tax_Amount1') && (!util_1.isNullOrUndefined(element["Tax_Amount1"]) && isNaN(parseFloat(element["Tax_Amount1"]))) && (element["Tax_Amount1"].length > 0) && (!util_1.isNullOrUndefined(element["Line_Total_Amount"]) && isNaN(parseFloat(element["Line_Total_Amount"]))) && (element["Line_Total_Amount"].length > 0) && (util_1.isNullOrUndefined(element["Taxable_Amount"]) || element["Taxable_Amount"].length > 0)) {
                            element["Taxable_Amount"] = parseFloat(element["Line_Total_Amount"]) - parseFloat(element["Tax_Amount1"]);
                            element["Taxable_Amount"] = parseFloat(parseFloat(element["Taxable_Amount"]).toFixed(2));
                            element["Taxable_Amount"] = !isNaN(element["Taxable_Amount"]) ? element["Taxable_Amount"] : '';
                            element["Taxable_Amount"] = element["Taxable_Amount"].toString().trim();
                            element["Taxable_Amount"] = (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && element["Taxable_Amount"].startsWith(".")) ? element["Taxable_Amount"].slice(1) : element["Taxable_Amount"];
                            element["Taxable_Amount"] = (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && element["Taxable_Amount"].endsWith(".")) ? element["Taxable_Amount"].slice(0, -1) : element["Taxable_Amount"];
                        }
                        //Tax_Rate using formulae
                        if (NumericalFields.includes('Tax_Rate')) {// && (!util_1.isNullOrUndefined(element["Tax_Rate"]) && isNaN(parseFloat(element["Tax_Rate"])))) {

                            if (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && !util_1.isNullOrUndefined(element["Tax_Amount1"]) && !isNaN(parseFloat(element["Taxable_Amount"])) && !isNaN(parseFloat(element["Tax_Amount1"]))) {
                                element["Tax_Rate"] = Math.round((parseFloat(element["Tax_Amount1"]) / parseFloat(element["Taxable_Amount"])) * 100);
                                element["Tax_Rate"] = !isNaN(element["Tax_Rate"]) && element["Tax_Rate"] > 0 ? 5 : 0;
                                element["Tax_Rate"] = element["Tax_Rate"].toString().trim();
                                element["Tax_Rate"] = (!util_1.isNullOrUndefined(element["Tax_Rate"]) && element["Tax_Rate"].startsWith(".")) ? element["Tax_Rate"].slice(1) : element["Tax_Rate"];
                                element["Tax_Rate"] = (!util_1.isNullOrUndefined(element["Tax_Rate"]) && element["Tax_Rate"].endsWith(".")) ? element["Tax_Rate"].slice(0, -1) : element["Tax_Rate"];

                            }
                        }

                        //Line_Total_Amount using formulae
                        if (NumericalFields.includes('Line_Total_Amount')) { //&& (!util_1.isNullOrUndefined(element["Line_Total_Amount"]) && isNaN(parseFloat(element["Line_Total_Amount"])))) {

                            if (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && !util_1.isNullOrUndefined(element["Tax_Amount1"]) && !isNaN(parseFloat(element["Taxable_Amount"])) && !isNaN(parseFloat(element["Tax_Amount1"]))) {
                                element["Line_Total_Amount"] = parseFloat(element["Tax_Amount1"]) + parseFloat(element["Taxable_Amount"]);
                                element["Line_Total_Amount"] = parseFloat(parseFloat(element["Line_Total_Amount"]).toFixed(2));
                                element["Line_Total_Amount"] = !isNaN(element["Line_Total_Amount"]) ? element["Line_Total_Amount"] : '';
                                element["Line_Total_Amount"] = element["Line_Total_Amount"].toString().trim();
                                element["Line_Total_Amount"] = (!util_1.isNullOrUndefined(element["Line_Total_Amount"]) && element["Line_Total_Amount"].startsWith(".")) ? element["Line_Total_Amount"].slice(1) : element["Line_Total_Amount"];
                                element["Line_Total_Amount"] = (!util_1.isNullOrUndefined(element["Line_Total_Amount"]) && element["Line_Total_Amount"].endsWith(".")) ? element["Line_Total_Amount"].slice(0, -1) : element["Line_Total_Amount"];

                            }
                        }
                        if (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && element["Taxable_Amount"].length > 1 && util_1.isNullOrUndefined(element["Line_Total_Amount"]) && (element["Line_Total_Amount"].length < 1 || element["Line_Total_Amount"] == "")) {
                            element["Line_Total_Amount"] = element["Taxable_Amount"];
                        }
                        else if (util_1.isNullOrUndefined(element["Line_Total_Amount"]) || element["Line_Total_Amount"] == "") {
                            if (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && !isNaN(element["Taxable_Amount"])
                                && element["Tax_Amount1"] == "" && element["Tax_Rate"] == "" && element["Quantity"] == ""
                                && element["Unit_Price"] == "") {
                                element["Line_Total_Amount"] = element["Taxable_Amount"];
                                element["Quantity"] = 1;
                                element["Unit_Price"] = element["Taxable_Amount"];

                            } else {
                                element["Line_Total_Amount"] = 0;
                            }
                        }
                        // Item_description Extraction 
                        if (!util_1.isNullOrUndefined(element["Item_Description"])) {
                            element["Item_Description"] = element["Item_Description"].replace(/["']/g, '');
                        }

                        // Item_PO_Number Extraction 
                        if (util_1.isNullOrUndefined(element["Item_PO_Number"]) || (!/\d+/.test(element["Item_PO_Number"]))) {
                            let regex = /((PO NO|PO#|PO No\.|No\.|PO|Cust P\.O\.|Cust|P\.O\.|PO No|LPO#|LPO number #|LPO #|LPO #|LPO|Purchase Order|Order)(\s{0,}\d+|\d+))/;
                            if (!util_1.isNullOrUndefined(element["Item_Description"]) && regex.test(element["Item_Description"]) && element["Item_Description"].match(regex) && !util_1.isNullOrUndefined(element["Item_Description"].match(regex))) {
                                if (element["Item_Description"].match(regex).length >= 1) {
                                    console.log("regex---------", element["Item_Description"].match(regex)[0]);
                                    let PO = !util_1.isNullOrUndefined(element["Item_Description"].match(regex)[0]) ? element["Item_Description"].match(regex)[0] : element["Item_Description"];
                                    PO = PO.replace(/(PO NO|PO#|PO No\.|No\.|PO|Cust P\.O\.|Cust|P\.O\.|PO No|LPO#|LPO number #|LPO #|LPO #|LPO|Purchase Order|Order|s-)/g, '').trim()
                                    element['Item_PO_Number'] = !util_1.isNullOrUndefined(PO) && /^\d/.test(PO) && /\d$/.test(PO) ? PO : element['Item_PO_Number'];
                                }
                            }
                            else if (!util_1.isNullOrUndefined(invoiceObject['PO_Number']) && isNaN(parseFloat(element["Item_PO_Number"]))) {
                                element['Item_PO_Number'] = invoiceObject['PO_Number']
                            }
                        }

                        var len = (str) => {
                            let size = Buffer.from(str).length;
                            return size;
                        };
                        if (!util_1.isNullOrUndefined(element['Item_Description']) && element['Item_Description'] != "") {
                            console.log("item desciption length", len(element['Item_Description']));
                            if (len(element['Item_Description']) > 210) {
                                element['Item_Description'] = element['Item_Description'].substring(0, 210);
                            }
                        } else {
                            element['Item_Description'] = "ITEM";
                        }

                        if (!util_1.isNullOrUndefined(element["Tax_Amount1"]) && (element["Tax_Amount1"] !== "")) {//&& element["Taxable_Amount"].length > 1 && element["Line_Total_Amount"] !== "") {
                            element["TAXABLE_FLAG"] = "Y";
                        } else {
                            // element["Taxable_Amount"] = 0;
                            element["TAXABLE_FLAG"] = "N";
                        }
                        if (!util_1.isNullOrUndefined(element["Taxable_Amount"]) && (element["Taxable_Amount"] !== "")) {//&& element["Taxable_Amount"].length > 1 && element["Line_Total_Amount"] !== "") {

                        } else {
                            element["Taxable_Amount"] = 0;

                        }
                        if (!util_1.isNullOrUndefined(element["Line_Total_Amount"]) && (element["Line_Total_Amount"] !== "")) {//&& element["Taxable_Amount"].length > 1 && element["Line_Total_Amount"] !== "") {
                        } else {
                            element["Line_Total_Amount"] = 0;
                        }
                        for (key in element) {
                            console.log("outside Fetching Tax_RATE..", key, element)
                            if ((key == "Tax_Amount1") && (doctype !== "GE_Doctype")) {
                                element[key] = !util_1.isNullOrUndefined(element[key]) ? element[key].toString().replace(/[a-zA-Z\]\[\|\/\\\%,]/g, '').trim() : '';
                                element[key] = Number(element[key]);
                                if (!isNaN(parseFloat(element[key]))) {
                                    console.log("outside before Fetching Tax_RATE..", key, element)
                                    if (parseFloat(element[key]) > 0) {
                                        invoiceObject['Tax_code'] = 'VAT_TWZ_DR';
                                    }
                                    else if ((parseFloat(element[key]) == 0) && (!util_1.isNullOrUndefined(invoiceObject['Invoice_Title']) && invoiceObject['Invoice_Title'].includes('TAX')) && (!util_1.isNullOrUndefined(invoiceObject['Supplier_TRN']) && invoiceObject['Supplier_TRN'] !== '')) {
                                        invoiceObject['Tax_code'] = 'VAT_TEC_0';
                                    }
                                    else if ((parseFloat(element[key]) == 0) && (!util_1.isNullOrUndefined(invoiceObject['Invoice_Title']) && !invoiceObject['Invoice_Title'].includes('TAX')) && (!util_1.isNullOrUndefined(invoiceObject['Supplier_TRN']) && invoiceObject['Supplier_TRN'] == '')) {
                                        invoiceObject['Tax_code'] = 'VAT_OOS';
                                    }
                                }
                                console.log("outside after Fetching Tax_RATE..", element)
                            }
                        }
                        if (element) {
                            if (util_1.isNullOrUndefined(element["Quantity"]) || element["Quantity"] == "") {
                                if (element["Line_Total_Amount"] == 0) {
                                    element["Quantity"] = 1;
                                } else {
                                    element["Quantity"] = 0;
                                }
                            }
                            element['LINE_TYPE_LOOKUP_CODE'] = "ITEM";
                            element['DIST_CODE_COMBINATION_ID'] = "";
                            element['LINE_NUMBER'] = index + 1;
                            invoiceObject.invoiceItems[index] = element;
                        }
                        //   console.log("-------------",element,tableKeys);

                    }
                }

                let invoiceItems = JSON.parse(JSON.stringify(invoiceObject.invoiceItems))


                //Extracting Header Level PO_Number

                if (!util_1.isNullOrUndefined(invoiceObject['PO_Number']) && (!/^\d/.test(invoiceObject['PO_Number'])) && (!/\d$/.test(invoiceObject['PO_Number']))) {
                    for (let index = 0; index < invoiceItems.length; index++) {
                        if (!util_1.isNullOrUndefined(invoiceItems[index]['Item_PO_Number']) && (/^\d/.test(invoiceItems[index]['Item_PO_Number'])) && (/\d$/.test(invoiceItems[index]['Item_PO_Number']))) {
                            invoiceObject['PO_Number'] = invoiceObject['PO_Number'] != '' ? invoiceObject['PO_Number'] + ',' + invoiceItems[index]['Item_PO_Number'] : invoiceItems[index]['Item_PO_Number'];
                        }
                    }
                }
                // Calculating Total
                if (invoiceItems.length == 1) {
                    for (let index = 0; index < invoiceItems.length; index++) {
                        let element = JSON.parse(JSON.stringify(invoiceItems[index]));
                        if (!util_1.isNullOrUndefined(element['Line_Total_Amount']) && !isNaN(element['Line_Total_Amount'])
                            && !util_1.isNullOrUndefined(element['Taxable_Amount']) && !isNaN(element['Taxable_Amount']) &&
                            element['Line_Total_Amount'] == element['Taxable_Amount'] && element['Tax_Amount1'] == "" &&
                            element['Tax_Rate'] == "" && !util_1.isNullOrUndefined(invoiceObject['Tax_Amount']) && !isNaN(invoiceObject['Tax_Amount'])) {
                            element['Tax_Amount1'] = Number(invoiceObject['Tax_Amount']);
                            element['Tax_Rate'] = Math.round((Number(invoiceObject['Tax_Amount']) / Number(element['Line_Total_Amount'])) * 100);
                            invoiceItems[index]['Tax_Amount1'] = Number(invoiceObject['Tax_Amount']);
                            invoiceItems[index]['Tax_Rate'] = Math.round((Number(invoiceObject['Tax_Amount']) / Number(element['Line_Total_Amount'])) * 100);
                        }
                        console.log("before for loop in invoice items length", element)
                        for (var key in element) {  //iterating over inv items array
                            console.log("inside for loop in invoice items length", element)
                            if ((key == "Tax_Amount1") && (doctype !== "GE_Doctype")) {
                                element[key] = !util_1.isNullOrUndefined(element[key]) ? element[key].toString().replace(/[a-zA-Z\]\[\|\/\\\%,]/g, '').trim() : '';
                                element[key] = Number(element[key]);
                                if (!isNaN(parseFloat(element[key]))) {
                                    console.log("inside before Fetching Tax_RATE..", key, element)
                                    if (parseFloat(element[key]) > 0) {
                                        invoiceObject['Tax_code'] = 'VAT_TWZ_DR';
                                        element['Tax_code'] = 'VAT_TWZ_DR';
                                    }
                                    else if ((parseFloat(element[key]) == 0) && (!util_1.isNullOrUndefined(invoiceObject['Invoice_Title']) && invoiceObject['Invoice_Title'].includes('TAX')) && (!util_1.isNullOrUndefined(invoiceObject['Supplier_TRN']) && invoiceObject['Supplier_TRN'] !== '')) {
                                        invoiceObject['Tax_code'] = 'VAT_TEC_0';
                                        element['Tax_code'] = 'VAT_TEC_0';
                                    }
                                    else if ((parseFloat(element[key]) == 0) && (!util_1.isNullOrUndefined(invoiceObject['Invoice_Title']) && !invoiceObject['Invoice_Title'].includes('TAX')) && (!util_1.isNullOrUndefined(invoiceObject['Supplier_TRN']) && invoiceObject['Supplier_TRN'] == '')) {
                                        invoiceObject['Tax_code'] = 'VAT_OOS';
                                        element['Tax_code'] = 'VAT_OOS';
                                    }
                                }
                                console.log("inside after invoiceitems----------------", key, element);
                            }
                        }
                        invoiceItems[index] = element;
                    }
                    invoiceObject['invoiceItems'] = invoiceItems;
                }
                invoiceObject['Calculated_Invoice_Total'] = 0;
                invoiceObject['Calculated_Taxable_Total'] = 0;
                invoiceObject['Calculated_Tax_Total'] = 0;
                let InvoiceTotalAmount = false;
                let Taxable_Amount = false;
                let Tax_Amount = false;
                if (util_1.isNullOrUndefined(invoiceObject['InvoiceTotalAmount']) || (!util_1.isNullOrUndefined(invoiceObject['InvoiceTotalAmount']) && parseFloat(invoiceObject['InvoiceTotalAmount']) < 1) || (!util_1.isNullOrUndefined(invoiceObject['InvoiceTotalAmount']) && (isNaN(parseFloat(invoiceObject['InvoiceTotalAmount']))))) {
                    invoiceObject['InvoiceTotalAmount'] = 0;
                    InvoiceTotalAmount = true;
                }
                if (util_1.isNullOrUndefined(invoiceObject['Taxable_Amount']) || (!util_1.isNullOrUndefined(invoiceObject['Taxable_Amount']) && parseFloat(invoiceObject['Taxable_Amount']) < 1) || (!util_1.isNullOrUndefined(invoiceObject['Taxable_Amount']) && (isNaN(parseFloat(invoiceObject['Taxable_Amount']))))) {
                    invoiceObject['Taxable_Amount'] = 0;
                    Taxable_Amount = true;
                }
                if (util_1.isNullOrUndefined(invoiceObject['Tax_Amount']) || (!util_1.isNullOrUndefined(invoiceObject['Tax_Amount']) && parseFloat(invoiceObject['Tax_Amount']) < 0) || (!util_1.isNullOrUndefined(invoiceObject['Tax_Amount']) && (isNaN(parseFloat(invoiceObject['Tax_Amount']))))) {
                    invoiceObject['Tax_Amount'] = 0;
                    Tax_Amount = true;
                }

                // invoiceObject['Taxable_Amount'] = 0;
                // invoiceObject['Tax_Amount'] = 0;

                if (InvoiceTotalAmount) {
                    for (let index = 0; index < invoiceItems.length; index++) {
                        if (!util_1.isNullOrUndefined(invoiceItems[index]['Line_Total_Amount']) && (!isNaN(parseFloat(invoiceItems[index]['Line_Total_Amount'])))) {
                            invoiceObject['InvoiceTotalAmount'] = invoiceObject['InvoiceTotalAmount'] + parseFloat(invoiceItems[index]['Line_Total_Amount']);
                            invoiceObject["InvoiceTotalAmount"] = parseFloat(parseFloat(invoiceObject["InvoiceTotalAmount"]).toFixed(2));
                        }
                        else {
                            invoiceObject['InvoiceTotalAmount'] = '';
                            break;
                        }
                    }
                }

                if (Taxable_Amount) {
                    for (let index = 0; index < invoiceItems.length; index++) {
                        if (!util_1.isNullOrUndefined(invoiceItems[index]['Taxable_Amount']) && (!isNaN(parseFloat(invoiceItems[index]['Taxable_Amount'])))) {
                            invoiceObject['Taxable_Amount'] = invoiceObject['Taxable_Amount'] + parseFloat(invoiceItems[index]['Taxable_Amount']);
                            invoiceObject["Taxable_Amount"] = parseFloat(parseFloat(invoiceObject["Taxable_Amount"]).toFixed(2));
                        }
                        else {
                            invoiceObject['Taxable_Amount'] = '';
                            break
                        }
                    }
                }

                if (Tax_Amount) {
                    for (let index = 0; index < invoiceItems.length; index++) {
                        if (!util_1.isNullOrUndefined(invoiceItems[index]['Tax_Amount1']) && (!isNaN(parseFloat(invoiceObject['Tax_Amount']))) && (!isNaN(parseFloat(invoiceItems[index]['Tax_Amount1'])))) {
                            invoiceObject['Tax_Amount'] = parseFloat(invoiceObject['Tax_Amount']) + parseFloat(invoiceItems[index]['Tax_Amount1']);
                            invoiceObject["Tax_Amount"] = parseFloat(parseFloat(invoiceObject["Tax_Amount"]).toFixed(2));

                        }
                        else {
                            invoiceObject['Tax_Amount'] = '';
                            break
                        }
                    }
                }

                //Tax_Amount1 using formulae
                if ((!util_1.isNullOrUndefined(invoiceObject['Tax_Amount'])) && ((invoiceObject['Tax_Amount'] == '') || (invoiceObject['Tax_Amount'] == '0') || (invoiceObject['Tax_Amount'] == 0))) {// && (!util_1.isNullOrUndefined(element["Tax_Amount1"]) && isNaN(parseFloat(element["Tax_Amount1"])))) {

                    if (!util_1.isNullOrUndefined(invoiceObject["InvoiceTotalAmount"]) && !util_1.isNullOrUndefined(invoiceObject["Taxable_Amount"]) && !isNaN(parseFloat(invoiceObject["InvoiceTotalAmount"])) && !isNaN(parseFloat(invoiceObject["Taxable_Amount"]))) {
                        invoiceObject['Tax_Amount'] = parseFloat(invoiceObject["InvoiceTotalAmount"]) - parseFloat(invoiceObject["Taxable_Amount"]);
                        invoiceObject['Tax_Amount'] = !isNaN(invoiceObject["Tax_Amount"]) ? invoiceObject["Tax_Amount"] : '';
                    }
                    invoiceObject["Tax_Amount"] = !util_1.isNullOrUndefined(invoiceObject["Tax_Amount"]) ? invoiceObject["Tax_Amount"].toString().trim() : '';
                    invoiceObject["Tax_Amount"] = (!util_1.isNullOrUndefined(invoiceObject["Tax_Amount"]) && invoiceObject["Tax_Amount"].startsWith(".")) ? invoiceObject["Tax_Amount"].slice(1) : invoiceObject["Tax_Amount"];
                    invoiceObject["Tax_Amount"] = (!util_1.isNullOrUndefined(invoiceObject["Tax_Amount"]) && invoiceObject["Tax_Amount"].endsWith(".")) ? invoiceObject["Tax_Amount"].slice(0, -1) : invoiceObject["Tax_Amount"];

                }
                if (!util_1.isNullOrUndefined(invoiceItems) && !util_1.isNullOrUndefined(invoiceItems.length) && invoiceItems.length > 0) {
                    let items = invoiceItems.map(v => Object.assign(v, { "Tax_code": invoiceObject['Tax_code'] }));
                    invoiceObject["invoiceItems"] = JSON.parse(JSON.stringify(items));
                }
                // }

                // if ((!util_1.isNullOrUndefined(invoiceObject['Calculated_Tax_Total']) && invoiceObject['Calculated_Tax_Total'] > 0) || (!util_1.isNullOrUndefined(invoiceObject['Tax_Amount']) && parseFloat(invoiceObject['Tax_Amount']) > 0)) {
                //     invoiceObject['Tax_code'] = 'VAT_TWZ_DR';
                // }
                // else if ((!util_1.isNullOrUndefined(invoiceObject['Invoice_Title']) && invoiceObject['Invoice_Title'].includes('TAX')) || (!util_1.isNullOrUndefined(invoiceObject['Supplier_TRN']) && invoiceObject['Supplier_TRN'] == '')) {
                //     invoiceObject['Tax_code'] = 'VAT_TEC_0';
                // }
                // else {
                //     invoiceObject['Tax_code'] = 'VAT_OOS';
                // }
                if (!util_1.isNullOrUndefined(invoiceObject['InvoiceTotalAmount'])) {
                    invoiceObject['InvoiceTotalAmount'] = invoiceObject['InvoiceTotalAmount'].toString();

                }
                if (!util_1.isNullOrUndefined(invoiceObject['Taxable_Amount'])) {
                    invoiceObject['Taxable_Amount'] = invoiceObject['Taxable_Amount'].toString();

                }
                if (!util_1.isNullOrUndefined(invoiceObject['Tax_Amount'])) {
                    if ((invoiceObject['Tax_Amount'] > 0) && (invoiceObject['Tax_code'] !== 'VAT_TWZ_DR')) {
                        invoiceObject['Tax_code'] = 'VAT_TWZ_DR';
                        let invItems = JSON.parse(JSON.stringify(invoiceObject.invoiceItems));
                        let items = invItems.map(v => Object.assign(v, { "Tax_code": invoiceObject['Tax_code'] }));
                        invoiceObject["invoiceItems"] = JSON.parse(JSON.stringify(items));
                    }
                    invoiceObject['Tax_Amount'] = invoiceObject['Tax_Amount'].toString();

                }
                if (!util_1.isNullOrUndefined(invoiceObject['Invoice_Number'])) {
                    invoiceObject['Invoice_Number'] = invoiceObject['Invoice_Number'].toString();

                }
                if (!util_1.isNullOrUndefined(invoiceObject['Customer_TRN'])) {
                    invoiceObject['Customer_TRN'] = invoiceObject['Customer_TRN'].toString();

                }
                return invoiceObject;
            }
        }
        catch (err) {
            // console.log(err)
            return invoiceObject;

        }
    }


    spaceClear(sortedLines, docType, index) {
        try {
            let counter = 0;
            let configData = config[docType];
            // console.log(configData, "configData", index)
            let abc = [];
            let final = [];
            console.log("yeh", configData);
            for (let i = 0; i < sortedLines.length; i++) {
                for (let j = 0; j < sortedLines[i].length; j++) {
                    counter = 0;
                    for (let k = 0; k < configData.length; k++) {
                        if (sortedLines[i][j]["Name"].startsWith(configData[k])) {
                            counter++;
                            let jj = configData[k];
                            let kk = sortedLines[i][j]["Name"].split(jj)[1];

                            // let splitWord = sortedLines[i][j].Name.split(":");
                            let textLength = sortedLines[i][j].Name.length;
                            let pixelLength = (sortedLines[i][j].rightX - sortedLines[i][j].leftX) / textLength;
                            let firstWordLength = pixelLength * jj.length;
                            let secondWordLength = pixelLength * kk.length;
                            // console.log(firstWordLength);
                            // console.log(secondWordLength);
                            let firstWordFinal = {};
                            firstWordFinal.leftX = sortedLines[i][j].leftX;
                            firstWordFinal.topY = sortedLines[i][j].topY;
                            firstWordFinal.pageNo = index + 1;
                            // firstWordFinal.width = firstWordLength;
                            // firstWordFinal.height = sortedLines[i][j].height;
                            firstWordFinal.rightX = sortedLines[i][j].leftX + firstWordLength;
                            firstWordFinal.bottomY = sortedLines[i][j].bottomY;
                            firstWordFinal.confidence = sortedLines[i][j].confidence;
                            firstWordFinal.Name = jj;
                            firstWordFinal.property = 'undefined';
                            let secondWordFinal = {};
                            secondWordFinal.leftX = sortedLines[i][j].rightX - secondWordLength;
                            secondWordFinal.topY = sortedLines[i][j].topY;
                            secondWordFinal.pageNo = index + 1;
                            // secondWordFinal.width = secondWordLength;
                            // secondWordFinal.height = sortedLines[i][j].height;
                            secondWordFinal.rightX = sortedLines[i][j].rightX;
                            secondWordFinal.bottomY = sortedLines[i][j].bottomY;
                            secondWordFinal.confidence = sortedLines[i][j].confidence;
                            secondWordFinal.Name = kk;
                            secondWordFinal.property = 'undefined';
                            abc.push(firstWordFinal);
                            abc.push(secondWordFinal);

                        }
                        else if (sortedLines[i][j]["Name"].endsWith(configData[k])) {
                            counter++;
                            let jj = configData[k];
                            let kk = sortedLines[i][j]["Name"].split(jj)[0];

                            // let splitWord = sortedLines[i][j].Name.split(":");
                            let textLength = sortedLines[i][j].Name.length;
                            let pixelLength = (sortedLines[i][j].rightX - sortedLines[i][j].leftX) / textLength;
                            let firstWordLength = pixelLength * jj.length;
                            let secondWordLength = pixelLength * kk.length;
                            // console.log(firstWordLength);
                            // console.log(secondWordLength);
                            let firstWordFinal = {};
                            firstWordFinal.leftX = sortedLines[i][j].leftX;
                            firstWordFinal.topY = sortedLines[i][j].topY;
                            firstWordFinal.pageNo = index + 1;
                            // firstWordFinal.width = firstWordLength;
                            // firstWordFinal.height = sortedLines[i][j].height;
                            firstWordFinal.rightX = sortedLines[i][j].leftX + firstWordLength;
                            firstWordFinal.bottomY = sortedLines[i][j].bottomY;
                            firstWordFinal.confidence = sortedLines[i][j].confidence;
                            firstWordFinal.Name = kk;
                            firstWordFinal.property = 'undefined';
                            let secondWordFinal = {};
                            secondWordFinal.leftX = sortedLines[i][j].rightX - secondWordLength;
                            secondWordFinal.topY = sortedLines[i][j].topY;
                            secondWordFinal.pageNo = index + 1;
                            // secondWordFinal.width = secondWordLength;
                            // secondWordFinal.height = sortedLines[i][j].height;
                            secondWordFinal.rightX = sortedLines[i][j].rightX;
                            secondWordFinal.bottomY = sortedLines[i][j].bottomY;
                            secondWordFinal.confidence = sortedLines[i][j].confidence;
                            secondWordFinal.Name = jj;
                            secondWordFinal.property = 'undefined';
                            abc.push(firstWordFinal);
                            abc.push(secondWordFinal);


                        }
                        // else {
                        //     abc.push(sortedLines[i][j])
                        // }
                    }
                    if (counter == 0) {
                        abc.push(sortedLines[i][j])
                    }
                }
                final.push(abc);
                abc = []
            }
            return final
        }
        catch (e) {
            logger.error('#combineLineWords space clear==>', e);
        }
    }



    createTokenFor(userId, subscriberId, orgId) {
        return __awaiter(this, void 0, void 0, function* () {
            userId = userId.toString()
            subscriberId = subscriberId.toString()
            orgId = orgId.toString()
            let token = jwt.encode({
                "permission": [],
                "userId": userId,
                "userType": '',
                // "allPermissions":permissions,
                "subscriberId": subscriberId,
                "userName": '',
                "role": '',
                "type": '',
                "accessKeyId": '',
                "secretAccessKey": '',
                "endpoint": '',
                "signatureVersion": '',
                "region": '',
                "Bucket": '',
                "ACL": '',
                // nbf: (Date.now() / 1000),
                exp: ((Date.now() / 1000) + 5400000)
            }, JWT_SECRET);
            return token
        });
    }
    runTrainingForInvoice(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                req.body.input.return ? '' : res.send({ status: 0 });
                logger.info('----------INSIDE FOR RUN TRAINING FOR INVOICE---------');
                let self = this;
                let fileDataArrayNew = [];
                let fieldDetectionNew = [];

                let token = req.body.token;
                let options = {};
                let botId = req.body.botId;
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;
                let orgId = req.body.input.orgId;
                console.log("Before FileDataArray")

                let fileDataArray = req.body.input.ruleObj;
                if (!util_1.isNullOrUndefined(fileDataArray)) {
                    let doctype;
                    // const MongoClient = require('mongodb').MongoClient;
                    // let mClient = yield MongoClient.connect(config.mongoConnection);
                    // let dbName = config.mongoConnection.split('/');
                    // let db = yield mClient.db(dbName[dbName.length - 1]);
                    if (!util_1.isNullOrUndefined(fileDataArray[0].ModelDocType)) {
                        doctype = fileDataArray[0].ModelDocType;
                        console.log("doctype-=====", doctype);
                    } else {
                        doctype = fileDataArray[0].obj.documentType;
                        console.log("doctypeExist-=====", doctype);
                    }
                    let modeldatas = yield (db.collection('modeldatas')).findOne({ documentType: doctype });
                    let datarule = yield scanField.findOne({ isDeleted: false, documentType: doctype });
                    if (!util_1.isNullOrUndefined(datarule) && typeof datarule == 'object') {
                        datarule = JSON.parse(JSON.stringify(datarule));
                    }
                    let emmptyTableCount = 0;
                    let tableDetected = true;
                    for (let index = 0; index < fileDataArray.length; index++) { // For Each PNG Image
                        let fileData = fileDataArray[index];
                        if (!util_1.isNullOrUndefined(fileData['newTable']) && fileData['newTable'].length == 0) {
                            emmptyTableCount = emmptyTableCount + 1;
                        }
                        if (index == fileDataArray.length - 1 && emmptyTableCount == fileDataArray.length) {
                            tableDetected = false;
                        }
                    }
                    for (let index = 0; index < fileDataArray.length; index++) { // For Each PNG Image
                        console.info("RUNNING FOR --------------- ---INSIDE FOR LOOP-------- ---------->>>>> >>>> >>>>    ", index);
                        let fileData = fileDataArray[index];
                        let invObj = {};
                        let fileRefNum = fileData.obj.fileRefNum;
                        let filePathimg = fileData.obj.filePath;
                        let filepath2 = filePathimg.replace(/.png|.jpg/, '');
                        let invFileName = filepath2 + "_" + 'invoice' + ".csv";
                        let predictionObj = [];
                        let tempInvoice = {};
                        let newUrl;
                        if (doctype == 'Passbook') {
                            newUrl = config.cudaprod + 'gibots-pyapi/fieldDetectionBajaj';
                        }
                        else if (doctype == 'D_Certifcate') {
                            newUrl = config.cudaprod + 'gibots-pyapi/fieldDetectionBajajDC';
                        }
                        else if (doctype == 'Cheque') {
                            newUrl = config.cudaprod + 'gibots-pyapi/omega';
                        }
                        else {
                            newUrl = config.cudaprod + 'gibots-pyapi/fieldDetectionTawazun';
                        }
                        if (!util_1.isNullOrUndefined(modeldatas)) {
                            let gstin = yield (db.collection('organisations')).findOne({ _id: ObjectId(orgId) }).lean();
                            gstin = JSON.parse(JSON.stringify(gstin));
                            gstin = gstin['gstin'];
                            options = {
                                method: 'POST',
                                url: newUrl,
                                body: {
                                    "filePath": invFileName,
                                    "orgId": orgId,
                                    "gstin": gstin,
                                    "documentType": doctype,
                                    "modelType": "formModel",
                                    "pageNo": index
                                },
                                json: true
                            };

                            console.warn(" -- -- CALLING PYTHON API -- -- ", options);

                            let pythonCall = yield self.requestApi(options);
                            if (!util_1.isNullOrUndefined(pythonCall) && !util_1.isNullOrUndefined(pythonCall.status) && pythonCall.status == 0) {
                                console.info(" -- -- CALLING PYTHON API SUCCESS  --- ---- ");

                                let op = yield self.jsonToCsv(pythonCall["output"]["result"]);
                                console.log("AFTER JSON TO CSV");
                                let invoiceData = op.output;

                                fieldDetectionNew.push(op.output)

                                let validInvData = [];

                                for (let i = 0; i < invoiceData.length; i++) {
                                    if (invoiceData[i].Property != 'undefined') {
                                        validInvData.push(JSON.parse(JSON.stringify(invoiceData[i])));
                                    }
                                    invoiceData[i]['property'] = invoiceData[i].Property ? invoiceData[i].Property : 'undefined';
                                }

                                yield (db.collection('documenttrainings')).findOneAndUpdate({ fileRefNum: fileRefNum, filePath: filePathimg }, { $set: { documentCsvData: invoiceData } }, { upsert: true });

                                const data = validInvData.filter(function (list) {
                                    const name = list.Name.replace("~", ",");
                                    list.Name = name;
                                    return list;
                                });

                                invObj = yield self.createFunInvoiceObj(data);//INVOICE OBJ FOR TABLE AND PREDICTION OBJECT
                                console.log("AFTER CREATE FUN INVOICEOBJ", JSON.stringify(invObj));
                                for (let i = 0; i < datarule.fields.length; i++) {
                                    if (util_1.isNullOrUndefined(invObj[datarule.fields[i].fieldName])) {
                                        invObj[datarule.fields[i].fieldName] = "";
                                    }
                                }

                                let ruleID = datarule["ruleId"];

                                tempInvoice = JSON.parse(JSON.stringify(invObj));
                                predictionObj = JSON.parse(JSON.stringify(tempInvoice["prediction"]));
                                if ((!util_1.isNullOrUndefined(ruleID) && ruleID !== "") || doctype == "GE_Doctype") {
                                    let rulesSetValue = JSON.parse(JSON.stringify(tempInvoice));
                                    delete rulesSetValue["prediction"];
                                    rulesSetValue['invoiceItems'] = fileData['newTable'];
                                    let token = yield self.createTokenFor(req.body.input.userId, req.body.input.subscriberId, req.body.input.orgId);

                                    console.info(" --- -----    ------ ruleId  ---- ------- ----- ", ruleID);

                                    let headers = {
                                        "Authorization": "Bearer " + token,
                                        "Content-Type": "application/json",
                                        "selectedorgid": orgId,
                                    };
                                    rulesSetValue['referenceNumber'] = fileData.obj.fileRefNum;
                                    //rulesSetValue['referenceNumber'] = JSONtringify(fileData.obj.fileRefNum);
                                    rulesSetValue['invoiceItems'] = [];
                                    let beforeRuleObj = yield (db.collection(doctype + "_beforeRule")).create(rulesSetValue);
                                    yield db.collection(doctype + "_beforeRule").findOneAndUpdate({ "referenceNumber": rulesSetValue['referenceNumber'] }, { "$set": { "invoiceItems": fileData['newTable'] } });
                                    console.log("BEFORE RULE ---- ENGINE --- OBJ --- >> >>  ", JSON.stringify(rulesSetValue));

                                    rulesSetValue['invoiceItems'] = fileData['newTable'];
                                    rulesSetValue = yield self.accuracyrules(rulesSetValue, doctype);
                                    fileData['newTable'] = rulesSetValue['invoiceItems'];

                                    rulesSetValue['invoiceItems'] = [];
                                    let beforeRuleObjAcc = yield (db.collection(doctype + "_accuracyRule")).create(rulesSetValue);
                                    if (!tableDetected && rulesSetValue['PO_Number'] == "" && rulesSetValue.InvoiceTotalAmount != "" && rulesSetValue.Tax_Amount != "") {
                                        let obj = {
                                            Item_Description: "Item",
                                            Quantity: "1",
                                            Taxable_Amount: parseFloat(rulesSetValue.InvoiceTotalAmount) - parseFloat(rulesSetValue.Tax_Amount),
                                            Tax_Amount1: parseFloat(rulesSetValue.Tax_Amount),
                                            Tax_Rate: rulesSetValue.Tax_code,
                                            Line_Total_Amount: parseFloat(rulesSetValue.InvoiceTotalAmount),
                                            LINE_TYPE_LOOKUP_CODE: "ITEM"
                                        }
                                        rulesSetValue["invoiceItems"].push(obj);
                                        fileData['newTable'] = rulesSetValue.invoiceItems;
                                        yield (db.collection(doctype + "_accuracyRule")).findOneAndUpdate({ "referenceNumber": rulesSetValue['referenceNumber'] }, { "$set": { "invoiceItems": rulesSetValue["invoiceItems"] } });

                                    } else {
                                        yield (db.collection(doctype + "_accuracyRule")).findOneAndUpdate({ "referenceNumber": rulesSetValue['referenceNumber'] }, { "$set": { "invoiceItems": fileData['newTable'] } });
                                    }

                                    console.log("ACCURACY RULE ----  ENGINE --- OBJ --- >> >>  ", JSON.stringify(rulesSetValue));
                                    // rulesSetValue['invoiceItems'] = fileData['newTable'];
                                    //delete rulesSetValue['referenceNumber'];

                                    rulesSetValue['orgId'] = orgId
                                    //delete rulesSetValue['invoiceItems'];
                                    options = {
                                        method: 'POST',
                                        url: config.pdfServerUrl + 'gibots-api/rule/EvaluateRuleSet',
                                        headers: headers,
                                        body: {
                                            rulesSetValue: rulesSetValue,
                                            id: ruleID
                                        },
                                        json: true
                                    };

                                    console.warn(" <<< << ------- ---------- ------- CALLING RULE ENGINE API ------- ---------- ------- >>> ");
                                    if (doctype !== "GE_Doctype") {


                                        let ruleBody = yield self.requestApi(options);
                                        if (!util_1.isNullOrUndefined(ruleBody) && !util_1.isNullOrUndefined(ruleBody.status) && ruleBody.status == 0) {

                                            console.info(" <<< << ------- ---------- ------- CALLING RULE ENGINE API SUCCESS ------- ---------- ------- >>> ");

                                            if (!util_1.isNullOrUndefined(ruleBody['output']) && !util_1.isNullOrUndefined(ruleBody['output']['data']) && Object.keys(ruleBody['output']['data']).length == 0) {
                                                console.log("<<<<<----------------      ruleBody['output']['data']).length == 0  --------- >>>>>>>> ");
                                                fileData['invoiceObject'] = rulesSetValue;
                                                fileData['newTable'] = fileData['newTable'];
                                                fileData['invoiceObject']['prediction'] = predictionObj;
                                            } else {
                                                if (!util_1.isNullOrUndefined(ruleBody['output']) && (typeof ruleBody['output'] == 'string' || util_1.isNullOrUndefined(ruleBody['output']['data']))) {
                                                    fileData['invoiceObject'] = rulesSetValue;
                                                    fileData['newTable'] = fileData['newTable'];
                                                    fileData['invoiceObject']['prediction'] = predictionObj;
                                                } else {
                                                    console.info(" <<< <<< ---- ----- RULE OBJECT ---- >>>> >>>>> ", ruleBody);
                                                    fileData['invoiceObject'] = ruleBody["output"]["data"];
                                                    fileData['invoiceObject']['prediction'] = predictionObj;
                                                    fileData['newTable'] = fileData['newTable'];
                                                    console.log("PREDICTION COUNT --- ---- ----- ----- ---- > >> >> > > > >   ", predictionObj.length);
                                                }
                                            }

                                            rulesSetValue['referenceNumber'] = fileData.obj.fileRefNum;
                                            invObj['RuleApplied'] = 'YES';

                                            //fileData['invoiceObject']['invoiceItems'] = [];

                                            let afterRuleObj = yield (db.collection(doctype + "_afterRule")).findOneAndUpdate({ "referenceNumber": rulesSetValue['referenceNumber'] }, { "$set": { "invoiceItems": fileData['invoiceObject'] } })

                                            yield (db.collection(doctype + "_afterRule")).findOneAndUpdate({ "referenceNumber": rulesSetValue['referenceNumber'] }, { "$set": { "invoiceItems": fileData['newTable'] } }, { upsert: true });
                                            //fileData['invoiceObject']['invoiceItems'] = fileData['newTable']
                                        }
                                    } else {
                                        fileData['invoiceObject'] = rulesSetValue;
                                        fileData['newTable'] = rulesSetValue["invoiceItems"];
                                        fileData['invoiceObject']['prediction'] = predictionObj;
                                        invObj['RuleApplied'] = 'YES';

                                        //fileData['invoiceObject']['invoiceItems'] = [];

                                        let afterRuleObj = yield db.collection(doctype + "_afterRule").insertOne(fileData['invoiceObject']);

                                        yield (db.collection(doctype + "_afterRule")).findOneAndUpdate({ "referenceNumber": fileData['invoiceObject']['referenceNumber'] }, { "$set": { "invoiceItems": fileData['newTable'] } });

                                        //fileData['invoiceObject']['invoiceItems'] = fileData['newTable'];
                                    }
                                } else {
                                    fileData['invoiceObject'] = JSON.parse(JSON.stringify(invObj));
                                }
                                yield (db.collection(doctype + "_Pages")).findOneAndUpdate({ "referenceNumber": fileRefNum, filePath: filePathimg }, { "$set": fileData['invoiceObject'] }, { upsert: true });

                                console.log("AFTER RULE -------- ENGINE ----- OBJ ----- >>>> >>>>> >> ", JSON.stringify(fileData['invoiceObject']))

                                fileDataArrayNew.push(fileData);
                            } else {
                                logger.error("<<< <<<<< <<<<<<<        <<<<<< ------------------- PKL FILE COULD NOT GENERATE FROM PYTHON JOB ---------  ---------- > > > >> >> >>> >>>  ");
                                invObj['referenceNumber'] = fileRefNum;
                                invObj['documentType'] = fileData.obj.documentType;
                                logger.info('Object generated without pkl file - ' + JSON.stringify(invObj));
                                fileData['invoiceObject'] = invObj;
                                fileDataArrayNew.push(fileData);


                                let outputData = { "runTrainingForInvoice": fileDataArray, "uploadStatus": true, 'statusCode': '200' };
                                let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                                let headers = { 'Authorization': token, 'content-type': "application/json" };
                                options = {
                                    method: 'POST',
                                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                                    headers: headers,
                                    body: taskData,
                                    json: true
                                };
                                console.warn(" <<< << ------- ---------- ------- CALLING BOT OUTPUT WRITE API IN NEGATION------- ---------- ------- >>> ");
                                // let negFlow = yield self.requestApi(options);
                                ///////////////////////////////////////////////////////
                                // let self=this;
                                yield self.ioWrite(options);


                                ///////////////////////////////////////////////////////
                                console.warn("OUTPUT WRITE ---- STATUS  ----- ---- >> ", negFlow['status'], "      ---------- NEGFLOW OUTPUT WRITE OUTPUT ---------  ", negFlow['output']);
                            }

                        }

                    }

                    console.info("RUNNING FOR --------------- ---AFTER FOR LOOP-------- ---------->>>>> >>>> >>>>    ");

                    let outputData = { "runTrainingForInvoice": fileDataArrayNew, "fieldDetectionData": fieldDetectionNew, "uploadStatus": true, 'statusCode': '200' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // let outputWrite = yield self.requestApi(options);
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    if (req.body.input.return)
                        return outputData;
                    else
                        yield self.ioWrite(options)


                    ///////////////////////////////////////////////////////
                    console.info("OUTPUT WRITE ---- STATUS  ----- ---- >> ", "      ----------  OUTPUT WRITE OUTPUT ---------  ");
                }
                else {
                    logger.error(" 1--- ---- ----- >>>> >>>> runTrainInvOobj ====> Internal server Error >>> --- >>> --- >> >>> ");
                    let outputData = { "runTrainingForInvoice": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = " 2--- ---- ----- >>>> >>>> runTrainInvOobj ====> Internal server Error >>> --- >>> --- >> >>> ";
                    options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    console.warn(" <<< << ------- ---------- ------- CALLING BOT OUTPUT WRITE API IN ERRORFILE------- ---------- ------- >>> ");
                    // let errorFile = yield self.requestApi(options);
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    yield self.ioWrite(options);


                    ///////////////////////////////////////////////////////
                    console.error("OUTPUT WRITE ---- STATUS  ----- ---- >> ", "      ----------  OUTPUT WRITE OUTPUT ---------  ")
                }
            }
            catch (err) {
                logger.error('In runRScript- ' + err);
                logger.info('Object generated for error invoice - inside catch');
                let outputData = { "runTrainingForInvoice": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = err.toString();
                let options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                // let errorFile = yield self.requestApi(options);
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
                console.error("OUTPUT WRITE ---- STATUS  ----- ---- >> ", "      ----------  OUTPUT WRITE OUTPUT ---------  ")
            }
        });
    }
    runTrainingForInvoiceNew(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                req.body.input.return ? '' : res.send({ status: 0 });
                logger.info('----------INSIDE FOR RUN TRAINING FOR INVOICE---------');
                let self = this;
                let fileDataArrayNew = [];
                let fieldDetectionNew = [];

                let token = req.body.token;
                let options = {};
                let botId = req.body.botId;
                let subscriberId = req.body.input.subscriberId;
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;
                let orgId = req.body.input.orgId, invObj;
                let templateId = "";
                let isTmp = "";
                console.log("Before FileDataArray")

                let fileDataArray = req.body.input.ruleObj;
                let fileRefNum = req.body.input.fileRefNum;
                if (!util_1.isNullOrUndefined(fileDataArray) && Array.isArray(fileDataArray) && fileDataArray.length > 0) {
                    let doctype;
                    if (!util_1.isNullOrUndefined(fileDataArray[0].ModelDocType)) {
                        doctype = fileDataArray[0].ModelDocType;
                        console.log("doctype-=====", doctype);
                    } else {
                        doctype = fileDataArray[0].obj.documentType;
                        console.log("doctypeExist-=====", doctype);
                    }
                    let modeldatas = yield (db.createDynamicModel('modeldatas')).findOne({ documentType: doctype });
                    let datarule = yield scanField.findOne({ isDeleted: false, documentType: doctype });
                    if (!util_1.isNullOrUndefined(datarule) && typeof datarule == 'object') {
                        datarule = JSON.parse(JSON.stringify(datarule));
                    }


                    let newUrl, imagePathArr;
                    if (doctype == 'Cheque') {
                        newUrl = config.cudaprod + 'gibots-pyapi/omega';

                        imagePathArr = req.body.input.chequeImages ? req.body.input.chequeImages : [];
                    }
                    else {
                        newUrl = config.cudaprod + 'gibots-pyapi/fieldDetectionTawazun';

                        let fileD = yield (db.createDynamicModel('fileuploadhistories')).findOne({ fileRefNum: fileRefNum }).lean();

                        imagePathArr = fileD && fileD['imagesPath'] ? fileD['imagesPath'] : [];
                    }

                    let csvPathArray = [];
                    let invFileName;
                    for (let index = 0; index < fileDataArray.length; index++) { // For Each PNG Image
                        let fileData = fileDataArray[index];
                        // orgId = fileData.obj.orgId;
                        let filePathimg = fileData.obj.filePath;
                        let filepath2 = filePathimg.replace(/.png|.jpg/, '');
                        let invFileName = filepath2 + "_" + 'invoice' + ".csv";
                        csvPathArray.push(invFileName)
                    }

                    if (csvPathArray.length > 1) {
                        let data = yield Promise.all(csvPathArray.map(a => self.jsonToCsv(a)))
                        data = data.filter(a => a.status == 0)
                        let concatFeatures = [];
                        data.forEach(a => {
                            concatFeatures = concatFeatures.concat(a['output'])
                        })
                        let mergedFilePath = csvPathArray[0].replace(/(.csv)$/, '');
                        let headers = config.tableHeaderScanning;
                        let mergeD = yield self.csvGenerate(concatFeatures, headers, fileRefNum, 'Merged', mergedFilePath);
                        invFileName = mergeD;
                    }
                    else if (csvPathArray.length == 1) {
                        invFileName = csvPathArray[0];
                    }
                    if (!util_1.isNullOrUndefined(modeldatas)) {
                        let gstin;
                        if (!util_1.isNullOrUndefined(req.body.input.oId) && !util_1.isNullOrUndefined(req.body.input.sId)) {
                            try {
                                gstin = yield db.collection('organisations').findOne({ _id: ObjectId(req.body.input.oId) }).lean();
                                orgId = req.body.input.oId;
                                subscriberId = req.body.input.sId;
                                console.log("Adding orgId from the Input....")
                            }
                            catch (e) {
                                gstin = yield db.collection('organisations').findOne({ _id: ObjectId(orgId) }).lean();
                            }
                        }
                        else {
                            gstin = yield db.collection('organisations').findOne({ _id: ObjectId(orgId) }).lean();
                        }
                        gstin = JSON.parse(JSON.stringify(gstin));
                        gstin = gstin ? gstin['gstin'] : '';
                        options = {
                            method: 'POST',
                            url: newUrl,
                            body: {
                                "filePath": invFileName,
                                "imagesPath": imagePathArr,
                                "orgId": orgId,
                                "gstin": gstin,
                                "subscriberId": subscriberId,
                                "documentType": doctype,
                                "modelType": "formModel",
                            },
                            json: true
                        };

                        console.warn(" -- -- CALLING PYTHON API -- -- ", options);

                        let pythonCall = yield self.requestApi(options);

                        if (orgId !== req.body.input.oId) {
                            orgId = req.body.input.orgId;
                            subscriberId = req.body.input.subscriberId;
                        }
                        console.info(" -- -- RESSSS  --- ---- ", JSON.stringify(pythonCall));
                        if (!util_1.isNullOrUndefined(pythonCall) && !util_1.isNullOrUndefined(pythonCall.status) && pythonCall["output"]["result"] && pythonCall.status == 0) {
                            console.info(" -- -- CALLING PYTHON API SUCCESS  --- ---- ", JSON.stringify(pythonCall));
                            let p0Prediction = !util_1.isNullOrUndefined(pythonCall["output"]["p0Prediction"]) ? pythonCall["output"]["p0Prediction"] : {};
                            let op = yield self.jsonToCsv(pythonCall["output"]["result"]);
                            templateId = pythonCall["output"]["templateId"];
                            isTmp = pythonCall["output"]["isTmp"];
                            console.log("AFTER JSON TO CSV");
                            let invoiceDataMerge = op.output;

                            let validInvData = [];

                            for (let i = 0; i < invoiceDataMerge.length; i++) {
                                if (invoiceDataMerge[i].Property != 'undefined' && invoiceDataMerge[i].Property !== "") {
                                    validInvData.push(JSON.parse(JSON.stringify(invoiceDataMerge[i])));
                                }
                                invoiceDataMerge[i]['property'] = invoiceDataMerge[i].Property ? invoiceDataMerge[i].Property : 'undefined';
                            }

                            const data = validInvData.filter(function (list) {
                                const name = list.Name.replace("~", ",");
                                list.Name = name;
                                return list;
                            });


                            let propertyWiseData;

                            try {
                                propertyWiseData = data.reduce(function (r, a) {
                                    r[a.Property] = r[a.Property] || [];
                                    r[a.Property].push(a);
                                    return r;
                                }, Object.create(null))
                            }
                            catch (e) {
                                propertyWiseData = {};
                            }

                            let D = yield self.createFunInvoiceObjNew(propertyWiseData, datarule.fields);
                            let propertyWiseDataM = D['propertyWiseDataM'];
                            invObj = D['obj'];

                            let extraPredictedIndices;
                            try {
                                extraPredictedIndices = propertyWiseDataM.map(a => a.mP).reduce((pre, cur) => pre.concat(cur)).map(a => ({ i: a.i, pN: a.pN }))
                            }
                            catch (e) {
                                extraPredictedIndices = []
                            }


                            console.log("AFTER CREATE FUN INVOICEOBJ NEW ", JSON.stringify(invObj));
                            invObj['oPred'] = [];

                            for (let i = 0; i < datarule.fields.length; i++) {
                                if (util_1.isNullOrUndefined(invObj[datarule.fields[i].fieldName]) && invObj[datarule.fields[i].fieldName] != '') {
                                    invObj[datarule.fields[i].fieldName] = "";
                                }
                                if (!util_1.isNullOrUndefined(p0Prediction[datarule.fields[i].fieldName])) {
                                    let obj = {};
                                    obj[datarule.fields[i].fieldName] = invObj[datarule.fields[i].fieldName];
                                    invObj['oPred'].push(JSON.parse(JSON.stringify(obj)));
                                    invObj[datarule.fields[i].fieldName] = p0Prediction[datarule.fields[i].fieldName];
                                }
                                //this is for the priority prediction to overwrite the prediction of model

                            }
                            // for templateDriven prediciton flag 
                            invObj["isTmp"] = !util_1.isNullOrUndefined(pythonCall["output"]["isTmp"]) ? pythonCall["output"]["isTmp"] : false;
                            invObj["templateId"] = !util_1.isNullOrUndefined(pythonCall["output"]["templateId"]) ? pythonCall["output"]["templateId"] : "";


                            let ruleID = datarule["ruleId"];
                            let tempInvoice = JSON.parse(JSON.stringify(invObj));
                            let predictionObj = JSON.parse(JSON.stringify(tempInvoice["prediction"]));

                            let rulesSetValue = JSON.parse(JSON.stringify(tempInvoice));

                            let token = yield self.createTokenFor(req.body.input.userId, req.body.input.subscriberId, req.body.input.orgId);

                            console.info(" --- -----    ------ ruleId  ---- ------- ----- ", ruleID);

                            let headers = {
                                "Authorization": "Bearer " + token,
                                "Content-Type": "application/json",
                                "selectedorgid": orgId,
                            };
                            rulesSetValue['referenceNumber'] = fileRefNum;
                            //rulesSetValue['invoiceItems'] = [];
                            rulesSetValue['pD'] = propertyWiseDataM;
                            delete rulesSetValue['S.No.'];
                            yield (db.createDynamicModel(doctype + "_cons_before")).findOneAndUpdate({ "referenceNumber": rulesSetValue['referenceNumber'] }, { "$set": rulesSetValue }, { upsert: true });
                            console.log("BEFORE RULE ---- ENGINE --- OBJ --- >> >>  ");
                            delete rulesSetValue['pD'];
                            delete rulesSetValue["prediction"];
                            rulesSetValue['orgId'] = orgId
                            //delete rulesSetValue['invoiceItems'];
                            let tOPred = JSON.parse(JSON.stringify(rulesSetValue['oPred']));
                            delete rulesSetValue['oPred'];

                            // options = {
                            //     method: 'POST',
                            //     url: config.pdfServerUrl + 'gibots-api/rule/EvaluateRuleSet',
                            //     headers: headers,
                            //     body: {
                            //         rulesSetValue: rulesSetValue,
                            //         id: ruleID
                            //     },
                            //     json: true
                            // };

                            // console.warn(" <<< << ------- ---------- ------- CALLING RULE ENGINE API ------- ---------- ------- >>> ");                               
                            // let ruleBody = yield self.requestApi(options);
                            // if (!util_1.isNullOrUndefined(ruleBody['output']) && !util_1.isNullOrUndefined(ruleBody['output']['data']) && Object.keys(ruleBody['output']['data']).length == 0)
                            // {
                            //     console.log("<<<<<----------------      ruleBody['output']['data']).length == 0  --------- >>>>>>>> ");
                            //     invObj = rulesSetValue;
                            // }
                            // else {
                            //     if (!util_1.isNullOrUndefined(ruleBody['output']) && (typeof ruleBody['output'] == 'string' || util_1.isNullOrUndefined(ruleBody['output']['data']))) {
                            //         invObj = rulesSetValue;
                            //     } else {
                            //         console.info(" <<< <<< ---- ----- RULE OBJECT ---- >>>> >>>>> ", ruleBody);
                            //         invObj = ruleBody["output"]["data"];
                            //         console.log("PREDICTION COUNT --- ---- ----- ----- ---- > >> >> > > > >   ", predictionObj.length);
                            //     }
                            // }
                            invObj = rulesSetValue;
                            invObj['prediction'] = predictionObj;
                            invObj['oPred'] = tOPred;

                            //yield (db.createDynamicModel(doctype + "_afterRule")).findOneAndUpdate({ "referenceNumber": rulesSetValue['referenceNumber'] }, { "$set": invObj  },{upsert : true});

                            for (let index = 0; index < fileDataArray.length; index++) { // For Each PNG Image
                                console.info("RUNNING FOR --------------- ---INSIDE FOR LOOP-------- ---------->>>>> >>>> >>>>    ", index);
                                let fileData = fileDataArray[index];
                                let filePathimg = fileData.obj.filePath;
                                let filepath2 = filePathimg.replace(/.png|.jpg/, '');
                                let invFileName = filepath2 + "_" + 'invoice' + ".csv";

                                let invoiceData = invoiceDataMerge.filter(a => a['pageNo'] == index || a['pageNo'] == String(index))

                                let removeIndices = extraPredictedIndices.filter(a => a.pN == index || a.pN == String(index)).map(a => a.i)

                                console.log("Total--->", removeIndices, invoiceData.filter(a => a.Property == 'undefined').length)

                                yield (db.createDynamicModel('raw_documenttrainings')).findOneAndUpdate({ fileRefNum: fileRefNum, filePath: filePathimg }, { $set: { documentCsvData: invoiceData } }, { upsert: true }).exec();

                                for (let i = 0; i < invoiceData.length; i++) {
                                    if (removeIndices.includes(invoiceData[i].index)) {
                                        invoiceData[i].property = 'undefined';
                                        invoiceData[i].Property = 'undefined';
                                    }
                                }
                                console.log("Total--->", invoiceData.filter(a => a.Property == 'undefined').length);

                                fieldDetectionNew.push(JSON.parse(JSON.stringify(invoiceData)));

                                yield (db.createDynamicModel('documenttrainings')).findOneAndUpdate({ fileRefNum: fileRefNum, filePath: filePathimg }, { $set: { documentCsvData: invoiceData } }, { upsert: true }).exec();
                                fileData['invoiceObject'] = JSON.parse(JSON.stringify(invObj));

                                fileDataArrayNew.push(fileData);
                            }
                            console.info("RUNNING FOR --------------- ---AFTER FOR LOOP-------- ---------->>>>> >>>> >>>>    ");

                            let outputData = { "templateId": templateId, "ruleId": ruleID, "isTmp": isTmp, "runTrainingForInvoice": fileDataArrayNew, "fieldDetectionData": fieldDetectionNew, "uploadStatus": true, 'statusCode': '200' };
                            let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                            headers = { 'Authorization': token, 'content-type': "application/json" };
                            options = {
                                method: 'POST',
                                url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                                headers: headers,
                                body: taskData,
                                json: true
                            };
                            process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                            // let outputWrite = yield self.requestApi(options);
                            ///////////////////////////////////////////////////////
                            // let self=this;
                            if (req.body.input.return)
                                return outputData;
                            else
                                yield self.ioWrite(options)
                        }
                        else {
                            logger.error(" 3--- ---- ----- >>>> >>>> runTrainInvOobj ====> Internal server Error >>> --- >>> --- >> >>> ");
                            let outputData = { "runTrainingForInvoice": pythonCall, "uploadStatus": true, 'statusCode': '202' };
                            let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                            let headers = { 'Authorization': token, 'content-type': "application/json" };
                            taskData['exception'] = "from prediction api 4--- ---- ----- >>>> >>>> runTrainInvOobj ====> Internal server Error >>> --- >>> --- >> >>> ";
                            options = {
                                method: 'POST',
                                url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                                headers: headers,
                                body: taskData,
                                json: true
                            };
                            console.warn(" <<< << ------- ---------- ------- CALLING BOT OUTPUT WRITE API IN ERRORFILE------- ---------- ------- >>> ");
                            // let errorFile = yield self.requestApi(options);
                            ///////////////////////////////////////////////////////
                            // let self=this;
                            yield self.ioWrite(options);


                            ///////////////////////////////////////////////////////
                            console.error("OUTPUT WRITE ---- STATUS  ----- ---- >> ", "      ----------  OUTPUT WRITE OUTPUT ---------  ")
                        }
                    }
                    else {
                        logger.error(" 5--- ---- ----- >>>> >>>> runTrainInvOobj ====> Internal server Error >>> --- >>> --- >> >>> ");
                        let outputData = { "runTrainingForInvoice": null, "uploadStatus": true, 'statusCode': '202' };
                        let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                        let headers = { 'Authorization': token, 'content-type': "application/json" };
                        taskData['exception'] = " 6--- ---- ----- >>>> >>>> runTrainInvOobj ====> Internal server Error >>> --- >>> --- >> >>> ";
                        options = {
                            method: 'POST',
                            url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                            headers: headers,
                            body: taskData,
                            json: true
                        };
                        console.warn(" <<< << ------- ---------- ------- CALLING BOT OUTPUT WRITE API IN ERRORFILE------- ---------- ------- >>> ");
                        // let errorFile = yield self.requestApi(options);
                        ///////////////////////////////////////////////////////
                        // let self=this;
                        yield self.ioWrite(options);


                        ///////////////////////////////////////////////////////
                        console.error("OUTPUT WRITE ---- STATUS  ----- ---- >> ", "      ----------  OUTPUT WRITE OUTPUT ---------  ")
                    }
                }
                else {
                    throw "fileData not found"
                }
            }
            catch (err) {
                logger.error('In runRScript- ' + err + err.lineNumber);
                logger.info('Object generated for error invoice - inside catch');
                let outputData = { "runTrainingForInvoice": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = err.toString();
                let options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                // let errorFile = yield self.requestApi(options);
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
                console.error("OUTPUT WRITE ---- STATUS  ----- ---- >> ", "      ----------  OUTPUT WRITE OUTPUT ---------  ")
            }
        });
    }
    runTrainingForInvoicePreML(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                req.body.input.return ? '' : res.send({ status: 0 });
                logger.info('----------INSIDE FOR RUN TRAINING FOR INVOICE---------');
                let self = this;

                let token = req.body.token;
                let options = {};
                let botId = req.body.botId;
                let subscriberId = req.body.input.subscriberId;
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;
                let orgId = req.body.input.orgId, invObj;
                let templateId = "";
                let isTmp = "";
                console.log("Before FileDataArray")

                let fileDataArray = req.body.input.ruleObj;
                let fileRefNum = req.body.input.fileRefNum;
                if (!util_1.isNullOrUndefined(fileDataArray) && Array.isArray(fileDataArray) && fileDataArray.length > 0) {
                    let doctype;
                    if (!util_1.isNullOrUndefined(fileDataArray[0].ModelDocType)) {
                        doctype = fileDataArray[0].ModelDocType;
                        console.log("doctype-=====", doctype);
                    } else {
                        doctype = fileDataArray[0].obj.documentType;
                        console.log("doctypeExist-=====", doctype);
                    }
                    let modeldatas = yield (db.createDynamicModel('modeldatas')).findOne({ documentType: doctype });
                    let datarule = yield scanField.findOne({ isDeleted: false, documentType: doctype });
                    if (!util_1.isNullOrUndefined(datarule) && typeof datarule == 'object') {
                        datarule = JSON.parse(JSON.stringify(datarule));
                    }


                    let fileD = yield (db.createDynamicModel('fileuploadhistories')).findOne({ fileRefNum: fileRefNum }).lean();

                    let imagePathArr = fileD && fileD['imagesPath'] ? fileD['imagesPath'] : [];

                    let csvPathArray = [];
                    let invFileName;
                    for (let index = 0; index < fileDataArray.length; index++) { // For Each PNG Image
                        let fileData = fileDataArray[index];
                        // orgId = fileData.obj.orgId;
                        let filePathimg = fileData.obj.filePath;
                        let filepath2 = filePathimg.replace(/.png|.jpg/, '');
                        let invFileName = filepath2 + "_" + 'invoice' + ".csv";
                        csvPathArray.push(invFileName)
                    }

                    if (csvPathArray.length > 1) {
                        let data = yield Promise.all(csvPathArray.map(a => self.jsonToCsv(a)))
                        data = data.filter(a => a.status == 0)
                        let concatFeatures = [];
                        data.forEach(a => {
                            concatFeatures = concatFeatures.concat(a['output'])
                        })
                        let mergedFilePath = csvPathArray[0].replace(/(.csv)$/, '');
                    let headers = config.tableHeaderScanning;
                        let mergeD = yield self.csvGenerate(concatFeatures, headers, fileRefNum, 'Merged', mergedFilePath);
                        invFileName = mergeD;
                    }
                    else if (csvPathArray.length == 1) {
                        invFileName = csvPathArray[0];
                    }
                    if (!util_1.isNullOrUndefined(modeldatas)) {
                        let gstin;
                        if (!util_1.isNullOrUndefined(req.body.input.oId) && !util_1.isNullOrUndefined(req.body.input.sId)) {
                            try {
                                gstin = yield (db.collection('organisations')).findOne({ _id: ObjectId(req.body.input.oId) }).lean();
                                orgId = req.body.input.oId;
                                subscriberId = req.body.input.sId;
                                console.log("Adding orgId from the Input....")
                            }
                            catch (e) {
                                gstin = yield (db.collection('organisations')).findOne({ _id: ObjectId(orgId) }).lean();
                            }
                        }
                        else {
                            gstin = yield (db.collection('organisations')).findOne({ _id: ObjectId(orgId) }).lean();
                        }
                        gstin = JSON.parse(JSON.stringify(gstin));
                        gstin = gstin ? gstin['gstin'] : '';

                        let pythonReqObj = {
                            "filePath": invFileName,
                            "imagesPath": imagePathArr,
                            "orgId": orgId,
                            "gstin": gstin,
                            "subscriberId": subscriberId,
                            "documentType": doctype,
                            "modelType": "formModel",
                        }
                        let outputData = { "mlInput": pythonReqObj, "uploadStatus": true, 'statusCode': '200', "runTrainingForInvoice": fileDataArray };

                        let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                        let headers = { 'Authorization': token, 'content-type': "application/json" };
                        let options = {
                            method: 'POST',
                            url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                            headers: headers,
                            body: taskData,
                            json: true
                        };
                        process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                        // let outputWrite = yield self.requestApi(options);
                        ///////////////////////////////////////////////////////
                        // let self=this;
                        if (req.body.input.return)
                            return outputData;
                        else
                            yield self.ioWrite(options)

                    }
                    else {
                        logger.error(" 7--- ---- ----- >>>> >>>> runTrainInvOobj ====> Internal server Error >>> --- >>> --- >> >>> ");
                        let outputData = { "runTrainingForInvoice": null, "uploadStatus": true, 'statusCode': '202' };
                        let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                        let headers = { 'Authorization': token, 'content-type': "application/json" };
                        taskData['exception'] = " 8--- ---- ----- >>>> >>>> runTrainInvOobj ====> Internal server Error >>> --- >>> --- >> >>> ";
                        options = {
                            method: 'POST',
                            url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                            headers: headers,
                            body: taskData,
                            json: true
                        };
                        console.warn(" <<< << ------- ---------- ------- CALLING BOT OUTPUT WRITE API IN ERRORFILE------- ---------- ------- >>> ");
                        // let errorFile = yield self.requestApi(options);
                        ///////////////////////////////////////////////////////
                        // let self=this;
                        yield self.ioWrite(options);


                        ///////////////////////////////////////////////////////
                        console.error("OUTPUT WRITE ---- STATUS  ----- ---- >> ", "      ----------  OUTPUT WRITE OUTPUT ---------  ")
                    }
                }
                else {
                    throw "fileData not found"
                }
            }
            catch (err) {
                logger.error('In runRScript- ' + err + err.lineNumber);
                logger.info('Object generated for error invoice - inside catch');
                let outputData = { "runTrainingForInvoice": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = err.toString();
                let options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                // let errorFile = yield self.requestApi(options);
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
                console.error("OUTPUT WRITE ---- STATUS  ----- ---- >> ", "      ----------  OUTPUT WRITE OUTPUT ---------  ")
            }
        });
    }
    runTrainingForInvoicePostML(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                req.body.input.return ? '' : res.send({ status: 0 });
                logger.info('----------INSIDE FOR RUN TRAINING FOR INVOICE---------');
                let self = this;
                let fileDataArrayNew = [];
                let fieldDetectionNew = [];

                let token = req.body.token;
                let options = {};
                let botId = req.body.botId;
                let subscriberId = req.body.input.subscriberId;
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;
                let orgId = req.body.input.orgId, invObj;
                let templateId = "";
                let isTmp = "";
                console.log("Before FileDataArray---")

                let fileDataArray = req.body.input.ruleObj;
                let fileRefNum = req.body.input.fileRefNum;
                let docType = req.body.input.docType;
                let pythonCall = { 'status': 0 };
                pythonCall['output'] = req.body.input.mlOutput;
                if (!util_1.isNullOrUndefined(fileDataArray) && Array.isArray(fileDataArray) && fileDataArray.length > 0) {
                    if (!util_1.isNullOrUndefined(pythonCall) && !util_1.isNullOrUndefined(pythonCall.status) && pythonCall["output"]["result"] && pythonCall.status == 0) {
                        console.info(" -- -- CALLING PYTHON API SUCCESS  --- ---- ", JSON.stringify(pythonCall));
                        let p0Prediction = !util_1.isNullOrUndefined(pythonCall["output"]["p0Prediction"]) ? pythonCall["output"]["p0Prediction"] : {};
                        let op = yield self.jsonToCsv(pythonCall["output"]["result"]);
                        templateId = pythonCall["output"]["templateId"];
                        isTmp = pythonCall["output"]["isTmp"];
                        console.log("AFTER JSON TO CSV");
                        let invoiceDataMerge = op.output;

                        let datarule = yield scanField.findOne({ isDeleted: false, documentType: docType });
                        if (!util_1.isNullOrUndefined(datarule) && typeof datarule == 'object') {
                            datarule = JSON.parse(JSON.stringify(datarule));
                        }
                        // console.log(datarule)
                        let validInvData = [];

                        for (let i = 0; i < invoiceDataMerge.length; i++) {
                            if (invoiceDataMerge[i].Property != 'undefined' && invoiceDataMerge[i].Property !== "") {
                                validInvData.push(JSON.parse(JSON.stringify(invoiceDataMerge[i])));
                            }
                            invoiceDataMerge[i]['property'] = invoiceDataMerge[i].Property ? invoiceDataMerge[i].Property : 'undefined';
                        }

                        const data = validInvData.filter(function (list) {
                            const name = list.Name.replace("~", ",");
                            list.Name = name;
                            return list;
                        });


                        let propertyWiseData;

                        try {
                            propertyWiseData = data.reduce(function (r, a) {
                                r[a.Property] = r[a.Property] || [];
                                r[a.Property].push(a);
                                return r;
                            }, Object.create(null))
                        }
                        catch (e) {
                            propertyWiseData = {};
                        }

                        let D = yield self.createFunInvoiceObjNew(propertyWiseData, datarule.fields);
                        let propertyWiseDataM = D['propertyWiseDataM'];
                        invObj = D['obj'];

                        let extraPredictedIndices;
                        try {
                            extraPredictedIndices = propertyWiseDataM.map(a => a.mP).reduce((pre, cur) => pre.concat(cur)).map(a => ({ i: a.i, pN: a.pN }))
                        }
                        catch (e) {
                            extraPredictedIndices = []
                        }


                        console.log("AFTER CREATE FUN INVOICEOBJ NEW ", JSON.stringify(invObj));
                        invObj['oPred'] = [];
                        let documentOutputGenai = {}
                        if(!util_1.isNullOrUndefined(req.body.input.genai_flow) && req.body.input.genai_flow != '') {
                            console.log('Inside find output from genai')
                            documentOutputGenai = yield db.collection(docType).findOne({"referenceNumber": fileRefNum});
                            if (!util_1.isNullOrUndefined(documentOutputGenai) && typeof documentOutputGenai == 'object') {
                                documentOutputGenai = JSON.parse(JSON.stringify(documentOutputGenai));
                            }
                            console.log('output from genai', JSON.stringify(documentOutputGenai))
                        }

                        for (let i = 0; i < datarule.fields.length; i++) {
                            if (util_1.isNullOrUndefined(invObj[datarule.fields[i].fieldName]) && invObj[datarule.fields[i].fieldName] != '') {
                                invObj[datarule.fields[i].fieldName] = "";
                            }
                            if (!util_1.isNullOrUndefined(p0Prediction[datarule.fields[i].fieldName])) {
                                let obj = {};
                                obj[datarule.fields[i].fieldName] = invObj[datarule.fields[i].fieldName];
                                invObj['oPred'].push(JSON.parse(JSON.stringify(obj)));
                                invObj[datarule.fields[i].fieldName] = p0Prediction[datarule.fields[i].fieldName];
                            }
                            //this is for the priority prediction to overwrite the prediction of model
                            //this is for the priority prediction to overwrite the prediction of model
                            if(!util_1.isNullOrUndefined(req.body.input.genai_flow) && req.body.input.genai_flow != '') {
                                if (!util_1.isNullOrUndefined(documentOutputGenai) && documentOutputGenai[datarule.fields[i].fieldName]) {
                                    console.log('value from genai',documentOutputGenai[datarule.fields[i].fieldName])
                                    invObj[datarule.fields[i].fieldName] = documentOutputGenai[datarule.fields[i].fieldName];
                                }
                            }                           

                        }
                        // for templateDriven prediciton flag 
                        invObj["isTmp"] = !util_1.isNullOrUndefined(pythonCall["output"]["isTmp"]) ? pythonCall["output"]["isTmp"] : false;
                        invObj["templateId"] = !util_1.isNullOrUndefined(pythonCall["output"]["templateId"]) ? pythonCall["output"]["templateId"] : "";

                        let ruleID = datarule["ruleId"];

                        let dTUpdate = [];
                        for (let index = 0; index < fileDataArray.length; index++) { // For Each PNG Image
                            console.info("RUNNING FOR --------------- ---INSIDE FOR LOOP-------- ---------->>>>> >>>> >>>>    ", index);
                            let fileData = fileDataArray[index];
                            let filePathimg = fileData.obj.filePath;

                            let invoiceData = invoiceDataMerge.filter(a => a['pageNo'] == index || a['pageNo'] == String(index))

                            let removeIndices = extraPredictedIndices.filter(a => a.pN == index || a.pN == String(index)).map(a => a.i)

                            console.log("Total--->", removeIndices, invoiceData.filter(a => a.Property == 'undefined').length)

                            // yield (db.createDynamicModel('raw_documenttrainings')).findOneAndUpdate({ fileRefNum: fileRefNum, filePath: filePathimg }, { $set: { documentCsvData: invoiceData } }, { upsert: true });
                            if (removeIndices.length > 0) {
                                let predictedData = invoiceData.filter(a => a.property != 'undefined' || a.Property != 'undefined')
                                for (let i = 0; i < predictedData.length; i++) {
                                    if (removeIndices.includes(predictedData[i].index)) {
                                        predictedData[i].property = 'undefined';
                                        predictedData[i].Property = 'undefined';
                                    }
                                }
                            }
                            console.log("Total--->", invoiceData.filter(a => a.Property == 'undefined').length);

                            fieldDetectionNew.push(invoiceData);

                            dTUpdate.push(docTraining.update({ fileRefNum: fileRefNum, filePath: filePathimg }, { $set: { documentCsvData: invoiceData } }, { upsert: true, strict:false, validateBeforeSave: false }));

                            fileData['invoiceObject'] = JSON.parse(JSON.stringify(invObj));

                            fileDataArrayNew.push(fileData);
                        }
                        console.log("Query----")
                        console.time("documentTraining")
                        yield Promise.all(dTUpdate);
                        console.timeEnd("documentTraining")

                        console.info("RUNNING FOR --------------- ---AFTER FOR LOOP-------- ---------->>>>> >>>> >>>>");

                        let outputData = { "templateId": templateId, "ruleId": ruleID, "isTmp": isTmp, "runTrainingForInvoice": fileDataArrayNew, "fieldDetectionData": fieldDetectionNew, "uploadStatus": true, 'statusCode': '200' };
                        let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                        let headers = { 'Authorization': token, 'content-type': "application/json" };
                        let options = {
                            method: 'POST',
                            url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                            headers: headers,
                            body: taskData,
                            json: true
                        };
                        process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                        // let outputWrite = yield self.requestApi(options);
                        ///////////////////////////////////////////////////////
                        // let self=this;
                        if (req.body.input.return)
                            return outputData;
                        else
                            yield self.ioWrite(options)
                    }
                    else {
                        logger.error(" 9--- ---- ----- >>>> >>>> runTrainInvOobj ====> Internal server Error >>> --- >>> --- >> >>> ");
                        let outputData = { "runTrainingForInvoice": pythonCall, "uploadStatus": true, 'statusCode': '202' };
                        let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                        let headers = { 'Authorization': token, 'content-type': "application/json" };
                        taskData['exception'] = "from prediction api 10--- ---- ----- >>>> >>>> runTrainInvOobj ====> Internal server Error >>> --- >>> --- >> >>> ";
                        options = {
                            method: 'POST',
                            url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                            headers: headers,
                            body: taskData,
                            json: true
                        };
                        console.warn(" <<< << ------- ---------- ------- CALLING BOT OUTPUT WRITE API IN ERRORFILE------- ---------- ------- >>> ");
                        // let errorFile = yield self.requestApi(options);
                        ///////////////////////////////////////////////////////
                        // let self=this;
                        yield self.ioWrite(options);


                        ///////////////////////////////////////////////////////
                        console.error("OUTPUT WRITE ---- STATUS  ----- ---- >> ", "      ----------  OUTPUT WRITE OUTPUT ---------  ")
                    }
                }
                else {
                    logger.error(" 11--- ---- ----- >>>> >>>> runTrainInvOobj ====> Internal server Error >>> --- >>> --- >> >>> ");
                    let outputData = { "runTrainingForInvoice": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = " 12--- ---- ----- >>>> >>>> runTrainInvOobj ====> Internal server Error >>> --- >>> --- >> >>> ";
                    options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    console.warn(" <<< << ------- ---------- ------- CALLING BOT OUTPUT WRITE API IN ERRORFILE------- ---------- ------- >>> ");
                    // let errorFile = yield self.requestApi(options);
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    yield self.ioWrite(options);


                    ///////////////////////////////////////////////////////
                    console.error("OUTPUT WRITE ---- STATUS  ----- ---- >> ", "      ----------  OUTPUT WRITE OUTPUT ---------  ")
                }
            }
            catch (err) {
                logger.error('In runRScript- ' + err + err.lineNumber);
                logger.info('Object generated for error invoice - inside catch');
                let outputData = { "runTrainingForInvoice": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = err.toString();
                let options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                // let errorFile = yield self.requestApi(options);
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
                console.error("OUTPUT WRITE ---- STATUS  ----- ---- >> ", "      ----------  OUTPUT WRITE OUTPUT ---------  ")
            }
        });
    }
    createInvoiceObjNew(Keys, sfields) {
        try
        {
            let obj = {};
            let propertyWiseData = [];
            obj["prediction"] = [];
            obj["ocrConfidence"] = [];
            let newKeys = {};
            let scanKeys = sfields.map(a => a.fieldName);
            let showTrue = sfields.filter(a=>a.show).map(a => a.fieldName);

            let multiLineFields = sfields.filter(a => a.isBlockP).map(a => a.fieldName);
            let nFields = sfields.filter(a => a.isNu).map(a => a.fieldName);
            for (let k in Keys) {
                let sameProperties = JSON.parse(JSON.stringify(Keys[k]));
                sameProperties.sort((a, b) => Number(a['index']) - Number(b['index']));
                sameProperties.sort((a, b) => Number(a['pageNo']) - Number(b['pageNo']));
                let newData = [];
                for (let i = 0, len = sameProperties.length; i < len; i++) {
                    let loopObj = JSON.parse(JSON.stringify(sameProperties[i]));
                    loopObj['concatedIndex'] = [];
                    loopObj['concatedIndex'].push(sameProperties[i].index)
                    if (!nFields.includes(k)) {
                        while (i < len - 1 && Number(sameProperties[i].pageNo) == Number(sameProperties[i + 1].pageNo) && ((Number(sameProperties[i].index) + 1 == Number(sameProperties[i + 1].index)) || (multiLineFields.includes(k) && Math.abs(Number(sameProperties[i].lineNumber) - Number(sameProperties[i + 1].lineNumber)) <= 3))) {   //multiLineFields field is for the multiLine Predicitons concat
                            // normally concatenating the side by side indices
                            loopObj.Name = loopObj.Name + ' ' + sameProperties[i + 1].Name;
                            loopObj.confidence = Number(loopObj.confidence) > Number(sameProperties[i + 1].confidence) ? Number(loopObj.confidence) : Number(sameProperties[i + 1].confidence);
                            loopObj['concatedIndex'].push(sameProperties[i + 1].index)
                            i++;
                        }
                    }
                    newData.push(JSON.parse(JSON.stringify(loopObj)));
                }
                newData.sort((a, b) => Number(b.confidence) - Number(a.confidence));
                if (multiLineFields.includes(k)) {
                    newData.sort((a, b) => b.concatedIndex.length - a.concatedIndex.length);
                }
                newKeys[k] = newData;

                let con = {};
                if (newData.length > 0) {
                    let list = newData[0];
                    //Only take fields which are in documentType
                    if (scanKeys.includes(k)) {
                        obj[k] = list.Name
                        con['fd'] = k;
                        con['vl'] = list.Name
                        con['cf'] = (Number(list.confidence) * 100).toFixed(4) + '%';
                        con["fr"] = list.Property_ML !== "undefined" ? "ML" : "TwoPass";
                        con["cP"] = sameProperties.filter(a => (list['concatedIndex'].includes(a.index) && a.pageNo == list.pageNo)).map(a => ({ i: a.index, cf: (Number(a.confidence) * 100).toFixed(4) + '%', v: a.Name, pN: a.pageNo, fr: a.Property_ML !== "undefined" ? "ML" : "TwoPass" }));
                        con['mP'] = sameProperties.filter(a => (!list['concatedIndex'].includes(a.index) || a.pageNo != list.pageNo)).map(a => ({ i: a.index, cf: (Number(a.confidence) * 100).toFixed(4) + '%', v: a.Name, pN: a.pageNo, fr: a.Property_ML !== "undefined" ? "ML" : "TwoPass" }));
                        obj["prediction"].push({ "ml": (Number(list.confidence) * 100).toFixed(2) + '%', "isColor": Number(list.confidence) * 100 > 60 ? false : true, "key": list.Property, "from": list.Property_ML !== "undefined" ? "ML" : "TwoPass" });

                        let ocrConfidence = newData.map(a=>Number(a.ocrConfidence)).reduce((total,elt)=>{
                            total=total+elt;
                            return total;},0);
                        
                        let perc =  ocrConfidence ? (ocrConfidence/newData.length) : 0;
                        
                        if(showTrue.includes(k))
                        {
                            obj["ocrConfidence"].push({ "pred": perc.toFixed(2) + '%', "isColor": perc > 60 ? false : true, "key": list.Property});
                        }
                    }
                }


                propertyWiseData.push(con);
            }

            // console.log("================= Invoice Objects GENERATED==============old wali");
            // console.log(obj)
            return { obj: obj, propertyWiseDataM: propertyWiseData };
        }
        catch(e)
        {
            console.log("Errrrrrr in createInvoiceNew-------------",e);
            return {};
        }
    }

    requestApi(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield new Promise(function (resolve, reject) {
                return __awaiter(this, void 0, void 0, function* () {
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0'
                    request(data, (err, res) => {
                        if (err) {
                            console.log("Error in the Request API function" + err);
                            resolve({ status: 1, err: err });
                        }
                        else {
                            console.log("Reponse from the request api");
                            resolve({ status: 0, output: JSON.parse(JSON.stringify(res['body'])) });
                        }
                    });
                });
            });
        });
    }

    createFunInvoiceObj(data) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            return yield new Promise(function (resolve, reject) {
                return __awaiter(this, void 0, void 0, function* () {
                    let objData = yield self.createInvoiceObj(data);
                    resolve(objData);
                });
            });
        });
    }
    createFunInvoiceObjNew(data, blockFields) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            return yield new Promise(function (resolve, reject) {
                return __awaiter(this, void 0, void 0, function* () {
                    let objData = yield self.createInvoiceObjNew(data, blockFields);
                    resolve(objData);
                });
            });
        });
    }
    prepareFormData(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                req.body.input.return ? '' : res.send({ status: 0 });
                logger.info("Inside prepareFormData");
                let self = this;
                let prepareFormDataOutput = [];
                let token = req.body.token;
                let botId = req.body.botId;
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;
                if (!util_1.isNullOrUndefined(req.body.input.ruleObj)) {
                    for (let index = 0; index < req.body.input.ruleObj.length; index++) {
                        let data = req.body.input.ruleObj[index];
                        let docType;
                        // console.log("SOHAILLLLLL",data['isApi']);
                        if (!util_1.isNullOrUndefined(data.documentType)) {
                            docType = data.documentType;
                            // console.log("Doc1--", docType);
                        }
                        else {
                            console.log("KRISHNA ---- ");
                            docType = data.obj.documentType;
                            // console.log("Doc2---doc", docType);
                        }
                        let fieldData = yield scanField.findOne({ isDeleted: false, documentType: docType })
                        fieldData = JSON.parse(JSON.stringify(fieldData))
                        //  function (err, fieldData) {
                        //	console.log("feildata---------..>>>",JSON.stringify(fieldData));
                        if (util_1.isNullOrUndefined(fieldData)) {
                            throw err;
                        }
                        else {
                            let invoiceData = data.invoiceObject;
                            // console.log("INVOICE DATA FOR PREDICT", JSON.stringify(invoiceData));
                            let formData = [];
                            let table = [];
                            let tableHeader = [];
                            let dbField = [];
                            let tableData = [];
                            if (!util_1.isNullOrUndefined(invoiceData) && invoiceData !== '' && !util_1.isNullOrUndefined(fieldData) && docType !== 'Documents') {
                                fieldData.fields.forEach(function (list, ind) {
                                    //  console.log("KRISHNA----filds coditionsss")
                                    if (!util_1.isNullOrUndefined(data['isApi'])) {
                                        //    console.log("IS API called bhai"+JSON.stringify(list));
                                        //    console.log("IS API called FILEDNAME---"+JSON.stringify(list.fieldName));
                                        //    console.log("LISTTTTT---",JSON.stringify(list));
                                        if (list.isTable) {
                                            //  console.log("Adding Data in the table");
                                            tableHeader.push(list.fieldName);
                                            dbField.push(list.placeHolder);
                                        }
                                    }
                                    if (!util_1.isNullOrUndefined(invoiceData[list.fieldName]) || (!util_1.isNullOrUndefined(list.fieldName))) {
                                        // if (!util_1.isNullOrUndefined(list.fieldName) || !util_1.isNullOrUndefined()) {
                                        // console.log("KRISHNA================+++++++",list.fieldName);
                                        let key = list.fieldName;
                                        let obj = {};
                                        obj['label'] = list.fieldName;
                                        obj['placeHolder'] = list.filedName;
                                        obj['type'] = "text";
                                        obj['field'] = list.fieldName;
                                        obj['isDMSKey'] = list.isDMSKey;
                                        obj['value'] = invoiceData[list.fieldName];
                                        obj[key] = invoiceData[list.fieldName];
                                        obj['isTable'] = list.isTable;
                                        formData.push(obj);
                                    }
                                });
                                if (!util_1.isNullOrUndefined(invoiceData) && !util_1.isNullOrUndefined(invoiceData['invoiceItems']) && !util_1.isNullOrUndefined(invoiceData['invoiceItems'].length > 0) && invoiceData['invoiceItems'].length > 0) {
                                    invoiceData['invoiceItems'].filter(function (row) {
                                        //    console.log("______SURESHH", data['isApi']);
                                        let item = [];
                                        if (!util_1.isNullOrUndefined(data['isApi'])) {
                                            console.log("INSIDE API BHAI IS API");
                                            tableData.push(JSON.parse(JSON.stringify(row)));
                                        }
                                        fieldData.fields.forEach(function (list) {
                                            if (!util_1.isNullOrUndefined(row[list.fieldName])) {
                                                let key = list.fieldName;
                                                let obj = {};
                                                obj['label'] = list.fieldName;
                                                obj['placeHolder'] = list.fieldName;
                                                obj['type'] = list.type;
                                                obj['field'] = list.fieldName;
                                                obj['isDMSKey'] = list.isDMSKey;
                                                obj['value'] = row[list.fieldName];
                                                obj[key] = row[list.fieldName];
                                                item.push(obj);
                                            }
                                        });
                                        if (!util_1.isNullOrUndefined(item) && item.length > 0) {
                                            table.push(item);
                                        }
                                    });
                                }
                            }
                            else if (docType === 'Documents') {
                                fieldData.fields.forEach(function (list) {
                                    formData.push({
                                        label: list.label,
                                        placeHolder: list.placeHolder,
                                        type: list.type,
                                        field: list.field,
                                        isDMSKey: list.isDMSKey,
                                        value: !util_1.isNullOrUndefined(data.consolidatedData.consolidatedText) ? data.consolidatedData.consolidatedText : ''
                                    });
                                });
                            }
                            if (util_1.isNullOrUndefined(invoiceData) ? false : !util_1.isNullOrUndefined(invoiceData.prediction)) {
                                for (let i = 0; i < formData.length; i++) {
                                    // console.log("Inside For Loop after check of prediction");
                                    let dataObj = _.findWhere(invoiceData.prediction, { "key": formData[i].label });
                                    //  console.log("OBJECT FOUND IN THE API" + JSON.stringify(dataObj));
                                    if (dataObj) {
                                        formData[i]['value'] = util_1.isNullOrUndefined(formData[i]['value']) || formData[i]['value'] == "" ? " " : formData[i]['value'];
                                        formData[i]['ml'] = dataObj.ml;
                                        formData[i]['isColor'] = dataObj.isColor;
                                    }
                                    else {
                                        formData[i]['value'] = util_1.isNullOrUndefined(formData[i]['value']) || formData[i]['value'] == "" ? " " : formData[i]['value'];
                                        formData[i]['ml'] = "";
                                        formData[i]['isColor'] = false;
                                    }
                                }
                            }
                            else {
                                console.log("PREDICTION NOT FOUND");
                            }
                            data['scanFormFields'] = [];
                            if (formData.length > 0) {
                                data['scanFormFields'] = formData;
                                formData.forEach(element => {
                                    if (util_1.isNullOrUndefined(element.value)) {
                                        element['value'] = '';
                                        element['ml'] = '';
                                        element['isColor'] = false;
                                    }
                                    // element.value
                                });
                            }
                            else {
                                fieldData.fields.forEach(function (list) {
                                    let obj = {};
                                    // console.log("Form data is 0000");
                                    //  console.log("Listttt-sohail",JSON.stringify(list));
                                    // console.log("rowss-sohail",JSON.stringify(row));
                                    if (!util_1.isNullOrUndefined(list.fieldName)) {
                                        let key = list.fieldName;
                                        let obj = {};
                                        obj['label'] = list.fieldName;
                                        obj['type'] = list.type;
                                        obj['isDMSKey'] = list.isDMSKey;
                                        obj['value'] = '';
                                        obj['field'] = list.fieldName;
                                        obj[key] = "";
                                        obj['ml'] = '';
                                        obj['isColor'] = false;
                                        obj['isTable'] = list.isTable;
                                        formData.push(obj);
                                        data['scanFormFields'] = formData;
                                    }
                                });
                            }
                            data['itemFields'] = table;
                            if (!util_1.isNullOrUndefined(data['isApi'])) {
                                let flag = false;
                                if (!util_1.isNullOrUndefined(data['scanFormFields']) && !util_1.isNullOrUndefined(data['scanFormFields'].length) && data['scanFormFields'].length > 0 && !util_1.isNullOrUndefined(invoiceData) && !util_1.isNullOrUndefined(invoiceData['tableMapping'])) {
                                    data['scanFormFields'].forEach(element => {
                                        if (element.isTable == true && !util_1.isNullOrUndefined(Object.keys(invoiceData['tableMapping']).length)) {
                                            let keys = Object.keys(invoiceData['tableMapping']);
                                            let value = "";
                                            keys.forEach((row, i) => {
                                                if (invoiceData['tableMapping'][row].includes(element.field)) {
                                                    value = row;
                                                }
                                            });
                                            element.value = value;
                                        }
                                        if (element.field == 'tableEnd') {
                                            flag = true;
                                        }
                                    });
                                }
                                if (flag == false && _.findIndex(data['scanFormFields'], { field: 'tableEnd' }) == -1) {
                                    if (!util_1.isNullOrUndefined(invoiceData) && !util_1.isNullOrUndefined(invoiceData['tableEnd']) && !util_1.isNullOrUndefined(invoiceData['tableEnd'].length)) {
                                        let TableEnd = {
                                            field: "tableEnd",
                                            isTable: true,
                                            label: "tableEnd",
                                            ml: "",
                                            value: invoiceData['tableEnd'][0],
                                            name: "",
                                        };
                                        data['scanFormFields'].push(TableEnd);
                                    }
                                    else {
                                        let TableEnd = {
                                            field: "tableEnd",
                                            isTable: true,
                                            label: "tableEnd",
                                            ml: "",
                                            value: "",
                                            name: "",
                                        };
                                        data['scanFormFields'].push(TableEnd);
                                    }
                                }
                                else {
                                    if (!util_1.isNullOrUndefined(invoiceData) && !util_1.isNullOrUndefined(invoiceData['tableEnd']) && invoiceData['tableEnd'].length > 0) {
                                        let index = _.findIndex(data['scanFormFields'], { field: 'tableEnd' });
                                        data['scanFormFields'][index]['value'] = invoiceData['tableEnd'][0];
                                    }
                                }
                            }
                            if (!util_1.isNullOrUndefined(data['isApi'])) {
                                console.log("Sending Specific to This only");
                                tableHeader = [];
                                dbField = [];
                                // console.log("tableData----------", JSON.stringify(tableData));
                                tableData.forEach((Element, i) => {
                                    let keys = Object.keys(Element);
                                    if (!util_1.isNullOrUndefined(tableHeader) && tableHeader.length > 0) {
                                        tableHeader.forEach((row, j) => {
                                            if (keys.indexOf(row) == -1) {
                                                tableHeader.push(row);
                                            }
                                        });
                                    }
                                    else {
                                        tableHeader = keys;
                                    }
                                });
                                dbField = tableHeader;
                                data['tableHeader'] = [...new Set(tableHeader)];
                                data['dbField'] = [...new Set(dbField)];
                                data['tableData'] = tableData;
                            }
                            console.log("datttttttttttttt");
                        }
                        // });
                        prepareFormDataOutput.push(data);
                    }
                    //adding api
                    let outputData = { "prepareFormData": prepareFormDataOutput, "uploadStatus": true, 'statusCode': '200' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     //console.log("body---responce",body);
                    //     //console.log("---res",response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    if (req.body.input.return)
                        return outputData;
                    else
                        yield self.ioWrite(options);

                    ///////////////////////////////////////////////////////
                }
                else {
                    logger.error("#prepareFormData==>Internal server Error");
                    let outputData = { "prepareFormData": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = "#prepareFormData==>Internal server Error";
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     // console.log("body---responce", body);
                    //     // console.log("---res", response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    yield self.ioWrite(options);


                    ///////////////////////////////////////////////////////
                }
            }
            catch (err) {
                logger.error('#prepareFormData==> Internal server Error   inside catch' + err);
                let outputData = { "prepareFormData": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = err.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
            }
        });
    }
    prepareCreateSave(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                req.body.input.return ? '' : res.send({ status: 0 });
                logger.info("Prepare table data");
                let self = this;
                let preapreCreateSaveOutput = [];
                let token = req.body.token;
                let botId = req.body.botId;
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;
                if (!util_1.isNullOrUndefined(req.body.input.ruleObj)) {
                    for (let index = 0; index < req.body.input.ruleObj.length; index++) {
                        let ruleObj = req.body.input.ruleObj[index];
                        let fileData = ruleObj.tableData;
                        let data = [];
                        if (!util_1.isNullOrUndefined(fileData)) {
                            fileData.forEach((list) => {
                                let temp = [];
                                let rightX;
                                list.forEach((row, ind) => {
                                    if (!util_1.isNullOrUndefined(row.rightX) && !util_1.isNullOrUndefined(list[ind - 1]) && !util_1.isNullOrUndefined(list[ind - 1].leftX)) {
                                        let diff = self.difference(row.leftX, rightX);
                                        if (diff <= 20) {
                                            let tableStart = config.tableStart;
                                            let info = tableStart.find((res) => {
                                                return temp[temp.length - 1] + ' ' + row.Name === res;
                                            });
                                            if (info) {
                                                rightX = row.rightX;
                                                temp[temp.length - 1] = temp[temp.length - 1] + ' ' + row.Name;
                                            }
                                            else {
                                                rightX = row.rightX;
                                                temp.push(row.Name);
                                            }
                                        }
                                        else {
                                            rightX = row.rightX;
                                            temp.push(row.Name);
                                        }
                                    }
                                    else if (!util_1.isNullOrUndefined(row.Name)) {
                                        rightX = row.rightX;
                                        temp.push(row.Name);
                                    }
                                });
                                data.push(temp);
                            });
                        }
                        // console.log(JSON.stringify(data));
                        ruleObj['invItemData'] = data;
                        let itemData = !util_1.isNullOrUndefined(ruleObj.invItemData) ? ruleObj.invItemData : [];
                        let headers1 = itemData.length > 0 ? itemData[0] : [];
                        itemData.splice(0, 1);
                        let configKeys = config.newItemObj;
                        let itemObjectKey = Object.keys(configKeys);
                        let num = config.numField;
                        let itemObjectValue = Object.values(configKeys);
                        let itemArray = [];
                        itemData.forEach((res) => {
                            let obj = {};
                            headers1.forEach((list, ind) => {
                                let info = itemObjectKey.find((row) => {
                                    return list === row;
                                });
                                if (!util_1.isNullOrUndefined(info)) {
                                    obj[configKeys[list]] = res[ind].replace('~', '');
                                }
                            });
                            let d = Object.values(obj);
                            let i = 0;
                            d.filter((l) => {
                                if (l.trim() !== '') {
                                    i++;
                                }
                            });
                            if (i >= 3) {
                                itemArray.push(obj);
                            }
                        });
                        // console.log("itemArrayaa", itemArray);
                        itemArray.forEach((res) => {
                            let data = Object.keys(res);
                            data.forEach((list) => {
                                let info = num.find((row) => {
                                    return list === row;
                                });
                                if (!util_1.isNullOrUndefined(info)) {
                                    res[list] = Number(res[list].replace(/[^\d.-]/g, ''));
                                }
                            });
                        });
                        console.log('Inside create invoice item object');
                        // console.log(JSON.stringify(itemArray));
                        ruleObj['invItem'] = ruleObj.newTable;
                        let invObj = !util_1.isNullOrUndefined(ruleObj['invoiceObject']) ? ruleObj['invoiceObject'] : {};
                        invObj['invoiceItems'] = ruleObj.newTable;
                        ruleObj['invoiceObject'] = invObj;
                        logger.info('Inside Save ErrorInvoicess');
                        let invData = new errorInv(ruleObj.invoiceObject);
                        // yield invData.save(function (err, invData) {
                        //     if (err) {
                        //         console.log("=========================================SVVVVVVV errrrr  ");
                        //         throw err;
                        //     }
                        //     else {
                        //         logger.info('Error invoice generated successfully');
                        //         let set = {};
                        //         set['status'] = 'Success';
                        //         set['isProcess'] = true;
                        //         set['fileRefNum'] = ruleObj.obj.fileRefNum;
                        //         set['accountNo'] = !util_1.isNullOrUndefined(invData.accountNo) ? invData.accountNo : '';
                        //         if (!util_1.isNullOrUndefined(ruleObj.Lines)) {
                        //             set['Lines'] = JSON.stringify(ruleObj.Lines);
                        //         }
                        //         if (!util_1.isNullOrUndefined(ruleObj.sortedWords)) {
                        //             set['sortedWords'] = JSON.stringify(ruleObj.sortedWords);
                        //         }
                        //         ruleObj['setFileHistory'] = set;
                        //         preapreCreateSaveOutput.push(ruleObj);
                        //     }
                        // });
                        let savedData = yield new Promise((resolve, reject) => {
                            invData.save(function (err, invData) {
                                if (err) {
                                    reject(err);
                                } else {
                                    resolve(invData);
                                }
                            });
                        });
                        logger.info('Error invoice generated successfully');
                        let set = {};
                        set['status'] = 'Success';
                        set['isProcess'] = true;
                        set['fileRefNum'] = ruleObj.obj.fileRefNum;
                        set['accountNo'] = !util_1.isNullOrUndefined(invData.accountNo) ? invData.accountNo : '';
                        if (!util_1.isNullOrUndefined(ruleObj.Lines)) {
                            set['Lines'] = JSON.stringify(ruleObj.Lines);
                        }
                        if (!util_1.isNullOrUndefined(ruleObj.sortedWords)) {
                            set['sortedWords'] = JSON.stringify(ruleObj.sortedWords);
                        }
                        ruleObj['setFileHistory'] = set;
                        preapreCreateSaveOutput.push(ruleObj);
                    }
                    //adding api
                    let outputData = { "prepareCreateSave": preapreCreateSaveOutput, "uploadStatus": true, 'statusCode': '200' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     //console.log("body---responce",body);
                    //     //console.log("---res",response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    if (req.body.input.return)
                        return outputData;
                    else
                        yield self.ioWrite(options);


                    ///////////////////////////////////////////////////////
                }
                else {
                    logger.error("#prepareCreateSave==>Internal server Error");
                    let outputData = { "prepareCreateSave": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = "#prepareCreateSave==>Internal server Error";
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     // console.log("body---responce", body);
                    //     // console.log("---res", response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    yield self.ioWrite(options);


                    ///////////////////////////////////////////////////////
                }
            }
            catch (e) {
                logger.error('Failed for prepare table data - inside catch' + e);
                let outputData = { "prepareCreateSave": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = e.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
            }
        });
    }
    multiPageArray(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                req.body.input.return ? '' : res.send({ status: 0 });
                logger.info("multiPageArray");
                let self = this;
                let multiPagearray = [];
                let token = req.body.token;
                let botId = req.body.botId;
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;
                if (!util_1.isNullOrUndefined(req.body.input.ruleObj)) {
                    for (let index = 0; index < req.body.input.ruleObj.length; index++) {
                        let result = req.body.input.ruleObj[index];
                        let invoiceFinalObj = {};
                        let obj = {};
                        // console.log("resulte----ofInvoiceObj", JSON.stringify(result.invoiceObject));
                        // console.log("Final---ofInvoiceObj", invoiceFinalObj['referenceNumber']);
                        obj = Object.assign(invoiceFinalObj, result.invoiceObject);
                        obj['documentType'] = result.obj.documentType;
                        obj['referenceNumber'] = result.obj.fileRefNum;
                        obj['filePath'] = result.obj.filePath;
                        obj['tableStart'] = !util_1.isNullOrUndefined(result['tableStart']) ? result['tableStart'] : [];
                        obj['tableEnd'] = !util_1.isNullOrUndefined(result['tableEnd']) ? result['tableEnd'] : [];
                        obj['tableMapping'] = !util_1.isNullOrUndefined(result['tableMapping']) ? result['tableMapping'] : {};
                        multiPagearray.push(JSON.parse(JSON.stringify(obj)));
                    }
                    //adding api
                    let outputData = { "multiPageArray": multiPagearray, "uploadStatus": true, 'statusCode': '200' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     //console.log("body---responce",body);
                    //     //console.log("---res",response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    if (req.body.input.return)
                        return outputData;
                    else
                        yield self.ioWrite(options);


                    ///////////////////////////////////////////////////////
                }
                else {
                    logger.error("#multiPageArray==>Internal server Error");
                    let outputData = { "multiPageArray": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = "#multiPageArray==>Internal server Error";

                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     // console.log("body---responce", body);
                    //     // console.log("---res", response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    yield self.ioWrite(options);


                    ///////////////////////////////////////////////////////
                }
            }
            catch (err) {
                logger.error('Failed for get Table OCR data - inside catch' + err);
                let outputData = { "multiPageArray": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = err.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
            }
        });
    }
    saveObjectData(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                req.body.input.return ? '' : res.send({ status: 0 });
                logger.info("Inside Function saveObject Data");
                let self = this;
                // let mClient = yield MongoClient.connect(config.mongoConnection);
                // let dbName = config.mongoConnection.split('/');
                // let db = yield mClient.db(dbName[dbName.length - 1]);
                let tableName;
                let options = {};
                let token = req.body.token;
                let botId = req.body.botId;
                let imagePath_parser;
                if (!util_1.isNullOrUndefined(req.body.input.imagePath)) {
                    imagePath_parser = req.body.input.imagePath;
                }
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;
                let multiPagearray = req.body.input.ruleObj;
                if (!util_1.isNullOrUndefined(multiPagearray)) {
                    console.log("multiPagearray[0].documentType--" + multiPagearray[0].documentType)
                    tableName = multiPagearray[0].documentType;
                    let invObj;
                    console.log("Multipagearraylength------", multiPagearray.length);
                    if (multiPagearray.length > 1) {
                        let temp = { "prediction": [] };
                        let fileds = [];
                        let obj = {};
                        let data = yield scanField.findOne({ isDeleted: false, documentType: tableName });
                        data.fields.forEach(element => {
                            if (element.isTable == false) {
                                fileds.push(element);
                            }
                        });
                        if (tableName == 'Clinical') {
                            console.log("its Contract typoeee");
                            for (let i = 0; i < fileds.length; i++) {
                                // const element = array[i];
                                let temp1 = {};
                                obj = {};
                                for (let j = 0; j < multiPagearray.length; j++) {
                                    // console.log("filds", fileds[i].fieldName);
                                    for (let k = 0; k < multiPagearray[j].prediction.length; k++) {
                                        if (fileds[i].fieldName == multiPagearray[j].prediction[k].key) {
                                            obj['key'] = fileds[i].fieldName;
                                            obj['ml'] = multiPagearray[j].prediction[k]['ml'];
                                            obj['isColor'] = multiPagearray[j].prediction[k]['isColor'];
                                            //       console.log("Object before break----->",obj.key)
                                            break;
                                        }
                                    }
                                    if (util_1.isNullOrUndefined(obj.key)) {
                                        console.log("------if No prediction");
                                        obj['ml'] = "100";
                                        obj["isColor"] = false;
                                        obj["key"] = fileds[i].fieldName;
                                        obj[fileds[i].fieldName] = multiPagearray[j][fileds[i].fieldName];
                                    }
                                    if (!util_1.isNullOrUndefined(temp1.ml)) {
                                        console.log("------IN tempIF");
                                        //   console.log("Temp1.ml---",temp1.ml);
                                        //  console.log("obj.ml-----",obj.ml);
                                        let tmpml = temp1.ml.replace(/%/, '');
                                        let objml = obj.ml.replace(/%/, '');
                                    }
                                    else {
                                        //     console.log("------KRISHNA----1",obj.key);
                                        temp1['ml'] = obj.ml;
                                        temp1["isColor"] = obj.isColor;
                                        temp1["key"] = obj.key;
                                        temp1[fileds[i].fieldName] = multiPagearray[j][fileds[i].fieldName];
                                    }
                                    const element = multiPagearray[j];
                                    // multiPagearray[j].prediction
                                    if (j >= 1) {
                                        multiPagearray[j][fileds[i].fieldName] = multiPagearray[j - 1][fileds[i].fieldName].concat(" ", multiPagearray[j][fileds[i].fieldName]);
                                        multiPagearray[j][fileds[i].fieldName] = multiPagearray[j][fileds[i].fieldName].trim();
                                    }
                                }
                                if (!util_1.isNullOrUndefined(temp1.ml)) {
                                    temp.prediction.push({ "ml": temp1.ml, "isColor": temp1.isColor, "key": temp1.key });
                                    temp[temp1.key] = temp1[temp1.key];
                                }
                            }
                            for (let index = 0; index < multiPagearray.length; index++) {
                                multiPagearray[multiPagearray.length - 1].prediction = temp.prediction;
                            }
                            invObj = multiPagearray[multiPagearray.length - 1];
                        }
                        else {
                            console.log("not contract doctype");
                            for (let i = 0; i < fileds.length; i++) {
                                let temp1 = {};
                                obj = {};
                                for (let j = 0; j < multiPagearray.length; j++) {
                                    if (!util_1.isNullOrUndefined(multiPagearray[j][fileds[i].fieldName]) && multiPagearray[j][fileds[i].fieldName] != "") {
                                        for (let k = 0; k < multiPagearray[j].prediction.length; k++) {
                                            if (fileds[i].fieldName == multiPagearray[j].prediction[k].key) {
                                                obj['key'] = fileds[i].fieldName;
                                                obj['ml'] = multiPagearray[j].prediction[k]['ml'];
                                                obj['isColor'] = multiPagearray[j].prediction[k]['isColor'];
                                                break;
                                            }
                                        }
                                        if (util_1.isNullOrUndefined(obj.key)) {
                                            console.log("------if No prediction");
                                            obj['ml'] = "100";
                                            obj["isColor"] = false;
                                            obj["key"] = fileds[i].fieldName;
                                            obj[fileds[i].fieldName] = multiPagearray[j][fileds[i].fieldName];
                                        }
                                        if (!util_1.isNullOrUndefined(temp1.ml)) {
                                            console.log("------IN tempIF");
                                            let tmpml = temp1.ml.replace(/%/, '');
                                            let objml = obj.ml.replace(/%/, '');
                                            if (Number(tmpml) < Number(objml)) {
                                                temp1["ml"] = obj.ml;
                                                temp1["isColor"] = obj.isColor;
                                                temp1["key"] = obj.key;
                                                temp1[fileds[i].fieldName] = multiPagearray[j][fileds[i].fieldName];
                                            }
                                        }
                                        else {
                                            temp1['ml'] = obj.ml;
                                            temp1["isColor"] = obj.isColor;
                                            temp1["key"] = obj.key;
                                            temp1[fileds[i].fieldName] = multiPagearray[j][fileds[i].fieldName];
                                        }
                                    }
                                }
                                if (!util_1.isNullOrUndefined(temp1.ml)) {
                                    temp.prediction.push({ "ml": temp1.ml, "isColor": temp1.isColor, "key": temp1.key });
                                    temp[temp1.key] = temp1[temp1.key];
                                }
                            }
                            temp['referenceNumber'] = multiPagearray[0].referenceNumber;
                            temp['tableStart'] = multiPagearray[0].tableStart;
                            temp['tableEnd'] = multiPagearray[0].tableEnd;
                            temp['tableMapping'] = multiPagearray[0].tableMapping;
                            temp['invoiceItems'] = [];
                            let tempArr = [];
                            let tempArr1 = [];
                            let tempArr2 = [];
                            let count = 0;
                            for (let i = 0; i < multiPagearray.length; i++) {
                                if (!util_1.isNullOrUndefined(multiPagearray[i].invoiceItems)) {
                                    console.log("INSIDE  MUKITITITIIT PAGE ARRYAYAYYAYYAYAYAY");
                                    for (let j = 0; j < multiPagearray[i].invoiceItems.length; j++) {
                                        // console.log("INSIDE  MUKITITITIIT PAGE ARRYAYAYYAYYAYAYAY" + multiPagearray[i]['invoiceItems'][j]);
                                        count = count + 1
                                        multiPagearray[i]['invoiceItems'][j] = JSON.parse(JSON.stringify(multiPagearray[i]['invoiceItems'][j]));
                                        // multiPagearray[i]['invoiceItems'][j]["Line_Number"] = count;
                                        console.info(" ---- INVOICE ITEM --- ", count, " ---- >> >>> ", JSON.parse(JSON.stringify(multiPagearray[i]['invoiceItems'][j])));
                                        tempArr.push(JSON.parse(JSON.stringify(multiPagearray[i]['invoiceItems'][j])));
                                    }
                                    // console.log("INVOICE ITEMS OF MULTIPAGE" + tempArr);
                                }
                                if (!util_1.isNullOrUndefined(multiPagearray[i].Error)) {
                                    for (let j = 0; j < multiPagearray[i].Error.length; j++) {
                                        // console.log("INSIDE  MUKITITITIIT PAGE ARRYAYAYYAYYAYAYAY" + multiPagearray[i]['Error'][j]);
                                        tempArr1.push(JSON.parse(JSON.stringify(multiPagearray[i]['Error'][j])));
                                    }
                                    // console.log("INVOICE ITEMS OF MULTIPAGE" + tempArr1);
                                }
                                if (!util_1.isNullOrUndefined(multiPagearray[i].Exception)) {
                                    for (let j = 0; j < multiPagearray[i].Exception.length; j++) {
                                        // console.log("INSIDE  MUKITITITIIT PAGE ARRYAYAYYAYYAYAYAY" + multiPagearray[i]['Exception'][j]);
                                        tempArr2.push(JSON.parse(JSON.stringify(multiPagearray[i]['Exception'][j])));
                                    }
                                    // console.log("INVOICE ITEMS OF MULTIPAGE" + tempArr2);
                                }
                            }
                            temp['invoiceItems'] = JSON.parse(JSON.stringify(tempArr));
                            temp['Error'] = tempArr1;
                            temp['Exception'] = tempArr2;
                            invObj = JSON.parse(JSON.stringify(temp));
                            console.log("---- ------MultiPage Page Invoice----", JSON.stringify(invObj));
                        }
                    }
                    else {
                        let count = 0;
                        if (!util_1.isNullOrUndefined(multiPagearray[0].invoiceItems) && multiPagearray[0].invoiceItems.length > 0) {
                            console.log("INSIDE  MUKITITITIIT PAGE ARRYAYAYYAYYAYAYAY");
                            for (let j = 0; j < multiPagearray[0].invoiceItems.length; j++) {
                                // console.log("INSIDE  MUKITITITIIT PAGE ARRYAYAYYAYYAYAYAY" + multiPagearray[i]['invoiceItems'][j]);
                                count = count + 1;
                                multiPagearray[0]['invoiceItems'][j] = JSON.parse(JSON.stringify(multiPagearray[0]['invoiceItems'][j]));
                                // multiPagearray[0]['invoiceItems'][j]["Line_Number"] = count;
                                console.info(" ---- INVOICE ITEM --- ", count, " ---- >> >>> ", JSON.parse(JSON.stringify(multiPagearray[0]['invoiceItems'][j])));
                                multiPagearray[0]['invoiceItems'][j] = JSON.parse(JSON.stringify(multiPagearray[0]['invoiceItems'][j]));
                            }
                            // console.log("INVOICE ITEMS OF MULTIPAGE" + tempArr);
                        }
                        invObj = JSON.parse(JSON.stringify(multiPagearray[0]));
                        console.log("---- ------Single Page Invoice----", JSON.stringify(invObj));
                    }
                    let keysss = Object.keys(invObj);
                    keysss.forEach(higkey => {
                        if (invObj[higkey] === "" && !util_1.isNullOrUndefined(invObj) && !util_1.isNullOrUndefined(invObj.prediction) && invObj.prediction.length > 0) {

                            invObj.prediction.forEach(element => {
                                if (element.key === higkey) {
                                    element.ml = "0";
                                }
                            });

                        }
                    });
                    let a = 0;
                    if (!util_1.isNullOrUndefined(invObj.prediction) && invObj.prediction.length > 0) {
                        for (let i = 0; i < invObj.prediction.length; i++) {
                            console.log("--------------------in avg");
                            a = a + Number(invObj.prediction[i].ml.replace('%', ''));
                        }
                        let avgSum = a / invObj.prediction.length;
                        console.log("avgSum=====", avgSum.toFixed(2));
                        invObj['avgPrediction'] = Number(avgSum.toFixed(2));
                    }
                    invObj['masterObj'] = true;
                    logger.info('Schema name - ' + tableName);
                    if (!util_1.isNullOrUndefined(imagePath_parser)) {
                        invObj["imageFilePath"] = imagePath_parser[0]["imageFilePath"];
                    }
                    invObj["pageLimit"] = multiPagearray.length;
                    invObj["subscriberId"] = req.body.input.subscriberId;
                    let token = yield self.createTokenFor(req.body.input.userId, req.body.input.subscriberId, req.body.input.orgId);
                    let ruleSetValue = { ...invObj }
                    let fileD = yield (db.createDynamicModel('fileuploadhistories')).findOne({ fileRefNum: fileRefNum }).lean();
                    fileD = JSON.parse(JSON.stringify(fileD));
                    ruleSetValue['filePath'] = fileD['filePath'];
                    let arrayFields = {}
                    if (Object.keys(ruleSetValue).length > 0) {
                        for (let key in ruleSetValue) {
                            if (key != 'invoiceItems' && Array.isArray(ruleSetValue[key])) {
                                arrayFields[key] = ruleSetValue[key]
                                delete ruleSetValue[key]
                            }
                        }
                    }
                    let ruleID = req['body']['ruleId']
                    console.info(" --- -----    ------ ruleId  ---- ------- ----- ", ruleID);

                    let apiheaders = {
                        "Authorization": "Bearer " + token,
                        "Content-Type": "application/json",
                        "selectedorgid": req.body.input.orgId,
                    };

                    options = {
                        method: 'POST',
                        url: config.pdfServerUrl + 'gibots-api/rule/EvaluateRuleSet',
                        headers: apiheaders,
                        body: {
                            rulesSetValue: ruleSetValue,
                            id: ruleID
                        },
                        json: true
                    };

                    console.warn(" <<< << ------- ---------- ------- CALLING RULE ENGINE API ------- ---------- ------- >>> ");
                    let ruleBody = yield self.requestApi(options);
                    if (!util_1.isNullOrUndefined(ruleBody['output']) && !util_1.isNullOrUndefined(ruleBody['output']['data']) && Object.keys(ruleBody['output']['data']).length == 0) {
                        console.log("<<<<<----------------      ruleBody['output']['data']).length == 0  --------- >>>>>>>> ");
                        invObj = { ...ruleSetValue, ...arrayFields };
                    }
                    else {
                        if (!util_1.isNullOrUndefined(ruleBody['output']) && (typeof ruleBody['output'] == 'string' || util_1.isNullOrUndefined(ruleBody['output']['data']))) {
                            invObj = { ...rulesSetValue, ...arrayFields };

                        } else {
                            console.info(" <<< <<< ---- ----- RULE OBJECT ---- >>>> >>>>> ", ruleBody);
                            invObj = { ...ruleBody["output"]["data"], ...arrayFields };
                        }
                    }
                    // let data = yield db.collection(tableName).findOneAndUpdate({ referenceNumber: invObj.referenceNumber }, { $set: invObj }, { upsert: true });
                    // //yield db.collection(tableName).findOneAndUpdate({ referenceNumber: invObj.referenceNumber }, { $set: invObj }, { upsert: true });
                    // yield db.collection('filequeues').findOneAndUpdate({ fileRefNum: invObj.referenceNumber }, { $set: { status: 'Success' } }, { upsert: true });
                    // yield db.collection("fileuploadhistories").findOneAndUpdate({ fileRefNum: invObj.referenceNumber }, { $set: { status: 'Success' } }, { upsert: true });
                    // yield db.collection("fileuploadhistories").findOne({ "fileRefNum": invObj.referenceNumber });
                    let orgId = req.body.input.orgId ? req.body.input.orgId : req.body.orgId;
                    console.log("OrgId---->", orgId);
                    let data = yield (db.createDynamicModel(tableName, "yes")).findOneAndUpdate({ orgId: orgId, referenceNumber: invObj.referenceNumber }, { $set: invObj }, { upsert: true });
                    let data1 = yield (db.createDynamicModel(tableName + "_cons_before", "yes")).findOneAndUpdate({ orgId: orgId, referenceNumber: invObj.referenceNumber }, { $set: invObj }, { upsert: true });

                    //yield db.collection(tableName).findOneAndUpdate({ referenceNumber: invObj.referenceNumber }, { $set: invObj }, { upsert: true });
                    yield (db.createDynamicModel('filequeues')).findOneAndUpdate({ fileRefNum: invObj.referenceNumber }, { $set: { status: 'Success' } }, { upsert: true });
                    yield (db.createDynamicModel("fileuploadhistories")).findOneAndUpdate({ fileRefNum: invObj.referenceNumber }, { $set: { status: 'Success' } }, { upsert: true });
                    yield (db.createDynamicModel("fileuploadhistories")).findOne({ "fileRefNum": invObj.referenceNumber });

                    let outputData = { "saveObjectData": invObj, "uploadStatus": true, 'statusCode': '200' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    // yield self.requestApi(options);
                    ///////////////////////////////////////////////////////
                    if (req.body.input.return)
                        return outputData;
                    else
                        yield self.ioWrite(options);


                    ///////////////////////////////////////////////////////
                    console.log("BOT OUTPUT WRITE DONE FOR SAVE OBJECT DATA SUCESS");
                }
                else {
                    logger.error("#saveObjectData==>Internal server Error");
                    let outputData = { "saveObjectData": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = "#saveObjectData==>Internal server Error";
                    options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    // yield self.requestApi(options);
                    ///////////////////////////////////////////////////////
                    yield self.ioWrite(options);


                    ///////////////////////////////////////////////////////
                    console.log("BOT OUTPUT WRITE DONE FOR SAVE OBJECT DATA ERROR")

                }
            }
            catch (err) {
                logger.error('Fail for generated objects - inside catch' + err);
                let outputData = { "saveObjectData": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = err.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                // yield self.requestApi(options);
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
            };
        });
    };
    saveObjNew(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                req.body.input.return ? '' : res.send({ status: 0 });
                logger.info("saveObjNew");
                let self = this;
                let token = req.body.token;
                let botId = req.body.botId;
                let eventId = req.body.input.eventId;
                let iterationId = req.body.iterationId;
                let projectId = req.body.projectId;
                let invoiceFinalObj = {};
                let tableName;
                let fileRefNum;
                let genai_flow = req.body.input.genai_flow || '';
                // console.info(`genai ${genai_flow}`)
                if (!util_1.isNullOrUndefined(req.body.input.ruleObj)) {
                    for (let index = 0; index < req.body.input.ruleObj.length; index++) {
                        let result = req.body.input.ruleObj[index];
                        Object.assign(invoiceFinalObj, result.invoiceObject);
                        invoiceFinalObj['documentType'] = result.obj.documentType;
                        invoiceFinalObj['referenceNumber'] = result.obj.fileRefNum;
                        if (util_1.isNullOrUndefined(fileRefNum)) {
                            fileRefNum = result.obj.fileRefNum;
                        }
                        invoiceFinalObj['filePath'] = result.obj.filePath;
                        invoiceFinalObj['tableStart'] = !util_1.isNullOrUndefined(result['tableStart']) ? result['tableStart'] : [];
                        invoiceFinalObj['tableEnd'] = !util_1.isNullOrUndefined(result['tableEnd']) ? result['tableEnd'] : [];
                        invoiceFinalObj['tableMapping'] = !util_1.isNullOrUndefined(result['tableMapping']) ? result['tableMapping'] : {};
                        invoiceFinalObj['templateName'] = !util_1.isNullOrUndefined(req.body['templateName']) ? req.body['templateName'] : "";
                        invoiceFinalObj['table_headers'] = !util_1.isNullOrUndefined(result['table_headers']) ? result['table_headers'] : [];
                        if(index==0){
                            invoiceFinalObj['multiTable'] = !util_1.isNullOrUndefined(result['multiTable']) ? result['multiTable'] : [];
                            invoiceFinalObj['tableCordinates'] = !util_1.isNullOrUndefined(result['tableCordinates']) ? result['tableCordinates'] : [];
                        }

                    }
                }

                if (!util_1.isNullOrUndefined(invoiceFinalObj)) {
                    console.log("DocumentType--" + invoiceFinalObj.documentType)
                    tableName = invoiceFinalObj.documentType;
                    let invObj = invoiceFinalObj;
                    invObj = JSON.parse(JSON.stringify(invObj));
                    console.log("---- ------Single Page Invoice----", JSON.stringify(invObj));
                    let keysss = Object.keys(invObj);
                    keysss.forEach(higkey => {
                        if (invObj[higkey] === "" && !util_1.isNullOrUndefined(invObj) && !util_1.isNullOrUndefined(invObj.prediction) && invObj.prediction.length > 0) {

                            invObj.prediction.forEach(element => {
                                if (element.key === higkey) {
                                    element.ml = "0";
                                }
                            });

                        }
                    });
                    let a = 0;
                    if (!util_1.isNullOrUndefined(invObj.prediction) && invObj.prediction.length > 0) {
                        for (let i = 0; i < invObj.prediction.length; i++) {
                            console.log("--------------------in avg");
                            a = a + Number(invObj.prediction[i].ml.replace('%', ''));
                        }
                        let avgSum = a / invObj.prediction.length;
                        console.log("avgSum=====", avgSum.toFixed(2));
                        invObj['avgPrediction'] = Number(avgSum.toFixed(2));
                    }
                    invObj['masterObj'] = true;
                    logger.info('Schema name - ' + tableName);
                    invObj["pageLimit"] = req.body.input.ruleObj.length;
                    invObj["subscriberId"] = req.body.input.subscriberId;

                    let orgId = req.body.input.orgId ? req.body.input.orgId : req.body.orgId;
                    console.log("OrgId---->", orgId);
                    let tokenC = yield self.createTokenFor(req.body.input.userId, req.body.input.subscriberId, req.body.input.orgId);
                    let ruleSetValue = { ...invObj }
                    let fileD = yield (db.createDynamicModel('fileuploadhistories')).findOne({ fileRefNum: fileRefNum }).lean();
                    fileD = JSON.parse(JSON.stringify(fileD));
                    ruleSetValue['filePath'] = fileD['filePath'];
                    let arrayFields = {}
                    if (Object.keys(ruleSetValue).length > 0) {
                        for (let key in ruleSetValue) {
                            if (key != 'invoiceItems' && Array.isArray(ruleSetValue[key])) {
                                arrayFields[key] = ruleSetValue[key]
                                delete ruleSetValue[key]
                            }
                        }
                    }
                    let ruleID = req['body']['ruleId'];

                    if(!util_1.isNullOrUndefined(req['body']['input']) && !util_1.isNullOrUndefined(req['body']['input']['ruleId'])){
                        ruleID = req['body']['input']['ruleId'];
                    }

                    if (util_1.isNullOrUndefined(ruleID)) {
                        let scanD = yield (db.createDynamicModel('scanningfields')).findOne({ documentType: tableName }).lean();

                        ruleID = String(scanD.ruleId);
                    }
                    console.info(" --- -----    ------ ruleId  ---- ------- ----- ", ruleID);

                    let apiheaders = {
                        "Authorization": "Bearer " + tokenC,
                        "Content-Type": "application/json",
                        "selectedorgid": req.body.input.orgId,
                    };

                    let finalObj = {};
                    for (let key in ruleSetValue) {
                        finalObj[key.replace(/\./g, '_')] = ruleSetValue[key];
                    }
                    ruleSetValue = JSON.parse(JSON.stringify(finalObj))
                    yield (db.createDynamicModel(tableName + "_cons_before")).findOneAndUpdate({ "referenceNumber": fileRefNum }, { "$set": ruleSetValue }, { upsert: true });
                    let multi_table_detected = false;
                    let multi_table_table_names = [];
                    if(!util_1.isNullOrUndefined(arrayFields['multiTable']) && arrayFields['multiTable'].length>0) {
                        let multi_table_data = arrayFields['multiTable'];
                        multi_table_detected = true;
                        for(let tableNo = 0; tableNo<multi_table_data.length; tableNo++) {
                            for (let table_name in multi_table_data[tableNo]) {
                                multi_table_table_names.push(table_name);
                                ruleSetValue[table_name] = multi_table_data[tableNo][table_name];
                            }
                        }
                        
                    }
                    options = {
                        method: 'POST',
                        url: config.pdfServerUrl + 'gibots-api/rule/EvaluateRuleSet',
                        headers: apiheaders,
                        body: {
                            rulesSetValue: ruleSetValue,
                            id: ruleID
                        },
                        json: true
                    };

                    let prmArr = [];

                    console.warn(" <<< << ------- ---------- ------- CALLING RULE ENGINE API ------- ---------- ------- >>> ");
                    let ruleBody;
                    if (ruleID) {
                        ruleBody = yield self.requestApi(options);
                    }
                    else {
                        console.log("RuleId not found...........")
                        ruleBody = {};
                        ruleBody['output'] = "pass"
                    }
                    if (!util_1.isNullOrUndefined(ruleBody['output']) && !util_1.isNullOrUndefined(ruleBody['output']['data']) && Object.keys(ruleBody['output']['data']).length == 0) {
                        console.log("<<<<<----------------      ruleBody['output']['data']).length == 0  --------- >>>>>>>> ");
                        invObj = { ...ruleSetValue, ...arrayFields };
                    }
                    else {
                        if (!util_1.isNullOrUndefined(ruleBody['output']) && (typeof ruleBody['output'] == 'string' || util_1.isNullOrUndefined(ruleBody['output']['data']))) {
                            console.log("From the ruleNot----------")
                            invObj = { ...ruleSetValue, ...arrayFields };

                        } else {
                            if (multi_table_detected) {
                                let updatedMultiTable = []
                                for(let i=0; i<multi_table_table_names.length; i++) {
                                    let newMultiTableAfterRule = {};
                                    if (!util_1.isNullOrUndefined(ruleBody["output"]["data"][multi_table_table_names[i]])) {
                                        newMultiTableAfterRule[multi_table_table_names[i]] = ruleBody["output"]["data"][multi_table_table_names[i]];
                                        updatedMultiTable.push(newMultiTableAfterRule);
                                        delete ruleBody["output"]["data"][multi_table_table_names[i]];
                                    }
                                }
                                arrayFields['multiTable'] = updatedMultiTable
                            }
                            prmArr.push((db.createDynamicModel(tableName + "_afterRule")).findOneAndUpdate({ "referenceNumber": invObj.referenceNumber }, { "$set": ruleBody['output']['data'] }, { upsert: true }))
                            console.info(" <<< <<< ---- ----- RULE OBJECT ---- >>>> >>>>> ", ruleBody);
                            invObj = { ...ruleBody["output"]["data"], ...arrayFields };
                            //console.log("PREDICTION COUNT --- ---- ----- ----- ---- > >> >> > > > >   ", predictionObj.length);
                        }
                    }
                    if (genai_flow != '') {
                        console.info(`Comparing genai pred with template prediction`);
                        let predFromGenAI = yield (db.createDynamicModel(tableName)).findOne({orgId: ObjectId(orgId), referenceNumber: invObj.referenceNumber}).lean();
                        function combineObjects(obj1, obj2) {
                            const result = {...obj1};
                            for (const key in obj2) { //Genai Prediction
                              if (obj2.hasOwnProperty(key) && result[key] === "" && obj2[key] !== "") {
                                result[key] = obj2[key];
                              } else if (key == 'multiTable' && Array.isArray(obj2[key]) && obj2[key].length > 0) {
                                console.log('multitable from genai');
                                result[key] = obj2[key];
                              }
                            }
                            result['flow'] = 'GENAI';
                            return result;
                        }
                        invObj = combineObjects(invObj,predFromGenAI)
                    }

                    if(invObj['multiTable'])
                    { 
                        let tableConfidence = [];
                        for(let table of invObj['multiTable'])
                        {
                            let tableName = Object.keys(table);
                            tableName = tableName.length ? tableName[0] : null;
                            if(tableName && Array.isArray(table[tableName]))
                            {
                                let rows = table[tableName];
                                let errRows = rows.filter(a=>a['error'] && a['error'].length)
                                let perc = rows.length ? ((rows.length-errRows.length)/rows.length)*100 : 0
                                tableConfidence.push({ "pred": perc.toFixed(2) + '%', "isColor": perc > 60 ? false : true, "key": tableName})
                            }
                        }

                        // console.log(tableConfidence)
                        invObj['tableConfidence'] = tableConfidence;
                    }
                    else if(invObj['invoiceItems'])
                    {
                        let rows = invObj['invoiceItems'];
                        let errRows = rows.filter(a=>a['error'] && a['error'].length)
                        let perc = rows.length ? ((rows.length-errRows.length)/rows.length)*100 : 0
                        tableConfidence.push({ "pred": perc.toFixed(2) + '%', "isColor": perc > 60 ? false : true, "key": "Table" });
                        invObj['tableConfidence'] = tableConfidence;
                    }
                    if(invObj['orgId'] && typeof invObj['orgId'] === 'string'){
                        invObj['orgId'] = ObjectId(invObj['orgId']);
                    }
                    if(invObj['subscriberId'] && typeof invObj['subscriberId'] === 'string'){
                        invObj['subscriberId'] = ObjectId(invObj['subscriberId']);
                    }
                    if(invObj['userId'] && typeof invObj['userId'] === 'string'){
                        invObj['userId'] = ObjectId(invObj['userId']);
                    }
                    if (genai_flow != ''){
                    	prmArr.push((db.createDynamicModel(tableName, "yes")).update({ orgId: ObjectId(orgId), referenceNumber: invObj.referenceNumber }, { $set: invObj }, { upsert: true }))
                    } else {
                    	prmArr.push((db.createDynamicModel(tableName, "yes")).update({ orgId: orgId, referenceNumber: invObj.referenceNumber }, { $set: invObj }, { upsert: true }))
                    }
                    prmArr.push((db.createDynamicModel('filequeues')).findOneAndUpdate({ fileRefNum: invObj.referenceNumber }, { $set: { status: 'Success' } }, { upsert: true }))
                    prmArr.push((db.createDynamicModel("fileuploadhistories")).findOneAndUpdate({ fileRefNum: invObj.referenceNumber }, { $set: { status: 'Success' } }, { upsert: true }))

                    yield Promise.all(prmArr);

                    invObj['ruleId'] = ruleID;
                    let outputData = { "saveObjectData": invObj, "uploadStatus": true, 'statusCode': '200' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // let self=this;
                    if (req.body.input.return)
                        return outputData;
                    else
                        yield self.ioWrite(options);
                }
                else {
                    logger.error("#saveObjectData==>Internal server Error");
                    let outputData = { "saveObjectData": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = "#saveObjectData==>Internal server Error";

                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    yield self.ioWrite(options);
                }
            }
            catch (err) {
                logger.error('Failed for get Table OCR data - inside catch' + err);
                let outputData = { "saveObjectData": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = err.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                let self = this;
                yield self.ioWrite(options);
            }
        });
    }
    OflineocrItemsNew(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                res.send({ status: 0 });
                logger.info('Inside oflineocrItems');
                let fileOutputDataNew = [];
                let body = req.body;
                let eventId = body.input.eventId;
                let projectId = body.projectId;
                let botId = body.botId;
                let token = body.token;
                let iterationId = body.iterationId;
                let fileData = body.input.fileData;
                let refNum = body.input.fileRefNum;
                let modelName = body.input.modelName;
                let mClient = yield MongoClient.connect(config.mongoConnection);
                let dbName = config.mongoConnection.split('/');
                let db = yield mClient.db(dbName[dbName.length - 1]);
                let data = yield db.collection('fileuploadhistories').findOne({ fileRefNum: refNum });
                let filePath = data["filePath"];
                let oid = data["orgId"];
                // console.log(oid);
                // console.log("helo", JSON.stringify(oid));
                // filePath = fileData[iterationId].imageFilePath;
                let type = "predict";
                console.log("type--------", type);
                var filename = filePath.replace(/^.*[\\\/]/, '');
                let cropfilePathTrain = config.cropfilePathTrain;
                let cropfilePathPredict = config.cropfilePathPredict;
                let rmdir;
                if (!util_1.isNullOrUndefined(fileData)) {
                    for (let pageIndex = 0; pageIndex < fileData.length; pageIndex++) {
                        let fileDataNew = {};
                        filePath = fileData[pageIndex].imageFilePath;
                        let obj = {};
                        obj['documentType'] = data["documentType"];
                        obj["filePath"] = filePath;
                        obj["fileRefNum"] = refNum;
                        obj["orgId"] = data["orgId"];
                        obj["userId"] = data["userId"];
                        obj["subscriberId"] = data["subscriberId"];
                        obj["fileName"] = data["fileName"];
                        fileDataNew["obj"] = obj;
                        let imagePath = fileData[pageIndex].imageFilePath;
                        let output = yield this.OFlineOcrNew(imagePath, type, cropfilePathTrain, cropfilePathPredict, modelName);
                        // let output = {}
                        // output.data = fileData[pageIndex].raw;
                        // console.log("ouput of OFLINEEE", output);
                        let ocrpathdir = fs.existsSync(cropfilePathTrain + '/' + filename);
                        let ocrpathdirPred = fs.existsSync(cropfilePathPredict + '/' + filename);
                        if (ocrpathdir) {
                            console.log("TRain---");
                            rmdir = yield execSync('rm -r' + ' ' + cropfilePathTrain + '/' + '*');
                        }
                        if (ocrpathdirPred) {
                            console.log("Predict---------");
                            rmdir = yield execSync('rm -r' + ' ' + cropfilePathPredict + '/' + '*');
                        }
                        if (output.status == 0) {
                            //console.log("Output Data----ofline", JSON.stringify(output.data));
                            // let outputnew = (output.data);
                            let outputnew = JSON.parse(output.data);
                            let filepath2 = filePath.replace(/.png|.jpg/, '');
                            // console.log("filepath of json=================>", filepath2);
                            // console.log("datadatadarta====>", outputnew[outputnew.length - 1]);
                            let pagewidthImg = outputnew[outputnew.length - 1].width;
                            let pageheightImg = outputnew[outputnew.length - 1].height;
                            outputnew.splice(-1, 1);
                            outputnew.forEach(element => {
                                if (!util_1.isNullOrUndefined(element.text)) {
                                    element['pageNo'] = pageIndex;
                                    element['Name'] = element.text.replace(/,/g, "~");
                                    element['Name'] = element.text.replace(/\\|\//g, '');
                                }
                            });
                            let tmp = [];
                            for (let index = 0; index < outputnew.length; index++) {
                                const element = outputnew[index];
                                if (!element.Name.replace(/\s/g, '').length) {
                                    //console.log('string only contains whitespace (ie. spaces, tabs or line breaks)');
                                    tmp.push(index);
                                }
                            }
                            for (var i = tmp.length - 1; i >= 0; i--) {
                                outputnew.splice(tmp[i], 1);
                            }
                            let outputCombinewords = outputnew;
                            outputnew.sort(function (a, b) {
                                return a["pageNo"] - b["pageNo"] || a["topY"] - b["topY"];
                            });
                            //start added 22 april '21
                            fileDataNew["obj"] = obj;
                            //end
                            fileDataNew['sortedWords'] = outputnew;
                            fileDataNew['combineWords'] = outputCombinewords;
                            fileDataNew['fileRefNum'] = fileData.obj.fileRefNum;
                            fileDataNew['raw'] = outputCombinewords;
                            fileDataNew['sortedLines'] = outputnew;
                            fileDataNew['pageWidth'] = pagewidthImg;
                            fileDataNew['pageHeight'] = pageheightImg;
                            delete fileDataNew.sortedLines;
                            // console.log("after del=====>", fileDataNew);
                            fileOutputDataNew.push(fileDataNew);
                        }
                        else {
                            logger.error('#OflineOcr==>error in OFLINE-OCR');
                        }
                    }
                    //adding api
                    let outputData = { "OflineocrItemsNew": fileOutputDataNew, "uploadStatus": true, 'statusCode': '200' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     //console.log("body---responce",body);
                    //     //console.log("---res",response);
                    // });
                    ///////////////////////////////////////////////////////
                    let self = this;
                    yield self.ioWrite(options);


                    ///////////////////////////////////////////////////////
                }
                else {
                    logger.error("#OflineocrItemsNew==>Internal server Error");
                    let outputData = { "OflineocrItemsNew": null, "uploadStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'Authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = "#OflineocrItemsNew==>Internal server Error";
                    var options = {
                        method: 'POST',
                        url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     // console.log("body---responce", body);
                    //     // console.log("---res", response);
                    // });
                    ///////////////////////////////////////////////////////
                    let self = this;
                    yield self.ioWrite(options);


                    ///////////////////////////////////////////////////////
                }
            }
            catch (e) {
                logger.error("error in OFLINE-OCR-------inside catch", e);
                let outputData = { "OflineocrItemsNew": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = e.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     // console.log("body---responce", body);
                //     // console.log("---res", response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
            }
        });
    }

    OFlineOcrNew(fileData, type, cropfilePathTrain, cropfilePathPredict, modelName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                logger.info("Inside ofline_OCR");
                //   console.log("FILEDATA in OflineOCR----",JSON.stringify(fileData.obj));
                let self = this;
                let ocrEnsambleScript = config.ocrEnsambleScript;
                let ocrEnsambleScriptPredict = config.ocrEnsambleScriptPredict;
                let ocrEnsambleException_Script = config.ocrEnsambleException_Script;
                let cropttextPath = config.cropttextPath;
                //    let isSecPass=fileData.obj.isSecPass;
                //   let filePath = fileData.obj.filePath;
                let filePath = fileData;
                //let filePath = fileData[0].imageFilePath;
                // console.log("superman =====>", filePath);
                //    let type= fileData.obj.type;
                let cpfile;
                //  console.log("------------IS secpassssssss", isSecPass);
                let pythonCommand;
                //     if(isSecPass == true )
                //    {
                //     console.log("------------------PRADNYA file-----its true");
                //        if(type == 'train'){
                //         console.log("type--is train for cmd---------");
                //         //cpfile = yield execSync('sudo cp -r ' + filePath + ' ' + cropfilePathTrain);
                //         cpfile = yield execSync('/bin/cp -r ' + filePath + ' ' + cropfilePathTrain);
                //         pythonCommand = 'python ' + ocrEnsambleException_Script + ' -i ' + cropfilePathTrain + '/' +  ' -o ' + cropttextPath;
                //        }else{
                //         console.log("type--is predict for cmd---------OCR");
                //           cpfile = yield execSync('/bin/cp -r ' + filePath + ' ' + cropfilePathPredict);
                //         pythonCommand = 'python ' + ocrEnsambleException_Script + ' -i ' + cropfilePathPredict + '/' +  ' -o ' + cropttextPath;
                //        }
                //    }else{
                console.log("-------------------RISHI file----- its false");
                //    config.modelName=modelName;
                if (type == 'train') {
                    console.log("type--is train for cmd---------2");
                    cpfile = yield execSync('/bin/cp -r ' + filePath + ' ' + cropfilePathTrain);
                    pythonCommand = 'python ' + ocrEnsambleScript + ' -i ' + cropfilePathTrain + '/' + ' -o ' + cropttextPath + ' -m ' + modelName;
                }
                else {
                    // console.log("type--is predict for cmd---------2", cropfilePathPredict, cropttextPath, filePath, ocrEnsambleScriptPredict);
                    cpfile = yield execSync('/bin/cp -r ' + filePath + ' ' + cropfilePathPredict);
                    pythonCommand = 'python ' + ocrEnsambleScriptPredict + ' -i ' + cropfilePathPredict + '/' + ' -o ' + cropttextPath + ' -m ' + modelName;
                }
                // console.log("PYTHON OCR ENSAMBLE COMMAND ====newew" + pythonCommand);
                let pythonOutput = yield this.terminalCoomandOfline(pythonCommand);
                // console.log("dattaa---", pythonOutput);
                let data = JSON.parse(JSON.stringify(pythonOutput.output));
                //         console.log("PYTHON COMMAND OUTPUT AFTER EXCEUTION--------------------" + JSON.stringify(pythonOutput) + "---------------");
                return { 'status': 0, "data": data, "info": "Executed successfully" };
            }
            catch (e) {
                logger.info('err in oflineOcr', e);
                return { 'status': 1, "data": [], "info": e };
            }
        });
    }
    extractInvoiceFeatures(lineWordsWithoutTable, pageWidth, pageHeight, docType) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let features = [];
                let featuresData = [];
                let self = this;
                let data = [];
                let result = [];
                let tmp = 1;
                let inclusionWords = [], exclusionWords = [];
                let scanDoc = yield scanField.findOne({ documentType: docType, isDeleted: false }, { tableMapping: 1.0, tableStart: 1.0, tableEnd: 1.0, anchorKey: 1.0, exclusionWords: 1.0, inclusionWords: 1.0 });
                let parsedScan = JSON.parse(JSON.stringify(scanDoc))
                if (!util_1.isNullOrUndefined(scanDoc) && !util_1.isNullOrUndefined(parsedScan.inclusionWords)) {
                    inclusionWords = parsedScan.inclusionWords;
                }
                if (!util_1.isNullOrUndefined(scanDoc) && !util_1.isNullOrUndefined(parsedScan.exclusionWords)) {
                    exclusionWords = parsedScan.exclusionWords;
                }
                let topWordFeat, currentWordFeat, bottomWordFeat, rightWordFeat, leftWordFeat, finalFeatures;
                for (let i = 0; i < lineWordsWithoutTable.length; i++) {
                    let array = config.ignoreFromCSV;
                    lineWordsWithoutTable[i].forEach(function (list, index) {
                        list['index_page'] = tmp++;
                        let info = array.find(function (item) {
                            if (item === list.Name) {
                                return list.Name;
                            }
                        });
                        if (!util_1.isNullOrUndefined(info)) {
                            lineWordsWithoutTable[i].splice(index, 1);
                        }
                    });
                    for (let j = 0; j < lineWordsWithoutTable[i].length; j++) {
                        // for (let index = 0; index < array.length; index++) {
                        //     const element = array[index];
                        // }
                        lineWordsWithoutTable[i][j]['lineNumber'] = i;
                        // lineWordsWithoutTable[i][j]['pageWidth']=pageWidth;
                        // lineWordsWithoutTable[i][j]['pageHeight']=pageHeight;
                        // console.log("pageeeeeeNO---",i)
                        features.push(lineWordsWithoutTable[i][j]);
                        // currentWordFeat = self.extractCurrentWordFeatures(features[features.length - 1], i, j, lineWordsWithoutTable, pageWidth, pageHeight, "");
                        //result.push(data);
                        for (let index = 0; index < 8; index++) {
                            topWordFeat = self.extractTopWordFeatures(features[features.length - 1], i, j, lineWordsWithoutTable, pageWidth, pageHeight, "TOP_", index, exclusionWords, inclusionWords);
                            // undefined
                            if (!util_1.isNullOrUndefined(topWordFeat)) {
                                break;
                            }
                        }
                        for (let index = 0; index < 8; index++) {
                            // topWordFeat = self.extractTopWordFeatures(features[features.length - 1], i, j, lineWordsWithoutTable, pageWidth, pageHeight, "TOP_",index);
                            bottomWordFeat = self.extractBottomWordFeatures(features[features.length - 1], i, j, lineWordsWithoutTable, pageWidth, pageHeight, "BOTTOM_", index, exclusionWords, inclusionWords);
                            // undefined
                            //       console.log("bootomwordFeat-----",bottomWordFeat)
                            if (!util_1.isNullOrUndefined(bottomWordFeat['undefined']) || (!util_1.isNullOrUndefined(bottomWordFeat.BOTTOM_Name))) {
                                break;
                            }
                        }
                        // bottomWordFeat = self.extractBottomWordFeatures(features[features.length - 1], i, j, lineWordsWithoutTable, pageWidth, pageHeight, "BOTTOM_",0);
                        // result.push()
                        // data["botWord"] =  self.extractBottomWordFeatures(features[features.length-1],i,j,lineWordsWithoutTable,pageHeight,pageWidth," ")
                        leftWordFeat = self.extractLeftWordFeatures(features[features.length - 1], i, j, lineWordsWithoutTable, pageWidth, pageHeight, "LEFT_", exclusionWords, inclusionWords);
                        rightWordFeat = self.extractRightWordFeatures(features[features.length - 1], i, j, lineWordsWithoutTable, pageWidth, pageHeight, "RIGHT_", exclusionWords, inclusionWords);
                        currentWordFeat = self.extractCurrentWordFeatures(features[features.length - 1], i, j, lineWordsWithoutTable, pageWidth, pageHeight, "", topWordFeat, bottomWordFeat, leftWordFeat, rightWordFeat);
                        let rM = self.rightMarginRelative(features[features.length - 1], i, j, lineWordsWithoutTable, pageWidth, pageHeight, "RIGHT_", rightWordFeat);
                        let lM = self.leftMarginRelative(features[features.length - 1], i, j, lineWordsWithoutTable, pageWidth, pageHeight, "LEFT_", leftWordFeat);
                        let tM = self.topMarginRelative(features[features.length - 1], i, j, lineWordsWithoutTable, pageWidth, pageHeight, "TOP_", topWordFeat);
                        let bM = self.bottomMarginRelative(features[features.length - 1], i, j, lineWordsWithoutTable, pageWidth, pageHeight, "BOTTOM_", bottomWordFeat);
                        let hP = self.horizontalPosition(features[features.length - 1], i, j, lineWordsWithoutTable, pageWidth, pageHeight, leftWordFeat, rightWordFeat);
                        let vP = self.verticalPosition(features[features.length - 1], i, j, lineWordsWithoutTable, pageWidth, pageHeight, topWordFeat, bottomWordFeat);
                        // features.push(lineWordsWithoutTable[i][j]);
                        features[features.length - 1] = Object.assign(currentWordFeat, topWordFeat, bottomWordFeat, leftWordFeat, rightWordFeat, rM, lM, tM, bM, hP, vP);
                    }
                }
                return features; //result;
            }
            catch (e) {
                console.log("Error in extractFeatures -----", e);
                return null;
            }
        });
    }
    extractCurrentWordFeatures(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position, topWordFeat, bottomWordFeat, leftWordFeat, rightWordFeat) {
        this.rightMargin(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position);
        this.leftMargin(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position);
        this.topMargin(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position);
        this.bottomMargin(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position);
        this.rightMarginRelative(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position, rightWordFeat);
        this.leftMarginRelative(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position, leftWordFeat);
        this.topMarginRelative(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position, topWordFeat);
        this.bottomMarginRelative(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position, bottomWordFeat);
        // //this.scanHelper.horizontalPosition(features[features.length-1],i,j,lineWordsWithoutTable,pageWidth,pageHeight);
        // this.scanHelper.verticalPosition(features[features.length-1],i,j,lineWordsWithoutTable,pageWidth,pageHeight);
        this.hasDigit(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position);
        this.TextPatterns(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position);
        this.allCaps(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position);
        // this.leftAlignment(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position);
        this.positionOnLine(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position);
        this.pageHeight(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position);
        this.pageWidth(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position);
        this.lineSize(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position);
        this.hasDate(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position);
        this.linewhitespace(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position);
        return currentObject;
    }
    extractTopWordFeatures(currentObject, lineNo, wordNo, lineWordsWithoutTable, pageWidth, pageHeight, position, iterationId, exclusionWords, inclusionWords) {
        // extractTopWordFeatures(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position) {
        //console.log("1",arguments.length);
        // console.log("LinesWOrds ===",JSON.stringify(lineWordsWithoutTable));
        // this.extractCurrentWordFeatures(currentObject,i,j,lineWordsWithoutTable,pageWidth,pageHeight,position);
        let str = '';
        let per;
        let lines = lineWordsWithoutTable;
        let topFeatures = [];
        let self = this;
        let itemFeatures = [];
        let itemWord = 0;
        let topcounter = 0;
        if (lineNo == 9) {
            // console.log("DATEEEEE--------", lines[lineNo][0].Name);
        }
        if (!util_1.isNullOrUndefined(lineNo) && lineNo - (1 + iterationId) >= 1) {
            lines[lineNo - (1 + iterationId)].every(function (item) {
                if ((item.leftX >= lines[lineNo][wordNo].leftX && item.leftX <= lines[lineNo][wordNo].rightX) || (item.rightX <= lines[lineNo][wordNo].rightX && item.rightX >= lines[lineNo][wordNo].rightX)
                    || (item.leftX <= lines[lineNo][wordNo].leftX && item.rightX > lines[lineNo][wordNo].leftX)) {
                    if (item.leftX >= lines[lineNo][wordNo].leftX && item.rightX <= lines[lineNo][wordNo].rightX) {
                        str = item.Name;
                        per = 100;
                    }
                    else if (item.leftX <= lines[lineNo][wordNo].leftX) {
                        per = ((item.rightX - lines[lineNo][wordNo].leftX) / (lines[lineNo][wordNo].rightX - lines[lineNo][wordNo].leftX)) * 100;
                    }
                    else {
                        per = ((lines[lineNo][wordNo].rightX - item.leftX) / (lines[lineNo][wordNo].rightX - lines[lineNo][wordNo].leftX)) * 100;
                    }
                    //extra and condition is added for Ananta's logic 
                    if (per >= 50 && !/\d+/.test(item['Name']) && !/^(?![0,]*(\.0+)?$)([,\d]*(?:\.[0-9]{0,4})?)$/.test(item['Name']) && item.Name != "" && exclusionWords.indexOf(item.Name) == -1 && item.Name.length > 2) {
                        str = str + ' ' + item.Name;
                        itemFeatures.push({
                            TOP_Name: item.Name,
                            TOP_leftX: item.leftX,
                            TOP_topY: item.topY,
                            TOP_rightX: item.rightX,
                            TOP_bottomY: item.bottomY,
                            TOP_index: item.index
                        });
                        // extractCurrentWordFeatures(currentObject, i, j, lineWordsWithoutTable, pageWidth, pageHeight, position, topWordFeat, bottomWordFeat, leftWordFeat, rightWordFeat) {
                        topcounter + 1;
                        self.extractCurrentWordFeatures(itemFeatures[0], lineNo - (1 + iterationId), topcounter, lines, pageWidth, pageHeight, position, "", "", "", "");
                        return false;
                    }
                    else {
                        str = '';
                        //topFeatures = [config.defaultFeatures];
                        topcounter + 1;
                        return true;
                    }
                }
                else {
                    str = '';
                    //   topFeatures = [config.defaultFeatures];
                    topcounter + 1;
                    return true;
                }
                topcounter + 1;
                itemWord++;
            });
        }
        const dec = this.getDecimalNumber(str);
        // currentObject["OnePositionOnTop"] = dec;
        //currentObject["TextOnePositionOnTop"] = "topFeatures";
        //currentObject["TextOnePositionOnTop"]['Name'] = str;
        //topFeatures = [] ;
        //   console.log("ITEM FEATURES ------- " + itemFeatures[0]);
        return itemFeatures[0];
    }
    extractBottomWordFeatures(currentObject, lineNo, wordNo, lineWordsWithoutTable, pageWidth, pageHeight, position, iterationId, exclusionWords, inclusionWords) {
        let str = '';
        let per;
        let lines = lineWordsWithoutTable;
        let botFeatures = [];
        let self = this;
        let itemFeatures = [];
        let itemWord = 0;
        // console.log("Linewordtable---",JSON.stringify(lineWordsWithoutTable));
        // if (!util_1.isNullOrUndefined(lineNo) && lineNo >= 1 && !util_1.isNullOrUndefined(lines[lineNo + 1])) {
        // lines[lineNo + 1].every(function (item) {
        if (lineNo == 5) {
            // console.log("deleveryInvoice--------", lines[lineNo][0].Name);
        }
        if (!util_1.isNullOrUndefined(lineNo) && lineNo + (1 + iterationId) >= 1 && !util_1.isNullOrUndefined(lines[lineNo + (1 + iterationId)])) {
            lines[lineNo + (1 + iterationId)].every(function (item) {
                if ((item.leftX >= lines[lineNo][wordNo].leftX && item.leftX <= lines[lineNo][wordNo].rightX) || (item.rightX <= lines[lineNo][wordNo].rightX && item.rightX >= lines[lineNo][wordNo].rightX)
                    || (item.leftX <= lines[lineNo][wordNo].leftX && item.rightX > lines[lineNo][wordNo].leftX)) {
                    if (item.leftX >= lines[lineNo][wordNo].leftX && item.rightX <= lines[lineNo][wordNo].rightX) {
                        str = item.Name;
                        per = 100;
                    }
                    else if (item.leftX <= lines[lineNo][wordNo].leftX) {
                        per = ((item.rightX - lines[lineNo][wordNo].leftX) / (lines[lineNo][wordNo].rightX - lines[lineNo][wordNo].leftX)) * 100;
                    }
                    else {
                        per = ((lines[lineNo][wordNo].rightX - item.leftX) / (lines[lineNo][wordNo].rightX - lines[lineNo][wordNo].leftX)) * 100;
                    }
                    //extra and condition is added for Ananta's logic 
                    if (per >= 50 && !/\d+/.test(item['Name']) && !/^(?![0,]*(\.0+)?$)([,\d]*(?:\.[0-9]{0,4})?)$/.test(item['Name']) && item.Name != "" && exclusionWords.indexOf(item.Name) == -1 && item.Name.length > 2) {
                        str = str + ' ' + item.Name;
                        // let concatNum=String(item.Name) +String(item.leftX) +String(item.topY) + String(item.rightX) + String(item.bottomY)
                        itemFeatures.push({
                            BOTTOM_Name: item.Name,
                            BOTTOM_leftX: item.leftX,
                            BOTTOM_topY: item.topY,
                            BOTTOM_rightX: item.rightX,
                            BOTTOM_bottomY: item.bottomY,
                            BOTTOM_index: item.index
                        });
                        botFeatures = [];
                        // botFeatures = self.extractCurrentWordFeatures(itemFeatures[0], lineNo + 1, itemWord, lines, pageWidth, pageHeight, position, "", "", "", "");
                        botFeatures = self.extractCurrentWordFeatures(itemFeatures[0], lineNo + (1 + iterationId), itemWord, lines, pageWidth, pageHeight, position, "", "", "", "");
                        return false;
                    }
                    else {
                        str = '';
                        botFeatures = [config.defaultFeatures];
                        return true;
                    }
                }
                else {
                    str = '';
                    botFeatures = [config.defaultFeatures];
                    return true;
                }
                itemWord++;
            });
        }
        const dec = this.getDecimalNumber(str);
        // if(str == '' &&  iterationId < 5 && lineNo >=1 ){
        //     console.log("in Bottom word feature reconsilation function call-----------")
        //     self.extractBottomWordFeatures(currentObject, lineNo, wordNo, lineWordsWithoutTable, pageHeight, pageWidth, "BOTTOM_", iterationId+1 );
        // }else{
        //     console.log("--------ELESSSSSSS in ");
        //     return botFeatures;
        // }
        // currentObject["OnePositionOnTop"] = dec;
        //currentObject["TextOnePositionOnTop"] = "topFeatures";
        //currentObject["TextOnePositionOnTop"]['Name'] = str;
        //topFeatures = [] ;
        return botFeatures;
        //    this.extractCurrentWordFeatures(currentObject,i,j,lineWordsWithoutTable,pageWidth,pageHeight,position);
        //console.log("2",arguments.length);
        //return currentObject;
    }
    extractLeftWordFeatures(currentObject, lineNo, wordNo, lineWordsWithoutTable, pageWidth, pageHeight, position, exclusionWords, inclusionWords) {
        //added exclusionWords,inclusionWords based on Ananta sir's logic for the documentCsvData 

        let lines = lineWordsWithoutTable;
        let leftFeatures = [];
        if (wordNo == 0) {
            //const leftFeat = [];
            //const dec = this.getDecimalNumber(leftFeat);
            // currentObject["TextOnePositionLeft"] = dec;
            //currentObject["TextOnePositionLeftText"] = leftFeat;
            return [];
        }
        else {
            let leftLine = lines[lineNo][wordNo - 1];
            if ((/^(?![0,]*(\.0+)?$)([,\d]*(?:\.[0-9]{0,4})?)$/.test(leftLine['Name']) || /\d+/.test(leftLine['Name']) || (!util_1.isNullOrUndefined(leftLine['Name']) && leftLine['Name'].length < 3) || exclusionWords.indexOf(leftLine['Name']) > -1)) {//This condition is added for Ananta's logic

                for (let i = wordNo - 2; i >= 0; i--) {
                    let element = JSON.parse(JSON.stringify(lines[lineNo][i]));
                    if (!/\d+/.test(element['Name']) && !/^(?![0,]*(\.0+)?$)([,\d]*(?:\.[0-9]{0,4})?)$/.test(element['Name']) && element.Name != "" && exclusionWords.indexOf(element.Name) == -1 && element.Name.length > 2) {
                        leftLine = element;
                        if (inclusionWords.indexOf(element.Name) > 0) {
                            break;
                        }
                    }
                }
            }
            const string = leftLine.Name;
            const dec = this.getDecimalNumber(string);
            //currentObject["TextOnePositionLeft"] = dec;
            //currentObject["TextOnePositionLeftText"] = string;
            let item = {
                LEFT_Name: leftLine.Name,
                LEFT_leftX: leftLine.leftX,
                LEFT_topY: leftLine.topY,
                LEFT_rightX: leftLine.rightX,
                LEFT_bottomY: leftLine.bottomY,
                LEFT_index: leftLine.index
            };
            leftFeatures = this.extractCurrentWordFeatures(item, lineNo, wordNo - 1, lineWordsWithoutTable, pageWidth, pageHeight, position, "", "", "", "");
        }
        return leftFeatures;
    }
    extractRightWordFeatures(currentObject, lineNo, wordNo, lineWordsWithoutTable, pageWidth, pageHeight, position, exclusionWords, inclusionWords) {
        //this.extractCurrentWordFeatures(currentObject,i,j,lineWordsWithoutTable,pageWidth,pageHeight,position);
        //console.log("4",arguments.length);
        //return currentObject;
        let lines = lineWordsWithoutTable;
        let rightFeatures = [];
        if (wordNo == lines[lineNo].length - 1) {
            //const leftFeat = [];
            //const dec = this.getDecimalNumber(leftFeat);
            // currentObject["TextOnePositionLeft"] = dec;
            //currentObject["TextOnePositionLeftText"] = leftFeat;
            return [];
        }
        else if (lines[lineNo].length == 1) {
            return [];
        }
        else {
            let rightLine = lines[lineNo][wordNo + 1];
            const string = rightLine.Name;
            // console.log(rightLine);
            //const dec = this.getDecimalNumber(string);
            //currentObject["TextOnePositionLeft"] = dec;
            //currentObject["TextOnePositionLeftText"] = string;
            if ((/^(?![0,]*(\.0+)?$)([,\d]*(?:\.[0-9]{0,4})?)$/.test(rightLine['Name']) || /\d+/.test(rightLine['Name']) || (!util_1.isNullOrUndefined(rightLine['Name']) && rightLine['Name'].length < 3) || exclusionWords.indexOf(rightLine['Name']) > -1)) {
                //This condition is added for Ananta's logic
                for (let i = wordNo + 2; i < lines[lineNo].length; i++) {
                    let element = JSON.parse(JSON.stringify(lines[lineNo][i]));
                    if (!/\d+/.test(element['Name']) && !/^(?![0,]*(\.0+)?$)([,\d]*(?:\.[0-9]{0,4})?)$/.test(element['Name']) && element.Name != "" && exclusionWords.indexOf(element.Name) == -1 && element.Name.length > 2) {
                        rightLine = element;
                        if (inclusionWords.indexOf(element.Name) > 0) {
                            break;
                        }
                    }
                }
            }
            let item1 = rightLine;
            let concatNum = String(item1.Name) + String(item1.leftX) + String(item1.topY) + String(item1.rightX) + String(item1.bottomY);
            let item = {
                RIGHT_Name: rightLine.Name,
                RIGHT_leftX: rightLine.leftX,
                RIGHT_topY: rightLine.topY,
                RIGHT_rightX: rightLine.rightX,
                RIGHT_bottomY: rightLine.bottomY,
                RIGHT_index: rightLine.index
            };
            rightFeatures = this.extractCurrentWordFeatures(item, lineNo, wordNo + 1, lineWordsWithoutTable, pageWidth, pageHeight, position, "", "", "", "");
        }
        return rightFeatures;
    }
    rightMarginRelative(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position, rightWordFeat) {
        // currentObject["Right Margin Relative"] = (currentObject.rightX/pageWidth)*100;
        if (!util_1.isNullOrUndefined(rightWordFeat)) {
            if (lines[lineNo].length == 1 || wordNo == (lines.length - 1)) {
                currentObject[position + "RightMarginRelative"] = (((0 - currentObject[position + 'rightX']) / pageWidth)).toFixed(4);
                if (isNaN(currentObject[position + "RightMarginRelative"])) {
                    currentObject[position + "RightMarginRelative"] = "";
                }
                else {
                    currentObject[position + "RightMarginRelative"] = Number(currentObject[position + "RightMarginRelative"]).toFixed(4);
                }
            }
            else {
                // currentObject[position + "RightMarginRelative"] = ((util_1.isNullOrUndefined(lines[lineNo][wordNo + 1]) ? 0 : lines[lineNo][wordNo + 1].leftX - currentObject.rightX) / pageWidth) * 100;
                currentObject[position + "RightMarginRelative"] = ((rightWordFeat.RIGHT_leftX - currentObject.rightX) / pageWidth);
                if (isNaN(currentObject[position + "RightMarginRelative"])) {
                    currentObject[position + "RightMarginRelative"] = "";
                }
                else {
                    currentObject[position + "RightMarginRelative"] = Number(currentObject[position + "RightMarginRelative"]).toFixed(4);
                }
            }
            if (currentObject[position + "RightMarginRelative"] < 0) {
                currentObject[position + "RightMarginRelative"] = "";
            }
        }
    }
    leftMarginRelative(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position, leftWordFeat) {
        //currentObject["Left Margin Relative"] = (currentObject.leftX/pageWidth)*100;
        if (!util_1.isNullOrUndefined(leftWordFeat)) {
            if (lines[lineNo].length == 1 || wordNo == 0) {
                currentObject[position + "LeftMarginRelative"] = ((0 - currentObject[position + 'leftX']) / pageWidth);
                if (isNaN(currentObject[position + "LeftMarginRelative"])) {
                    currentObject[position + "LeftMarginRelative"] = "";
                }
                else {
                    currentObject[position + "LeftMarginRelative"] = Number(currentObject[position + "LeftMarginRelative"]).toFixed(4);
                }
            }
            else {
                // currentObject[position + "LeftMarginRelative"] = ((lines[lineNo][wordNo - 1] - currentObject.leftX) / pageWidth) * 100;
                currentObject[position + "LeftMarginRelative"] = ((currentObject.leftX - leftWordFeat.LEFT_rightX) / pageWidth);
                if (isNaN(currentObject[position + "LeftMarginRelative"])) {
                    currentObject[position + "LeftMarginRelative"] = "";
                }
                else {
                    currentObject[position + "LeftMarginRelative"] = Number(currentObject[position + "LeftMarginRelative"]).toFixed(4);
                }
            }
            if (currentObject[position + "LeftMarginRelative"] < 0) {
                currentObject[position + "LeftMarginRelative"] = "";
            }
        }
    }
    topMarginRelative(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position, topWordFeat) {
        let self = this;
        if (!util_1.isNullOrUndefined(topWordFeat)) {
            if (lineNo == 0) {
                currentObject[position + "TopMarginRelative"] = ((0 - currentObject[position + 'topY']) / pageHeight);
                if (isNaN(currentObject[position + "TopMarginRelative"])) {
                    currentObject[position + "TopMarginRelative"] = 0;
                }
                else {
                    currentObject[position + "TopMarginRelative"] = Number(currentObject[position + "TopMarginRelative"]).toFixed(4);
                }
            }
            else {
                if (!util_1.isNullOrUndefined(topWordFeat.TOP_bottomY) && !util_1.isNullOrUndefined(currentObject.topY)) {
                    //  currentObject[position + "TopMarginRelative"] = ((util_1.isNullOrUndefined(lines[lineNo - 1]) ? 0 : lines[lineNo - 1][0].bottomY - currentObject.topY) / pageHeight) * 100;
                    //console.log("KRISHNA", currentObject.topY - topWordFeat.TOP_bottomY);
                    currentObject[position + "TopMarginRelative"] = ((currentObject.topY - topWordFeat.TOP_bottomY) / pageHeight);
                    //  currentObject[position + "TopMarginRelative"] = ((util_1.isNullOrUndefined(lines[lineNo - 1]) ? 0 : topWordFeat.bottomY - currentObject.topY) / pageHeight) * 100;
                    if (isNaN(currentObject[position + "TopMarginRelative"])) {
                        currentObject[position + "TopMarginRelative"] = "";
                    }
                    else {
                        currentObject[position + "TopMarginRelative"] = Number(currentObject[position + "TopMarginRelative"]).toFixed(4);
                    }
                }
                else {
                    currentObject[position + "TopMarginRelative"] = "";
                }
            }
            if (currentObject[position + "TopMarginRelative"] < 0) {
                currentObject[position + "TopMarginRelative"] = "";
            }
        }
    }
    bottomMarginRelative(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position, bottomWordFeat) {
        if (!util_1.isNullOrUndefined(bottomWordFeat)) {
            if (lineNo == (lines.length - 1)) {
                currentObject[position + "BottomMarginRelative"] = ((0 - currentObject[position + 'rightX'] / pageHeight));
                if (isNaN(currentObject[position + "BottomMarginRelative"])) {
                    currentObject[position + "BottomMarginRelative"] = "";
                }
                else {
                    currentObject[position + "BottomMarginRelative"] = Number(currentObject[position + "BottomMarginRelative"]).toFixed(4);
                }
            }
            else {
                if (!util_1.isNullOrUndefined(bottomWordFeat.BOTTOM_topY) && !util_1.isNullOrUndefined(currentObject.bottomY)) {
                    // currentObject[position + "BottomMarginRelative"] = ((util_1.isNullOrUndefined(lines[lineNo + 1]) ? 0 : lines[lineNo + 1][0].bottomY - currentObject.topY) / pageHeight) * 100;
                    currentObject[position + "BottomMarginRelative"] = ((bottomWordFeat.BOTTOM_topY - currentObject.bottomY) / pageHeight);
                    if (isNaN(currentObject[position + "BottomMarginRelative"])) {
                        currentObject[position + "BottomMarginRelative"] = "";
                    }
                    else {
                        currentObject[position + "BottomMarginRelative"] = Number(currentObject[position + "BottomMarginRelative"]).toFixed(4);
                    }
                }
                else {
                    currentObject[position + "BottomMarginRelative"] = "";
                }
            }
            if (currentObject[position + "BottomMarginRelative"] < 0) {
                currentObject[position + "BottomMarginRelative"] = "";
            }
        }
    }
    horizontalPosition(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, leftWordFeat, rightWordFeat) {
        //(Previous word right x- current word word left x)/(Previous word right x- next word left x)
        if (!util_1.isNullOrUndefined(leftWordFeat) && !util_1.isNullOrUndefined(rightWordFeat)) {
            // currentObject["HorizontalPositionRelative"] = (currentObject.leftX - leftWordFeat.LEFT_rightX) / (rightWordFeat.RIGHT_leftX - leftWordFeat.LEFT_rightX).toFixed(4);
            currentObject["HorizontalPositionRelative"] = (currentObject.leftX - leftWordFeat.LEFT_rightX) / ((rightWordFeat.RIGHT_leftX - currentObject.rightX) + (currentObject.leftX - leftWordFeat.LEFT_rightX));
            if (currentObject["HorizontalPositionRelative"] == '-Infinity' || currentObject["HorizontalPositionRelative"] == 'Infinity') {
                currentObject["HorizontalPositionRelative"] = "";
            }
            if (isNaN(currentObject["HorizontalPositionRelative"])) {
                currentObject["HorizontalPositionRelative"] = "";
            }
            else {
                currentObject["HorizontalPositionRelative"] = Number(currentObject["HorizontalPositionRelative"]).toFixed(4);
            }
        }
    }
    verticalPosition(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, topWordFeat, bottomWordFeat) {
        //  (Top word bottom Y- current word word top Y)/(Top word bottom Y- below word  Top Y)
        if (!util_1.isNullOrUndefined(topWordFeat) && !util_1.isNullOrUndefined(bottomWordFeat)) {
            //     currentObject["VerticalPositionRelative"] = Number((currentObject.topY - topWordFeat.TOP_bottomY) / (bottomWordFeat.BOTTOM_topY - topWordFeat.TOP_bottomY)).toFixed(4);
            //  currentObject["VerticalPositionRelative"] = (currentObject.topY - topWordFeat.TOP_bottomY) / (bottomWordFeat.BOTTOM_topY - topWordFeat.TOP_bottomY);
            //  currentObject["VerticalPositionRelative"] = (currentObject.topY - topWordFeat.TOP_bottomY) / (currentObject.bott - topWordFeat.TOP_bottomY);
            currentObject["VerticalPositionRelative"] = (currentObject.topY - topWordFeat.TOP_bottomY) / (((bottomWordFeat.BOTTOM_topY - currentObject.bottomY) + (currentObject.topY - topWordFeat.TOP_bottomY)));
            if (currentObject["VerticalPositionRelative"] == '-Infinity' || currentObject["VerticalPositionRelative"] == 'Infinity') {
                currentObject["VerticalPositionRelative"] = "";
            }
            if (isNaN(currentObject["VerticalPositionRelative"])) {
                currentObject["VerticalPositionRelative"] = "";
            }
            else {
                currentObject["VerticalPositionRelative"] = Number(currentObject["VerticalPositionRelative"]).toFixed(4);
            }
        }
    }
    rightMargin(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position) {
        // if (!util_1.isNullOrUndefined(currentObject) && !util_1.isNullOrUndefined(currentObject.rightX)) {
        currentObject[position + "RightMargin"] = ((currentObject[position + 'rightX'] / pageWidth)).toFixed(4);
        // currentObject[position + "RightMarginRelative"] = ((currentObject[position + 'rightX'] / pageWidth)).toFixed(4);
        if (isNaN(currentObject[position + "RightMargin"])) {
            currentObject[position + "RightMargin"] = 0;
        }
        //  }
    }
    leftMargin(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position) {
        // if (!util_1.isNullOrUndefined(currentObject) && !util_1.isNullOrUndefined(currentObject.leftX)) {
        currentObject[position + "LeftMargin"] = ((currentObject[position + 'leftX'] / pageWidth)).toFixed(4);
        // currentObject[position + "LeftMarginRelative"] = ((currentObject[position + 'leftX'] / pageWidth)).toFixed(4);
        if (isNaN(currentObject[position + "LeftMargin"])) {
            currentObject[position + "LeftMargin"] = 0;
        }
        // }
    }
    // leftAlignment(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position) {
    //     currentObject[position + "leftAlignment"] = ((currentObject[position + 'leftX'] / pageWidth)).toFixed(4);
    //     currentObject.leftX;
    //     if (isNaN(currentObject[position + "LeftMargin"])) {
    //         currentObject[position + "LeftMargin"] = 0;
    //     }
    // }
    topMargin(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position) {
        // if (!util_1.isNullOrUndefined(currentObject) && !util_1.isNullOrUndefined(currentObject.topY)) {
        currentObject[position + "TopMargin"] = ((currentObject[position + 'topY'] / pageHeight)).toFixed(4);
        // currentObject[position + "TopMarginRelative"] = ((currentObject[position + 'topY'] / pageHeight)).toFixed(4);
        if (isNaN(currentObject[position + "TopMargin"])) {
            currentObject[position + "TopMargin"] = 0;
        }
        //  }
    }
    bottomMargin(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position) {
        // if (!util_1.isNullOrUndefined(currentObject) && !util_1.isNullOrUndefined(currentObject.bottomY)) {
        // currentObject[position + "BottomMargin"] = ((currentObject[position + 'topY'] / pageHeight) * 100).toFixed(2);
        currentObject[position + "BottomMargin"] = ((currentObject[position + 'bottomY'] / pageHeight)).toFixed(4);
        // currentObject[position + "BottomMarginRelative"] = ((currentObject[position + 'bottomY'] / pageHeight)).toFixed(4);
        if (isNaN(currentObject[position + "BottomMargin"])) {
            currentObject[position + "BottomMargin"] = 0;
        }
        // }
    }
    hasDigit(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position) {
        if (isNaN(currentObject[position + 'Name'])) {
            currentObject["HasDigit"] = 0;
        }
        else {
            currentObject["HasDigit"] = 1;
        }
    }
    allCaps(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position) {
        let isallcaps = currentObject[position + 'Name'];
        let checkCaps = isallcaps.toUpperCase();
        if (isallcaps === checkCaps) {
            currentObject[position + "isAllCaps"] = 1;
        }
        else {
            currentObject[position + "isAllCaps"] = 0;
        }
    }
    TextPatterns(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position) {
        //console.log("Dataaa----", currentObject);
        // if (!isNaN(currentObject[position + 'Name'])) {
        // if (str.toLowerCase() === item.Name.toLowerCase()) {
        let currentObjName = currentObject["Name"];
        // console.log("KKK---", currentObjName);
        if (!util_1.isNullOrUndefined(currentObjName)) {
            let currentObj = currentObjName.replace(/[^\w\s]/gi, '?');
            let finalTextpat = currentObj.replace(/[A-Z]/g, "X").replace(/[a-z]/g, 'x').replace(/  +/g, ' ').replace(/[0-9]/g, '0');
            //   console.log("KRISHNA---finalll-", finalTextpat);
            // let cu1= currentObject[position"Name"];
            //   console.log("KRISHNA---", currentObject['Name']);
            // currentObject[position + "AllCapsTextPatterns"]= k.toUpperCase();
            currentObject[position + "TextPatterns"] = finalTextpat;
        }
        // }
        // else {
        // currentObject[position = "HasDigit"] = 0;
        // }
    }
    pageHeight(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position) {
        currentObject[position + "PageHeight"] = pageHeight;
    }
    pageWidth(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position) {
        currentObject[position + "PageWidth"] = pageWidth;
    }
    positionOnLine(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position) {
        // Count of words to the left of this N-gram normalized to the count of total words on this line
        currentObject[position + "PositionOnLine"] = (wordNo / lines[lineNo].length).toFixed(4);
        // if( currentObject[position + "PositionOnLine"] == 0 || currentObject[position + "PositionOnLine"] == "0"){
        //     currentObject[position + "PositionOnLine"]= "";
        // }
        // console.log("dattaa---", currentObject);
    }
    lineSize(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position) {
        // Count of words to the left of this N-gram normalized to the count of total words on this line
        currentObject[position + "LineSize"] = lines[lineNo].length;
    }
    hasDate(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position) {
        // Count of words to the left of this N-gram normalized to the count of total words on this line//currentObject["Has Date"] = lines[lineNo].length;
        if (isNaN(currentObject[position + 'Name'])) {
            const string = currentObject[position + 'Name'];
            //   console.log('strinnnnnng', string);
            // const date = string.replace(/[`~!@#$%^&*()_|+\-=÷¿?;:'",.<>\{\}\[\]\\\/`]/gi, ' ');
            const date1 = string.replace(/[`~!@#$%^&*()_|+\-=÷¿?;:'",.<>\{\}\[\]\\\/`]/gi, ' ').replace(/ /, '');
            let date = date1.replace(/\s/g, '');
            var neglectFormats = ['YYYYDDD'];
            let d = moment(date, [moment.ISO_8601,
                // "MMM YYYY", "MMM YY", "DD MM YYYY", "MM DD YYYY", "YYYY MM DD", "D MMMM YYYY", "YYYY MM D",
                // "D MMM YYYY", "DD MM YY HH MM", "D MM YY HH MM", "DD MM YYYY HH MM",
                // "D MM YYYY HH MM", "DD   MM   YYYY HH   mm a", "MM   DD   YYYY HH   mm a",
                // "DD   MM   YYYY HH   mm A", "MM   DD   YYYY HH   mm A", "DD   MM   YYYY HH   mm",
                // "MM   DD   YYYY HH   mm", "DD MM YYYY HH mm a", "MM DD YYYY HH mm a", "DD MM YYYY HH mm A",
                // "MM DD YYYY HH mm A", "DD MM YYYY HH mm", "MM DD YYYY HH mm", 'DD   MM   YYYY', 'MM   DD   YYYY'], true).isValid()) {
                "DDMMYYYY", "DDMMMYYYY", "DDMMYY", "MMMYYYY", "MMMYY", "MMDDYYYY", "YYYYMMDD", "DMMMMYYYY", "YYYYMMD",
                "DMMMYYYY", "DDMMYYHHMM", "DMMYYHHMM", "DDMMYYYYHHMM", "DDMMMYY",
                "DMMYYYYHHMM", "DDMMYYYYHHmma", "MMDDYYYYHHmma",
                "DDMMYYYYHHmmA", "MMDDYYYYHHmmA", "DDMMYYYYHHmm",
                "MMDDYYYYHHmm", "DDMMYYYYHHmma", "MMDDYYYYHHmma", "DDMMYYYYHHmmA",
                "MMDDYYYYHHmmA", "DDMMYYYYHHmm", "MMDDYYYYHHmm", 'DDMMYYYY', 'MMDDYYYY'], true)
            if (d.isValid() && !neglectFormats.includes(d._f)) {
                currentObject[position + "HasDate"] = 1;
            }
            else {
                currentObject[position + "HasDate"] = 0;
            }
        }
        else {
            currentObject[position + "HasDate"] = 0;
        }
    }
    linewhitespace(currentObject, lineNo, wordNo, lines, pageWidth, pageHeight, position) {
        // console.log("curentObj---",currentObject);
        let a = [];
        if (!util_1.isNullOrUndefined(lineNo)) {
            lines[lineNo].forEach(element => {
                let wordspace = element.rightX - element.leftX;
                a.push(wordspace);
            });
            // var a = [1,2,3];
            var sum = a.reduce(function (a, b) { return a + b; }, 0);
            currentObject[position + "linewhitespace"] = ((pageWidth - sum) / pageWidth).toFixed(4);
        }
        if (!util_1.isNullOrUndefined(lineNo) && lineNo >= 1) {
            lines[lineNo].every(function (item) {
            });
        }
    }
    findOverLapping(arr, lineArray, tableHeaders, scanD) {
        let line = JSON.parse(JSON.stringify(lineArray));
        let arrOld = JSON.parse(JSON.stringify(arr));
        let result = [];
        let lineE = [];
        let overlapping = true;
        let duplicateFound = false;
        let overLappingNew = false;
        let digitConcat = true;
        for (let i = 0; i < arr.length; i++) {
            let a = arr[i];
            let b;
            let aWidth = a.rightX - a.leftX;
            // let matched = false;
            for (let j = 0; j < line.length; j++) {
                b = line[j];
                if (!util_1.isNullOrUndefined(b)) {
                    let bWidth = b.rightX - b.leftX;
                    if (aWidth < bWidth) {
                        let aMean = aWidth / 2;
                        aWidth = a.leftX + aMean;
                        if (b.leftX <= aWidth && aWidth <= b.rightX) {
                            if (a.Name.replace(/\]+/g, '') == b.Name.replace(/\]+/g, '') && a.length > 2) {
                                duplicateFound = true;
                                console.log('+++++++++++++++++++++++++++++++');
                            }
                            else {

                                if (tableHeaders.indexOf(b.Name.replace(/\s+/g, '').toUpperCase()) > -1) {
                                    if (tableHeaders.indexOf(a.Name.replace(/\s+/g, '').toUpperCase()) == -1) {
                                        let allow = true;
                                        for (let value of Object.values(scanD.data.tableMapping)) {
                                            value = value.toUpperCase();
                                            if (value.includes(b.Name.toUpperCase()) && value.includes("|")) {
                                                allow = false;
                                            }
                                        }
                                        if (!util_1.isNullOrUndefined(scanD.data.subHeaderBreakWords) && scanD.data.subHeaderBreakWords.length > 0) {
                                            for (const item of scanD.data.subHeaderBreakWords) {
                                                for (const prop in item) {
                                                    const value = item[prop];
                                                    if (typeof value === "object" && (value.start.includes(b.Name) || value.end.includes(b.Name))) {
                                                        allow = false;
                                                    }
                                                }
                                            }
                                        }
                                        if (allow) {
                                            // a.leftX = 0;
                                            // a.rightX = 0;
                                            // line[j]['matched'] = true;
                                            // line[j]['allowPush'] = true;
                                        }

                                    }

                                }
                                if (util_1.isNullOrUndefined(line[j]['matched'])) {
                                    // obj[a.Name]=b.Name.replace('~', '');
                                    // nextLine.splice(j, 1);
                                    if (tableHeaders.indexOf(b.Name.replace(/\s+/g, '').toUpperCase()) > -1) {
                                        // lineArray[j]['verticalTableHeader'] = true;
                                        // line[j]['verticalTableHeader'] = true;
                                        // overLappingNew = true;
                                    }
                                    if (isNaN(a.Name.replace('~', '')) && isNaN(b.Name.replace('~', '')) && util_1.isNullOrUndefined(lineArray[j]['verticalTableHeader'])) {
                                        let newWord = a.Name + ' ' + b.Name;
                                        newWord = newWord.replace(/@@n|\s/g, '').toUpperCase();
                                        let newWord1 = a.Name.toUpperCase();
                                        newWord1 = newWord1.replace(/@@N|\s/g, '');
                                        let all=false;
                                            for (let index = 0; index < tableHeaders.length; index++) {
                                                let element = tableHeaders[index];
                                                if(element.includes(newWord1)){
                                                    all=true;
                                                }
                                            }
                                            let allNew=false;
                                            for (let index = 0; index < tableHeaders.length; index++) {
                                                let element = tableHeaders[index];
                                                if(element.includes(newWord) && newWord.length>3){
                                                    allNew=true;
                                                }
                                            }
                                        if (tableHeaders.indexOf(newWord1) > -1 || all) {
                                            if (tableHeaders.indexOf(newWord) > -1 || allNew) {
                                                arr[i].Name = a.Name + '@@n' + b.Name;
                                                arr[i].rightX = arr[i].rightX < b.rightX ? b.rightX : arr[i].rightX;
                                                arr[i].leftX = arr[i].leftX > b.leftX ? b.leftX : arr[i].leftX;
                                                line[j]['matched'] = true;
                                                overLappingNew = true;
                                            }
                                            else {
                                                // line[j]['matched']=true;
                                                //   lineE.push(b);
                                                overlapping = false;
                                            }
                                        }
                                        else {
                                            let all = true;
                                            // if(i<arr.length-1){
                                            for (let m = i + 1; m < arr.length; m++) {
                                                let c = arr[m];
                                                let diff = a.rightX - a.leftX;
                                                let wordLength = a.Name.length;
                                                let wordDiff = c.leftX - a.rightX;
                                                if (c.Name == ":" || /^\:/.test(c.Name)) {
                                                    wordDiff = 0;
                                                }
                                                if (wordDiff >= 0 && wordDiff <= (diff / wordLength) * 1 && (!/(\d)[(\,)(\.)]/.test(c.Name) || /^\(.+\)$/.test(c.Name) || /^\:\(.+\)$/.test(c.Name)) && c.Name != "|" && a.Name != "|" &&
                                                    !/^\|/.test(c.Name.trim()) && !/^\{/.test(c.Name) && !/\d\s\d/.test(a.Name) && !/^\'/.test(c.Name)) {
                                                    all = false;
                                                } else if (!all && util_1.isNullOrUndefined(line[j]['matched'])) {
                                                    if (b.rightX > c.leftX && b.leftX < c.rightX) {
                                                        if (b.Name.includes(")") && !b.Name.includes("(") || (b.Name.includes("(") && !b.Name.includes(")"))) {
                                                            arr[m].Name = arr[m].Name + ' ' + b.Name;
                                                        } else {
                                                            if (arr[m].topY == b.topY && arr[m].bottomY == b.bottomY) {
                                                                arr[m].Name = arr[m].Name + ' ' + b.Name;
                                                            } else {
                                                                arr[m].Name = arr[m].Name + '@@n' + b.Name;
                                                            }
                                                        }
                                                        arr[m].rightX = arr[m].rightX < b.rightX ? b.rightX : arr[m].rightX;
                                                        arr[m].leftX = arr[m].leftX > b.leftX ? b.leftX : arr[m].leftX;

                                                    } else {
                                                        if (b.Name.includes(")") && !b.Name.includes("(") || (b.Name.includes("(") && !b.Name.includes(")"))) {
                                                            arr[m - 1].Name = arr[m - 1].Name + ' ' + b.Name;
                                                        } else {
                                                            if (arr[m - 1].topY == b.topY && arr[m - 1].bottomY == b.bottomY) {
                                                                arr[m - 1].Name = arr[m - 1].Name + ' ' + b.Name;
                                                            } else {
                                                                arr[m - 1].Name = arr[m - 1].Name + '@@n' + b.Name;
                                                            }
                                                        }
                                                        arr[m - 1].rightX = arr[m - 1].rightX < b.rightX ? b.rightX : arr[m - 1].rightX;
                                                        arr[m - 1].leftX = arr[m - 1].leftX > b.leftX ? b.leftX : arr[m - 1].leftX;

                                                    }

                                                    line[j]['matched'] = true;
                                                    overLappingNew = true;
                                                    break;
                                                }
                                                if (m == arr.length - 1 && !all && util_1.isNullOrUndefined(line[j]['matched'])) {
                                                    if (b.Name.includes(")") && !b.Name.includes("(") || (b.Name.includes("(") && !b.Name.includes(")"))) {
                                                        arr[m].Name = arr[m].Name + ' ' + b.Name;
                                                    } else {
                                                        if (arr[m].topY == b.topY && arr[m].bottomY == b.bottomY) {
                                                            arr[m].Name = arr[m].Name + ' ' + b.Name;
                                                        } else {
                                                            arr[m].Name = arr[m].Name + '@@n' + b.Name;
                                                        }
                                                    }
                                                    arr[m].rightX = arr[m].rightX < b.rightX ? b.rightX : arr[m].rightX;
                                                    arr[m].leftX = arr[m].leftX > b.leftX ? b.leftX : arr[m].leftX;
                                                    arr[m].topY = b.topY;
                                                    arr[m].bottomY = b.bottomY;
                                                    line[j]['matched'] = true;
                                                    overLappingNew = true;
                                                }
                                            }
                                            // }
                                            if (all && (i == arr.length - 1 || (i < arr.length - 1 && !(b.rightX > arr[i + 1].leftX && b.leftX < arr[i + 1].rightX)))) {
                                                if (b.Name.includes(")") && !b.Name.includes("(") || (b.Name.includes("(") && !b.Name.includes(")"))) {
                                                    arr[i].Name = a.Name + ' ' + b.Name;
                                                } else {
                                                    if (a.topY == b.topY && a.bottomY == b.bottomY) {
                                                        arr[i].Name = a.Name + ' ' + b.Name;
                                                    } else {
                                                        arr[i].Name = a.Name + '@@n' + b.Name;
                                                    }
                                                }
                                                arr[i].rightX = arr[i].rightX < b.rightX ? b.rightX : arr[i].rightX;
                                                arr[i].leftX = arr[i].leftX > b.leftX ? b.leftX : arr[i].leftX;

                                                // arr[i].leftX = arr[i].leftX > b.leftX ? b.leftX : arr[i].leftX;
                                                line[j]['matched'] = true;
                                                overLappingNew = true;
                                            }

                                        }
                                    }
                                    else {
                                        // line[j]['matched']=true;
                                        // lineE.push(b);
                                        overlapping = false;
                                    }
                                }
                            }
                        }
                    }
                    else {
                        let bMean = bWidth / 2;
                        bWidth = b.leftX + bMean;
                        if (a.leftX <= bWidth && bWidth <= a.rightX) {
                            if (a.Name.replace(/\]+/g, '') == b.Name.replace(/\]+/g, '') && a.length > 2) {
                                duplicateFound = true;
                                console.log('+++++++++++++++++++++++++++++++');
                            }
                            else {
                                if (tableHeaders.indexOf(b.Name.replace(/\s+/g, '').toUpperCase()) > -1) {
                                    if (tableHeaders.indexOf(a.Name.replace(/\s+/g, '').toUpperCase()) == -1) {
                                        let allow = true;
                                        for (let value of Object.values(scanD.data.tableMapping)) {
                                            value = value.toUpperCase();
                                            if (value.includes(b.Name.toUpperCase()) && value.includes("|")) {
                                                allow = false;
                                            }
                                        }
                                        if (!util_1.isNullOrUndefined(scanD.data.subHeaderBreakWords) && scanD.data.subHeaderBreakWords.length > 0) {
                                            for (const item of scanD.data.subHeaderBreakWords) {
                                                for (const prop in item) {
                                                    const value = item[prop];
                                                    if (typeof value === "object" && (value.start.includes(b.Name) || value.end.includes(b.Name))) {
                                                        allow = false;
                                                    }
                                                }
                                            }
                                        }

                                        if (allow) {
                                            // a.leftX = 0;
                                            // a.rightX = 0;
                                            // line[j]['matched'] = true;
                                            // line[j]['allowPush'] = true;
                                        }
                                    }

                                }
                                if (util_1.isNullOrUndefined(line[j]['matched'])) {
                                    // obj[a.Name]=b.Name.replace('~', '');
                                    // nextLine.splice(j, 1);
                                    let al = false;
                                    for (let m = 0; m < tableHeaders.length; m++) {
                                        let newName = a.Name + " " + b.Name;
                                        newName = newName.toLocaleUpperCase();
                                        newName = newName.replace(/@@N|\s/g, '');
                                        newName = newName.replace(/\]+/g, '');
                                        if (tableHeaders[m].includes(newName) && newName.length >= 3) {
                                            al = true;
                                        }
                                    }
                                    if (b.rightX > a.leftX && b.leftX < a.rightX) {
                                        al = true;
                                    }
                                    if (b.topY > a.bottomY || al) {
                                        if (tableHeaders.indexOf(b.Name.replace(/\s+/g, '').toUpperCase()) > -1) {
                                            // lineArray[j]['verticalTableHeader'] = true;
                                            // line[j]['verticalTableHeader'] = true;
                                            // overLappingNew = true;
                                        }
                                        if (isNaN(a.Name.replace('~', '')) && isNaN(b.Name.replace('~', '')) && util_1.isNullOrUndefined(lineArray[j]['verticalTableHeader'])) {
                                            let newWord = a.Name + ' ' + b.Name;
                                            newWord = newWord.replace(/@@n|\s/g, '').toUpperCase();
                                            let newWord1 = a.Name.toUpperCase();
                                            newWord1 = newWord1.replace(/@@N|\s/g, '');
                                            let all=false;
                                            for (let index = 0; index < tableHeaders.length; index++) {
                                                let element = tableHeaders[index];
                                                if(element.includes(newWord1)){
                                                    all=true;
                                                }
                                            }
                                            let allNew=false;
                                            for (let index = 0; index < tableHeaders.length; index++) {
                                                let element = tableHeaders[index];
                                                if(element.includes(newWord) && newWord.length>3){
                                                    allNew=true;
                                                }
                                            }
                                            if (tableHeaders.indexOf(newWord1) > -1 || all) {
                                                if (tableHeaders.indexOf(newWord) > -1 || allNew) {
                                                    arr[i].Name = a.Name + '@@n' + b.Name;
                                                    arr[i].rightX = arr[i].rightX < b.rightX ? b.rightX : arr[i].rightX;
                                                    arr[i].leftX = arr[i].leftX > b.leftX ? b.leftX : arr[i].leftX;
                                                    arr[i].topY = b.topY;
                                                    arr[i].bottomY = b.bottomY;
                                                    line[j]['matched'] = true;
                                                    overLappingNew = true;
                                                }
                                                else {
                                                    // lineE.push(b);
                                                    overlapping = false;
                                                }
                                            }
                                            else {
                                                let all = true;
                                                for (let m = i + 1; m < arr.length; m++) {
                                                    let c = arr[m];
                                                    let diff = a.rightX - a.leftX;
                                                    let wordLength = a.Name.length;
                                                    let wordDiff = c.leftX - a.rightX;
                                                    if (c.Name == ":" || /^\:/.test(c.Name)) {
                                                        wordDiff = 0;
                                                    }
                                                    if (wordDiff >= 0 && wordDiff <= (diff / wordLength) * 1 && (!/(\d)[(\,)(\.)]/.test(c.Name) || /^\(.+\)$/.test(c.Name) || /^\:\(.+\)$/.test(c.Name)) && c.Name != "|" && a.Name != "|" &&
                                                        !/^\|/.test(c.Name.trim()) && !/^\{/.test(c.Name) && !/\d\s\d/.test(a.Name) && !/^\'/.test(c.Name)) {
                                                        all = false;
                                                    } else if (!all && util_1.isNullOrUndefined(line[j]['matched'])) {
                                                        if (b.rightX > c.leftX && b.leftX < c.rightX) {
                                                            if (b.Name.includes(")") && !b.Name.includes("(") || (b.Name.includes("(") && !b.Name.includes(")"))) {
                                                                arr[m].Name = arr[m].Name + ' ' + b.Name;
                                                            } else {
                                                                if (arr[m].topY == b.topY && arr[m].bottomY == b.bottomY) {
                                                                    arr[m].Name = arr[m].Name + ' ' + b.Name;
                                                                } else {
                                                                    arr[m].Name = arr[m].Name + '@@n' + b.Name;
                                                                }
                                                            }
                                                            arr[m].rightX = arr[m].rightX < b.rightX ? b.rightX : arr[m].rightX;
                                                            arr[m].leftX = arr[m].leftX > b.leftX ? b.leftX : arr[m].leftX;
                                                            arr[m].topY = b.topY;
                                                            arr[m].bottomY = b.bottomY;
                                                        } else {
                                                            if (b.Name.includes(")") && !b.Name.includes("(") || (b.Name.includes("(") && !b.Name.includes(")"))) {
                                                                arr[m - 1].Name = arr[m - 1].Name + ' ' + b.Name;
                                                            } else {
                                                                if (arr[m - 1].topY == b.topY && arr[m - 1].bottomY == b.bottomY) {
                                                                    arr[m - 1].Name = arr[m - 1].Name + ' ' + b.Name;
                                                                } else {
                                                                    arr[m - 1].Name = arr[m - 1].Name + '@@n' + b.Name;
                                                                }
                                                            }
                                                            arr[m - 1].rightX = arr[m - 1].rightX < b.rightX ? b.rightX : arr[m - 1].rightX;
                                                            arr[m - 1].leftX = arr[m - 1].leftX > b.leftX ? b.leftX : arr[m - 1].leftX;
                                                            arr[m - 1].bottomY = b.bottomY;
                                                        }

                                                        line[j]['matched'] = true;
                                                        overLappingNew = true;
                                                        break;
                                                    }
                                                    if (m == arr.length - 1 && !all && util_1.isNullOrUndefined(line[j]['matched'])) {
                                                        if (b.Name.includes(")") && !b.Name.includes("(") || (b.Name.includes("(") && !b.Name.includes(")"))) {
                                                            arr[m].Name = arr[m].Name + ' ' + b.Name;
                                                        } else {

                                                            if (arr[m].topY == b.topY && arr[m].bottomY == b.bottomY) {
                                                                arr[m].Name = arr[m].Name + ' ' + b.Name;
                                                            } else {
                                                                arr[m].Name = arr[m].Name + '@@n' + b.Name;
                                                            }
                                                        }
                                                        arr[m].rightX = arr[m].rightX < b.rightX ? b.rightX : arr[m].rightX;
                                                        arr[m].leftX = arr[m].leftX > b.leftX ? b.leftX : arr[m].leftX;
                                                        arr[m].topY = b.topY;
                                                        arr[m].bottomY = b.bottomY;
                                                        line[j]['matched'] = true;
                                                        overLappingNew = true;
                                                    }
                                                }
                                                if (all && (i == arr.length - 1 || (i < arr.length - 1 && !(b.rightX > arr[i + 1].leftX && b.leftX < arr[i + 1].rightX)))) {
                                                    if (b.Name.includes(")") && !b.Name.includes("(") || (b.Name.includes("(") && !b.Name.includes(")"))) {
                                                        arr[i].Name = a.Name + ' ' + b.Name;
                                                    } else {
                                                        if (a.topY == b.topY && a.bottomY == b.bottomY) {
                                                            arr[i].Name = a.Name + ' ' + b.Name;
                                                        } else {
                                                            arr[i].Name = a.Name + '@@n' + b.Name;
                                                        }
                                                    }
                                                    arr[i].rightX = arr[i].rightX < b.rightX ? b.rightX : arr[i].rightX;
                                                    arr[i].leftX = arr[i].leftX > b.leftX ? b.leftX : arr[i].leftX;

                                                    // arr[i].leftX = arr[i].leftX > b.leftX ? b.leftX : arr[i].leftX;
                                                    arr[i].topY = b.topY;
                                                    arr[i].bottomY = b.bottomY;
                                                    line[j]['matched'] = true;
                                                    overLappingNew = true;
                                                }
                                            }
                                        }
                                        else {
                                            //lineE.push(b);
                                            overlapping = false;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (line && Array.isArray(line) && arr) {
                let allo = true;
                for (let index = 0; index < line.length; index++) {
                    const element = line[index];
                    if (element['header']) {
                        allo = false;
                    }

                }
                let currentHeader=false;
                for (let index = 0; index < lineArray.length; index++) {
                    let element = lineArray[index];
                    for (let l = 0; l < tableHeaders.length; l++) {
                        const ele = tableHeaders[l];
                        let newName = element["Name"].toLocaleUpperCase();
                        newName = newName.replace(/\s+/g, '');
                        newName = newName.replace(/[^a-zA-Z0-9]/g, "");
                        if(newName.length>2 && ele.includes(newName)){
                            currentHeader=true;
                            break;
                        }
                    }
                    
                  }
                  let lastHeader=false;
                  for (let index = 0; index < arr.length; index++) {
                      let element = arr[index];
                      for (let l = 0; l < tableHeaders.length; l++) {
                          const ele = tableHeaders[l];
                          let newName = element["Name"].toLocaleUpperCase();
                          newName = newName.replace(/\s+/g, '');
                          newName = newName.replace(/[^a-zA-Z0-9]/g, "");
                          if(newName.length>2 && ele.includes(newName)){
                            lastHeader=true;
                              break;
                          }
                      }
                      
                    }
                    if(lastHeader && currentHeader){
                        allo = false;
                    }
                let vk = line.filter(a => (a.leftX && a.rightX && arr[i].leftX && arr[i].rightX && (a.leftX + a.rightX) / 2 > arr[i].leftX) && ((a.leftX + a.rightX) / 2 < arr[i].rightX))
                if (vk && vk.length == 1 && vk[0].Name && ((/^\d+\.\d+$/.test(vk[0].Name)) || (/^[\d+\,+\d+\.]+$/.test(vk[0].Name)))) {
                    if (allo) {
                        digitConcat = false;
                    }
                }
                if (vk && vk.length == 1 && vk[0].Name && !arr[i].Name.includes(vk[0].Name) && (vk[0]['allowMerge'] || (!(/^\d+\.\d+$/.test(vk[0].Name)) && !(/^[\d+\,+\d+\.]+$/.test(vk[0].Name))))) {
                    // arr[i].text = arr[i].text+' '+vk[0].text;
                    let val = arr[i].Name + ' ' + vk[0].Name;
                    let val1 = vk[0].Name + ' ' + arr[i].Name;
                    if (val && tableHeaders.indexOf(val.replace(/\s+/g, '').toUpperCase()) > -1) {
                        arr[i].Name = val;
                        overlapping = true;
                        vk[0].matched = true;
                        arr[i].rightX = arr[i].rightX < vk[0].rightX ? vk[0].rightX : arr[i].rightX;
                    }
                    else if (val1 && tableHeaders.indexOf(val1.replace(/\s+/g, '').toUpperCase()) > -1) {
                        arr[i].Name = val1;
                        overlapping = true;
                        vk[0].matched = true;
                        arr[i].rightX = arr[i].rightX < vk[0].rightX ? vk[0].rightX : arr[i].rightX;
                    }
                }
            }
        }
        for (let j = 0; j < line.length; j++) {
            if (util_1.isNullOrUndefined(line[j]['matched']) || line[j]['allowPush']) {
                arr.push(line[j]);
            }
        }
        arr = arr.filter(function (x) { return x['rightX'] != 0; })
        // arr = arr.concat(line);
        if ((!overlapping && !overLappingNew) || !digitConcat) {
            if (!(lineArray.length > 0 && lineArray[0]['allowMerge']) && !(lineArray.length > 0 && lineArray[0]['verticalTableHeader'])) {
                lineE = lineArray;
                arr = arrOld;
            }
        }
        return { arr: arr, duplicateFound: duplicateFound, lineE: lineE };
    }
    csvGenerate(data, headers, fileRefNum, entity, filePath) {
        try {
            console.log("Inside CgenerateCSVFile-------------------");
            let csv = json2csv({ data: data, fields: headers, fieldNames: headers });
            // let fileName = config.path + fileRefNum + "_" + entity + ".csv";
            let filepath2 = filePath.replace(/.png|.jpg/, '');
            let fileName = filepath2 + "_" + entity + ".csv";
            console.log("filename>>>", fileName);
            fs.writeFileSync(fileName, csv);
            fs.chmodSync(fileName, 0o777);
            // let temp = yield execSync('chmod -R 777 ' + fileName);
            logger.info('Csv generated successfully');
            return fileName;
        }
        catch (err) {
            logger.error('In generate csv file - ' + err);
        }
    }
    createHandWrittenObject(fileData, invObj, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let self = this;
                invObj["prediction"] = [];
                self.getScanningFieldsData(fileData, function (err, data) {
                    return __awaiter(this, void 0, void 0, function* () {
                        if (err && util_1.isNullOrUndefined(data)) {
                            throw err;
                        }
                        else {
                            let ocrCor = [];
                            if (!util_1.isNullOrUndefined(data.fields) && data.fields.length > 0) {
                                data.fields.forEach((field) => {
                                    if (field.fieldType != 'Checkbox') {
                                        let str = '';
                                        let obj = { "leftX": 0, "rightX": 0, "topY": 0, "bottomY": 0, "Name": '' };
                                        let count = 0;
                                        fileData.Lines.forEach((row) => {
                                            row.forEach((item) => {
                                                if (field.leftX <= item.leftX && field.rightX >= item.rightX && field.topY <= item.topY && field.bottomY >= item.bottomY) {
                                                    // str = str + '' + item.Name;
                                                    if (count == 0) {
                                                        obj["leftX"] = item["leftX"];
                                                        obj["rightX"] = item["rightX"];
                                                        obj["topY"] = item["topY"];
                                                        obj["bottomY"] = item["bottomY"];
                                                    }
                                                    else {
                                                        obj["rightX"] = item["rightX"];
                                                    }
                                                    str = str + '' + item.Name.replace(/[`~!@#$%^&*()_|+\-=÷¿?;:'",.<>\{\}\[\]\\\/`]/gi, '');
                                                    count++;
                                                }
                                            });
                                        });
                                        invObj[field.fieldName] = str;
                                        obj["Name"] = field.fieldName;
                                        if (field.fieldName == 'Gender' || field.fieldName == 'Critical Disease Family' || field.fieldName == 'Critical Disease Self'
                                            || field.fieldName == 'Marital Status' || field.fieldName == 'Occupation' || field.fieldName == 'Tobacco User') {
                                        }
                                        else {
                                            ocrCor.push(JSON.parse(JSON.stringify(obj)));
                                        }
                                    }
                                    else {
                                    }
                                });
                            }
                            for (let m = 0; m < ocrCor.length; m++) {
                                if (ocrCor[m].fieldType != 'Checkbox') {
                                    let bobj;
                                    fileData.confidanceBox.forEach(item => {
                                        if (ocrCor[m].leftX >= item.leftX && ocrCor[m].rightX <= item.rightX && ocrCor[m].topY >= item.topY && ocrCor[m].bottomY <= item.bottomY) {
                                            bobj = item;
                                            return bobj;
                                        }
                                    });
                                    // console.log("Predicted value" + JSON.stringify(bobj));
                                    if (util_1.isNullOrUndefined(bobj)) {
                                        invObj["prediction"].push({ "ml": "100%", "isColor": false, "key": ocrCor[m].Name });
                                    }
                                    else {
                                        invObj["prediction"].push({ "ml": (Number(bobj.confidence) * 100).toFixed(2) + '%', "isColor": Number(bobj.confidence) * 100 > 80 ? false : true, "key": ocrCor[m].Name });
                                    }
                                }
                            }
                            let pycommand = 'python ' + config.scriptFilePath + 'Pixel_count.py ' + fileData.obj.imagesPath[0].imageFilePath;
                            // console.log("python command" + pycommand);
                            let pythonop = yield self.terminalCoomand(pycommand);
                            let checkData = JSON.parse(pythonop.output);
                            let validCheck = checkData.filter(check => {
                                return check.IsClicked == 'Yes';
                            });
                            let gender = ['Male', 'Female', 'Other'];
                            let mStatus = ['Married', 'Single', 'Divorced', 'Widowed'];
                            let occupation = ['Business', 'Salaried', 'Professional'];
                            let tUser = ['TobaccoY', 'TobaccoN'];
                            let cds = ['CDSelfY', 'CDSelfN'];
                            let cdf = ['CDFamilyY', 'CDFamilyN'];
                            for (let k = 0; k < validCheck.length; k++) {
                                let validvalue = validCheck[k].fieldName;
                                let ind = gender.indexOf(validCheck[k].fieldName);
                                if (gender.indexOf(validCheck[k].fieldName) >= 0) {
                                    invObj["Gender"] = validCheck[k].fieldName;
                                    invObj["prediction"].push({ "ml": "100%", "isColor": false, "key": "Gender" });
                                }
                                else if (mStatus.indexOf(validCheck[k].fieldName) >= 0) {
                                    invObj["Marital Status"] = validCheck[k].fieldName;
                                    invObj["prediction"].push({ "ml": "100%", "isColor": false, "key": "Marital Status" });
                                }
                                else if (occupation.indexOf(validCheck[k].fieldName) >= 0) {
                                    invObj["Occupation"] = validCheck[k].fieldName;
                                    invObj["prediction"].push({ "ml": "100%", "isColor": false, "key": "Occupation" });
                                }
                                else if (tUser.indexOf(validCheck[k].fieldName) >= 0) {
                                    if (tUser.indexOf(validCheck[k].fieldName) == 0) {
                                        invObj["Tobacco User"] = 'Yes';
                                        invObj["prediction"].push({ "ml": "100%", "isColor": false, "key": "Tobacco User" });
                                    }
                                    else {
                                        invObj["Tobacco User"] = 'No';
                                        invObj["prediction"].push({ "ml": "100%", "isColor": false, "key": "Tobacco User" });
                                    }
                                }
                                else if (cds.indexOf(validCheck[k].fieldName) >= 0) {
                                    if (cds.indexOf(validCheck[k].fieldName) == 0) {
                                        invObj["Critical Disease Self"] = 'Yes';
                                        invObj["prediction"].push({ "ml": "100%", "isColor": false, "key": "Critical Disease Self" });
                                    }
                                    else {
                                        invObj["Critical Disease Self"] = 'No';
                                        invObj["prediction"].push({ "ml": "100%", "isColor": false, "key": "Critical Disease Self" });
                                    }
                                }
                                else if (cdf.indexOf(validCheck[k].fieldName) >= 0) {
                                    if (cdf.indexOf(validCheck[k].fieldName) == 0) {
                                        invObj["Critical Disease Family"] = 'Yes';
                                        invObj["prediction"].push({ "ml": "100%", "isColor": false, "key": "Critical Disease Family" });
                                    }
                                    else {
                                        invObj["Critical Disease Family"] = 'No';
                                        invObj["prediction"].push({ "ml": "100%", "isColor": false, "key": "Critical Disease Family" });
                                    }
                                }
                            }
                            // console.log("Invoice Object 12222" + JSON.stringify(invObj));
                            fileData['invoiceObject'] = invObj;
                            callback(null, fileData);
                        }
                    });
                });
            }
            catch (err) {
                fileData['invoiceObject'] = invObj;
                callback(null, fileData);
            }
        });
    }
    //end

    /* 
     convertPdfToImage(req, res) {
         return __awaiter(this, void 0, void 0, function* () {
             let self = this;
             try {
                 res.send({ status: 0 });
                 let imagesPathaaray;
                 let body = req.body;
                 let eventId = body.input.eventId;
                 let projectId = body.projectId;
                 let botId = body.botId;
                 let token = body.token;
                 let imageBasedPdf = body.input.imageBasedPdf;
                 let iterationId = body.iterationId;
                 let filePath = body.input.filePath;
                 logger.info("In convert pdftoimg==============");
                 // console.log("---------------body---", JSON.stringify(body));
                 //let filePath = !util_1.isNullOrUndefined(body) && !util_1.isNullOrUndefined(body.input.filePath) ? body.filePath : '';
                 console.log("filepath---", filePath);
                 if (filePath[0] == "[") {
                     filePath = JSON.parse(filePath);
                     filePath = filePath[0]
                     // console.log("array filepath -->", filePath);
                 }
                 if (filePath !== '') {
                     let ext = path.extname(filePath);
                     let base = path.basename(filePath);
                     let extension = !util_1.isNullOrUndefined(ext) ? ext : '';
                     if (extension !== '' && base !== '') {
                         //    if (extension.toLowerCase() === '.pdf') {
                         if (extension.toLowerCase() === '.pdf' || extension.toLowerCase() === '.tif') {
                             let name = base.split('.');
                             let path = config.path;
                             if (imageBasedPdf == 'true') {
                                 console.log("image based pdf   ======>");
                                 return yield new Promise(async (resolve, reject) => {
                                     exec('convert  -density 300 -background white -alpha remove ' + filePath + ' -verbose ' + path + name[0] + '.png', function (err, data, ssd) {
                                         if (err) {
                                             throw err;
                                             resolve(1);
                                         }
                                         else {
                                             if (ssd !== '') {
                                                 console.log("SSD DATATATATTATASJNDNAJNDJANSD" + ssd);
                                                 ssd = ssd.split('\n');
                                                 console.log("NEW ===============>>>>>>>.>>>>SSD===" + ssd);
                                                 //ssd.shift();
                                                 ssd.pop();
                                                 console.log("SSD-------afterrrr===========>>>>>>>>>>>>>>>>>" + ssd);
                                             }
                                             let imagesPath = [];
                                             let counter = 0;
                                             console.log("SSDDDDDDDDD LENGHT AJIANKAIUAIA" + ssd.length);
                                             if (ssd.length <= 1) {
                                                 imagesPath.push({ imageFilePath: path + name[0] + ".png" });
                                                 console.log("ssd.lengthIMAGEPATH<=1======", imagesPath);
                                             }
                                             else {
                                                 ssd.forEach((list) => {
                                                     if (list.trim() !== '') {
                                                         let imgpath = path + name[0] + '-' + counter + '.png';
                                                         imagesPath.push({ imageFilePath: path + name[0] + '-' + counter + '.png' });
                                                         counter++;
                                                     }
                                                 });
                                             }
                                             // let  file = fs.readFileSync(imagesPath);
                                             let tmp = [];
                                             let temp = [];
                                             for (let index = 0; index < imagesPath.length; index++) {
                                                 const element = imagesPath[index];
                                                 if (fs.existsSync(element.imageFilePath)) {
                                                     //file exists
                                                     let script = "chmod ugo+rwx" + " " + element.imageFilePath;
                                                     exec(script, function (err, data, ssd) {
                                                         if (err) {
                                                             throw err;
                                                             resolve(1);
                                                         }
                                                         else {
                                                             console.info("<----  FILE EXISTS AND ITS CAN BE WRITTEN FROM OTHER CODE ---->>")
                                                             console.log('file existsfirsttttt!!!');
                                                             temp.push(element);
                                                         }
                                                     });
 
                                                 }
                                                 else {
                                                     console.log('file not exists!!!!!!!!!!!');
                                                     tmp.push(element);
                                                 } // console.log('pathpppp)
                                             }
                                             console.log("tmppp", tmp.length);
                                             if (tmp.length != 0) {
                                                 imagesPath = temp;
                                             }
                                             else {
                                                 console.log("--------------file found successfullyyyy");
                                             }
                                             //console.log("imagesPath-------new-", imagesPath);
                                             imagesPathaaray = imagesPath;
                                             let outputData = { "imagesPathaaray": imagesPathaaray, "uplodeStatus": true, 'statusCode': '200' };
                                             let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                                             let headers = { 'authorization': token, 'content-type': "application/json" };
                                             var options = {
                                                 method: 'POST',
                                                 url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
                                                 headers: headers,
                                                 body: taskData,
                                                 json: true
                                             };
                                             process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                                             request(options, function (error, response, body) {
                                                 resolve(0)
                                             });
                                         }
                                     });
                                 });
                             }
                             else {
                                 console.log("text based pdf   ======>");
                                 return yield new Promise(async (resolve, reject) => {
                                     exec('convert  -density 300 -background white -alpha remove ' + filePath + ' -verbose ' + path + name[0] + '.png', function (err, data, ssd) {
                                         if (err) {
                                             throw err;
                                             resolve(1);
                                         }
                                         else {
                                             if (ssd !== '') {
                                                 console.log("SSD DATATATATTATASJNDNAJNDJANSD" + ssd);
                                                 ssd = ssd.split('\n');
                                                 console.log("NEW ===============>>>>>>>.>>>>SSD===" + ssd);
                                                 //ssd.shift();
                                                 ssd.pop();
                                                 console.log("SSD-------afterrrr===========>>>>>>>>>>>>>>>>>" + ssd);
                                             }
                                             let imagesPath = [];
                                             let counter = 0;
                                             console.log("SSDDDDDDDDD LENGHT AJIANKAIUAIA" + ssd.length);
                                             if (ssd.length <= 1) {
                                                 imagesPath.push({ imageFilePath: path + name[0] + ".png" });
                                                 console.log("ssd.lengthIMAGEPATH<=1======", imagesPath);
                                             }
                                             else {
                                                 ssd.forEach((list) => {
                                                     if (list.trim() !== '') {
                                                         let imgpath = path + name[0] + '-' + counter + '.png';
                                                         imagesPath.push({ imageFilePath: path + name[0] + '-' + counter + '.png' });
                                                         counter++;
                                                     }
                                                 });
                                             }
                                             // let  file = fs.readFileSync(imagesPath);
                                             let tmp = [];
                                             let temp = [];
                                             for (let index = 0; index < imagesPath.length; index++) {
                                                 const element = imagesPath[index];
                                                 if (fs.existsSync(element.imageFilePath)) {
                                                     //file exists
                                                     let script = "chmod ugo+rwx" + " " + element.imageFilePath;
                                                     exec(script, function (err, data, ssd) {
                                                         if (err) {
                                                             throw err;
                                                             resolve(1);
                                                         }
                                                         else {
                                                             console.info("<----  FILE EXISTS AND ITS CAN BE WRITTEN FROM OTHER CODE ---->>")
                                                             console.log('file existsfirsttttt!!!');
                                                             temp.push(element);
                                                         }
                                                     });
                                                 }
                                                 else {
                                                     console.log('file not exists!!!!!!!!!!!');
                                                     tmp.push(element);
                                                 } // console.log('pathpppp)
                                             }
                                             console.log("tmppp", tmp.length);
                                             if (tmp.length != 0) {
                                                 imagesPath = temp;
                                             }
                                             else {
                                                 console.log("--------------file found successfullyyyy");
                                             }
                                             //console.log("imagesPath-------new-", imagesPath);
                                             console.log("url ", config.cudaprod + "gibots-orch/orchestrator/botsiowrite");
                                             imagesPathaaray = imagesPath;
                                             let outputData = { "imagesPathaaray": imagesPathaaray, "uplodeStatus": true, 'statusCode': '200' };
                                             let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                                             let headers = { 'authorization': token, 'content-type': "application/json" };
                                             var options = {
                                                 method: 'POST',
                                                 url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
                                                 headers: headers,
                                                 body: taskData,
                                                 json: true
                                             };
                                             process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                                             request(options, function (error, response, body) {
                                                 resolve(0);
                                             });
                                         }
                                     });
                                 });
                             }
                         }
                         else {
                             logger.info("this is a png files-----------------------");
                             let imagesPath = [];
                             imagesPath.push({ imageFilePath: filePath });
                             // fileData['imagesPath'] = imagesPath;
                             imagesPathaaray = imagesPath;
                             console.log("imagesPatharray of png output-", imagesPathaaray);
                             let outputData = { "imagesPathaaray": imagesPathaaray, "uplodeStatus": true, 'statusCode': '200' };
                             let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                             let headers = { 'authorization': token, 'content-type': "application/json" };
                             //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
                             var options = {
                                 method: 'POST',
                                 url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
                                 headers: headers,
                                 body: taskData,
                                 json: true
                             };
                             process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                             // request(options, function (error, response, body) {
                             //     // console.log("--------------err in res",error);
                             //     //console.log("body---responce",body);
                             //     //console.log("---res",response);
                             // });
                             ///////////////////////////////////////////////////////
                             // let self=this;
                             yield self.ioWrite(options);
                             return 0;
 
                             ///////////////////////////////////////////////////////
                         }
                     }
                     else {
                         // logger.error('File Path Not Found');
                         // throw 'File Path Not Found';
                         console.log("file path not found")
                         let outputData = { "imagesPathaaray": null, "uplodeStatus": true, 'statusCode': '202' };
                         let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                         let headers = { 'authorization': token, 'content-type': "application/json" };
                         taskData['exception'] = "file path not found";
                         //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
                         var options = {
                             method: 'POST',
                             url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
                             headers: headers,
                             body: taskData,
                             json: true
                         };
                         process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                         // request(options, function (error, response, body) {
                         //     // console.log("--------------err in res",error);
                         //     //console.log("body---responce",body);
                         //     //console.log("---res",response);
                         // });
                         ///////////////////////////////////////////////////////
                         // let self=this;
                         yield self.ioWrite(options);
                         return 0;
 
                         ///////////////////////////////////////////////////////
                     }
                 }
                 else {
                     // logger.error('File Path Not Found');
                     // throw 'File Path Not Found';
                     console.log("file path not found")
                     let outputData = { "imagesPathaaray": null, "uplodeStatus": true, 'statusCode': '202' };
                     let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                     let headers = { 'authorization': token, 'content-type': "application/json" };
                     taskData['exception'] = "file path not found";
                     //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
                     var options = {
                         method: 'POST',
                         url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
                         headers: headers,
                         body: taskData,
                         json: true
                     };
                     process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                     // request(options, function (error, response, body) {
                     //     // console.log("--------------err in res",error);
                     //     //console.log("body---responce",body);
                     //     //console.log("---res",response);
                     // });
                     ///////////////////////////////////////////////////////
                     // let self=this;
                     yield self.ioWrite(options);
                     return 0;
 
                     ///////////////////////////////////////////////////////
                 }
             }
             catch (err) {
                 console.log("errrrrrrrrrr", err);
                 let outputData = { "imagesPathaaray": null, "uplodeStatus": true, 'statusCode': '202' };
                 let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                 let headers = { 'authorization': req.body.token, 'content-type': "application/json" };
                 taskData['exception'] = err.toString();
                 //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
                 var options = {
                     method: 'POST',
                     url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
                     headers: headers,
                     body: taskData,
                     json: true
                 };
                 process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                 // request(options, function (error, response, body) {
                 //     // console.log("--------------err in res",error);
                 //     //console.log("body---responce",body);
                 //     //console.log("---res",response);
                 // });
                 ///////////////////////////////////////////////////////
                 // let self=this;
                 yield self.ioWrite(options);
                 return 0;
 
                 ///////////////////////////////////////////////////////
             }
         });
     }
     
     */
    sh(cmd) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(function (resolve, reject) {
                exec(cmd, { maxBuffer: 1024 * 1024 * 500 }, (err, stdout, stderr) => {
                    // if (err) {
                    //     resolve({ status: 1, err: err });
                    // } if (stderr !== '') {
                    //     resolve({ status: 1, err: stderr });
                    // } else {
                    resolve({ err: err, stdout: stdout, stderr: stderr });
                    // }
                });
            });
        })
    }
    convertPdfToImage(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;

            try {
                res.send({ status: 0 });
                let imagesPathaaray;
                let body = req.body;
                let eventId = body.input.eventId;
                let projectId = body.projectId;
                let botId = body.botId;
                let token = body.token;
                let imageBasedPdf = body.input.imageBasedPdf;
                let iterationId = body.iterationId;
                let filePath = body.input.filePath;
                let multiPageScan = body.input.multiPageScan;
                let fileRefNum = body.input.fileRefNum;
                let subId = body.input.subscriberId;
                let docType = body.input.docType;
                let execute;

                let i_size, pl_start = performance.now();
                try { i_size = req.headers['content-length'] } catch (e) { i_size = 0 };


                logger.info("In convert pdftoimg==============");
                // console.log("---------------body---", JSON.stringify(body));
                //let filePath = !util_1.isNullOrUndefined(body) && !util_1.isNullOrUndefined(body.input.filePath) ? body.filePath : '';
                console.log("filepath---", filePath);
                if (filePath[0] == "[") {
                    filePath = JSON.parse(filePath);
                    filePath = filePath[0]
                }
                if (multiPageScan && (multiPageScan == "true" || multiPageScan == true)) {
                    let iData = yield (db.createDynamicModel("fileuploadhistories")).findOne({ fileRefNum: fileRefNum }).exec();
                    iData = JSON.parse(JSON.stringify(iData));
                    if (iData && iData['imagesPath'] && Array.isArray(iData['imagesPath'])) {
                        imagesPathaaray = (iData['imagesPath'].filter(a => a['imageFilePath']).length == iData['imagesPath'].length) ? iData['imagesPath'] : undefined;
                    }
                }
                if (imagesPathaaray && Array.isArray(imagesPathaaray)) {
                    imagesPathaaray = imagesPathaaray;
                }
                else if (filePath !== '') {
                    let ext = path.extname(filePath);
                    let base = path.basename(filePath);
                    let extension = !util_1.isNullOrUndefined(ext) ? ext : '';
                    if (extension !== '' && base !== '') {
                        if (extension.toLowerCase() === '.pdf' || extension.toLowerCase() === '.tif') {
                            let name = base.split('.');
                            let path = config.path;
                            if (imageBasedPdf == 'true') {
                                console.log("image based pdf   ======>");
                                execute = yield self.sh('convert  -density 300 -background white -alpha remove ' + filePath + ' -verbose ' + path + name[0] + '.png');
                            }
                            else {
                                console.log("text based pdf   ======>");
                                console.time("convert")
                                execute = yield self.sh('convert  -density 300 -strip -background white -alpha remove ' + filePath + ' -verbose ' + path + name[0] + '.png');
                                console.timeEnd("convert")
                            }
                            if (execute.err) {
                                throw execute.err;
                            }
                            else {
                                let ssd = execute.stderr;
                                if (ssd !== '') {
                                    ssd = ssd.split('\n');
                                    ssd.pop();
                                    ssd = ssd.filter(a => !/(^\*)|(Error)|(Output may be incorrect)/.test(a.trim())); //for handling exceptions for imageMagic
                                }
                                let imagesPath = [];
                                let counter = 0;
                                console.log("SSDDDDDDDDD LENGHT AJIANKAIUAIA" + ssd.length);
                                if (ssd.length <= 1) {
                                    imagesPath.push({ imageFilePath: path + name[0] + ".png" });
                                }
                                else {
                                    ssd.forEach((list) => {
                                        if (list.trim() !== '') {
                                            let imgpath = path + name[0] + '-' + counter + '.png';
                                            imagesPath.push({ imageFilePath: path + name[0] + '-' + counter + '.png' });
                                            counter++;
                                        }
                                    });
                                }
                                console.log("Converted-------", imagesPath);
                                let tmp = [];
                                let temp = [];
                                for (let index = 0; index < imagesPath.length; index++) {
                                    const element = imagesPath[index];
                                    if (fs.existsSync(element.imageFilePath)) {
                                        //file exists
                                        try {
                                            fs.chmodSync(element.imageFilePath, 511);
                                            temp.push(element);
                                        }
                                        catch (e) {
                                            throw e;
                                        }
                                    }
                                    else {
                                        console.log('file not exists!!!!!!!!!!!');
                                        tmp.push(element);
                                    }
                                }
                                console.log("tmppp", tmp.length);
                                if (tmp.length != 0) {
                                    imagesPath = temp;
                                    throw "All files not created properly"
                                }
                                imagesPathaaray = imagesPath;
                            }
                        }
                        else {
                            logger.info("this is a png files-----------------------");
                            let imagesPath = [];
                            imagesPath.push({ imageFilePath: filePath });
                            imagesPathaaray = imagesPath;
                            console.log("imagesPatharray of png output-", imagesPathaaray);
                        }
                    }
                }

                let finalFiles = imagesPathaaray.map(a => a.imageFilePath);
                finalFiles.push(filePath);

                finalFiles = [... new Set(finalFiles)];

                let size = 0;
                for (let file of finalFiles) {
                    size = size + (self.getFilesizeInBytes(file) / (1024 * 1024));
                }

                let d = yield subscriber.findOneAndUpdate({ _id: subId, "documentTypeList.documentTypeName": docType }, { $inc: { "documentTypeList.$.usedLimit": size } }).exec();

                // console.log(d)
                let outputData = { "imagesPathaaray": imagesPathaaray, "uplodeStatus": true, 'statusCode': '200' };
                if (util_1.isNullOrUndefined(imagesPathaaray) || imagesPathaaray.length == 0) {
                    outputData['statusCode'] = '202';
                }
                let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'authorization': token, 'content-type': "application/json" };

                //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
                var options = {
                    method: 'POST',
                    url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';

                let pl_end = performance.now();
                yield commonFunctions.performanceLog(req.body.input && req.body.input.eventId ? req.body.input.eventId : '', req.body.iterationId ? req.body.iterationId : '', 'convertPdfToImage', pl_start, pl_end, i_size, pl_end - pl_start)

                yield self.ioWrite(options);
                return 0;
                ///////////////////////////////////////////////////////
            }
            catch (err) {
                console.log("errrrrrrrrrr", err);
                let outputData = { "imagesPathaaray": null, "uplodeStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = err.toString();
                //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
                var options = {
                    method: 'POST',
                    url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     //console.log("body---responce",body);
                //     //console.log("---res",response);
                // });
                ///////////////////////////////////////////////////////
                // let self=this;
                yield self.ioWrite(options);
                return 0;
                ///////////////////////////////////////////////////////
            }
        });
    }
    convertPdfToPng(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;

            try {

                let fileRefNum = req.body.fileRefNum;
                let imagesPathaaray, filePath, execute, imageBasedPdf = 'false';
                let data = yield db.collection('fileuploadhistories').findOne({ fileRefNum: fileRefNum }).lean();
                data = JSON.parse(JSON.stringify(data));
                if (data && data['filePath'] && data['filePath'] != "") {
                    filePath = data['filePath'];
                    let ext = path.extname(filePath);
                    let base = path.basename(filePath);
                    let extension = !util_1.isNullOrUndefined(ext) ? ext : '';
                    if (extension !== '' && base !== '') {
                        if (extension.toLowerCase() === '.pdf' || extension.toLowerCase() === '.tif') {
                            let name = base.split('.');
                            let path = config.path;
                            if (imageBasedPdf == 'true') {
                                console.log("image based pdf   ======>");
                                execute = yield self.sh('convert  -density 300 -background white -alpha remove ' + filePath + ' -verbose ' + path + name[0] + '.png');
                            }
                            else {
                                console.log("text based pdf   ======>");
                                console.time("convert")
                                execute = yield self.sh('convert  -density 300 -strip -background white -alpha remove ' + filePath + ' -verbose ' + path + name[0] + '.png');
                                console.timeEnd("convert")
                            }
                            if (execute.err) {
                                throw execute.err;
                            }
                            else {
                                let ssd = execute.stderr;
                                if (ssd !== '') {
                                    ssd = ssd.split('\n');
                                    ssd.pop();
                                    ssd = ssd.filter(a => !/(^\*)|(Error)|(Output may be incorrect)/.test(a.trim())); //for handling exceptions for imageMagic
                                }
                                let imagesPath = [];
                                let counter = 0;
                                console.log("SSDDDDDDDDD LENGHT AJIANKAIUAIA" + ssd.length);
                                if (ssd.length <= 1) {
                                    imagesPath.push({ imageFilePath: path + name[0] + ".png" });
                                }
                                else {
                                    ssd.forEach((list) => {
                                        if (list.trim() !== '') {
                                            let imgpath = path + name[0] + '-' + counter + '.png';
                                            imagesPath.push({ imageFilePath: path + name[0] + '-' + counter + '.png' });
                                            counter++;
                                        }
                                    });
                                }
                                console.log("Converted-------", imagesPath);
                                imagesPathaaray = imagesPath;
                            }
                        }
                        else {
                            logger.info("this is a png files-----------------------");
                            let imagesPath = [];
                            imagesPath.push({ imageFilePath: filePath });
                            imagesPathaaray = imagesPath;
                            console.log("imagesPatharray of png output-", imagesPathaaray);
                        }
                    }

                    let re = yield db.collection('fileuploadhistories').findOneAndUpdate({ fileRefNum: fileRefNum }, { $set: { imagesPath: imagesPathaaray } });
                    // console.log("Res-------->",res);

                    res.send({ message: "Images Converted...", status: 0, data: imagesPathaaray })

                }

                return res.send({ message: "Not found in fileuploadhistories", status: 1 })

            }
            catch (e) {
                console.log("ImageMagic ---", e)
                return res.send({ message: e, status: 1 })
            }
        });
    }
    getFilesizeInBytes(filename) {
        var stats = fs.statSync(filename);
        var fileSizeInBytes = stats.size;
        return fileSizeInBytes;
    }
    convertPdfToImageBkp(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            try {
                res.send({ status: 0 });
                let imagesPathaaray;
                let body = req.body;
                let eventId = body.input.eventId;
                let projectId = body.projectId;
                let botId = body.botId;
                let token = body.token;
                let imageBasedPdf = body.input.imageBasedPdf;
                let iterationId = body.iterationId;
                let filePath = body.input.filePath;
                logger.info("In convert pdftoimg==============");
                // console.log("---------------body---", JSON.stringify(body));
                //let filePath = !util_1.isNullOrUndefined(body) && !util_1.isNullOrUndefined(body.input.filePath) ? body.filePath : '';
                console.log("filepath---", filePath);
                if (filePath[0] == "[") {
                    filePath = JSON.parse(filePath);
                    filePath = filePath[0]
                    // console.log("array filepath -->", filePath);
                }
                if (filePath !== '') {
                    let ext = path.extname(filePath);
                    let base = path.basename(filePath);
                    let extension = !util_1.isNullOrUndefined(ext) ? ext : '';
                    if (extension !== '' && base !== '') {
                        //    if (extension.toLowerCase() === '.pdf') {
                        if (extension.toLowerCase() === '.pdf' || extension.toLowerCase() === '.tif') {
                            let name = base.split('.');
                            let path = config.path;
                            if (imageBasedPdf == 'true') {
                                console.log("image based pdf   ======>");
                                return yield new Promise(async (resolve, reject) => {
                                    exec('convert  -density 300 -background white -alpha remove ' + filePath + ' -verbose ' + path + name[0] + '.png', function (err, data, ssd) {
                                        if (err) {
                                            throw err;
                                            resolve(1);
                                        }
                                        else {
                                            if (ssd !== '') {
                                                console.log("SSD DATATATATTATASJNDNAJNDJANSD" + ssd);
                                                ssd = ssd.split('\n');
                                                console.log("NEW ===============>>>>>>>.>>>>SSD===" + ssd);
                                                //ssd.shift();
                                                ssd.pop();
                                                console.log("SSD-------afterrrr===========>>>>>>>>>>>>>>>>>" + ssd);
                                            }
                                            let imagesPath = [];
                                            let counter = 0;
                                            console.log("SSDDDDDDDDD LENGHT AJIANKAIUAIA" + ssd.length);
                                            if (ssd.length <= 1) {
                                                imagesPath.push({ imageFilePath: path + name[0] + ".png" });
                                                console.log("ssd.lengthIMAGEPATH<=1======", imagesPath);
                                            }
                                            else {
                                                ssd.forEach((list) => {
                                                    if (list.trim() !== '') {
                                                        let imgpath = path + name[0] + '-' + counter + '.png';
                                                        imagesPath.push({ imageFilePath: path + name[0] + '-' + counter + '.png' });
                                                        counter++;
                                                    }
                                                });
                                            }
                                            // let  file = fs.readFileSync(imagesPath);
                                            let tmp = [];
                                            let temp = [];
                                            for (let index = 0; index < imagesPath.length; index++) {
                                                const element = imagesPath[index];
                                                if (fs.existsSync(element.imageFilePath)) {
                                                    //file exists
                                                    let script = "chmod ugo+rwx" + " " + element.imageFilePath;
                                                    exec(script, function (err, data, ssd) {
                                                        if (err) {
                                                            throw err;
                                                            resolve(1);
                                                        }
                                                        else {
                                                            console.info("<----  FILE EXISTS AND ITS CAN BE WRITTEN FROM OTHER CODE ---->>")
                                                            console.log('file existsfirsttttt!!!');
                                                            temp.push(element);
                                                        }
                                                    });

                                                }
                                                else {
                                                    console.log('file not exists!!!!!!!!!!!');
                                                    tmp.push(element);
                                                } // console.log('pathpppp)
                                            }
                                            console.log("tmppp", tmp.length);
                                            if (tmp.length != 0) {
                                                imagesPath = temp;
                                            }
                                            else {
                                                console.log("--------------file found successfullyyyy");
                                            }
                                            //console.log("imagesPath-------new-", imagesPath);
                                            imagesPathaaray = imagesPath;
                                            let outputData = { "imagesPathaaray": imagesPathaaray, "uplodeStatus": true, 'statusCode': '200' };
                                            let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                                            let headers = { 'authorization': token, 'content-type': "application/json" };
                                            var options = {
                                                method: 'POST',
                                                url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
                                                headers: headers,
                                                body: taskData,
                                                json: true
                                            };
                                            process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                                            request(options, function (error, response, body) {
                                                resolve(0)
                                            });
                                        }
                                    });
                                });
                            }
                            else {
                                console.log("text based pdf   ======>");
                                return yield new Promise(async (resolve, reject) => {
                                    exec('convert  -density 300 -strip -background white -alpha remove ' + filePath + ' -verbose ' + path + name[0] + '.png', function (err, data, ssd) {
                                        if (err) {
                                            throw err;
                                            resolve(1);
                                        }
                                        else {
                                            if (ssd !== '') {
                                                console.log("SSD DATATATATTATASJNDNAJNDJANSD" + ssd);
                                                ssd = ssd.split('\n');
                                                console.log("NEW ===============>>>>>>>.>>>>SSD===" + ssd);
                                                //ssd.shift();
                                                ssd.pop();
                                                console.log("SSD-------afterrrr===========>>>>>>>>>>>>>>>>>" + ssd);
                                            }
                                            let imagesPath = [];
                                            let counter = 0;
                                            console.log("SSDDDDDDDDD LENGHT AJIANKAIUAIA" + ssd.length);
                                            if (ssd.length <= 1) {
                                                imagesPath.push({ imageFilePath: path + name[0] + ".png" });
                                                console.log("ssd.lengthIMAGEPATH<=1======", imagesPath);
                                            }
                                            else {
                                                ssd.forEach((list) => {
                                                    if (list.trim() !== '') {
                                                        let imgpath = path + name[0] + '-' + counter + '.png';
                                                        imagesPath.push({ imageFilePath: path + name[0] + '-' + counter + '.png' });
                                                        counter++;
                                                    }
                                                });
                                            }
                                            // let  file = fs.readFileSync(imagesPath);
                                            let tmp = [];
                                            let temp = [];
                                            for (let index = 0; index < imagesPath.length; index++) {
                                                const element = imagesPath[index];
                                                if (fs.existsSync(element.imageFilePath)) {
                                                    //file exists
                                                    let script = "chmod ugo+rwx" + " " + element.imageFilePath;
                                                    exec(script, function (err, data, ssd) {
                                                        if (err) {
                                                            throw err;
                                                            resolve(1);
                                                        }
                                                        else {
                                                            console.info("<----  FILE EXISTS AND ITS CAN BE WRITTEN FROM OTHER CODE ---->>")
                                                            console.log('file existsfirsttttt!!!');
                                                            temp.push(element);
                                                        }
                                                    });
                                                }
                                                else {
                                                    console.log('file not exists!!!!!!!!!!!');
                                                    tmp.push(element);
                                                } // console.log('pathpppp)
                                                console.log("tmppp", tmp.length);
                                                if (tmp.length != 0 && index == imagesPath.length - 1) {
                                                    imagesPath = temp;

                                                    console.log("url ", config.cudaprod + "gibots-orch/orchestrator/botsiowrite");
                                                    imagesPathaaray = imagesPath;
                                                    console.info(" ----- IMAGESPATH -----", JSON.parse(JSON.stringify(imagesPath)));
                                                    let outputData = { "imagesPathaaray": imagesPathaaray, "uplodeStatus": true, 'statusCode': '200' };
                                                    if (imagesPathaaray.length == 0) {
                                                        outputData['statusCode'] = '202'
                                                    }
                                                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                                                    let headers = { 'authorization': token, 'content-type': "application/json" };
                                                    var options = {
                                                        method: 'POST',
                                                        url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
                                                        headers: headers,
                                                        body: taskData,
                                                        json: true
                                                    };
                                                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                                                    request(options, function (error, response, body) {
                                                        resolve(0);
                                                    })
                                                }
                                                else {
                                                    console.log("--------------file found successfullyyyy");
                                                    if (index == imagesPath.length - 1) {
                                                        console.log("url ", config.cudaprod + "gibots-orch/orchestrator/botsiowrite");
                                                        imagesPathaaray = imagesPath;
                                                        console.info(" ----- IMAGESPATH -----", JSON.parse(JSON.stringify(imagesPath)));
                                                        let outputData = { "imagesPathaaray": imagesPathaaray, "uplodeStatus": true, 'statusCode': '200' };
                                                        if (imagesPathaaray.length == 0) {
                                                            outputData['statusCode'] = '202'
                                                        }
                                                        let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                                                        let headers = { 'authorization': token, 'content-type': "application/json" };
                                                        var options = {
                                                            method: 'POST',
                                                            url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
                                                            headers: headers,
                                                            body: taskData,
                                                            json: true
                                                        };
                                                        process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                                                        request(options, function (error, response, body) {
                                                            resolve(0);
                                                        })
                                                    }
                                                }
                                            }

                                            //console.log("imagesPath-------new-", imagesPath);
                                        }
                                    });
                                });
                            }
                        }
                        else {
                            logger.info("this is a png files-----------------------");
                            let imagesPath = [];
                            imagesPath.push({ imageFilePath: filePath });
                            // fileData['imagesPath'] = imagesPath;
                            imagesPathaaray = imagesPath;
                            console.log("imagesPatharray of png output-", imagesPathaaray);
                            let outputData = { "imagesPathaaray": imagesPathaaray, "uplodeStatus": true, 'statusCode': '200' };
                            if (imagesPathaaray.length == 0) {
                                outputData['statusCode'] = '202'
                            }
                            let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                            let headers = { 'authorization': token, 'content-type': "application/json" };
                            //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
                            var options = {
                                method: 'POST',
                                url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
                                headers: headers,
                                body: taskData,
                                json: true
                            };
                            process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                            // request(options, function (error, response, body) {
                            //     // console.log("--------------err in res",error);
                            //     //console.log("body---responce",body);
                            //     //console.log("---res",response);
                            // });
                            ///////////////////////////////////////////////////////
                            // let self=this;
                            yield self.ioWrite(options);
                            return 0;

                            ///////////////////////////////////////////////////////
                        }
                    }
                    else {
                        // logger.error('File Path Not Found');
                        // throw 'File Path Not Found';
                        console.log("file path not found")
                        let outputData = { "imagesPathaaray": null, "uplodeStatus": true, 'statusCode': '202' };
                        let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                        let headers = { 'authorization': token, 'content-type': "application/json" };
                        taskData['exception'] = "file path not found";
                        //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
                        var options = {
                            method: 'POST',
                            url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
                            headers: headers,
                            body: taskData,
                            json: true
                        };
                        process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                        // request(options, function (error, response, body) {
                        //     // console.log("--------------err in res",error);
                        //     //console.log("body---responce",body);
                        //     //console.log("---res",response);
                        // });
                        ///////////////////////////////////////////////////////
                        // let self=this;
                        yield self.ioWrite(options);
                        return 0;

                        ///////////////////////////////////////////////////////
                    }
                }
                else {
                    // logger.error('File Path Not Found');
                    // throw 'File Path Not Found';
                    console.log("file path not found")
                    let outputData = { "imagesPathaaray": null, "uplodeStatus": true, 'statusCode': '202' };
                    let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                    let headers = { 'authorization': token, 'content-type': "application/json" };
                    taskData['exception'] = "file path not found";
                    //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
                    var options = {
                        method: 'POST',
                        url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
                        headers: headers,
                        body: taskData,
                        json: true
                    };
                    process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                    // request(options, function (error, response, body) {
                    //     // console.log("--------------err in res",error);
                    //     //console.log("body---responce",body);
                    //     //console.log("---res",response);
                    // });
                    ///////////////////////////////////////////////////////
                    // let self=this;
                    yield self.ioWrite(options);
                    return 0;

                    ///////////////////////////////////////////////////////
                }
            }
            catch (err) {
                console.log("errrrrrrrrrr", err);
                let outputData = { "imagesPathaaray": null, "uplodeStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = err.toString();
                //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
                var options = {
                    method: 'POST',
                    url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     //console.log("body---responce",body);
                //     //console.log("---res",response);
                // });
                ///////////////////////////////////////////////////////
                // let self=this;
                yield self.ioWrite(options);
                return 0;

                ///////////////////////////////////////////////////////
            }
        });
    }
    // convertPdfToImage(req, res) {
    //     return __awaiter(this, void 0, void 0, function* () {
    //         let self = this;
    //         try {
    //             let imagesPathaaray;
    //             let body = req.body;
    //             let eventId = body.input.eventId;
    //             let projectId = body.projectId;
    //             let botId = body.botId;
    //             let token = body.token;
    //             let iterationId = body.iterationId;
    //             let filePath = body.input.filePath;
    //             logger.info("In convert pdftoimg==============");
    //             console.log("---------------body---", JSON.stringify(body));
    //             //let filePath = !util_1.isNullOrUndefined(body) && !util_1.isNullOrUndefined(body.input.filePath) ? body.filePath : '';
    //             console.log("filepath---", filePath);
    //             if (filePath !== '') {
    //                 let ext = path.extname(filePath);
    //                 let base = path.basename(filePath);
    //                 let extension = !util_1.isNullOrUndefined(ext) ? ext : '';
    //                 if (extension !== '' && base !== '') {
    //                        if (extension.toLowerCase() === '.pdf') {
    //                     if (extension.toLowerCase() === '.pdf' || extension.toLowerCase() === '.tif') {
    //                         let name = base.split('.');
    //                         // let path ="/home/user/Desktop/output/";
    //                         let path = config.path;
    //                         exec('convert  -density 300 -background white -alpha remove ' + filePath + ' -verbose ' + path + name[0] + '.png', function (err, data, ssd) {
    //                             if (err) {
    //                                 throw err;
    //                             }
    //                             else {
    //                                 if (ssd !== '') {
    //                                     console.log("SSD DATATATATTATASJNDNAJNDJANSD" + ssd);
    //                                     ssd = ssd.split('\n');
    //                                     console.log("NEW ===============>>>>>>>.>>>>SSD===" + ssd);
    //                                     //ssd.shift();
    //                                     ssd.pop();
    //                                     console.log("SSD-------afterrrr===========>>>>>>>>>>>>>>>>>" + ssd);
    //                                 }
    //                                 let imagesPath = [];
    //                                 let counter = 0;
    //                                 console.log("SSDDDDDDDDD LENGHT AJIANKAIUAIA" + ssd.length);
    //                                 if (ssd.length <= 1) {
    //                                     imagesPath.push({ imageFilePath: path + name[0] + ".png" });
    //                                     console.log("ssd.lengthIMAGEPATH<=1======", imagesPath);
    //                                 }
    //                                 else
    //                                 {
    //                                     ssd.forEach((list) => {
    //                                         if (list.trim() !== '') {
    //                                             let imgpath = path + name[0] + '-' + counter + '.png';
    //                                             imagesPath.push({ imageFilePath: path + name[0] + '-' + counter + '.png' });
    //                                             counter++;
    //                                         }
    //                                     });
    //                                 }
    //                                 let  file = fs.readFileSync(imagesPath);
    //                                 let tmp = [];
    //                                 let temp = [];
    //                                 for (let index = 0; index < imagesPath.length; index++) {
    //                                     const element = imagesPath[index];
    //                                     if (fs.existsSync(element.imageFilePath)) {
    //                                         //file exists
    //                                         console.log('file existsfirsttttt!!!');
    //                                         temp.push(element);
    //                                     }
    //                                     else {
    //                                         console.log('file not exists!!!!!!!!!!!');
    //                                         tmp.push(element);
    //                                     } // console.log('pathpppp)
    //                                 }
    //                                 console.log("tmppp", tmp.length);
    //                                 if (tmp.length != 0) {
    //                                     imagesPath = temp;
    //                                 }
    //                                 else {
    //                                     console.log("--------------file found successfullyyyy");
    //                                 }
    //                                 console.log("imagesPath-------new-", imagesPath);
    //                                 imagesPathaaray = imagesPath;
    //                                 let outputData = { "imagesPathaaray": imagesPathaaray, "uplodeStatus": true, 'statusCode': '200' };
    //                                 let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
    //                                 let headers = { 'authorization': token, 'content-type': "application/json" };
    //                                 //  let headers = { 'authorization': body['token'], 'content-type': "application/json", "selectedorgid": body['selectedorgid'] };
    //                                 //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
    //                                 console.log(JSON.stringify(headers), " pdff file======>>>>>>>----------->>>>>>>> ", JSON.stringify(taskData));
    //                                 var options = {
    //                                     method: 'POST',
    //                                     url: "http://192.168.1.23/gibots-orch/orchestrator/botsiowrite",
    //                                     // url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
    //                                     headers: headers,
    //                                     body: taskData,
    //                                     json: true
    //                                 };
    //                                 process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
    //                                 request(options, function (error, response, body) {
    //                                     // console.log("--------------err in res",error);
    //                                     //console.log("body---responce",body);
    //                                     //console.log("---res",response);
    //                                 });
    //                             }
    //                         });
    //                     }
    //                     else {
    //                         logger.info("this is a png files-----------------------");
    //                         let imagesPath = [];
    //                         imagesPath.push({ imageFilePath: filePath });
    //                         // fileData['imagesPath'] = imagesPath;
    //                         imagesPathaaray = imagesPath;
    //                         console.log("imagesPatharray of png output-", imagesPathaaray);
    //                         let outputData = { "imagesPathaaray": imagesPathaaray, "uplodeStatus": true, 'statusCode': '200' };
    //                         let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
    //                         let headers = { 'authorization': token, 'content-type': "application/json" };
    //                         //  let headers = { 'authorization': body['token'], 'content-type': "application/json", "selectedorgid": body['selectedorgid'] };
    //                         //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
    //                         console.log(JSON.stringify(headers), "png file ======>>>>>>>----------->>>>>>>> ", JSON.stringify(taskData));
    //                         var options = {
    //                             method: 'POST',
    //                             url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
    //                             headers: headers,
    //                             body: taskData,
    //                             json: true
    //                         };
    //                         process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
    //                         request(options, function (error, response, body) {
    //                             // console.log("--------------err in res",error);
    //                             //console.log("body---responce",body);
    //                             //console.log("---res",response);
    //                         });
    //                     }
    //                 }
    //                 else {
    //                     // logger.error('File Path Not Found');
    //                     throw 'File Path Not Found';
    //                 }
    //             }
    //             else {
    //                 // logger.error('File Path Not Found');
    //                 throw 'File Path Not Found';
    //             }
    //         }
    //         catch (err) {
    //             console.log("errrrrrrrrrr", err);
    //         }
    //     });
    // }
    oflineOcrItems(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            let fileData = [];
            var mergearray = [];
            try {
                res.send({ status: 0 });
                logger.info('Inside oflineocrItems');
                let pathfeaturescsv;
                let pagewidthImg;
                let pageheightImg;
                let body = req.body;
                let imagesPathaaray = body.input.imagesPathaaray;
                let OCR_modelName = body.input.OCR_modelName;
                //let imagesPathaaray = body.input.outputArray;
                let fileRefNum = body.input.fileRefNum;
                let documentType = body.input.documentType;
                let eventId = body.input.eventId;
                let projectId = body.projectId;
                let botId = body.botId;
                let token = body.token;
                let iterationId = body.iterationId;
                // console.log("---------------body---", JSON.stringify(body));
                console.log("imgs Array---------", imagesPathaaray);
                for (let k = 0; k < imagesPathaaray.length; k++) {
                    const element = imagesPathaaray[k];
                    console.log("merge aaray ki lenghttt------", mergearray.length);
                    let filePath = imagesPathaaray[k].imageFilePath;
                    var filename = filePath.replace(/^.*[\\\/]/, '');
                    let pageNum;
                    let pg = filename.split('-');
                    if (filename === pg[pg.length - 1]) {
                        console.log("page number split by 'underscore' ");
                        let ji = filename.split('_');
                        pageNum = ji[ji.length - 1];
                        pageNum = pageNum.replace(/.png|.jpg/g, '');
                        console.log("page number====", pageNum);
                    }
                    else {
                        console.log("page number split by 'dash' ");
                        pageNum = pg[pg.length - 1];
                        pageNum = pageNum.replace(/.png|.jpg/g, '');
                        console.log("page number====", pageNum);
                    }
                    // let cropfilePathPredict = "/home/user/Desktop/fromserver1";
                    let cropfilePathPredict = config.cropfilePathPredict;
                    let rmdir;
                    let output = yield this.OFlineOcr(cropfilePathPredict, filePath, OCR_modelName);
                    let ocrpathdirPred = fs.existsSync(cropfilePathPredict + filename);
                    if (ocrpathdirPred) {
                        console.log("Predict---------remove filesss");
                        rmdir = yield execSync('/bin/rm -r' + ' ' + cropfilePathPredict + filename);
                        console.log("remove success---------");
                    }
                    if (output.status == 0) {
                        //    console.log("Output Data----ofline", JSON.stringify(output.data));
                        let outputnew = JSON.parse(output.data);
                        //  let filepath2= filePath.replace(/.png|.jpg/,'');
                        // console.log("filepath of json=================>",filepath2);
                        // fs.writeFileSync(filePath+'.json',JSON.stringify(outputnew));
                        pagewidthImg = outputnew[outputnew.length - 1].width;
                        pageheightImg = outputnew[outputnew.length - 1].height;
                        outputnew.splice(-1, 1);
                        outputnew.forEach(element => {
                            if (!util_1.isNullOrUndefined(element.text)) {
                                element['pageNo'] = pageNum;
                                element['pageWidth'] = pagewidthImg;
                                element['pageHeight'] = pageheightImg;
                            }
                        });
                        //                let tmp= [];
                        // tmp
                        /*
                                             for (let index = 0; index < outputnew.length; index++) {
                                                 const element = outputnew[index];


                                            if (!element.Name.replace(/\s/g, '').length) {


                                                tmp.push(index);





                                              }

                                             }



                                             for (var i = tmp.length -1; i >= 0; i--) {

                                                outputnew.splice(tmp[i], 1);
                                             }

                        */
                        // let outputCombinewords = outputnew;
                        // outputnew.sort(function (a, b) {
                        //     return a["pageNo"] - b["pageNo"] || a["topY"] - b["topY"];
                        // });
                        //  console.log("ouputnew-----",JSON.stringify(outputnew));
                        mergearray = mergearray.concat(outputnew);
                    }
                    else {
                        logger.error('#OflineOcr==>error in OFLINE-OCR');
                    }
                }
                console.log("multipage ka aaraay ", JSON.stringify(mergearray));
                const MongoClient = require('mongodb').MongoClient;
                let mClient = yield MongoClient.connect(config.mongoConnection);
                let dbName = config.mongoConnection.split('/');
                let db = yield mClient.db(dbName[dbName.length - 1]);
                let data = yield db.collection('documenttrainings').findOneAndUpdate({ fileRefNum: fileRefNum }, { $set: { fileRefNum: fileRefNum, documentType: 'Contract', documentCsvData: mergearray, isDeleted: false } }, { upsert: true }).exec();
                let data2 = yield db.collection('fileuploadhistories').findOneAndUpdate({ fileRefNum: fileRefNum }, { $set: { imagesPath: imagesPathaaray, documentType: 'Contract' } }, { upsert: true }).exec();
                let outputData = { "mergearray": mergearray, "uplodeStatus": true, 'statusCode': '200' };
                let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'authorization': token, 'content-type': "application/json" };
                //  let headers = { 'authorization': body['token'], 'content-type': "application/json", "selectedorgid": body['selectedorgid'] };
                //"https://ocri.gibots.com/gibots-orch/orchestrator/botsiowrite"
                // console.log(JSON.stringify(headers)," ======>>>>>>>----------->>>>>>>> ", JSON.stringify(taskData));
                var options = {
                    method: 'POST',
                    url: config.cudaprod + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     //console.log("body---responce",body);
                //     //console.log("---res",response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
                console.log("finishhhhhhhhhhh===========");
            }
            catch (e) {
                logger.info("error in OFLINE-OCR-------", e);
            }
        });
    }
    OFlineOcr(cropfilePathPredict, filePath, OCR_modelName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                logger.info("Inside ofline_OCR");
                //   console.log("FILEDATA in OflineOCR----",JSON.stringify(fileData.obj));
                let self = this;
                //   let ocrEnsambleScriptPredict= "/home/user/Documents/KRISHNA-scan/maf/OCR_Ensemble/tesseract_ensemble.py";
                let ocrEnsambleScriptPredict = config.ocrEnsambleScriptPredict;
                // let cropttextPath = "/home/user/Desktop/output";
                let cropttextPath = config.cropttextPath;
                let pythonCommand;
                console.log("filepath------", filePath);
                console.log("type--is predict for cmd---------2", cropfilePathPredict);
                let cpfile = yield execSync('/bin/cp -r ' + filePath + ' ' + cropfilePathPredict);
                console.log("cpppppppppppppppp");
                // pythonCommand = 'python ' + ocrEnsambleScriptPredict + ' -i ' + cropfilePathPredict + '/' +  ' -o ' + cropttextPath;
                pythonCommand = 'python ' + ocrEnsambleScriptPredict + ' -i ' + cropfilePathPredict + '/' + ' -o ' + cropttextPath + ' -m ' + OCR_modelName;
                console.log("PYTHON OCR ENSAMBLE COMMAND ====newew" + pythonCommand);
                let pythonOutput = yield this.terminalCoomandOfline(pythonCommand);
                //           console.log("dattaa---", pythonOutput);
                let data = JSON.parse(JSON.stringify(pythonOutput.output));
                // let data = JSON.parse(JSON.stringify(pythonOutput));
                //         console.log("PYTHON COMMAND OUTPUT AFTER EXCEUTION--------------------" + JSON.stringify(pythonOutput) + "---------------");
                return { 'status': 0, "data": data, "info": "Executed successfully" };
            }
            catch (e) {
                logger.info('err in oflineOcr', e);
                return { 'status': 1, "data": [], "info": e };
            }
        });
    }
    createInvoiceObj(data) {
        let obj = {};
        obj["prediction"] = [];
        let cgst = 0;
        let sgst = 0;
        let igst = 0;
        const numField = config.numField;
        data.filter(function (list) {
            //      console.log("list---of KRISHNA---",JSON.stringify(list.Name));
            const info = numField.find(function (v) {
                return list.Property === v;
            });
            if (info) {
                // var regex = /[+-]?\d+(?:\.\d+)?/g;
                // let match;
                // let invTotal = '';Rs . 230 /
                // while (match = regex.exec(list.Name)) {
                //     invTotal = invTotal.concat(match[0]);
                // }
                list.Name = list.Name.replace('Rs . ', '');
                obj[list.Property] = Number(list.Name.replace(/[^\d.-]/g, ''));
                obj["prediction"].push({ "ml": (Number(list.confidence) * 100).toFixed(4) + '%', "isColor": Number(list.confidence) * 100 > 60 ? false : true, "key": list.Property });
            }
            else {
                if (list.Property.includes("cgst") || list.Property.includes("sgst") || list.Property.includes("igst")) {
                    if (list.Property.includes("cgst")) {
                        cgst = cgst + Number(list.Name.replace(/[^\d.-]/g, ''));
                        obj["invTotalCgstAmt"] = cgst;
                    }
                    if (list.Property.includes("sgst")) {
                        sgst = sgst + Number(list.Name.replace(/[^\d.-]/g, ''));
                        obj["invTotalSgstAmt"] = sgst;
                    }
                    if (list.Property.includes("igst")) {
                        igst = igst + Number(list.Name.replace(/[^\d.-]/g, ''));
                        obj["invTotalIgstAmt"] = igst;
                    }
                }
                else if (list.Property.includes("stin")) {
                    console.log("============= Inside gstin =========");
                    // console.log(list.Name);
                    list.Name = list.Name.slice(list.Name.length - 15);
                    obj[list.Property] = list.Name.substr(0, 13) + 'Z' + list.Name.substr(14, 1);
                }
                else {
                    if (!util_1.isNullOrUndefined(_.findIndex(Object.keys(obj), list.Property))) {
                        if ((!util_1.isNullOrUndefined(obj[list.Property])) && (list.Property != "undefined")) {
                            obj[list.Property] = obj[list.Property] + " " + list.Name;
                            obj["prediction"].push({ "ml": (Number(list.confidence) * 100).toFixed(2) + '%', "isColor": Number(list.confidence) * 100 > 60 ? false : true, "key": list.Property });
                        }
                        else {
                            obj[list.Property] = list.Name.replace(":", "");
                            obj["prediction"].push({ "ml": (Number(list.confidence) * 100).toFixed(2) + '%', "isColor": Number(list.confidence) * 100 > 60 ? false : true, "key": list.Property });
                        }
                    }
                }
            }
        });
        console.log("================= Invoice Objects GENERATED==============old wali");
        // console.log(JSON.stringify(obj));
        return obj;
    }
    jsontocsv(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            try {
                let body = req.body;
                let jsonarray = body.input.mergearray;
                let fileRefNum = body.input.fileRefNum;
                //  let csvPath = body.csvPath;
                let csvgenreatedpath;
                let eventId = body.input.eventId;
                let projectId = body.projectId;
                let botId = body.botId;
                let token = body.token;
                let iterationId = body.iterationId;
                //      console.log("---------------body---",JSON.stringify(body));
                jsonexport(jsonarray, function (err, csv) {
                    if (err)
                        return console.log("err", err);
                    /*
                  var outputDirectory = csvPath + "/" + "csvdowloadedSuccesfully";
                          if (!fs.existsSync(outputDirectory)) {
                      fs.mkdirSync(outputDirectory);
                      }
                  //    let  fl=filename.replace(/.pdf|.png/g,'');

                  */
                    var outputDirectory = '/var/www/cuda-fs';
                    csvgenreatedpath = outputDirectory + '/' + fileRefNum + '_csvgenrated' + ".csv";
                    const out = fs.writeFileSync(csvgenreatedpath, csv, function (err) {
                        if (err) {
                            return console.log("errrrrrrr", err);
                        }
                    });
                });
                console.log("csvgenrated_path------", csvgenreatedpath);
                let outputData = { "csvgenreatedpath": csvgenreatedpath, "uplodeStatus": true, 'statusCode': '200' };
                let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'authorization': token, 'content-type': "application/json" };
                //  let headers = { 'authorization': body['token'], 'content-type': "application/json", "selectedorgid": body['selectedorgid'] };
                //"https://cuda-testing.gibots.com/gibots-orch/orchestrator/botsiowrite"
                // console.log(JSON.stringify(headers)," ======>>>>>>>----------->>>>>>>> ", JSON.stringify(taskData));
                var options = {
                    method: 'POST',
                    //url: "http://cuda-testing.gibots.com:1443/gibots-orch/orchestrator/botsiowrite",
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     //console.log("body---responce",body);
                //     //console.log("---res",response);
                // });
                ///////////////////////////////////////////////////////
                // let self=this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
            }
            catch (err) {
                console.log("errrrrrrrrrr", err);
            }
        });
    }
    mergeTableRows(tables, mapping) {
        let self = this;
        var regex = /^[1-9]\d*(((,\d{3}){1})?(\.\d{0,2})?)$/;
        if (tables.length > 0) {
            // tables = self.mergeWords(tables[0], tables);
            if (tables.length > 2) {
                let newTable = [tables[0], tables[1]];
                for (let index = 2; index < tables.length; index++) {
                    const currentRow = tables[index];
                    // for (let l = 0; l < currentRow.length; l++) {
                    //     const element = currentRow[i];
                    // }
                    let allow = false;
                    for (let i = 0; i < currentRow.length; i++) {
                        const element = currentRow[i];
                        // const element = tables[index][0];
                        let lastRow = tables[index - 1][0];
                        let lastRow1 = tables[index - 1];
                        let lastlastRow = tables[index - 2];
                        let height = lastRow.bottomY - lastRow.topY;
                        let diff = element.topY - lastRow.bottomY;
                        if (height * 3 < diff && lastRow1.length != currentRow.length && lastlastRow.length != currentRow.length) {

                        } else {
                            allow = true;
                        }

                    }
                    if (allow) {
                        newTable.push(tables[index]);
                    } else {
                        break;
                    }
                }
                // tables = newTable;
            }
        }
        var tableHeaders = [];
        var tableHeadersW = [];
        for (var k in mapping) {
            tableHeadersW.push(k);
            k = k.toLocaleUpperCase();
            k = k.replace(/\s+/g, '');
            k = k.replace(/\.+/g, '');
            tableHeaders.push(k);
        }
        // let value = headers[i].Name.toUpperCase();
        // value = value.replace(/\s+/g,'')
        let resultTables = [];
        for (let i = 0; i < tables.length; i++) {
            let row = tables[i];
            if (i > 0 && row.length == 1) {
                let rowData = row[0];
                let previousRow = resultTables[resultTables.length - 1];
                for (let j = 0; j < previousRow.length; j++) {
                    let rowElement = previousRow[j];
                    let value = rowElement.Name.toUpperCase();
                    value = value.replace(/\s+/g, '');
                    if (tableHeaders.indexOf(value) == -1 && !((/\d+\,+/.test(value)) && /\d+$/.test(value)) && (/^[^0-9]+$/.test(rowData.Name) || /^[^0-9]+$/.test(rowElement.Name))) {
                        //row[0]['mark']=true;
                        let biggerData, smallData;
                        if (rowData.Name.length > rowElement.Name.length) {
                            biggerData = rowData;
                            smallData = rowElement;
                        }
                        else {
                            biggerData = rowElement;
                            smallData = rowData;
                        }
                        if ((((smallData.rightX >= biggerData.leftX && smallData.rightX <= biggerData.rightX) || (Math.round(smallData.leftX) == Math.round(biggerData.leftX)))

                            && util_1.isNullOrUndefined(row[0]['mark']) && !util_1.isNullOrUndefined(resultTables[resultTables.length - 1][j]))) {
                            resultTables[resultTables.length - 1][j].Name = resultTables[resultTables.length - 1][j].Name + ' ' + rowData.Name;
                            resultTables[resultTables.length - 1][j].rightX = biggerData.rightX;
                            row[0]['mark'] = true;
                        }
                        else {
                            if (util_1.isNullOrUndefined(row[0]['mark']) && !regex.test(row[0].Name)) {
                                resultTables.push(row);
                                row[0]['mark'] = true;
                            }
                        }
                    }
                    if (util_1.isNullOrUndefined(row[0]['mark']) && !regex.test(row[0].Name)) {
                        resultTables.push(row);
                        row[0]['mark'] = true;
                    }
                    if (util_1.isNullOrUndefined(row[0]['mark']) && j == previousRow.length - 1) {
                        resultTables.push(row);
                        row[0]['mark'] = true;
                    }
                }
            }
            else {
                resultTables.push(row);
            }
        }
        return resultTables;
    }
    mergeWords(headers, tableRows) {
        let newTables = [];
        newTables.push(headers);
        let newRow = [];
        let columnNew = {};
        for (let j = 1; j < tableRows.length; j++) {
            let row = tableRows[j];
            if (newRow.length > 0) {
                newTables.push(newRow);
            }
            newRow = [];
            columnNew = {};

            for (let i = 0; i < headers.length; i++) {
                let header = headers[i];
                let rightMargin = 0;
                let leftMargin = 0;
                if (i < headers.length - 1) {
                    let nextHeader = headers[i + 1];
                    rightMargin = ((nextHeader.leftX - header.rightX) / 2)
                    rightMargin = rightMargin + header.rightX;
                    if (i > 0) {
                        let lastHeader = headers[i - 1];
                        leftMargin = ((header.leftX - lastHeader.rightX) / 2)
                        leftMargin = header.leftX - leftMargin;
                    }
                }
                if (i == headers.length - 1 && i > 0) {
                    rightMargin = header.rightX;
                    let lastHeader = headers[i - 1];
                    leftMargin = ((header.leftX - lastHeader.rightX) / 2)
                    leftMargin = header.leftX - leftMargin;
                    rightMargin = rightMargin + leftMargin;
                }
                for (let k = 0; k < row.length; k++) {
                    let col = row[k];
                    let diffL = rightMargin - col.leftX;
                    let diffR = col.rightX - rightMargin;
                    let allow = false;
                    if (diffL > 0 && diffR > 0 && diffR > diffL && k < row.length - 1) {
                        allow = false;
                    } else {
                        allow = true;
                    }
                    if (diffR < 0 && diffL > 0) {
                        allow = true;
                    }
                    if (!/[\/\-]+/.test(columnNew.Name) && !/[\/\-]+/.test(col.Name) && ((/^\d+/.test(columnNew.Name) || /\d+$/.test(columnNew.Name)) && (/^\d+/.test(col.Name) || /\d+$/.test(col.Name)))) {
                        let str = columnNew.Name.replace(/[^a-zA-z]/gi, '');
                        let str2 = col.Name.replace(/[^a-zA-z]/gi, '')
                        if (!(str.length > 2 && str2.length > 2)) {
                            // allow = false;
                        }
                    }
                    if (((/(\d)[(\,)(\.)]/.test(columnNew.Name)) || (/(\d)[(\,)(\.)]/.test(col.Name))) && !/^\d+\C/.test(col.Name) && ["Cr", "C", "C1", "C/", "C¢", "Cr|", "C1]", "C|", "Cr|", "C/|", "C]", "Cr]", "C¢|", "C¢]", "C1]", "C1|", "Crj", "Cd", "CR", "DR", "EA"].indexOf(col.Name) == -1 &&
                        !(!util_1.isNullOrUndefined(columnNew.Name) && columnNew.rightX > header.leftX && columnNew.leftX < header.rightX && col.rightX > header.leftX && col.leftX < header.rightX)) {
                        allow = false;
                    }
                    let wordDiff = col.leftX - columnNew.rightX;
                    let wordHeight = columnNew.bottomY - columnNew.topY
                    if ((wordHeight / wordDiff) < 0.35) {
                        allow = false;
                    }
                    let al = true;
                    if (i > 0 && col.leftX < headers[i - 1].rightX) {
                        al = false;
                    }
                    if (util_1.isNullOrUndefined(col['used'])) {
                        if (al && (((col.leftX < rightMargin && (leftMargin < col.leftX || allow)) || (col.leftX < rightMargin && col.rightX > header.leftX)) && !(i < headers.length - 1 && col.rightX > headers[i + 1].leftX))) {
                            if (util_1.isNullOrUndefined(columnNew.Name)) {
                                columnNew = col;
                                row[k]['used'] = true;
                            }
                            else if (allow) {
                                columnNew.Name = columnNew.Name + " " + col.Name;
                                columnNew.rightX = col.rightX;
                                tableRows[j][k]['merged'] = true;
                                row[k]['used'] = true;
                            } else {
                                newRow.push(columnNew);
                                row[k]['used'] = true;
                                newRow.push(col);
                                columnNew = {};
                            }
                        }
                        else {
                            if (!util_1.isNullOrUndefined(columnNew.Name) && util_1.isNullOrUndefined(col['merged'])) {
                                newRow.push(columnNew);
                                columnNew = {};
                            } else {
                                if (!al) {
                                    row[k]['used'] = true;
                                    newRow.push(col);
                                }
                            }
                        }
                        if (k == row.length - 1 && !util_1.isNullOrUndefined(columnNew.Name)) {
                            newRow.push(columnNew);
                            columnNew = {};
                        }
                        // if (k == row.length - 1 && !util_1.isNullOrUndefined(col.Name) && !allow) {
                        //     row[k]['used'] = true;
                        //     newRow.push(col);
                        // }                        
                    }
                }
            }
            if (j == tableRows.length - 1 && newRow.length > 0) {
                newTables.push(newRow);
            }
        }
        return newTables;
    }
    mapTableHeaders(headers, tableMapping, mapping, length, templateId) {
        // let tableHeaders = config.newMap;
        let self = this;
        var tableHeaders = [];
        var tableHeadersNew = [];
        var tableHeadersW = [];
        let subRowHeaders = [];
        let matchedIndexes = [];
        for (var k in mapping) {
            tableHeadersW.push(k);
            // k = k.toLocaleUpperCase();
            k = k.replace(/\s+/g, '');
            k = k.replace(/\.+/g, '');
            tableHeaders.push(k);
        }
        for (var k in mapping) {
            // k = k.toLocaleUpperCase();
            k = k.replace(/\s+/g, '');
            k = k.replace(/\.+/g, '');
            k = k.replace(/[^a-zA-Z ]/g, "");
            tableHeadersNew.push(k);

        }
        let finalHeaders = [];
        for (let i = 0; i < headers.length; i++) {
            let matched = false;
            // let value = headers[i].Name.toUpperCase();
            let value = headers[i].Name.replace(/@@n/g, '');
            value = value.replace(/\s+/g, '');
            value = value.replace(/\]+/g, '');
            value = value.replace(/\[+/g, '');
            value = value.replace(/\‘+/g, '');
            value = value.replace(/\.+/g, '');
            value = value.replace(/[^a-zA-Z0-9.]/g, "");
            let headerIndex = tableHeaders.indexOf(value);
            let headerIndexNew = tableHeadersNew.indexOf(value);
            if (matchedIndexes.indexOf(headerIndex) == -1) {
                matchedIndexes.push(headerIndex);
            }
            if (matchedIndexes.indexOf(headerIndexNew) == -1) {
                matchedIndexes.push(headerIndexNew);
            }
            let tempName=headers[i].Name.replace(/@@n/g, ' ')
            if(mapping[tempName]){
                headers[i].Name=mapping[tempName];
                finalHeaders.push(headers[i]);
                matched = true;
                continue;
            }
            if (headerIndex > -1 || headerIndexNew > -1) {
                if (headerIndexNew > -1) {
                    headers[i].Name = mapping[tableHeadersW[headerIndexNew]];
                } else {
                    headers[i].Name = mapping[tableHeadersW[headerIndex]];
                }
                headers[i].Name = headers[i].Name.replace(/@@n/g, '')
                finalHeaders.push(headers[i]);
                tableMapping[tableHeadersW[headerIndex]] = mapping[tableHeadersW[headerIndex]];
                matched = true;

            } else {
                // if (headers.length <= length) {
                //     finalHeaders.push(headers[i]);
                // }
                for (let j = 0; j < tableHeaders.length; j++) {
                    let header = tableHeadersNew[j];
                    let similarity = self.similarity(header, value)
                    // console.log(similarity);
                    if (similarity > 0.80) {
                        matchedIndexes.push(j);
                        headers[i].Name = mapping[tableHeadersW[j]];
                        headers[i].Name = headers[i].Name.replace(/@@n/g, '')
                        finalHeaders.push(headers[i]);
                        matched = true;
                    }

                }
                // tableMapping[tableHeadersW[headerIndex]] = mapping[tableHeadersW[headerIndex]];
            }
            if (!matched) {
                headers[i]['notMatched'] = true;
                headers[i].Name = headers[i].Name.replace(/@@n+/g, '')
                finalHeaders.push(headers[i]);
            }
        }
        for (let i = 0; i < tableHeadersW.length; i++) {
            if (matchedIndexes.indexOf(i) == -1 && !util_1.isNullOrUndefined(templateId)) {
                subRowHeaders.push(tableHeadersW[i]);
            }
        }
        return { finalHeaders: finalHeaders, subRowHeaders: subRowHeaders };
    }
    similarity(s1, s2) {
        let self = this;
        var longer = s1;
        var shorter = s2;
        if (s1.length < s2.length) {
            longer = s2;
            shorter = s1;
        }
        var longerLength = longer.length;
        if (longerLength == 0) {
            return 1.0;
        }
        return (longerLength - self.editDistance(longer, shorter)) / parseFloat(longerLength);
    }
    editDistance(s1, s2) {
        s1 = s1.toLowerCase();
        s2 = s2.toLowerCase();

        var costs = new Array();
        for (var i = 0; i <= s1.length; i++) {
            var lastValue = i;
            for (var j = 0; j <= s2.length; j++) {
                if (i == 0)
                    costs[j] = j;
                else {
                    if (j > 0) {
                        var newValue = costs[j - 1];
                        if (s1.charAt(i - 1) != s2.charAt(j - 1))
                            newValue = Math.min(Math.min(newValue, lastValue),
                                costs[j]) + 1;
                        costs[j - 1] = lastValue;
                        lastValue = newValue;
                    }
                }
            }
            if (i > 0)
                costs[s2.length] = lastValue;
        }
        return costs[s2.length];
    }
    createTablbeObject(line, lineData, scanData, tableColumns, subRowHeaders, lastValidRow, subHaderFound, scanD, columnCordinates, validRows, tableIndex, amountFound, validRowLength, lastRowLength,bestMatchingTable) {
        line = line.filter(function (x) { return x.Name != "tableEnd"; });
        lineData = lineData.filter(function (x) { return x.Name != "|" && x.Name != "]" && !x.Name.includes('---'); });
        let tableHeaders = scanData.tableMapping;
        let nextLine = JSON.parse(JSON.stringify(lineData));
        let obj = {};
        let count = 0;
        let digitFound = false;
        let totalFound = false;
        let alignment = 'center';
        let subheader = false;
        let subheaders = [];
        let subheaderNew = [];
        let subheaderMatched = false;
        let subheadersFound = false;
        let headers = JSON.parse(JSON.stringify(line));
        let headersO = JSON.parse(JSON.stringify(line));
        let columnsArray = [];
        let self = this;
        let subHearderRow = false;
        let doneHeads = [];
        let assignedUsingColumnCordinates = [];
        let tableCordinates=[];
        if (util_1.isNullOrUndefined(subRowHeaders)) {
            subRowHeaders = [];
        }
        for (let i = 0; i < tableColumns.length; i++) {
            // if(tableColumns[i].length==line.length){
            columnsArray = tableColumns[i];
            // }
        }
        if (!util_1.isNullOrUndefined(scanD.data['columnCordinates']) && scanD.data['columnCordinates'].length > 0) {
            columnCordinates = scanD.data['columnCordinates'];
        }
        columnsArray = self.filterColumns(line, columnsArray);
        for (let i = 0; i < columnsArray.length; i++) {
            let c = columnsArray[i];
            for (let j = 0; j < headers.length; j++) {
                let n = headers[j];
                if (!(j != 0 && headers[j - 1].rightX > c.xmin) && c.xmin <= n.leftX && c.xmax >= n.rightX) {
                    if (headers[j].leftX > c.xmin) {
                        headers[j].leftX = c.xmin;
                    }
                    headers[j].rightX = c.xmax;
                }
            }
        }
        let verticalTableHeaderFound = false;
        let verticalHeadersSkip = [];
        for (let i = 0; i < line.length; i++) {
            let a = line[i];
            if (a.verticalTableHeader && lastValidRow) {
                verticalTableHeaderFound = true;
            }

            for (let j = 0; j < line.length; j++) {
                let b = line[j];
                if (util_1.isNullOrUndefined(a.verticalTableHeader) && b.verticalTableHeader) {

                    if (b.rightX > a.leftX && b.leftX < a.rightX) {
                        a['verticalTableHeaderSkip'] = true;
                        verticalHeadersSkip.push(a.Name)
                    }

                }

            }
        }
        for (let i = 0; i < line.length; i++) {
            let a = line[i];
            if (util_1.isNullOrUndefined(obj[a.Name])) {
                obj[a.Name] = '';
            }
            let aWidth = a.rightX - a.leftX;
            let lastB;
            if (a.verticalTableHeader && !lastValidRow) {
                continue;
            }
            // if (a.verticalTableHeader) {
            //     columnCordinates = [];
            // }
            if (verticalTableHeaderFound && lastValidRow && util_1.isNullOrUndefined(a.verticalTableHeader) && a['verticalTableHeaderSkip']) {
                continue;
            }
            for (let j = 0; j < nextLine.length; j++) {
                let b = nextLine[j];
                if (/\d+\/\d+\/\d+/.test(obj[a.Name]) && /\d+\/\d+\/\d+/.test(b.Name)) {
                    break;
                }
                let breakLoop = false;
                let allowSubHeader = true;
                if (!util_1.isNullOrUndefined(subHaderFound) && !subHaderFound) {
                    allowSubHeader = false;
                    if (scanD.data['defaultTableSubHeader'] && scanD.data['defaultTableSubHeader'] != "") {
                        allowSubHeader = true;
                    }
                }
                let allw = false;
                if (util_1.isNullOrUndefined(nextLine[j]['matched']) && !util_1.isNullOrUndefined(subRowHeaders) && nextLine.length < (validRowLength / 2) && !lastValidRow && subRowHeaders.length > 0 && !(!util_1.isNullOrUndefined(scanD.data['upperRowCountMerge']) && scanD.data['upperRowCountMerge'] > 0) && 
                !(!util_1.isNullOrUndefined(bestMatchingTable) && !util_1.isNullOrUndefined(bestMatchingTable['upperRowCountMerge']) && bestMatchingTable['upperRowCountMerge'] > 0) && lastRowLength != 1) {
                    allw = true;
                }
                if ((util_1.isNullOrUndefined(nextLine[j]['matched']) && !util_1.isNullOrUndefined(subRowHeaders) && lastValidRow && j == 0 && subRowHeaders.length > 0 && allowSubHeader && (nextLine.length != validRowLength || subHaderFound) && (nextLine.length < validRowLength || subHaderFound)) || allw) {
                    subHearderRow = true;
                    let doneSubHeaders = [];
                    for (let o = 0; o < subRowHeaders.length; o++) {
                        for (let inx = 0; inx < nextLine.length; inx++) {
                            if (util_1.isNullOrUndefined(nextLine[inx]['matched'])) {
                                let element = nextLine[inx];
                                element.Name = element.Name.replace(/\:+/g, '')
                                let orI = self.findIndex(subRowHeaders, element.Name);
                                if (element.Name.indexOf(subRowHeaders[o]) > -1 || orI > -1) {
                                    let spAr = element.Name.split(subRowHeaders[o]);
                                    if (orI > -1) {
                                        spAr = element.Name.split(subRowHeaders[orI]);
                                    }
                                    if (spAr.length > 0 && spAr[0].trim() == "" && !(spAr.length > 1 && spAr[1].trim() != "")) {
                                        let brakLoop = false;
                                        for (let index = inx + 1; index < nextLine.length; index++) {
                                            const element = nextLine[index];
                                            let oI = self.findIndex(subRowHeaders, element.Name);
                                            let res = self.checkIfbelongTOanother(scanD.data['subHeaderBreakWords'], subRowHeaders[o], element.Name);
                                            if (!res['allow']) {
                                                oI = 0;
                                            }
                                            if (oI == -1) {
                                                if (element.Name.indexOf(subRowHeaders[o]) == -1) {
                                                    if (util_1.isNullOrUndefined(obj[subRowHeaders[orI]]) && (scanD.data['tableMapping'] && util_1.isNullOrUndefined(obj[scanD.data['tableMapping'][subRowHeaders[orI]]]))) {
                                                        // obj[subRowHeaders[orI]] = element.Name;
                                                        if (scanD.data['tableMapping'] && scanD.data['tableMapping'][subRowHeaders[orI]]) {
                                                            obj[scanD.data['tableMapping'][subRowHeaders[orI]]] = element.Name;
                                                        } else {
                                                            obj[subRowHeaders[orI]] = element.Name;
                                                        }
                                                    } else {
                                                        if (scanD.data['tableMapping'] && scanD.data['tableMapping'][subRowHeaders[orI]]) {
                                                            obj[scanD.data['tableMapping'][subRowHeaders[orI]]] = obj[scanD.data['tableMapping'][subRowHeaders[orI]]] + " " + element.Name;
                                                        } else {
                                                            obj[subRowHeaders[orI]] = obj[subRowHeaders[orI]] + " " + element.Name;
                                                        }
                                                    }
                                                    doneSubHeaders.push(orI);
                                                    nextLine[index]['matched'] = true;
                                                    nextLine[inx]['matched'] = true;
                                                } else {
                                                    if (util_1.isNullOrUndefined(obj[subRowHeaders[o]]) && (scanD.data['tableMapping'] && util_1.isNullOrUndefined(obj[scanD.data['tableMapping'][subRowHeaders[o]]]))) {
                                                        if (scanD.data['tableMapping'] && scanD.data['tableMapping'][subRowHeaders[o]]) {
                                                            obj[scanD.data['tableMapping'][subRowHeaders[o]]] = element.Name;
                                                        } else {
                                                            obj[subRowHeaders[o]] = element.Name;
                                                        }
                                                    } else {
                                                        if (scanD.data['tableMapping'] && scanD.data['tableMapping'][subRowHeaders[o]]) {
                                                            obj[scanD.data['tableMapping'][subRowHeaders[o]]] = obj[scanD.data['tableMapping'][subRowHeaders[o]]] + " " + element.Name;
                                                        } else {
                                                            obj[subRowHeaders[o]] = obj[subRowHeaders[o]] + " " + element.Name;
                                                        }
                                                    }
                                                    nextLine[index]['matched'] = true;
                                                    nextLine[inx]['matched'] = true;
                                                }

                                            } else {
                                                brakLoop = true;
                                                break;
                                            }
                                        }
                                        if (brakLoop) {
                                            break;
                                        }

                                    } else {
                                        if (element.Name.indexOf(subRowHeaders[o]) == -1) {
                                            obj[subRowHeaders[orI]] = spAr[1];
                                            // nextLine[index]['matched'] = true;
                                            nextLine[inx]['matched'] = true;
                                            doneSubHeaders.push(orI);
                                        } else {
                                            obj[subRowHeaders[o]] = spAr[1];
                                            // nextLine[index]['matched'] = true;
                                            nextLine[inx]['matched'] = true;
                                        }

                                        break;

                                    }

                                } else if (doneSubHeaders.indexOf(o) == -1) {
                                    if (scanD.data['defaultTableSubHeader'] && scanD.data['defaultTableSubHeader'] != "") {
                                        if (util_1.isNullOrUndefined(obj[scanD.data['defaultTableSubHeader']])) {
                                            obj[scanD.data['defaultTableSubHeader']] = element.Name;
                                            nextLine[inx]['matched'] = true;
                                        } else {
                                            if (inx > 0) {
                                                let diff = nextLine[inx].leftX - nextLine[inx - 1].rightX;
                                                let pixelPerWord = (nextLine[inx].rightX - nextLine[inx].leftX) / nextLine[inx].Name.length;
                                                if (Math.round(diff) <= Math.round(pixelPerWord)) {
                                                    obj[scanD.data['defaultTableSubHeader']] = obj[scanD.data['defaultTableSubHeader']] + " " + element.Name;
                                                    nextLine[inx]['matched'] = true;
                                                } else {
                                                    break;
                                                }
                                            }
                                        }
                                    } else {
                                        if (!util_1.isNullOrUndefined(scanD.data['subHeaderBreakWords']) && scanD.data['subHeaderBreakWords'].length > 0) {
                                            let res = self.checkIfbelongTOanother(scanD.data['subHeaderBreakWords'], subRowHeaders[o], element.Name)
                                            if (res['allow']) {
                                                if (util_1.isNullOrUndefined(obj[subRowHeaders[o]])) {
                                                    obj[subRowHeaders[o]] = element.Name;
                                                } else {
                                                    obj[subRowHeaders[o]] = obj[subRowHeaders[o]] + " " + element.Name;
                                                }
                                                nextLine[inx]['matched'] = true;
                                                if (res['break']) {
                                                    break;
                                                }
                                            } else {
                                                break;
                                            }
                                        } else if (util_1.isNullOrUndefined(obj[subRowHeaders[o]]) && (scanD.data['tableMapping'] && util_1.isNullOrUndefined(obj[scanD.data['tableMapping'][subRowHeaders[o]]]))) {
                                            if (scanD.data['tableMapping'] && scanD.data['tableMapping'][subRowHeaders[o]]) {
                                                obj[scanD.data['tableMapping'][subRowHeaders[o]]] = element.Name;
                                            } else {
                                                obj[subRowHeaders[o]] = element.Name;
                                            }
                                            nextLine[inx]['matched'] = true;
                                        } else {
                                            if (inx > 0) {
                                                let diff = nextLine[inx].leftX - nextLine[inx - 1].rightX;
                                                let pixelPerWord = (nextLine[inx].rightX - nextLine[inx].leftX) / nextLine[inx].Name.length;
                                                if (Math.round(diff) <= Math.round(pixelPerWord)) {
                                                    // obj[subRowHeaders[o]] = obj[subRowHeaders[o]] +" "+ element.Name;
                                                    if (scanD.data['tableMapping'] && scanD.data['tableMapping'][subRowHeaders[o]]) {
                                                        obj[scanD.data['tableMapping'][subRowHeaders[o]]] = obj[scanD.data['tableMapping'][subRowHeaders[o]]] + " " + element.Name;
                                                    } else {
                                                        obj[subRowHeaders[o]] = obj[subRowHeaders[o]] + " " + element.Name;
                                                    }
                                                    nextLine[inx]['matched'] = true;
                                                } else {
                                                    break;
                                                }
                                            }
                                        }
                                    }

                                }
                            }

                        }
                    }
                    ////////////////////////////////////////////////////////////////////////////
                    // for (let inx = j; inx < nextLine.length; inx++) {
                    //     const element = nextLine[inx];
                    //     if(util_1.isNullOrUndefined(nextLine[inx]['matched'])){

                    //         // for (let o = index; o < subRowHeaders.length; o++) {
                    //             if(util_1.isNullOrUndefined(nextLine[inx]['matched'])){
                    //                 let oI=self.findIndex(subRowHeaders,element.Name);
                    //                 if(oI>-1){
                    //                     let spAr=element.Name.split(subRowHeaders[oI]);
                    //                     if(spAr.length>0 && spAr[0].trim()=="" && !(spAr.length>1 && spAr[1].trim()!="")){

                    //                         for (let index = inx+1; index < nextLine.length; index++) {
                    //                             const element = nextLine[index];
                    //                             let o=self.findIndex(subRowHeaders,element.Name);
                    //                             if(o==-1){
                    //                                 if(util_1.isNullOrUndefined(obj[subRowHeaders[oI]])){
                    //                                     obj[subRowHeaders[oI]] = element.Name;
                    //                                 }else{
                    //                                     obj[subRowHeaders[oI]]=obj[subRowHeaders[oI]]+" "+element.Name;
                    //                                 }
                    //                                 nextLine[j]['matched'] = true;
                    //                                 nextLine[index]['matched'] = true;
                    //                                 nextLine[inx]['matched'] = true;
                    //                             }else{
                    //                                 break;
                    //                             }
                    //                         }

                    //                     }else{
                    //                         obj[subRowHeaders[oI]] = spAr[1];
                    //                         nextLine[index]['matched'] = true;
                    //                         nextLine[inx]['matched'] = true;
                    //                         nextLine[j]['matched'] = true;

                    //                     }

                    //                 }else if(lastValidRow){
                    //                     for (let index = inx; index < nextLine.length; index++) {
                    //                         const element = nextLine[index];
                    //                         let o=self.findIndex(subRowHeaders,element.Name);
                    //                         if(o==-1){
                    //                             if(util_1.isNullOrUndefined(obj[subRowHeaders[0]])){
                    //                                 obj[subRowHeaders[0]] = element.Name;
                    //                                 nextLine[index]['matched'] = true;
                    //                             }else{
                    //                                 if(index>0){
                    //                                 let diff=nextLine[index].leftX-nextLine[index-1].rightX;
                    //                                 let pixelPerWord= (nextLine[index].rightX-nextLine[index].leftX)/nextLine[index].Name.length;
                    //                                 if(diff<pixelPerWord){
                    //                                     obj[subRowHeaders[0]] = obj[subRowHeaders[0]] +" "+ element.Name;
                    //                                     nextLine[index]['matched'] = true;
                    //                                 }else{
                    //                                     break;
                    //                                 }
                    //                                 }
                    //                             }
                    //                         }else{
                    //                             break; 
                    //                         }

                    //                     }
                    //                 }
                    //             }  
                    //             // }
                    //     }                  

                    // }

                } else {
                    if (columnCordinates.length > 0 && !verticalTableHeaderFound) {
                        for (let i = 0; i < columnCordinates.length; i++) {
                            let a = columnCordinates[i];
                            for (let inx = 0; inx < nextLine.length; inx++) {
                                let b = nextLine[inx];
                                if (util_1.isNullOrUndefined(nextLine[inx]['matched'])) {
                                    if ((b.rightX > a.leftX && b.leftX < a.rightX)) {
                                        let allow = self.findOverLapp(a, b, columnCordinates);
                                        if (allow) {
                                            doneHeads.push(a.header);
                                            if (util_1.isNullOrUndefined(obj[a.header])) {
                                                obj[a.header] = b.Name;
                                                nextLine[inx]['matched'] = true;
                                                assignedUsingColumnCordinates.push(a.header);
                                            } else if (!(/\d+\/\d+\/\d+/.test(obj[a.header]) && /\d+\/\d+\/\d+/.test(b.Name))) {
                                                if (/\d/.test(obj[a.header]) && /^\d\.\d/.test(b.Name) && !a.header.includes("|")) {
                                                    obj[a.header] = obj[a.header] + b.Name;
                                                } else {
                                                    obj[a.header] = obj[a.header] + " " + b.Name;
                                                }
                                                nextLine[inx]['matched'] = true;
                                                assignedUsingColumnCordinates.push(a.header);
                                            }
                                        }

                                    }
                                }
                            }
                        }
                    }
                }


                // if(breakLoop){
                //    break;
                // }

                if (a.leftX == b.leftX) {
                    alignment = 'left';
                }
                subheaderMatched = false;
                if (!util_1.isNullOrUndefined(b)) {
                    let value = b.Name.toUpperCase();
                    if (/^[^0-9]+$/.test(value)) {
                        value = value.replace(/\s+/g, '');
                    }
                    if (tableHeaders.hasOwnProperty(value)) {
                        subheader = true;
                    }
                    else {
                        subheader = false;
                    }
                    let bWidth = b.rightX - b.leftX;
                    let diff = b.leftX - a.leftX;
                    if (-11 <= diff && diff <= 11) {
                        if (util_1.isNullOrUndefined(line[0].alignment)) {
                            alignment = 'left';
                            line[0].alignment = 'left';
                        }
                    }
                    if (!util_1.isNullOrUndefined(line[0].alignment)) {
                        // alignment = line[0].alignment;
                    }
                    if (columnsArray.length > 0) {
                        a.leftX = headers[i].leftX;
                        a.rightX = headers[i].rightX;
                    }
                    if (columnsArray.length == 0 && b.leftX > a.leftX) {
                        if (b.leftX < a.rightX) {
                            let overlap = b.leftX - a.rightX;
                            let allow = true;
                            if (util_1.isNullOrUndefined(nextLine[j]['matched']) && i > 0 && j > 0 && !(lastB.rightX >= a.leftX && lastB.leftX <= a.rightX) && !util_1.isNullOrUndefined(obj[a.Name]) && obj[a.Name].trim() !== '' && /\d+/.test(lastB.Name) && /\d+/.test(b.Name) && (((b.leftX - lastB.rightX) > ((b.bottomY - b.topY) * 2)) || ((/(\d)[(\,)(\.)]/.test(lastB.Name)) || (/(\d)[(\,)(\.)]/.test(b.Name)))) && (obj[line[i - 1]['Name']] == "" || (obj[line[i - 1]['Name']].length == 1 && /[(\d)(\$)]/.test(obj[line[i - 1]['Name']])))) {
                                if (obj[line[i - 1]['Name']].length == 1) {
                                    obj[line[i - 1]['Name']] = obj[line[i - 1]['Name']] + obj[a.Name];
                                } else {
                                    obj[line[i - 1]['Name']] = obj[a.Name];
                                }
                                allow = false;
                            }
                            allow = self.checkIfBelongsTOSameHeader(a, b, headersO);
                            if (!util_1.isNullOrUndefined(obj[a.Name]) && obj[a.Name].trim() !== '' && allow) {
                                // if (b.Name.length > obj[a.Name].length) {
                                if (util_1.isNullOrUndefined(nextLine[j]['matched'])) {
                                    // obj[a.Name]=b.Name.replace('~', '');
                                    // nextLine.splice(j, 1);
                                    if (a.Name.indexOf("||||") > -1 && !(/\|+$/.test(a.Name))) {
                                        let splitArr = a.Name.split("|");
                                        if (splitArr.length == 2) {

                                            obj[splitArr[0].trim()] = obj[a.Name];
                                            obj[splitArr[1].trim()] = b.Name;
                                            delete obj[a.Name];
                                            nextLine[j]['matched'] = true;
                                        }
                                    } else {
                                        b.Name = b.Name.replace(/\)/g, '');
                                        b.Name = b.Name.replace(/\(/g, '');
                                        obj[a.Name] = obj[a.Name] + ' ' + b.Name.replace('~', '');
                                        obj[a.Name] = obj[a.Name].replace(/~/g, '');
                                        nextLine[j]['matched'] = true;
                                        if (subheader) {
                                            nextLine[j].Name = line[i].Name + ' ' + b.Name;
                                            subheaders.push(nextLine[j]);
                                            subheaderMatched = true;
                                            line[i]['subheaderMatched'] = true;
                                            subheadersFound = true;
                                            subheaderNew.push(nextLine[j]);
                                        }
                                    }


                                }
                                // }
                            }
                            else {
                                if (util_1.isNullOrUndefined(nextLine[j]['matched'])) {
                                    obj[a.Name] = b.Name.replace('~', '');
                                    obj[a.Name] = obj[a.Name].replace(/\)/g, '');
                                    obj[a.Name] = obj[a.Name].replace(/\(/g, '');
                                    obj[a.Name] = obj[a.Name].replace(/~/g, '');
                                    let value = /^[^0-9]+$/.test(obj[a.Name]) ? obj[a.Name].replace(/\s+/g, '') : obj[a.Name];
                                    let isDigit = /^\d+(\.\d+)?$/.test(value);
                                    if (isDigit) {
                                        obj[a.Name] = value;
                                    }
                                    if (subheader) {
                                        nextLine[j].Name = line[i].Name + ' ' + b.Name;
                                        subheaders.push(nextLine[j]);
                                        subheaderMatched = true;
                                        line[i]['subheaderMatched'] = true;
                                        subheadersFound = true;
                                        subheaderNew.push(nextLine[j]);
                                    }
                                    // nextLine.splice(j, 1);
                                    nextLine[j]['matched'] = true;
                                }
                            }
                        }
                    }
                    if (columnsArray.length == 0 && a.leftX > b.leftX) {
                        if (a.leftX < b.rightX) {
                            let overlap = a.leftX - b.rightX;
                            let allow = true;
                            if (util_1.isNullOrUndefined(nextLine[j]['matched']) && i > 0 && j > 0 && !(lastB.rightX >= a.leftX && lastB.leftX <= a.rightX) && !util_1.isNullOrUndefined(obj[a.Name]) && obj[a.Name].trim() !== '' && /\d+/.test(lastB.Name) && /\d+/.test(b.Name) && (((b.leftX - lastB.rightX) > ((b.bottomY - b.topY) * 2)) || ((/(\d)[(\,)(\.)]/.test(lastB.Name)) || (/(\d)[(\,)(\.)]/.test(b.Name)))) && (obj[line[i - 1]['Name']] == "" || (obj[line[i - 1]['Name']].length == 1 && /[(\d)(\$)]/.test(obj[line[i - 1]['Name']])))) {
                                if (obj[line[i - 1]['Name']].length == 1) {
                                    obj[line[i - 1]['Name']] = obj[line[i - 1]['Name']] + obj[a.Name];
                                } else {
                                    obj[line[i - 1]['Name']] = obj[a.Name];
                                }
                                allow = false;
                            }
                            if (!util_1.isNullOrUndefined(obj[a.Name]) && obj[a.Name].trim() !== '' && allow) {
                                // if (b.Name.length > obj[a.Name].length) {
                                if (util_1.isNullOrUndefined(nextLine[j]['matched'])) {
                                    // obj[a.Name]=b.Name.replace('~', '');
                                    if (a.Name.indexOf("||||") > -1 && !(/\|+$/.test(a.Name))) {
                                        let splitArr = a.Name.split("|");
                                        if (splitArr.length == 2) {

                                            obj[splitArr[0].trim()] = obj[a.Name];
                                            obj[splitArr[1].trim()] = b.Name;
                                            delete obj[a.Name];
                                            nextLine[j]['matched'] = true;
                                        }
                                    } else {
                                        b.Name = b.Name.replace(/\)/g, '');
                                        b.Name = b.Name.replace(/\(/g, '');
                                        obj[a.Name] = obj[a.Name] + ' ' + b.Name.replace('~', '');
                                        obj[a.Name] = obj[a.Name].replace(/~/g, '');
                                        if (subheader) {
                                            nextLine[j].Name = line[i].Name + ' ' + b.Name;
                                            subheaders.push(nextLine[j]);
                                            subheaderMatched = true;
                                            line[i]['subheaderMatched'] = true;
                                            subheadersFound = true;
                                            subheaderNew.push(nextLine[j]);
                                        }
                                        // nextLine.splice(j, 1);
                                        nextLine[j]['matched'] = true;
                                    }

                                }
                                // }
                            }
                            else {
                                if (util_1.isNullOrUndefined(nextLine[j]['matched'])) {
                                    obj[a.Name] = b.Name.replace('~', '');
                                    obj[a.Name] = obj[a.Name].replace(/\)/g, '');
                                    obj[a.Name] = obj[a.Name].replace(/\(/g, '');
                                    obj[a.Name] = obj[a.Name].replace(/~/g, '');
                                    let value = obj[a.Name].replace(/\s+/g, '');
                                    let isDigit = /^\d+(\.\d+)?$/.test(value);
                                    if (isDigit) {
                                        obj[a.Name] = value;
                                    }
                                    if (subheader) {
                                        nextLine[j].Name = line[i].Name + ' ' + b.Name;
                                        subheaders.push(nextLine[j]);
                                        subheaderMatched = true;
                                        line[i]['subheaderMatched'] = true;
                                        subheadersFound = true;
                                        subheaderNew.push(nextLine[j]);
                                    }
                                    // nextLine.splice(j, 1);
                                    nextLine[j]['matched'] = true;
                                }
                            }
                        }
                    }
                    if (columnsArray.length > 0) {
                        if (b.leftX >= a.leftX) {
                            if (b.rightX <= a.rightX) {
                                let overlap = b.leftX - a.rightX;
                                let allow = true;
                                if (util_1.isNullOrUndefined(nextLine[j]['matched']) && i > 0 && j > 0 && !(lastB.rightX >= a.leftX && lastB.leftX <= a.rightX) && !util_1.isNullOrUndefined(obj[a.Name]) && obj[a.Name].trim() !== '' && /\d+/.test(lastB.Name) && /\d+/.test(b.Name) && (((b.leftX - lastB.rightX) > ((b.bottomY - b.topY) * 2)) || ((/(\d)[(\,)(\.)]/.test(lastB.Name)) || (/(\d)[(\,)(\.)]/.test(b.Name)))) && (obj[line[i - 1]['Name']] == "" || (obj[line[i - 1]['Name']].length == 1 && /[(\d)(\$)]/.test(obj[line[i - 1]['Name']])))) {
                                    if (obj[line[i - 1]['Name']].length == 1) {
                                        obj[line[i - 1]['Name']] = obj[line[i - 1]['Name']] + obj[a.Name];
                                    } else {
                                        obj[line[i - 1]['Name']] = obj[a.Name];
                                    }
                                    allow = false;
                                }
                                if (!util_1.isNullOrUndefined(obj[a.Name]) && obj[a.Name].trim() !== '' && allow) {
                                    // if (b.Name.length > obj[a.Name].length) {
                                    if (util_1.isNullOrUndefined(nextLine[j]['matched'])) {
                                        // obj[a.Name]=b.Name.replace('~', '');
                                        // nextLine.splice(j, 1);
                                        if (a.Name.indexOf("||||") > -1 && !(/\|+$/.test(a.Name))) {
                                            let splitArr = a.Name.split("|");
                                            if (splitArr.length == 2) {

                                                obj[splitArr[0].trim()] = obj[a.Name];
                                                obj[splitArr[1].trim()] = b.Name;
                                                delete obj[a.Name];
                                                nextLine[j]['matched'] = true;
                                            }
                                        } else {
                                            b.Name = b.Name.replace(/\)/g, '');
                                            b.Name = b.Name.replace(/\(/g, '');
                                            obj[a.Name] = obj[a.Name] + ' ' + b.Name.replace('~', '');
                                            obj[a.Name] = obj[a.Name].replace(/~/g, '');
                                            nextLine[j]['matched'] = true;
                                            if (subheader) {
                                                nextLine[j].Name = line[i].Name + ' ' + b.Name;
                                                subheaders.push(nextLine[j]);
                                                subheaderMatched = true;
                                                line[i]['subheaderMatched'] = true;
                                                subheadersFound = true;
                                                subheaderNew.push(nextLine[j]);
                                            }
                                        }


                                    }
                                    // }
                                }
                                else {
                                    if (util_1.isNullOrUndefined(nextLine[j]['matched'])) {
                                        obj[a.Name] = b.Name.replace('~', '');
                                        obj[a.Name] = obj[a.Name].replace(/\)/g, '');
                                        obj[a.Name] = obj[a.Name].replace(/\(/g, '');
                                        obj[a.Name] = obj[a.Name].replace(/~/g, '');
                                        let value = /^[^0-9]+$/.test(obj[a.Name]) ? obj[a.Name].replace(/\s+/g, '') : obj[a.Name];
                                        let isDigit = /^\d+(\.\d+)?$/.test(value);
                                        if (isDigit) {
                                            obj[a.Name] = value;
                                        }
                                        if (subheader) {
                                            nextLine[j].Name = line[i].Name + ' ' + b.Name;
                                            subheaders.push(nextLine[j]);
                                            subheaderMatched = true;
                                            line[i]['subheaderMatched'] = true;
                                            subheadersFound = true;
                                            subheaderNew.push(nextLine[j]);
                                        }
                                        // nextLine.splice(j, 1);
                                        nextLine[j]['matched'] = true;
                                    }
                                }
                            }
                        }
                    }
                    if (a.leftX == b.leftX) {
                        let allow = true;
                        if (util_1.isNullOrUndefined(nextLine[j]['matched']) && i > 0 && j > 0 && !(lastB.rightX >= a.leftX && lastB.leftX <= a.rightX) && !util_1.isNullOrUndefined(obj[a.Name]) && obj[a.Name].trim() !== '' && /\d+/.test(lastB.Name) && /\d+/.test(b.Name) && (((b.leftX - lastB.rightX) > ((b.bottomY - b.topY) * 2)) || ((/(\d)[(\,)(\.)]/.test(lastB.Name)) || (/(\d)[(\,)(\.)]/.test(b.Name)))) && (obj[line[i - 1]['Name']] == "" || (obj[line[i - 1]['Name']].length == 1 && /[(\d)(\$)]/.test(obj[line[i - 1]['Name']])))) {
                            if (obj[line[i - 1]['Name']].length == 1) {
                                obj[line[i - 1]['Name']] = obj[line[i - 1]['Name']] + obj[a.Name];
                            } else {
                                obj[line[i - 1]['Name']] = obj[a.Name];
                            }
                            allow = false;
                        }
                        if (!util_1.isNullOrUndefined(obj[a.Name]) && obj[a.Name].trim() !== '' && allow) {
                            // if (b.Name.length > obj[a.Name].length) {
                            if (util_1.isNullOrUndefined(nextLine[j]['matched'])) {
                                // obj[a.Name]=b.Name.replace('~', '');
                                // nextLine.splice(j, 1);
                                if (a.Name.indexOf("||||") > -1 && !(/\|+$/.test(a.Name))) {
                                    let splitArr = a.Name.split("|");
                                    if (splitArr.length == 2) {

                                        obj[splitArr[0].trim()] = obj[a.Name];
                                        obj[splitArr[1].trim()] = b.Name;
                                        delete obj[a.Name];
                                        nextLine[j]['matched'] = true;
                                    }
                                } else {
                                    b.Name = b.Name.replace(/\)/g, '');
                                    b.Name = b.Name.replace(/\(/g, '');
                                    obj[a.Name] = obj[a.Name] + ' ' + b.Name.replace('~', '');
                                    obj[a.Name] = obj[a.Name].replace(/~/g, '');
                                    nextLine[j]['matched'] = true;
                                    if (subheader) {
                                        nextLine[j].Name = line[i].Name + ' ' + b.Name;
                                        subheaders.push(nextLine[j]);
                                        subheaderMatched = true;
                                        line[i]['subheaderMatched'] = true;
                                        subheadersFound = true;
                                        subheaderNew.push(nextLine[j]);
                                    }
                                }

                            }
                            // }
                        }
                        else {
                            if (util_1.isNullOrUndefined(nextLine[j]['matched'])) {
                                obj[a.Name] = b.Name.replace('~', '');
                                obj[a.Name] = obj[a.Name].replace(/\)/g, '');
                                obj[a.Name] = obj[a.Name].replace(/\(/g, '');
                                obj[a.Name] = obj[a.Name].replace(/~/g, '');
                                let value = obj[a.Name].replace(/\s+/g, '');
                                let isDigit = /^\d+(\.\d+)?$/.test(value);
                                if (isDigit) {
                                    obj[a.Name] = value;
                                }
                                if (subheader) {
                                    nextLine[j].Name = line[i].Name + ' ' + b.Name;
                                    subheaders.push(nextLine[j]);
                                    subheaderMatched = true;
                                    line[i]['subheaderMatched'] = true;
                                    subheadersFound = true;
                                    subheaderNew.push(nextLine[j]);
                                }
                                // nextLine.splice(j, 1);
                                nextLine[j]['matched'] = true;
                            }
                        }
                    } else {
                        if ((b.rightX >= a.leftX && b.leftX < a.rightX) || (i == line.length - 1 && j == nextLine.length - 1)) {
                            //  let diff=a.rightX-b.leftX;
                            //  let lengthB=b.rightX-b.leftX;
                            //  let overlap =diff/lengthB;
                            //  if((overlap>0.80 && /^[0-9]+[,.0-9\s]+[0-9|\]]+$/.test(b.Name) && !util_1.isNullOrUndefined(obj[a.Name]) && obj[a.Name].trim() == '') || i < line.length - 1 && overlap>0.35 && b.rightX<=line[i + 1].leftX || (i == line.length - 1 && j == nextLine.length-1)){
                            let allow = true;
                            // console.log("-----------");
                            // console.log(a,"--",lastB,"--",b,"--",line[i-1]);
                            if (util_1.isNullOrUndefined(nextLine[j]['matched']) && i > 0 && j > 0 && !(lastB.rightX >= a.leftX && lastB.leftX <= a.rightX) && !util_1.isNullOrUndefined(obj[a.Name]) && obj[a.Name].trim() !== '' && /\d+/.test(lastB.Name) && /\d+/.test(b.Name) && (((b.leftX - lastB.rightX) > ((b.bottomY - b.topY) * 2)) || ((/(\d)[(\,)(\.)]/.test(lastB.Name)) || (/(\d)[(\,)(\.)]/.test(b.Name)))) && (obj[line[i - 1]['Name']] == "" || (obj[line[i - 1]['Name']].length == 1 && /[(\d)(\$)]/.test(obj[line[i - 1]['Name']])))) {
                                obj[line[i - 1]['Name']] = obj[a.Name];
                                allow = false;
                            }
                            if (!util_1.isNullOrUndefined(obj[a.Name]) && obj[a.Name].trim() !== '' && allow) {
                                //  if(b.Name.length>obj[a.Name].length){
                                if (util_1.isNullOrUndefined(nextLine[j]['matched'])) {
                                    if (a.Name.indexOf("||||") > -1 && !(/\|+$/.test(a.Name))) {
                                        let splitArr = a.Name.split("|");
                                        if (splitArr.length == 2) {

                                            obj[splitArr[0].trim()] = obj[a.Name];
                                            obj[splitArr[1].trim()] = b.Name;
                                            delete obj[a.Name];
                                            nextLine[j]['matched'] = true;
                                        }
                                    } else {
                                        obj[a.Name] = obj[a.Name] + ' ' + b.Name;
                                        obj[a.Name] = obj[a.Name].replace(/~/g, '');
                                        nextLine[j]['matched'] = true;
                                    }

                                }
                                if (subheader) {
                                    nextLine[j].Name = line[i].Name + ' ' + b.Name;
                                    subheaders.push(nextLine[j]);
                                    subheaderMatched = true;
                                    line[i]['subheaderMatched'] = true;
                                    subheadersFound = true;
                                    subheaderNew.push(nextLine[j]);
                                }
                            }
                            else {
                                if (util_1.isNullOrUndefined(nextLine[j]['matched'])) {
                                    if (/\|\s*[a-zA-z0-9]/.test(b.Name)) {
                                        let arr = b.Name.split("|");
                                        if (!util_1.isNullOrUndefined(arr[1])) {
                                            b.Name = arr[1];
                                        }
                                    }
                                    obj[a.Name] = b.Name.replace('~', '');
                                    obj[a.Name] = obj[a.Name].replace(/\)/g, '');
                                    obj[a.Name] = obj[a.Name].replace(/\(/g, '');
                                    obj[a.Name] = obj[a.Name].replace(/~/g, '');
                                    let value = obj[a.Name].replace(/\s+/g, '');
                                    let isDigit = /^\d+(\.\d+)?$/.test(value);
                                    if (isDigit) {
                                        obj[a.Name] = value;
                                    }
                                    else {
                                        // obj[a.Name] = value;
                                    }
                                    // nextLine.splice(j, 1);
                                    nextLine[j]['matched'] = true;
                                    if (subheader) {
                                        nextLine[j].Name = line[i].Name + ' ' + b.Name;
                                        subheaders.push(nextLine[j]);
                                        subheaderMatched = true;
                                        line[i]['subheaderMatched'] = true;
                                        subheadersFound = true;
                                        subheaderNew.push(nextLine[j]);
                                    }
                                }
                            }
                            //  }
                        }
                    }
                    let previousRightX = 0;
                    let nextLeftX = 0;
                    if (i > 0 && i < line.length - 1) {
                        previousRightX = line[i - 1].rightX;
                        previousRightX = (a.leftX - previousRightX) / 2;
                        previousRightX = a.leftX - previousRightX;
                        nextLeftX = line[i + 1].leftX;
                        nextLeftX = (nextLeftX - a.rightX) / 2;
                        nextLeftX = nextLeftX + a.rightX;
                        if (alignment == 'left') {
                            nextLeftX = line[i + 1].leftX;
                            previousRightX = a.leftX;
                        }
                    }
                    if (i == 0 && i < line.length - 1) {
                        nextLeftX = line[i + 1].leftX;
                        nextLeftX = (nextLeftX - a.rightX) / 2;
                        nextLeftX = nextLeftX + a.rightX;
                        if (alignment == 'left') {
                            nextLeftX = line[i + 1].leftX;
                        }
                    }
                    if (nextLeftX == 0) {
                        if (a.rightX > b.rightX) {
                            nextLeftX = a.rightX;
                        }
                        else {
                            nextLeftX = b.rightX;
                        }
                    }

                    let leftDiff = 0;
                    let rightDiff = 0;
                    let allow = false;
                    if (b.rightX > nextLeftX) {
                        rightDiff = b.rightX - nextLeftX;
                        if (b.leftX < nextLeftX) {
                            leftDiff = nextLeftX - b.leftX;
                            if (i < line.length - 1 && (leftDiff) > rightDiff && (b.leftX - a.rightX) < line[i + 1].leftX - b.rightX) {
                                // allow = true;
                            }
                        }

                    }
                    
                    if (i == 0 && j == 0 && line.length > 1 && b.rightX < line[i + 1].leftX) {
                        let rightDifference=line[i + 1].leftX-b.rightX
                        let leftDifference=b.leftX-line[i].rightX
                        if((leftDifference/2)<rightDifference){
                            allow = true;
                        }
                    }
                    if (util_1.isNullOrUndefined(nextLine[j]['matched']) && (b.rightX < nextLeftX || allow)) {
                        let allow = true;
                        if (util_1.isNullOrUndefined(nextLine[j]['matched']) && i > 0 && j > 0 && !(lastB.rightX >= a.leftX && lastB.leftX <= a.rightX) && !util_1.isNullOrUndefined(obj[a.Name]) && obj[a.Name].trim() !== '' && /\d+/.test(lastB.Name) && /\d+/.test(b.Name) && (((b.leftX - lastB.rightX) > ((b.bottomY - b.topY) * 2)) || ((/(\d)[(\,)(\.)]/.test(lastB.Name)) || (/(\d)[(\,)(\.)]/.test(b.Name)))) && (obj[line[i - 1]['Name']] == "" || (obj[line[i - 1]['Name']].length == 1 && /[(\d)(\$)]/.test(obj[line[i - 1]['Name']])))) {
                            if (obj[line[i - 1]['Name']].length == 1) {
                                obj[line[i - 1]['Name']] = obj[line[i - 1]['Name']] + obj[a.Name];
                            } else {
                                obj[line[i - 1]['Name']] = obj[a.Name];
                            }
                            allow = false;
                        }
                        if (!util_1.isNullOrUndefined(obj[a.Name]) && obj[a.Name].trim() !== '' && allow) {
                            //  if(b.Name.length>obj[a.Name].length){
                            let allow = true;
                            if ((!/\$/.test(obj[a.Name]) && ((/(\d)[(\,)(\.)]/.test(obj[a.Name].replace(/\s/g, '')) || /(\d)[(\,)(\.)]/.test(b.Name.replace(/\)/g, ''))))) ||
                                (b.Name.length == 1 && obj[a.Name] == "-" && /\d+/.test(b.Name))) {
                                allow = false;
                            }
                            if (assignedUsingColumnCordinates.indexOf(a.Name) > -1 && /^\$$/.test(b.Name) && !allow) {
                                obj[a.Name] = b.Name + ' ' + obj[a.Name];
                                obj[a.Name] = obj[a.Name].replace(/~/g, '');
                                nextLine[j]['matched'] = true;
                            }
                            if (util_1.isNullOrUndefined(nextLine[j]['matched']) && allow) {
                                if (a.Name.indexOf("||||") > -1 && !(/\|+$/.test(a.Name))) {
                                    let splitArr = a.Name.split("|");
                                    if (splitArr.length == 2) {

                                        obj[splitArr[0].trim()] = obj[a.Name];
                                        obj[splitArr[1].trim()] = b.Name;
                                        delete obj[a.Name];
                                        nextLine[j]['matched'] = true;
                                    }
                                } else {
                                    obj[a.Name] = obj[a.Name] + ' ' + b.Name;
                                    obj[a.Name] = obj[a.Name].replace(/~/g, '');
                                    nextLine[j]['matched'] = true;
                                }

                            }
                            if (subheader) {
                                nextLine[j].Name = line[i].Name + ' ' + b.Name;
                                subheaders.push(nextLine[j]);
                                subheaderMatched = true;
                                line[i]['subheaderMatched'] = true;
                                subheadersFound = true;
                                subheaderNew.push(nextLine[j]);
                            }
                        }
                        else {
                            if (util_1.isNullOrUndefined(nextLine[j]['matched'])) {
                                if (/\|\s*[a-zA-z0-9]/.test(b.Name)) {
                                    let arr = b.Name.split("|");
                                    if (!util_1.isNullOrUndefined(arr[1])) {
                                        b.Name = arr[1];
                                    }
                                }
                                if (doneHeads.indexOf(a.Name) == -1) {
                                    for (let index = 0; index < columnCordinates.length; index++) {
                                        let element = columnCordinates[index];
                                        if (element.header == a.Name) {
                                            if (b.leftX < element.leftX && b.rightX < element.leftX) {
                                                element.leftX = b.rightX - 1;
                                            }
                                            if (b.rightX > element.rightX && b.leftX > element.rightX) {
                                                element.rightX = b.leftX + 1;
                                            }
                                        }
                                    }
                                }
                                obj[a.Name] = b.Name.replace('~', '');
                                obj[a.Name] = obj[a.Name].replace(/\)/g, '');
                                obj[a.Name] = obj[a.Name].replace(/\(/g, '');
                                obj[a.Name] = obj[a.Name].replace(/~/g, '');
                                let value = obj[a.Name].replace(/\s+/g, '');
                                let isDigit = /^\d+(\.\d+)?$/.test(value);
                                if (isDigit) {
                                    obj[a.Name] = value;
                                }
                                else {
                                    // obj[a.Name] = value;
                                }
                                // nextLine.splice(j, 1);
                                nextLine[j]['matched'] = true;
                                if (subheader) {
                                    nextLine[j].Name = line[i].Name + ' ' + b.Name;
                                    subheaders.push(nextLine[j]);
                                    subheaderMatched = true;
                                    line[i]['subheaderMatched'] = true;
                                    subheadersFound = true;
                                    subheaderNew.push(nextLine[j]);
                                }
                            }
                        }
                    }
                }
                lastB = JSON.parse(JSON.stringify(b));
                if (util_1.isNullOrUndefined(nextLine[j]['matched']) && !util_1.isNullOrUndefined(obj[a.Name]) && obj[a.Name].trim() !== '') {
                    break;
                }
            }
            if (!subheaderMatched && util_1.isNullOrUndefined(a['subheaderMatched'])) {
                subheaders.push(a);
            }
        }
        if (!digitFound) {
        }
        else {
        }
        if (obj.hasOwnProperty('Quantity') && obj['Quantity'] == '') {
            if (obj.hasOwnProperty('Sales Price') && obj.hasOwnProperty('Unit Price') && obj['Sales Price'] !== '' && obj['Unit Price'] !== '') {
                obj['Quantity'] = (Math.round(parseFloat(obj['Sales Price']) / parseFloat(obj['Unit Price']))).toString();
            }
        }
        if (obj.hasOwnProperty('IGST Rate') && obj['IGST Rate'] !== '') {
            if (obj['IGST Rate'] == '1200112') {
                obj['IGST Rate'] = '12.00';
            }
        }
        if (obj.hasOwnProperty('Unit Price') && obj['Unit Price'] !== '' && obj.hasOwnProperty('Amount') && obj['Amount'] !== '') {
            if (obj.hasOwnProperty('Quantity') && obj['Quantity'] == '') {
                let isDigit = /^\d+(\.\d+)?$/.test(obj['Amount']);
                let isDigit2 = /^\d+(\.\d+)?$/.test(obj['Amount']);
                if (isDigit && isDigit2) {
                    obj['Quantity'] = (obj['Amount'] / obj['Unit Price']).toString();
                }
            }
        }
        if (subheaders.length > 0 && subheadersFound && subheaderNew.length > 1) {
            // obj['newHeaders'] = subheaders;
        }
        if (!util_1.isNullOrUndefined(subRowHeaders)) {
            for (let o = 0; o < subRowHeaders.length; o++) {
                if (util_1.isNullOrUndefined(obj[subRowHeaders[o]]) || util_1.isNullOrUndefined(obj[scanD.data['tableMapping'][subRowHeaders[o]]])) {
                    if (scanD.data['tableMapping'][subRowHeaders[o]] && util_1.isNullOrUndefined(obj[scanD.data['tableMapping'][subRowHeaders[o]]])) {
                        obj[scanD.data['tableMapping'][subRowHeaders[o]]] = "";
                    } else if (util_1.isNullOrUndefined(obj[subRowHeaders[o]])) {
                        if (scanD.data['tableMapping'][subRowHeaders[o]] && !util_1.isNullOrUndefined(obj[scanD.data['tableMapping'][subRowHeaders[o]]])) {

                        } else {
                            obj[subRowHeaders[o]] = "";
                        }
                    }
                }
            }

        }
        if (scanD.data['defaultTableSubHeader'] && scanD.data['defaultTableSubHeader'] != "") {
            if (util_1.isNullOrUndefined(obj[scanD.data['defaultTableSubHeader']])) {
                obj[scanD.data['defaultTableSubHeader']] = "";
            }
        }
        let emptyCount = 0;
        let headerCount = 0;
        let digitFond = false;
        for (var k in obj) {
            if (/^\d+$/.test(k)) {
                //    delete obj[k];
            }

            if (k.indexOf("||||") > -1 && !(/\|+$/.test(k))) {
                let splitArr = k.split("|");
                if (splitArr.length == 2 && util_1.isNullOrUndefined(obj[splitArr[0].trim()])) {
                    if (obj[k] != "") {
                        obj[splitArr[0].trim()] = obj[k];
                        obj[splitArr[1].trim()] = "";
                    } else {
                        obj[splitArr[0].trim()] = "";
                        obj[splitArr[1].trim()] = "";
                    }

                    delete obj[k];
                } else {
                    if (splitArr.length == 2 && !util_1.isNullOrUndefined(obj[splitArr[0].trim()])) {
                        delete obj[k];
                    }
                }
            }

        }
        let newSubRowHeaders = [];
        for (let i = 0; i < subRowHeaders.length; i++) {
            if (scanD.data['tableMapping'] && scanD.data['tableMapping'][subRowHeaders[i]]) {
                newSubRowHeaders.push(scanD.data['tableMapping'][subRowHeaders[i]]);
            } else {
                newSubRowHeaders.push(subRowHeaders[i]);
            }
        }
        let amount = false;
        for (var k in obj) {
            if (scanD.data['defaultTableSubHeader'] != k && subRowHeaders.indexOf(k) == -1 && newSubRowHeaders.indexOf(k) == -1) {
                headerCount = headerCount + 1;
            }
            if (((obj[k] == "" || obj[k] == k)) && scanD.data['defaultTableSubHeader'] != k && subRowHeaders.indexOf(k) == -1 && newSubRowHeaders.indexOf(k) == -1) {
                emptyCount = emptyCount + 1;
            }
            if ((/^[0-9]+$/.test(obj[k]) || /^[0-9]+[,.0-9\s]+[0-9]+$/.test(obj[k]) || /(\d)[(\,)(\.)]/.test(obj[k]) || /(\d)+(\s)\d+/.test(obj[k]))) {
                digitFond = true;
            }
            let digitAndCommaCount = 0
            if (/(\d)[(\,)(\.)]/.test(obj[k]) && !/\)/.test(obj[k])) {
                for (let i = 0; i < obj[k].length; i++) {
                    let element = obj[k].charAt(i);
                    if (/[\d,]/.test(element)) {
                        digitAndCommaCount = digitAndCommaCount + 1;
                    }
                }
                if (((digitAndCommaCount / obj[k].length) * 100) > 55) {
                    amount = true;
                }

            }
        }
        if (amount && ((emptyCount / headerCount) * 100) > 90) {
            amount = false;
        }
        if (amountFound && !amount) {
            emptyCount = 1000
        }
        if (amountFound && amount) {
            emptyCount = 1;
        }
        if (util_1.isNullOrUndefined(amountFound) && amount) {
            emptyCount = 1;
            amountFound = true;
        }

        // if(amountFound && ((emptyCount / headerCount) * 100) > 55 && !subHearderRow){
        //     headerCount=0;
        //     emptyCount=0;
        //     for (var k in obj) {
        //         if (scanD.data['defaultTableSubHeader'] != k && subRowHeaders.indexOf(k) == -1 && newSubRowHeaders.indexOf(k) == -1 && !/^\d+\.?\d*$/.test(k)) {
        //             headerCount = headerCount + 1;
        //         }
        //         if (((obj[k] == "" || obj[k] == k)) && scanD.data['defaultTableSubHeader'] != k && subRowHeaders.indexOf(k) == -1 && newSubRowHeaders.indexOf(k) == -1 && !/^\d+\.?\d*$/.test(k)) {
        //             emptyCount = emptyCount + 1;
        //         }
        //     }
        // }
        if (digitFond && ((emptyCount / headerCount) * 100) <= 55 && !subHearderRow) {
            lastValidRow = true;
            let allow = true;
            let val = lineData[lineData.length - 1].Name;
            if ((/^[0-9]+$/.test(val) || /^[0-9]+[,.0-9\s]+[0-9]+$/.test(val) || /(\d)[(\,)(\.)]/.test(val) || /(\d)+(\s)\d+/.test(val))) {
                allow = true;
            }
            if (lineData.length > 1) {
                let val = lineData[lineData.length - 2].Name;
                if ((/^[0-9]+$/.test(val) || /^[0-9]+[,.0-9\s]+[0-9]+$/.test(val) || /(\d)[(\,)(\.)]/.test(val) || /(\d)+(\s)\d+/.test(val))) {
                    allow = true;
                }
            }
            if (validRowLength == 0 || (validRowLength < nextLine.length && lineData.length <= line.length && allow)) {
                validRowLength = nextLine.length;
            }
            validRows.push(tableIndex - 1);
            if (columnCordinates.length == 0) {
                for (let i = 0; i < line.length; i++) {
                    let a = line[i];
                    let matched = false;
                    for (let j = 0; j < lineData.length; j++) {
                        let b = lineData[j];
                        if ((b.rightX > a.leftX && b.leftX < a.rightX) && a.Name.indexOf("|") == -1) {
                            matched = true;
                            let obj = {
                                "header": a['Name'],
                                leftX: b.leftX < a.leftX ? b.leftX : a.leftX,
                                rightX: b.rightX > a.rightX ? b.rightX : a.rightX
                            }
                            if (util_1.isNullOrUndefined(columnCordinates[i])) {
                                columnCordinates.push(obj);
                            } else {
                                if (columnCordinates[i]['rightX'] < b.rightX) {
                                    columnCordinates[i]['rightX'] = b.rightX;
                                }
                            }
                        }

                    }
                    if (!matched) {
                        let obj = {
                            "header": a['Name'],
                            leftX: a.leftX,
                            rightX: a.rightX
                        }
                        if (util_1.isNullOrUndefined(columnCordinates[i])) {
                            columnCordinates.push(obj);
                        }
                    }
                }
            }

        } else {
            lastValidRow = false;
        }

        return { obj: obj, lastValidRow: lastValidRow, subHearderRow: subHearderRow, columnCordinates: columnCordinates, amountFound: amountFound, validRowLength: validRowLength };
    }
    findOverLapp(a, element, columnCordinates) {
        let overLap = [];
        for (let index = 0; index < columnCordinates.length; index++) {
            let field = columnCordinates[index];
            if ((element.rightX > field.leftX && element.leftX < field.rightX)) {
                let overlap = field.rightX - element.leftX;
                if (element.leftX < field.leftX) {
                    overlap = element.rightX - field.leftX
                }
                let dist = field.rightX - field.leftX;
                let overLapPerc = (overlap / dist) * 100
                let ob = {
                    element: field,
                    overLapPerc: overLapPerc
                }
                overLap.push(ob);

            }

        }
        if (overLap.length > 0) {
            overLap.sort(function (a, b) {
                return a.overLapPerc - b.overLapPerc;
            });
            let overlapHeader = overLap[overLap.length - 1]['element'];
            if (overlapHeader.header != a.header) {
                return false;
            }
        }


        return true;
    }
    findMultiOverLapp(a, element, columnCordinates) {
        let overLap = [];
        for (let index = 0; index < columnCordinates.length; index++) {
            let field = columnCordinates[index];
            if ((element.rightX > field.leftX && element.leftX < field.rightX)) {
                let overlap = field.rightX - element.leftX;
                if (element.leftX < field.leftX) {
                    overlap = element.rightX - field.leftX
                }
                let dist = field.rightX - field.leftX;
                let overLapPerc = (overlap / dist) * 100
                // if(overLapPerc>5){
                let ob = {
                    element: field,
                    overLapPerc: overLapPerc
                }
                overLap.push(ob);
                // }


            }

        }
        if (overLap.length > 1) {
            return { overLapPerc: 0, allow: false };
        }

        let overLapPerc = 0;
        if (overLap.length > 0) {
            return { overLapPerc: overLap[0].overLapPerc, allow: true };
        }
        return { overLapPerc: 0, allow: true };
    }
    filterColumns(line, columns) {
        let finalColumns = [];
        for (let i = 0; i < columns.length; i++) {
            let col = columns[i];
            for (let j = 0; j < line.length; j++) {
                let textD = line[j];
                if (col.xmin < textD.leftX && col.xmax < textD.rightX && col.xmax > textD.leftX) {
                    col['delete'] = true;
                }
            }
        }
        finalColumns = columns.filter(function (x) { return util_1.isNullOrUndefined(x.delete); });
        return finalColumns;
    }
    update_fileuploadHistories(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                res.send({ status: 0 });

                let i_size, pl_start = performance.now();
                try { i_size = req.headers['content-length'] } catch (e) { i_size = 0 };

                logger.info("for update_fileuploadHistories");
                let body = req.body;
                // console.log("body-----", JSON.stringify(req.body));
                let imagesPathaaray = body.input.imagesPathaaray;
                //let imagesPathaaray = body.input.outputArray;
                let fileRefNum = body.input.fileRefNum;
                let documentType = body.input.documentType;
                let eventId = body.input.eventId;
                let projectId = body.projectId;
                let botId = body.botId;
                let token = body.token;
                let iterationId = body.iterationId;
                let subscriberId = body.input.subscriberId;
                // const MongoClient = require('mongodb').MongoClient;
                // let mClient = yield MongoClient.connect(config.mongoConnection);
                // let dbName = config.mongoConnection.split('/');
                // let db = yield mClient.db(dbName[dbName.length - 1]);----18888
                let data2 = yield (db.createDynamicModel('fileuploadhistories')).findOneAndUpdate({ fileRefNum: fileRefNum }, { $set: { imagesPath: imagesPathaaray, documentType: documentType } }, { upsert: true });

                let data3 = yield subscriber.findOneAndUpdate({ 
                    _id: ObjectId(String(subscriberId)), 
                    "features.documentTypeList" : {
                        $elemMatch: {
                            name: documentType
                        }
                    }
                }, { $set: { "features.$[].documentTypeList.$[elem].used": imagesPathaaray.length } },
                { arrayFilters: [ { "elem.name": documentType } ] }).exec();



                data3 = JSON.parse(JSON.stringify(data3));

                let outputData = { "imagesPathaaray_op": imagesPathaaray, "uplodeStatus": true, 'statusCode': '200' };
                //   let outputData = { "mergearray":mergearray,"uplodeStatus": true, 'statusCode': '200' };
                let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'authorization': token, 'content-type': "application/json" };
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     //console.log("body---responce",body);
                //     //console.log("---res",response);
                // });
                ///////////////////////////////////////////////////////
                let pl_end = performance.now();
                yield this.commonFunctions.performanceLog(req.body.input && req.body.input.eventId ? req.body.input.eventId : '', req.body.iterationId ? req.body.iterationId : '', "update_fileuploadHistories", pl_start, pl_end, i_size, pl_end - pl_start);
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
                console.log("finishhhhhhhhhhh===========");
            }
            catch (e) {
                // logger.error("In catch for failed to update in fileuploadhistorytable", e);
                console.log("In catch for failed to update in fileuploadhistorytable", e);
                let outputData = { "imagesPathaaray_op": null, "uplodeStatus": true, 'statusCode': '202' };
                //   let outputData = { "mergearray":mergearray,"uplodeStatus": true, 'statusCode': '200' };
                let taskData = { 'projectId': req.body.projectId, 'botId': req.body.botId, 'eventId': req.body.input.eventId, 'iterationId': req.body.iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'authorization': req.body.token, 'content-type': "application/json" };
                taskData['exception'] = e.toString();
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                // request(options, function (error, response, body) {
                //     // console.log("--------------err in res",error);
                //     //console.log("body---responce",body);
                //     //console.log("---res",response);
                // });
                ///////////////////////////////////////////////////////
                let self = this;
                yield self.ioWrite(options);


                ///////////////////////////////////////////////////////
            }
        });
    }
    linebylineformationOld(req, res) {
        var fs = require('fs');
        let body = req.body;
        let eventId = body.input.eventId;
        let projectId = body.projectId;
        let botId = body.botId;
        let token = body.token;
        let iterationId = body.iterationId;
        let filePath;
        //let filePath = !util_2.isNullOrUndefined(body.input.filePath) ? body.input.filePath : '';
        if (!util_2.isNullOrUndefined(body.input.filePath) && typeof body.input.filePath !== "string" && body.input.filePath.length > 0) {
            filePath = body.input.filePath[iterationId];
        }
        else {
            filePath = !util_2.isNullOrUndefined(body.input.filePath) ? body.input.filePath : '';
        }
        console.log("ABhijeet testing", filePath);
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            try {
                res.send({ status: 0 });
                logger.info('Inside findUplode');
                //   let body = req.body;
                let fileName;
                console.log("---------------body---", JSON.stringify(body));
                // const filePath = !util_2.isNullOrUndefined(body.input.filePath) ? body.input.filePath : '';
                //    const filePath = !util_2.isNullOrUndefined(body.filePath) ? body.filePath : '';
                // console.log(filePath);
                const file = fs.readFileSync(filePath);
                if (!util_2.isNullOrUndefined(file) && file !== '') {
                    // fileData['file'] = file.toString('base64');
                    fileName = file.toString('base64');
                }
                else {
                }
                // let folderPath = body.input.folderPath;
                // let renameFile1=body.input.renameFile;
                let fileData = [];
                // requestData(fileData, callback) {
                logger.info('Inside Request Data');
                /*Send file to google vision api*/
                // let rawData = fileData.file;
                let rawData = fileName;
                const baseUrl = "https://vision.googleapis.com/v1/images:annotate", data = {
                    'requests': [
                        {
                            'image': {
                                'content': rawData
                            },
                            'features': [
                                {
                                    'type': 'DOCUMENT_TEXT_DETECTION'
                                }
                            ]
                        }
                    ]
                }, self = this;
                const urloptions = {
                    url: baseUrl + "?key=" + subscriptionKey,
                    headers: {
                        'Content-Type': 'application/octet-stream',
                        'Ocp-Apim-Subscription-Key': subscriptionKey
                    },
                    body: data,
                    json: true
                };
                request.post(urloptions, function (err, resp, body) {
                    if (err) {
                        console.log("Eroooroor" + err);
                        callback(err, null);
                    }
                    else {
                        if (util_1.isNullOrUndefined(body['responses'][0]['fullTextAnnotation'])) {
                            console.log("Inside request if condition");
                            callback(true);
                        }
                        else {
                            console.log("Error" + err);
                            //   console.log("Response" + JSON.stringify(resp));
                            fileData['sortedLines'] = body['responses'][0];
                            //  let  filePath = fileData.obj.filePath;
                            //  let filepath2= filePath.replace(/.png|.jpg/,'');
                            //console.log("filepath of json=================>",filepath2);
                            fs.writeFileSync('/var/www/cuda-fs/fulltext.json', JSON.stringify(body['responses'][0]['fullTextAnnotation']));
                            //google call--
                            let result = [];
                            for (let i = 0; i < fileData['sortedLines'].fullTextAnnotation.pages[0].blocks.length; i++) {
                                let obj = {};
                                let x = [];
                                let y = [];
                                for (let j = 0; j < fileData['sortedLines'].fullTextAnnotation.pages[0].blocks[i].boundingBox.vertices.length; j++) {
                                    x.push(fileData['sortedLines'].fullTextAnnotation.pages[0].blocks[i].boundingBox.vertices[j].x);
                                    y.push(fileData['sortedLines'].fullTextAnnotation.pages[0].blocks[i].boundingBox.vertices[j].y);
                                }
                                x.sort();
                                y.sort();
                                obj['confidence'] = fileData['sortedLines'].fullTextAnnotation.pages[0].blocks[i].confidence;
                                obj['leftX'] = x[0];
                                obj['rightX'] = x[x.length - 1];
                                obj['topY'] = y[0];
                                obj['bottomY'] = y[y.length - 1];
                                result.push(obj);
                            }
                            fileData['confidanceBox'] = result;
                            fileData['pageWidth'] = body['responses'][0]['fullTextAnnotation'].pages[0].width;
                            fileData['pageHeight'] = body['responses'][0]['fullTextAnnotation'].pages[0].height;
                            logger.info('Inside Get Sorted Lines');
                            /*Create object of words here set - Name, leftX, rightX, topY, bottomY and sort it topY*/
                            let resp = fileData.sortedLines;
                            //	console.log("respoce filedata",JSON.stringify(resp));
                            if (!util_1.isNullOrUndefined(resp['textAnnotations'])) {
                                console.log("--------------INNNNNN");
                                let lineWords = resp['textAnnotations'];
                                let sortedWords;
                                let lines = self.processWords(lineWords);
                                sortedWords = JSON.parse(JSON.stringify(lines));
                                sortedWords.sort(function (a, b) {
                                    return a["pageNo"] - b["pageNo"] || a["topY"] - b["topY"];
                                });
                                fileData['sortedWords'] = sortedWords;
                                fileData['combineWords'] = lines;
                                //here sorted words-----
                                //fs.writeFileSync('/var/www/cuda-fs/fulltext_11.json',JSON.stringify(fileData['combineWords']);
                                fs.writeFileSync('/var/www/cuda-fs/PRADNYA_combineWords_' + new Date() + '.json', JSON.stringify(lines));
                                fs.writeFileSync('/var/www/cuda-fs/PRADNYA_sortedWords_' + new Date() + '.json', JSON.stringify(sortedWords));
                                // fileData['fileRefNum'] = fileData.obj.fileRefNum;
                                fileData['raw'] = lineWords;
                                delete fileData.sortedLines;
                            }
                            logger.info('Inside combine lines');
                            let scanData = { "_id": "5eaab641e646f10be6f6badc", "updatedAt": "2020-06-29T10:00:38.733Z", "createdAt": "2020-04-07T09:52:49.535Z", "userId": "5beaabd82ac6767c86dc311e", "subscriberId": "5beaabd82ac6767c86dc311c", "orgId": "5c495dbfffa2a85b2c19a77f", "__v": 0, "ruleId": "5e8c8b03a215f50edc23381a", "tableEnd": ["total", "sub-total", "sub total", "subtotal", "gross amount", "net amount", "net amt", "gross amt", "gross total", "Total / Total"], "tableStart": ["No", "item Name", "qty", "quantity", "description", "item description", "vat rate", "FAM", "Article", "Ord.Qty", "Barcode", "desc", "rate", "te", "tax", "per", "hsn/sac", "amount", "Item", "item", "vat", "itm", "net", "PCS", "gross", "net", "si", "PRICE", "UNIT", "OTY", "DESCRIPTIONS", "SR.N", "UnitConv.", "Unit.Cost", "Tot.Cost", "Discount", "Gross Total", "Ex.Tax", "Vendor Ref.", "St.Bin", "St.Lo", "S", "S.No", "Seq", "Taskcard/Interval", "Item", "R. (Op)", "Step", "Panel No", "Panel Description", "Affected Taskcard", "Time", "Sr.", "CGST", "SGST", "IGST", "Qty /", "Total gross /", "Item /Producto", "No. /No."], "isDeleted": false, "functionNames": [["requestData", "getsortedLines", "combineLines", "extractFeatures", "saveDocTrainData", "identifyTable", "extractTableData", "genrateCsv", "runTrainingForInvoice", "prepareFormData", "prepareTableData", "createItemObject", "saveErrorInvoice"]], "ruleName": "OfflineOcr", "tableMapping": { "Total gross /": "Total gross", "VAT amount/IVA": "Tax Amount", "VAT": "Tax Rate", "No. /No.": "srNo", "Item /Producto": "Item", "Qty /": "Quantity", "Unit net pricel": "Unit Price", "Total net/Total": "Net Amount", "SKUDESCRIPTION": "Description Of Goods", "SKU/DESCRIPTION": "Description Of Goods", "ID": "ID", "BETRAG(EUR)": "BETRAG(EUR)", "MWST.": "MWST.", "ZWISCHENSUMME": "ZWISCHENSUMME", "RABATTE": "RABATTE", "BESCHREIBUNG": "BESCHREIBUNG", "STOCKPREIS": "STOCKPREIS", "AMOUNT(INR)": "Amount (INR)", "AMOUNT(CAD)": "Amount(CAD)", "AMOUNT(USD)": "Amount(USD)", "CHARGES(RS.)": "Charges (Rs.)", "UNITRATE": "Unit Rate", "BILLED": "Billed", "FREE": "Free", "USAGE": "Usage", "PLANNAME": "Plan Name", "RATE": "Rate", "AMT": "Amount", "PER": "Per", "AMOUNT": "Amount", "INVOICENUMBER": "Invoice Number", "DOCUMENTNUMBER": "Document Number", "DOCUMENTDATE": "Document Date", "INVOICEAMOUNT": "Invoice Amount", "DEDUCTIONS": "Deductions", "NETAMOUNT": "Net Amount", "SNO": "srNo", "SNO.": "srNo", "MATERIALCODE": "Material Code", "DESCRIPTIONOFGOODS": "Description Of Goods", "DESCRIPTIONOF": "Description Of Goods", "DESCRIPTION": "Description Of Goods", "HSNSACNO.": "HSN / SAC No", "HSNSACNO": "HSN / SAC No", "HSN/SACNO": "HSN / SAC No", "HSN/SACNO.": "HSN / SAC No", "QUANTITY": "Quantity", "UNITPRICE": "Unit Price", "SALESPRICE": "Sales Price", "DISCOUNT": "Discount", "TAXABLEVALUE": "Taxable Value", "CGSTRATE": "CGST Rate", "CGST": "CGST", "SGST/UGSTRATE": "SGST / UGST Rate", "SGST/UGST": "SGST / UGST", "TOTALVALUE": "Total Value", "IGST": "IGST", "IGSTRATE": "IGST Rate", "ITEM": "Item", "LINEPRICE": "Line Price", "SLNO": "SL NO", "PRODUCT": "Product", "TAXRATE": "Tax Rate", "TAXTYPE": "Tax Type", "TAXAMOUNT": "Tax Amount", "PRICE": "Price", "QTY": "Quantity", "QTY.": "Quantity", "ITEMCODE": "Item Code", "ITEMDESCRIPTION": "Item Description", "TAXCODE": "Tax Code", "NO": "No", "UNITPRICE(USD)": "UNIT PRICE (USD)", "TOTALPRICE(USD)": "TOTAL PRICE (USD)", "DESCRIPTIONOFSERVICES/GOODS": "Description of Services / Goods", "HSN/SAC": "HSN/SAC", "SR.No.": "SR.No.", "TAXABLEAMOUNT": "Taxable Amount", "SRNo": "SR No", "SGST": "SGST", "UNITS(KVARH)": "Units ( kVArh )", "COST(F)": "Cost(f)", "OTY": "Quantity", "ITEM/DESCRIPTION": "Item / Description", "SERIALNO": "Serial No", "RENTALFROM": "Rental From", "RENTALTO": "Rental To", "UNIT": "Unit", "SALESTAX": "Sales Tax", "TOTALPRICE": "Total Price", "HSN": "HSN / SAC No" }, "langs": ["eng"], "fields": [{ "_id": "5e8c4d711c51481d0743ac8a", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": true, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Supplier_Name" }, { "_id": "5e8c4d711c51481d0743ac89", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Date" }, { "_id": "5e8c4d711c51481d0743ac88", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "TRN_number" }, { "_id": "5e8c4d711c51481d0743ac87", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": true, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Invoice_No" }, { "_id": "5e90170b4275654305fcad14", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Supplier_Address" }, { "_id": "5e9072d44275654305fcae2d", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Supplier_Code" }, { "_id": "5e9072d44275654305fcae2c", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "InvoiceTotalAmount" }, { "_id": "5e9072d44275654305fcae2b", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "InvTotalTaxAmt" }, { "_id": "5e9072d44275654305fcae2a", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Payment_Due_Date" }, { "_id": "5e9072d44275654305fcae29", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "PO_Number" }, { "_id": "5e9072d44275654305fcae28", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "PO_Date" }, { "_id": "5ea54c903c3d666ead88b26b", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "float", "fieldName": "Currency" }, { "_id": "5ea54c903c3d666ead88b26a", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "float", "fieldName": "Other_Charges" }, { "_id": "5ea54c903c3d666ead88b269", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "float", "fieldName": "Discount" }, { "_id": "5ea54c903c3d666ead88b268", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Country" }, { "_id": "5ea54c903c3d666ead88b267", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Supplier_city" }, { "_id": "5ea54c903c3d666ead88b266", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "any", "fieldName": "Supplier_Zip_Code" }, { "_id": "5ea54c903c3d666ead88b265", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Customer_City" }, { "_id": "5ea54c903c3d666ead88b264", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "any", "fieldName": "Customer_Zip_Code" }, { "_id": "5ea54c903c3d666ead88b263", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Customer_Address" }, { "_id": "5ea54c903c3d666ead88b262", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "float", "fieldName": "Net_Total" }, { "_id": "5e946620e5e25861e5936fa2", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "SlNo" }, { "_id": "5e946620e5e25861e5936fa1", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Description" }, { "_id": "5e946620e5e25861e5936f9e", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "number", "fieldName": "Quantity" }, { "_id": "5e946620e5e25861e5936f9d", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "float", "fieldName": "Rate" }, { "_id": "5e946620e5e25861e5936f9b", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "float", "fieldName": "Amount" }, { "_id": "5e946620e5e25861e5936f9a", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Product_Code" }, { "_id": "5e946620e5e25861e5936f99", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "float", "fieldName": "Tax_percent" }, { "_id": "5e946620e5e25861e5936f98", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "float", "fieldName": "Tax_Amount" }, { "_id": "5e946620e5e25861e5936f97", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "TRN" }, { "_id": "5e94665ae5e25861e5936fa8", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "float", "fieldName": "Taxable_Amount" }], "isSystemDefined": false, "documentType": "Landmark" };
                            // console.log("Scanfiled data",JSON.stringify(scanData));
                            // fs.writeFileSync("scanfiledPradnya.json",JSON.stringify(scanData));
                            /*Combine Lines and Words of lines here by overlapping*/
                            logger.info('Inside combine lines');
                            //  console.log("combineliness-----data--KRISHNA",JSON.stringify(fileData));
                            let itemData = _.groupBy(fileData.combineWords, 'pageNo');
                            let keys = Object.keys(itemData);
                            let sortedLines = [];
                            for (const lin of keys) {
                                let bags = itemData[lin];
                                bags.sort(function (a, b) {
                                    return a["topY"] - b["topY"] || a["leftX"] - b["leftX"];
                                });
                                let multiline = bags[0]["Name"];
                                multiline = multiline.match(/\n/g);
                                if (multiline) {
                                    bags.splice(0, 1);
                                }
                                // bags.splice(0, 1);
                                let topY = bags[0].topY, bottomY = bags[0].bottomY, leftX = bags[0].leftX;
                                let len = bags.length;
                                let line = [];
                                let firstWord = self.findFirstWord(bags, bags[0]);
                                if (firstWord.length > 0) {
                                    firstWord = _.sortBy(firstWord, 'leftX');
                                    firstWord.every(function (item) {
                                        if (leftX >= item.leftX) {
                                            line.push(item);
                                            leftX = item.leftX;
                                            bottomY = item.bottomY;
                                            topY = item.topY;
                                            bags = _.without(bags, _.findWhere(bags, { Name: item.Name, rightX: item.rightX, leftX: item.leftX, topY: item.topY, bottomY: item.bottomY }));
                                            return false;
                                        }
                                        else {
                                            return true;
                                        }
                                    });
                                }
                                else {
                                    line.push(bags[0]);
                                    bags.splice(0, 1);
                                }
                                let lineArray;
                                let j = 0;
                                while (bags.length > 0) {
                                    j++;
                                    lineArray = self.findNextLines(bags, topY, bottomY, leftX);
                                    lineArray = _.sortBy(lineArray, 'leftX');
                                    lineArray.every(function (item) {
                                        if (leftX <= item.leftX) {
                                            if (line.length > 0) {
                                                line.push(item);
                                            }
                                            leftX = item.leftX;
                                            bottomY = item.bottomY > bottomY ? item.bottomY : bottomY;
                                            bags = _.without(bags, _.findWhere(bags, { Name: item.Name, rightX: item.rightX, leftX: item.leftX, topY: item.topY, bottomY: item.bottomY }));
                                            return false;
                                        }
                                        else {
                                            return true;
                                        }
                                    });
                                    if (bags.length == 0) {
                                        sortedLines.push(line);
                                    }
                                    if (lineArray.length === 0) {
                                        sortedLines.push(line);
                                        bags.sort(function (a, b) {
                                            return a["topY"] - b["topY"] || a["leftX"] - b["leftX"];
                                        });
                                        topY = bags[0].topY;
                                        bottomY = bags[0].bottomY;
                                        leftX = bags[0].leftX;
                                        len = bags.length;
                                        line = [];
                                        let firstWord = self.findFirstWord(bags, bags[0]);
                                        if (firstWord.length > 0) {
                                            firstWord = _.sortBy(firstWord, 'leftX');
                                            firstWord.every(function (item) {
                                                if (leftX >= item.leftX) {
                                                    line.push(item);
                                                    leftX = item.leftX;
                                                    bottomY = item.bottomY;
                                                    topY = item.topY;
                                                    bags = _.without(bags, _.findWhere(bags, { Name: item.Name, rightX: item.rightX, leftX: item.leftX, topY: item.topY, bottomY: item.bottomY }));
                                                    return false;
                                                }
                                                else {
                                                    return true;
                                                }
                                            });
                                        }
                                        else {
                                            line.push(bags[0]);
                                            bags.splice(0, 1);
                                        }
                                    }
                                }
                            }
                            logger.info('Lines created successfully');
                            let sortedLinesNew = JSON.parse(JSON.stringify(sortedLines));
                            let lineWithCombineWords = [];
                            let lineWithCombineWordsNew = [];
                            var tableHeaders = [];
                            var tableHeadersW = [];
                            for (var k in scanData.tableMapping) {
                                tableHeadersW.push(k);
                                k = k.toLocaleUpperCase();
                                k = k.replace(/\s+/g, '');
                                tableHeaders.push(k);
                            }
                            // console.log('sorted Lies----------->',JSON.stringify(sortedLines));
                            for (let i = 0; i < sortedLines.length; i++) {
                                lineWithCombineWords.push(self.combineLineWords(sortedLines[i], sortedLines));
                                lineWithCombineWordsNew.push(self.combineTableHeaders(sortedLinesNew[i], tableHeaders));
                            }
                            // console.log(JSON.stringify(sortedLines));
                            fileData['Lines'] = sortedLines;
                            //fs.writeFileSync('LinesArray--11.json',JSON.stringify(sortedLines));
                            // fs.writeFileSync('linewwithCombinewords--11.json',JSON.stringify(lineWithCombineWords));
                            //fs.writeFileSync('KRISHNA.json',JSON.stringify(lineWithCombineWordsNew));
                            lineWithCombineWordsNew[0].push({ pagewidth: fileData.pageWidth, pageHieght: fileData.pageHeight });
                            //  console.log();
                            fileData['lineWithCombineWords'] = lineWithCombineWords;
                            fileData['lineWithCombineWordsNew'] = lineWithCombineWordsNew;
                            delete fileData.combineWords;
                            let csvInfoArray = [];
                            fileData['csvInfoArray'] = csvInfoArray;
                            //  fileData['fileRefNum'] = fileData.obj.fileRefNum;
                            //  callback(null, fileData);
                            let ll = filePath.split(/\//);
                            console.log("LLLL ----------****__________>>>>>>>>>>>>>>>>>>>>", ll);
                            let namefile = ll[ll.length - 1];
                            let txtfile = namefile.replace(/.jpg|.png/g, '');
                            let output_filepath = '/var/www/cuda-fs/' + txtfile + '.txt';
                            console.log("Here is output filepth---->>>>>><<<<--------", output_filepath);
                            console.log("--------------------------------textfile created----", txtfile);
                            fs.writeFileSync(output_filepath, JSON.stringify(lineWithCombineWordsNew));
                            let outputData = { "output": lineWithCombineWordsNew, "uplodeStatus": true, 'statusCode': '200' };
                            let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                            let headers = { 'authorization': token, 'content-type': "application/json" };
                            //  let headers = { 'authorization': body['token'], 'content-type': "application/json", "selectedorgid": body['selectedorgid'] };
                            //"https://cuda-testing.gibots.com/gibots-orch/orchestrator/botsiowrite"
                            // console.log(JSON.stringify(headers)," ======>>>>>>>----------->>>>>>>> ", JSON.stringify(taskData));
                            var options = {
                                method: 'POST',
                                url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                                //url: "http://cuda-testing.gibots.com:1443/gibots-orch/orchestrator/botsiowrite",
                                headers: headers,
                                body: taskData,
                                json: true
                            };
                            process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                            request(options, function (error, response, body) {
                                // console.log("--------------err in res",error);
                                //console.log("body---responce",body);
                                console.log("--*******-res", response);
                            });
                        }
                    }
                });
                // }
                console.log("Filedat------", JSON.stringify(fileData));
            }
            catch (err) {
                logger.error('Inside catch---- ' + err);
            }
        });
    }
    linebylineformation(req, res) {
        res.send({ status: 0 });
        const self = this;
        var fs = require('fs');
        let body = req.body;
        let ruleObj = [];
        let documentType = body.input.documentType;
        let fileRefNum = body.input.fileRefNum;
        let eventId = body.input.eventId;
        let projectId = body.projectId;
        let botId = body.botId;
        let token = body.token;
        let iterationId = body.iterationId;
        let filePathArry = Array.isArray(body.input.filePath) ? body.input.filePath.map(a => a.imageFilePath) : [body.input.filePath];
        let filePath;
        let obj = {
            'documentType': documentType,
            'fileRefNum': fileRefNum
        }
        //let filePath = !util_2.isNullOrUndefined(body.input.filePath) ? body.input.filePath : '';

        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            try {
                let promiseArr = []
                for (let f = 0, flen = filePathArry.length; f < flen; f++) {
                    filePath = filePathArry[f];
                    logger.info('Inside findUplode');
                    let fileName;
                    // console.log("---------------body---", JSON.stringify(body));

                    // console.log(filePath);
                    const file = fs.readFileSync(filePath);
                    if (!util_2.isNullOrUndefined(file) && file !== '') {
                        fileName = file.toString('base64');
                    }
                    else {
                    }
                    logger.info('Inside Request Data');
                    let rawData = fileName;
                    const baseUrl = "https://vision.googleapis.com/v1/images:annotate", data = {
                        'requests': [
                            {
                                'image': {
                                    'content': rawData
                                },
                                'features': [
                                    {
                                        'type': 'DOCUMENT_TEXT_DETECTION'
                                    }
                                ]
                            }
                        ]
                    }
                    const urloptions = {
                        method: 'POST',
                        url: baseUrl + "?key=" + subscriptionKey,
                        headers: {
                            'Content-Type': 'application/octet-stream',
                            'Ocp-Apim-Subscription-Key': subscriptionKey
                        },
                        body: data,
                        json: true
                    };

                    console.warn(" -- -- CALLING GOOGLE API -- -- ");

                    promiseArr.push(self.requestApi(urloptions));
                    // let googleCall = fs.readFileSync("/home/user/Desktop/help/googleOcr.json");
                    // googleCall = JSON.parse(googleCall);\
                }
                let allRes = yield Promise.all(promiseArr);
                for (let f = 0, flen = allRes.length; f < flen; f++) {
                    let googleCall = allRes[f];
                    let fileData = {};
                    if (googleCall['status'] == 0) {
                        let googleO = googleCall['output'];
                        fileData['sortedLines'] = googleO['responses'][0];
                        //google call--
                        let result = [];
                        for (let i = 0; i < fileData['sortedLines'].fullTextAnnotation.pages[0].blocks.length; i++) {
                            let obj = {};
                            let x = [];
                            let y = [];
                            for (let j = 0; j < fileData['sortedLines'].fullTextAnnotation.pages[0].blocks[i].boundingBox.vertices.length; j++) {
                                x.push(fileData['sortedLines'].fullTextAnnotation.pages[0].blocks[i].boundingBox.vertices[j].x);
                                y.push(fileData['sortedLines'].fullTextAnnotation.pages[0].blocks[i].boundingBox.vertices[j].y);
                            }
                            x.sort();
                            y.sort();
                            obj['confidence'] = fileData['sortedLines'].fullTextAnnotation.pages[0].blocks[i].confidence;
                            obj['leftX'] = x[0];
                            obj['rightX'] = x[x.length - 1];
                            obj['topY'] = y[0];
                            obj['bottomY'] = y[y.length - 1];
                            result.push(obj);
                        }
                        fileData['confidanceBox'] = result;
                        fileData['pageWidth'] = googleO['responses'][0]['fullTextAnnotation'].pages[0].width;
                        fileData['pageHeight'] = googleO['responses'][0]['fullTextAnnotation'].pages[0].height;
                        logger.info('Inside Get Sorted Lines');
                        /*Create object of words here set - Name, leftX, rightX, topY, bottomY and sort it topY*/
                        let resp = fileData.sortedLines;
                        //	console.log("respoce filedata",JSON.stringify(resp));
                        if (!util_1.isNullOrUndefined(resp['textAnnotations'])) {
                            console.log("--------------INNNNNN");
                            let lineWords = resp['textAnnotations'];
                            let sortedWords;
                            let lines = self.processWords(lineWords);
                            sortedWords = JSON.parse(JSON.stringify(lines));
                            sortedWords.sort(function (a, b) {
                                return a["pageNo"] - b["pageNo"] || a["topY"] - b["topY"];
                            });
                            fileData['sortedWords'] = sortedWords;
                            fileData['combineWords'] = lines;
                            fileData['raw'] = lineWords;

                            delete fileData['sortedLines'];
                            obj['filePath'] = filePathArry[f];

                            fileData['obj'] = obj;
                            fileData['fileRefNum'] = fileRefNum;

                            ruleObj.push(JSON.parse(JSON.stringify(fileData)));
                        }

                    }
                    else {
                        throw "googleApi failed"
                    }
                }
                let outputData = { "uplodeStatus": true, 'statusCode': '200', 'output': ruleObj };
                let taskData = { 'projectId': body['projectId'], 'botId': body['botId'], 'eventId': body.input['eventId'], iterationId: body['iterationId'], 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'authorization': body['token'], 'content-type': "application/json", "selectedorgid": body['selectedorgid'] };
                // console.log(JSON.stringify(headers), " ======>>>>>>>----------->>>>>>>> ", JSON.stringify(taskData));
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';

                yield self.ioWrite(options);
            }
            catch (err) {
                logger.error('Inside catch---- ' + err);
                logger.error("#extractFeatures==>Internal server Error");
                let outputData = { "output": null, "uploadStatus": true, 'statusCode': '202' };
                let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'Authorization': token, 'content-type': "application/json" };
                taskData['exception'] = "#output==>Internal server Error " + err;
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                ///////////////////////////////////////////////////
                yield self.ioWrite(options)
            }
        });
    }
    processWords(lineWords) {
        let processWords = [];
        _.each(lineWords, function (words) {
            let wordObj = {};
            wordObj["Name"] = words.description.replace(",", "~");
            words.boundingPoly.vertices.sort(function (a, b) {
                return a.y - b.y;
            });
            wordObj["topY"] = util_1.isNullOrUndefined(words.boundingPoly.vertices[0].y) ? 0 : words.boundingPoly.vertices[0].y;
            wordObj["bottomY"] = words.boundingPoly.vertices[3].y;
            words.boundingPoly.vertices.sort(function (a, b) {
                return a.x - b.x;
            });
            wordObj["leftX"] = words.boundingPoly.vertices[0].x;
            wordObj["rightX"] = words.boundingPoly.vertices[3].x;
            wordObj["pageNo"] = !util_1.isNullOrUndefined(words.boundingPoly.vertices[2].pageNo) ? words.boundingPoly.vertices[2].pageNo : 1;
            wordObj["confidence"] = !util_1.isNullOrUndefined(words.confidence) ? words.confidence : 1;
            wordObj["property"] = 'undefined';
            // console.log("words"+JSON.stringify(wordObj));
            if (util_1.isNullOrUndefined(wordObj.leftX) || util_1.isNullOrUndefined(wordObj.rightX)) {
                console.log("Leaving word because of Leftx or Rightx Not present for" + wordObj.Name);
            }
            else {
                processWords.push(wordObj);
            }
            // console.log(wordObj)
            // processWords.push(wordObj);
        });
        // console.log(wordObj.length)
        // console.log(wordObj)
        return processWords;
    }
    processWordsNew(lineWords, a) {
        let processWords = [];
        a = Number(a);
        console.log("A", a);
        _.each(lineWords, function (words) {
            let wordObj = {};
            wordObj["Name"] = words.text.split('\\').join('');
            wordObj["leftX"] = words.left * a;
            wordObj["rightX"] = (words.left + words.width) * a;
            wordObj["topY"] = (words.pageHeight - words.top - words.Height) * a;
            wordObj["bottomY"] = ((words.pageHeight - words.top)) * a;
            let perc = (words.Height * a) * 0.65;
            wordObj["topY"] = wordObj["topY"] - (perc / 2);
            wordObj["bottomY"] = wordObj["bottomY"] + (perc / 2);
            wordObj["pageNo"] = words.pageId + 1;
            wordObj["confidence"] = 100;
            wordObj["property"] = 'undefined';
            processWords.push(wordObj);
        });
        return processWords;
    }
    findFirstWord(bags, currWords) {
        /*Find first word of line*/
        try {
            let per;
            let temp = [];
            bags.forEach(function (list) {
                if ((list.topY >= currWords.topY && list.bottomY <= currWords.bottomY) || (list.bottomY <= currWords.bottomY && list.topY <= currWords.topY) ||
                    (list.bottomY >= currWords.bottomY && list.topY <= currWords.topY) || (list.topY >= currWords.topY && list.topY < currWords.bottomY)) {
                    if (list.leftX <= currWords.leftX) {
                        if (list.topY >= currWords.topY && list.bottomY <= currWords.bottomY) {
                            per = 100;
                        }
                        else if (list.topY <= currWords.topY) {
                            per = ((list.bottomY - currWords.topY) / (list.bottomY - list.topY)) * 100;
                        }
                        else {
                            per = ((currWords.bottomY - list.topY) / (list.bottomY - list.topY)) * 100;
                        }
                        if (per >= 50) {
                            temp.push(list);
                        }
                    }
                }
            });
            return temp;
        }
        catch (err) {
            logger.error('Error in find first words of line' + err);
            return [];
        }
    }
    findNextLines(bags, topY, bottomY, leftX) {
        /*Find next words of line*/
        let per;
        let temp = [];
        bags.filter(function (item) {
            if ((item.topY >= topY && item.topY <= bottomY) || (item.bottomY <= bottomY && item.topY <= topY) ||
                (item.bottomY >= bottomY && item.topY <= topY)) {
                if (item.leftX >= leftX) {
                    if (item.topY >= topY && item.bottomY <= bottomY) {
                        per = 100;
                    }
                    else if (item.topY <= topY) {
                        per = ((item.bottomY - topY) / (item.bottomY - item.topY)) * 100;
                    }
                    else {
                        per = ((bottomY - item.topY) / (item.bottomY - item.topY)) * 100;
                    }
                    let height = (bottomY - topY) / (item.bottomY - item.topY);
                    if (per >= 50 && height < 2) {
                        temp.push(item);
                    }
                }
            }
        });
        return temp;
    }
    colonSplitter(lineWithCombineWords) {
        try {
            let counter = 0;
            let abc = [];
            let final = [];
            for (let i = 0; i < (lineWithCombineWords.length); i++) {
                for (let j = 0; j < lineWithCombineWords[i].length; j++) {
                    if (lineWithCombineWords[i][j]["Name"].includes(":")) {
                        let splitWord = lineWithCombineWords[i][j].Name.split(":");
                        let textLength = lineWithCombineWords[i][j].Name.length;
                        let pixelLength = (lineWithCombineWords[i][j].rightX - lineWithCombineWords[i][j].leftX) / textLength;
                        let firstWordLength = pixelLength * splitWord[0].length;
                        let secondWordLength = pixelLength * splitWord[1].length;
                        // console.log(firstWordLength);
                        // console.log(secondWordLength);
                        let wordArray = [];
                        let firstWordFinal = {};
                        firstWordFinal.level = lineWithCombineWords[i][j].level;
                        firstWordFinal.block_num = lineWithCombineWords[i][j].block_num;
                        firstWordFinal.par_num = lineWithCombineWords[i][j].par_num;
                        firstWordFinal.line_num = lineWithCombineWords[i][j].line_num;
                        firstWordFinal.word_num = lineWithCombineWords[i][j].word_num;
                        firstWordFinal.leftX = lineWithCombineWords[i][j].leftX;
                        firstWordFinal.topY = lineWithCombineWords[i][j].topY;
                        firstWordFinal.width = firstWordLength;
                        firstWordFinal.height = lineWithCombineWords[i][j].height;
                        firstWordFinal.rightX = lineWithCombineWords[i][j].leftX + firstWordLength;
                        firstWordFinal.bottomY = lineWithCombineWords[i][j].bottomY;
                        firstWordFinal.confidence = lineWithCombineWords[i][j].confidence;
                        firstWordFinal.Name = splitWord[0];
                        wordArray.push(firstWordFinal);
                        let secondWordFinal = {};
                        secondWordFinal.level = lineWithCombineWords[i][j].level;
                        secondWordFinal.block_num = lineWithCombineWords[i][j].block_num;
                        secondWordFinal.par_num = lineWithCombineWords[i][j].par_num;
                        secondWordFinal.line_num = lineWithCombineWords[i][j].line_num;
                        secondWordFinal.word_num = lineWithCombineWords[i][j].word_num;
                        secondWordFinal.leftX = lineWithCombineWords[i][j].rightX - secondWordLength;
                        secondWordFinal.topY = lineWithCombineWords[i][j].topY;
                        secondWordFinal.width = secondWordLength;
                        secondWordFinal.height = lineWithCombineWords[i][j].height;
                        secondWordFinal.rightX = lineWithCombineWords[i][j].rightX;
                        secondWordFinal.bottomY = lineWithCombineWords[i][j].bottomY;
                        secondWordFinal.confidence = lineWithCombineWords[i][j].confidence;
                        secondWordFinal.Name = splitWord[1];
                        // abc.push(firstWordFinal);
                        // abc.push(secondWordFinal);
                        if (firstWordFinal.Name.replace(/\s/g, '') != "") {
                            firstWordFinal.Name = firstWordFinal.Name.trim()
                            abc.push(firstWordFinal);
                        }
                        if (secondWordFinal.Name.replace(/\s/g, '') != "") {
                            secondWordFinal.Name = secondWordFinal.Name.trim()
                            abc.push(secondWordFinal);
                        }
                        counter = counter + 1;
                    }
                    else {
                        abc.push(lineWithCombineWords[i][j]);
                    }
                }
                final.push(abc);
                abc = [];
            }
            // console.log(final);
            return final;
        }
        catch (e) {
            logger.error('#combineLineWords==>', e);
        }
    }
    combineLineWords(currentline, lines) {
        try {
            /*Combile words from generated lines - find space of two word and combine*/
            let breakFields = config.breakFields;
            let breakWords = config.breakWords;
            //let lineIndex = 0;
            let combineLineWords = [];
            let whiteSpaceDiff = 0;
            let tableHeader = {};
            for (let k = 0; k < currentline.length; k++) {
                tableHeader = JSON.parse(JSON.stringify({ "Name": currentline[k].Name, "leftX": currentline[k].leftX, "topY": currentline[k].topY, "rightX": currentline[k].rightX, "bottomY": currentline[k].bottomY, "colRightX": currentline[k].colRightX, "colLeftX": currentline[k].colLeftX, "lineNo": currentline[k].lineNo, "wordWidth": currentline[k].wordWidth, "pageNo": currentline[k].pageNo, "property": currentline[k].property, "level": currentline[k].level, "block_num": currentline[k].block_num, "par_num": currentline[k].par_num, "line_num": currentline[k].line_num, "word_num": currentline[k].word_num }));
                if (currentline.length == k) {
                    combineLineWords.push(tableHeader);
                }
                else {
                    for (let l = k; l < currentline.length - 1; l++) {
                        let data = [];
                        let info;
                        whiteSpaceDiff = Math.round((currentline[k].bottomY - currentline[k].topY) * (45 / 100));
                        // if ((currentline[l + 1].leftX - currentline[l].rightX) <= whiteSpaceDiff) { ---maF
                        if ((currentline[l + 1].leftX - currentline[l].rightX) <= whiteSpaceDiff + 1 && (currentline[l + 1].leftX - currentline[l].rightX) >= -5) {
                            data = breakFields.filter((item) => {
                                if (item === currentline[l].Name) {
                                    if (currentline[l].length > 2) {
                                        let word = currentline[l - 1].Name === '.' ? currentline[l - 2].Name : currentline[l - 1].Name;
                                        info = breakWords.find(function (list) {
                                            return list === word;
                                        });
                                    }
                                }
                                return info;
                            });
                            if (!util_1.isNullOrUndefined(data) && data.length > 0) {
                                break;
                            }
                            else {
                                let brkSpace = Math.round((currentline[k].bottomY - currentline[k].topY) * (10 / 100));
                                let info = breakFields.find((list) => {
                                    return list === currentline[l + 1].Name.trim();
                                });
                                if (info && (currentline[l + 1].leftX - currentline[l].rightX) >= brkSpace) {
                                    //   console.log('break space - ' + brkSpace);
                                    // console.log('break word - ' + currentline[l + 1].Name);
                                    currentline.splice(l + 1, 1);
                                    break;
                                }
                                else {
                                    //  tableHeader.Name = tableHeader.Name + " " + currentline[l + 1].Name;
                                    //  tableHeader.rightX = currentline[l + 1].rightX;
                                    //  k++;
                                    //  whiteSpaceDiff = Math.round((currentline[k].bottomY - currentline[k].topY) * (60 / 100));
                                    let str = tableHeader.Name.replace(/\s+/g, '');
                                    if (str.substring(str.length - 1, str.length) == '.') {
                                        let str2 = currentline[l + 1].Name.replace(/\s+/g, '');
                                        let isDigit1 = /^\d+(\.\d+)?$/.test(str2);
                                        if (isDigit1) {
                                            tableHeader.Name = tableHeader.Name + " " + currentline[l + 1].Name;
                                            tableHeader.rightX = currentline[l + 1].rightX;
                                            k++;
                                            whiteSpaceDiff = Math.round((currentline[k].bottomY - currentline[k].topY) * (60 / 100));
                                        }
                                    } /*else if(str!==':'){
                                tableHeader.Name = tableHeader.Name + " " + currentline[l + 1].Name;
                                tableHeader.rightX = currentline[l + 1].rightX;
                                k++;
                                whiteSpaceDiff = Math.round((currentline[k].bottomY - currentline[k].topY) * (60 / 100));
                            }*/
                                    else if (str !== ':' && currentline[l + 1].Name !== ':' && str !== '|' && currentline[l + 1].Name !== '|' && str !== ']' && currentline[l + 1].Name !== ']' && str !== '[' && currentline[l + 1].Name !== '['
                                        && !/[a-zA-Z0-9.]+[\|\[\]\{\}\:\)]+$/.test(str)
                                        && !/^[\|\[\]\{\}\:]+[a-zA-Z0-9]+/.test(currentline[l + 1].Name) && ((!/(\d)[(\,)(\.)]/.test(str) && !/(\d)[(\,)(\.)]/.test(currentline[l + 1].Name)) || (Math.round(tableHeader.rightX) == Math.round(currentline[l + 1].leftX)))) {
                                        tableHeader.Name = tableHeader.Name + " " + currentline[l + 1].Name;
                                        tableHeader.rightX = currentline[l + 1].rightX;
                                        k++;
                                        whiteSpaceDiff = Math.round((currentline[k].bottomY - currentline[k].topY) * (60 / 100));
                                    }
                                    else {
                                        break;
                                    }
                                }
                            }
                        }
                        else {
                            break;
                        }
                    }
                }
                combineLineWords.push(tableHeader);
            }
            for (let j = 0; j < combineLineWords.length; j++) {
                if (!util_1.isNullOrUndefined(combineLineWords[j]["Name"])) {
                    if (combineLineWords[j]["Name"] == "") {
                        console.log("combinelinewords ----- before", combineLineWords[j]);
                        combineLineWords.splice(j, 1);
                        console.log("combinelinewords ----- after", combineLineWords[j]);
                    }
                }
            }
            for (let j = 0; j < combineLineWords.length; j++) {
                if (j < combineLineWords.length - 1) {
                    if (combineLineWords[j].leftX < combineLineWords[j + 1].leftX && combineLineWords[j].rightX > combineLineWords[j + 1].leftX) {
                        combineLineWords[j].rightX = combineLineWords[j + 1].leftX - 2
                    }
                }
            }
            return combineLineWords;
        }
        catch (e) {
            logger.error('#combineLineWords==>', e);
        }
    }
    combineTableHeaders(line, tableHeaders) {
        let FinalArray = [];
        let avgLineHeight = 0;
        let lineHeight = 0;
        let avgSpace = 0;
        let space = 0;
        let count = 0;
        let heightArr = [];
        let spaceArr = [];
        let maxHeight = 0;
        let maxSpace = 0;
        let threshold = 0;
        for (let j = 0; j < line.length; j++) {
            let a = line[j];
            lineHeight = lineHeight + a.bottomY - a.topY;
            heightArr.push(a.bottomY - a.topY);
        }
        // heightArr.sort();
        heightArr.sort(function (a, b) { return a - b; });
        maxHeight = heightArr[heightArr.length - 1];
        avgLineHeight = (lineHeight / line.length);
        for (let j = 0; j < line.length; j++) {
            let a = line[j];
            if (j < line.length - 1) {
                let b = line[j + 1];
                if (b.leftX - a.rightX < maxHeight) {
                    space = space + b.leftX - a.rightX;
                    spaceArr.push(b.leftX - a.rightX);
                    count++;
                }
            }
        }
        // spaceArr.sort();
        spaceArr.sort(function (a, b) { return a - b; });
        maxSpace = spaceArr[spaceArr.length - 1];
        avgSpace = (space / count);
        avgSpace = Math.round(avgSpace);
        for (let j = 0; j < line.length - 1; j++) {
            let a = line[j];
            let b = line[j + 1];
            if (typeof (line[j]) == "object" && typeof (line[j + 1]) == "object") {
                a = JSON.parse(JSON.stringify(line[j]));
                b = JSON.parse(JSON.stringify(line[j + 1]));
            }
            if (j < line.length - 1) {
                if ((avgSpace / maxHeight) * 100 > 75) {
                    threshold = maxHeight;
                }
                else {
                    threshold = avgSpace;
                }
            }
            let newWord1 = "";
            if (util_1.isNullOrUndefined(b)) {
            }
            else {
                newWord1 = a.Name + ' ' + b.Name;
            }
            let newValue1 = newWord1.toUpperCase();
            newValue1 = newValue1.replace(/\s+/g, '');
            if (j < line.length - 1 && Math.round(((b.leftX - a.rightX) / maxHeight) * 100) <= 61 || (tableHeaders.indexOf(newValue1) > -1)) {
                // a.rightX = b.rightX;
                // a.Name = a.Name+' '+b.Name;
                // FinalArray.push(a)
                // b['marked'] = true;
                if (util_1.isNullOrUndefined(a['marked'])) {
                    if (a.confidence < b.confidence) {
                        a.confidence = b.confidence;
                    }
                    let word = b.Name;
                    let value = word.toUpperCase();
                    value = value.replace(/\s+/g, '');
                    let newWord = a.Name + ' ' + b.Name;
                    let newValue = newWord.toUpperCase();
                    newValue = newValue.replace(/\s+/g, '');
                    if (a.Name !== '|' && b.Name !== '|' && a.Name !== ':' && b.Name !== ':' && (tableHeaders.indexOf(value) == -1 || tableHeaders.indexOf(newValue) > -1)) {
                        if (a.rightX < b.rightX) {
                            a.rightX = b.rightX;
                        }
                        a.Name = a.Name + ' ' + b.Name;
                        FinalArray.push(a);
                        b['marked'] = true;
                        line[j + 1]['marked'] = true;
                    }
                    else {
                        if (util_1.isNullOrUndefined(a['marked']) && a.Name !== '|' && a.Name !== ':') {
                            FinalArray.push(a);
                        }
                    }
                }
                else {
                    // let k = FinalArray[FinalArray.length-1];
                    //  let tableHeaders = config.newMap;
                    let word = FinalArray[FinalArray.length - 1].Name;
                    let value = word.toUpperCase();
                    value = value.replace(/\s+/g, '');
                    if (tableHeaders.indexOf(value) > -1) {
                        let newWord = FinalArray[FinalArray.length - 1].Name + ' ' + b.Name;
                        let newValue = newWord.toUpperCase();
                        newValue = newValue.replace(/\s+/g, '');
                        if (tableHeaders.indexOf(newValue) > -1) {
                            FinalArray[FinalArray.length - 1].Name = FinalArray[FinalArray.length - 1].Name + ' ' + b.Name;
                            if (FinalArray[FinalArray.length - 1].rightX < b.rightX) {
                                FinalArray[FinalArray.length - 1].rightX = b.rightX;
                            }
                            b['marked'] = true;
                            line[j + 1]['marked'] = true;
                        }
                    }
                    else {
                        FinalArray[FinalArray.length - 1].Name = FinalArray[FinalArray.length - 1].Name + ' ' + b.Name;
                        if (FinalArray[FinalArray.length - 1].rightX < b.rightX) {
                            FinalArray[FinalArray.length - 1].rightX = b.rightX;
                        }
                        b['marked'] = true;
                        line[j + 1]['marked'] = true;
                    }
                }
            }
            else if (j == line.length - 1 || (j < line.length - 1 && b.leftX - a.rightX > 0)) {
                if (util_1.isNullOrUndefined(a['marked']) && a.Name !== '|' && a.Name !== ':') {
                    FinalArray.push(a);
                }
            }
        }
        return FinalArray;
    }
    getCaAccess(req, res) {
        if (!util_2.isNullOrUndefined(req.body.caUserId) && req.body.caUserId !== '') {
            let body = req.body;
            let self = this;
            async.waterfall([
                async.apply(self.websiteHelper.taxCaAccess, body),
                async.apply(self.websiteHelper.createCaToken)
            ], function (err, data) {
                if (err) {
                    res.send(new response_model_5.postResponse(false, err, null, responseMessages.inventory.tokenNotFound));
                }
                else {
                    res.send(new response_model_5.postResponse(true, null, data, responseMessages.inventory.tokenFound));
                }
            });
        }
        else {
            res.send(new response_model_5.postResponse(false, responseMessages.inventory.dataNotFound, null, responseMessages.inventory.dataNotFound));
        }
    }
    subscriberExists(req, res) {
        if (req) {
            let body = req.body;
            this.websiteHelper.subscriberExists(function (err, Result) {
                if (err) {
                    res.send(new response_model_4.getResponse(false, err, err));
                }
                else {
                    res.send(new response_model_4.getResponse(true, null, responseMessages.license.valid));
                }
            });
        }
        else {
            res.send(new response_model_4.getResponse(false, null, responseMessages.license.dataNotFound));
        }
    }
    isLicenseValid(req, res) {
        if (req) {
            let body = req.body;
            this.websiteHelper.isLicenseValid(body.mobile, body.currDate, function (err, result) {
                if (err) {
                    res.send(new response_model_5.postResponse(false, err, null, responseMessages.license.dataNotFound));
                }
                else {
                    if (result == 1)
                        res.send(new response_model_5.postResponse(true, null, 1, responseMessages.license.valid));
                    else if (result == 2)
                        res.send(new response_model_5.postResponse(true, null, 2, responseMessages.license.invalid));
                }
            });
        }
        else {
            res.send(new response_model_4.getResponse(false, null, responseMessages.license.dataNotFound));
        }
    }
    jsonToCsv(path) {
        try {
            if (util_1.isNullOrUndefined(path)) {
                throw "csv path is undefined"
            }
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise(function (resolve, reject) {
                    /* exec(cmd, (err, stdout, stderr) => {
                         if (err) {
                             resolve({ status: 1, err: err });
                         }
                         if (stderr !== '') {
                             resolve({ status: 1, err: stderr });
                         }
                         else {
                             resolve({ status: 0, output: stdout });
                         }
                     });*/
                    if (!util_1.isNullOrUndefined(path) && typeof path === 'object') {
                    }
                    else {
                        const csvFilePath = path;
                        const csv = require('csvtojson');
                        const jsonArray = csv().fromFile(csvFilePath);
                        csv()
                            .fromFile(csvFilePath)
                            .then((jsonObj) => {
                                //     console.log(jsonObj);
                                // fs.writeFileSync('LandMarkKRISHNA.json',JSON.stringify(jsonObj));
                                //console.log("Returnning the objeeeeeeeeeeee===============>");
                                //return jsonObj
                                resolve({ status: 0, output: jsonObj });
                            });
                    }
                });
            });
        } catch (error) {
            // console.log(error);
            return { status: 1, output: {} }
        }
    }
    ioWrite(options,input={}) {

        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let count = 2;
                let self = this;
                options.body.outputParameters = yield self.writeBotOutPut(options.body.outputParameters, options.body.projectId, options.body.botId, options.body.iterationId, options.body.eventId,input)
                if(input.jsonRespond){
                    resolve({ message: "Api Response", status: 0, data: options.body.outputParameters });
                }
                let response = yield self.remoteApiCall(options);
                if (response['status'] == 1) {
                    console.log("----------" + response['data']);
                    for (let index = 0; index < count; index++) {
                        yield self.sleep(180000);
                        response = yield self.remoteApiCall(options);
                        if (response['status'] != 1) {
                            resolve({ message: "Api Response", status: 0, data: "" });
                            break;
                        }
                    }
                    if (response['status'] == 1) {
                        // let outPut = {};
                        // for (const stat of operationStatusesParse.data) {
                        //     if (!stat.isSuccess) {
                        //         outPut['statusCode'] = stat.statusCode;
                        //         if (response['status'] == 1) {
                        //             outPut['exception'] = response['data'];
                        //             outPut['errorMessage'] = response['data'];
                        //         }
                        //         else {
                        //             outPut['exception'] = response['data'];
                        //             outPut['errorMessage'] = response['data'];
                        //         }
                        //     }
                        // }
                        resolve({ message: "Api Response", status: 1, data: "" });
                    }
                } else {
                    resolve({ message: "Api Response", status: 0, data: "" });
                }

            }));
        });

    }
    sleep(ms) {
        try {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((resolve) => {
                    setTimeout(resolve, ms);
                });
            });
        } catch (error) {
            return 1;
        }

    }
    remoteApiCall(options) {
        try {
            return __awaiter(this, void 0, void 0, function* () {
                // let self=this;
                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    request(options, function (error, response, body) {
                        // console.log(error, response, body)
                        if (error || (!util_1.isNullOrUndefined(body) && body.status != 0)) {
                            if (error) {
                                resolve({ message: "Api Response", status: 1, data: error });
                            }
                            else if (!util_1.isNullOrUndefined(body) && !util_1.isNullOrUndefined(body.err)) {
                                resolve({ message: "Api Response", status: 1, data: body.err });
                            } else if (!util_1.isNullOrUndefined(body) && body.status != 0 && body.status != 1 && body.status != 2) {
                                resolve({ message: "Api Response", status: 1, data: body });
                            }
                        }
                        else {
                            resolve({ message: "Api Response", status: 0, data: "" });
                        }
                    });
                }));
            });
        } catch (e) {
            return ({ message: "Api Response", status: 1, data: e.toString() });
        }
    }
    getTableCordinates(options) {
        try {
            return __awaiter(this, void 0, void 0, function* () {
                // let self=this;
                return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                    request(options, function (error, response, body) {
                        // console.log(error, response, body)
                        if (error) {
                            if (error) {
                                resolve({ message: "Api Response", status: 1, data: error });
                            }
                            else if (!util_1.isNullOrUndefined(body) && !util_1.isNullOrUndefined(body.err)) {
                                resolve({ message: "Api Response", status: 1, data: body.err });
                            }
                        }
                        else {
                            resolve({ message: "Api Response", status: 0, data: body });
                        }
                    });
                }));
            });
        } catch (e) {
            return ({ message: "Api Response", status: 1, data: e.toString() });
        }
    }
    getTableColumns(response) {
        try {

            let columns = [];
            let finalColumns = [];
            for (let i = 0; i < response['tableStructureCordinates'].length; i++) {

                let element = response['tableStructureCordinates'][i];
                if (element['type'] == "table column" && util_1.isNullOrUndefined(element['marked'])) {
                    if (columns.length > 0) {
                        finalColumns.push(columns);
                        columns = [];
                    }
                    columns.push(element);
                    element['marked'] = true;
                    for (let j = i + 1; j < response['tableStructureCordinates'].length; j++) {

                        let elementNext = response['tableStructureCordinates'][j];
                        if (elementNext['type'] == "table column") {
                            if ((element['ymin'] - elementNext['ymin'] <= 5 || element['ymin'] - elementNext['ymin'] >= -5) || (element['ymax'] - elementNext['ymax'] <= 5 || element['ymax'] - elementNext['ymax'] >= -5)) {
                                columns.push(elementNext);
                                elementNext['marked'] = true;
                            }
                        }
                    }
                }
                if (i == response['tableStructureCordinates'].length - 1) {
                    if (columns.length > 0) {
                        columns.sort(function (a, b) {
                            return a.xmin - b.xmin;
                        });
                        finalColumns.push(columns);
                        columns = [];
                    }
                }
            }
            return finalColumns;
        } catch (e) {
            return [];
        }
    }

    linebylinemulti(req, res) {
        return __awaiter(this, void 0, void 0, function* () {
            let self = this;
            try {
                logger.info('Inside findUplode');
                var fs = require('fs');
                let body = req.body;
                let eventId = body.input.eventId;
                let projectId = body.projectId;
                let botId = body.botId;
                let token = body.token;
                let outputDataMulti = [];
                let iterationId = body.iterationId;
                let filePath;
                let multiFilePath = (body.input.filePath);
                // console.log(body.input.filePath, (body.input.filePath).length)
                for (let i = 0; i < multiFilePath.length; i++) {
                    filePath = Object.values(multiFilePath[i])[0];
                    console.log("oh------", filePath)
                    //let filePath = !util_2.isNullOrUndefined(body.input.filePath) ? body.input.filePath : '';
                    // if (!util_2.isNullOrUndefined(body.input.filePath) && typeof body.input.filePath !== "string" && body.input.filePath.length > 0) {
                    //     filePath = body.input.filePath[iterationId];
                    // }
                    // else {
                    //     filePath = !util_2.isNullOrUndefined(body.input.filePath) ? body.input.filePath : '';
                    // }

                    //   let body = req.body;
                    let fileName;
                    // console.log("---------------body---", JSON.stringify(body));
                    // const filePath = !util_2.isNullOrUndefined(body.input.filePath) ? body.input.filePath : '';
                    //    const filePath = !util_2.isNullOrUndefined(body.filePath) ? body.filePath : '';
                    // console.log(filePath);
                    const file = fs.readFileSync(filePath);
                    if (!util_2.isNullOrUndefined(file) && file !== '') {
                        // fileData['file'] = file.toString('base64');
                        fileName = file.toString('base64');
                    }
                    else {
                    }
                    // let folderPath = body.input.folderPath;

                    // let renameFile1=body.input.renameFile;
                    let fileData = [];
                    // requestData(fileData, callback) {
                    logger.info('Inside Request Data');
                    /*Send file to google vision api*/
                    // let rawData = fileData.file;
                    let rawData = fileName;
                    console.log("6");
                    const baseUrl = "https://vision.googleapis.com/v1/images:annotate", data = {
                        'requests': [
                            {
                                'image': {
                                    'content': rawData
                                },
                                'features': [
                                    {
                                        'type': 'DOCUMENT_TEXT_DETECTION'
                                    }
                                ]
                            }
                        ]
                    }, self = this;
                    const urloptions = {
                        url: baseUrl + "?key=" + subscriptionKey,
                        headers: {
                            'Content-Type': 'application/octet-stream',
                            'Ocp-Apim-Subscription-Key': subscriptionKey
                        },
                        body: data,
                        json: true
                    };
                    let lineWithCombineWordsNew = yield self.linebylinemultiloop(urloptions, filePath)
                    outputDataMulti.push(lineWithCombineWordsNew)
                }
                let outputData = { "output": outputDataMulti, "uplodeStatus": true, 'statusCode': '200' };
                let taskData = { 'projectId': projectId, 'botId': botId, 'eventId': eventId, 'iterationId': iterationId, 'status': 'Complete', 'outputParameters': outputData };
                let headers = { 'authorization': token, 'content-type': "application/json" };
                //  let headers = { 'authorization': body['token'], 'content-type': "application/json", "selectedorgid": body['selectedorgid'] };
                //"https://cuda-testing.gibots.com/gibots-api/orchestrator/botsiowrite"
                // console.log(JSON.stringify(headers), " ======>>>>>>>----------->>>>>>>> ", JSON.stringify(taskData));
                var options = {
                    method: 'POST',
                    url: config.pdfServerUrl + "gibots-orch/orchestrator/botsiowrite",
                    //url: "http://cuda-testing.gibots.com:1443/gibots-api/orchestrator/botsiowrite",
                    headers: headers,
                    body: taskData,
                    json: true
                };
                process.env['NODE_TLS_REJECT_UNAUTHORIZED'] = '0';
                request(options, function (error, response, body) {
                    console.log("--------------err in res", error);
                    console.log("body---responce", body);
                    console.log("--*******-res", response);
                });
                // }
                // console.log("Filedat------", JSON.stringify(fileData));
            }
            catch (err) {
                logger.error('Inside catch---- ' + err);
            }
        });
    }
    linebylinemultiloop(urloptions, filePath) {

        return __awaiter(this, void 0, void 0, function* () {
            let fileData = []
            let self = this;

            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {

                request.post(urloptions, function (err, resp, body) {
                    if (err) {
                        console.log("Eroooroor" + err);
                        // callback(err, null);
                    }
                    else {
                        if (util_1.isNullOrUndefined(body['responses'][0]['fullTextAnnotation'])) {
                            console.log("Inside request if condition");
                            //     // callback(true);
                        }
                        else {
                            console.log("Error" + err);
                            //   console.log("Response" + JSON.stringify(resp));
                            fileData['sortedLines'] = body['responses'][0];
                            //  let  filePath = fileData.obj.filePath;
                            //  let filepath2= filePath.replace(/.png|.jpg/,'');
                            //console.log("filepath of json=================>",filepath2);
                            // fs.writeFileSync('/var/www/cuda-fs/fulltext.json', JSON.stringify(body['responses'][0]['fullTextAnnotation']));
                            //google call--   
                            let result = [];
                            for (let i = 0; i < fileData['sortedLines'].fullTextAnnotation.pages[0].blocks.length; i++) {
                                let obj = {};
                                let x = [];
                                let y = [];
                                for (let j = 0; j < fileData['sortedLines'].fullTextAnnotation.pages[0].blocks[i].boundingBox.vertices.length; j++) {
                                    x.push(fileData['sortedLines'].fullTextAnnotation.pages[0].blocks[i].boundingBox.vertices[j].x);
                                    y.push(fileData['sortedLines'].fullTextAnnotation.pages[0].blocks[i].boundingBox.vertices[j].y);
                                }
                                x.sort();
                                y.sort();
                                obj['confidence'] = fileData['sortedLines'].fullTextAnnotation.pages[0].blocks[i].confidence;
                                obj['leftX'] = x[0];
                                obj['rightX'] = x[x.length - 1];
                                obj['topY'] = y[0];
                                obj['bottomY'] = y[y.length - 1];
                                result.push(obj);
                            }
                            fileData['confidanceBox'] = result;
                            fileData['pageWidth'] = body['responses'][0]['fullTextAnnotation'].pages[0].width;
                            fileData['pageHeight'] = body['responses'][0]['fullTextAnnotation'].pages[0].height;
                            logger.info('Inside Get Sorted Lines');
                            /*Create object of words here set - Name, leftX, rightX, topY, bottomY and sort it topY*/
                            let resp = fileData.sortedLines;
                            //  console.log("respoce filedata",JSON.stringify(resp));
                            if (!util_1.isNullOrUndefined(resp['textAnnotations'])) {
                                console.log("--------------INNNNNN");
                                let lineWords = resp['textAnnotations'];
                                let sortedWords;
                                let lines = self.processWords(lineWords);
                                sortedWords = JSON.parse(JSON.stringify(lines));
                                sortedWords.sort(function (a, b) {
                                    return a["pageNo"] - b["pageNo"] || a["topY"] - b["topY"];
                                });
                                fileData['sortedWords'] = sortedWords;
                                fileData['combineWords'] = lines;
                                //here sorted words-----
                                //fs.writeFileSync('/var/www/cuda-fs/fulltext_11.json',JSON.stringify(fileData['combineWords']);
                                // fs.writeFileSync('/var/www/cuda-fs/PRADNYA_combineWords_' + new Date() + '.json', JSON.stringify(lines));
                                // fs.writeFileSync('/var/www/cuda-fs/PRADNYA_sortedWords_' + new Date() + '.json', JSON.stringify(sortedWords));
                                // fileData['fileRefNum'] = fileData.obj.fileRefNum;
                                fileData['raw'] = lineWords;
                                delete fileData.sortedLines;
                            }
                            logger.info('Inside combine lines');
                            let scanData = {
                                "_id": "5eaab641e646f10be6f6badc",
                                "updatedAt": "2020-06-29T10:00:38.733Z", "createdAt": "2020-04-07T09:52:49.535Z", "userId": "5beaabd82ac6767c86dc311e",
                                "subscriberId": "5beaabd82ac6767c86dc311c", "orgId": "5c495dbfffa2a85b2c19a77f", "__v": 0, "ruleId": "5e8c8b03a215f50edc23381a",
                                "tableEnd": ["total", "sub-total", "sub total", "subtotal", "gross amount", "net amount", "net amt", "gross amt", "gross total", "Total / Total"],
                                "tableStart": ["No", "item Name", "qty", "quantity", "description", "item description", "vat rate", "FAM", "Article", "Ord.Qty", "Barcode", "desc",
                                    "rate", "te", "tax", "per", "hsn/sac", "amount", "Item", "item", "vat", "itm", "net", "PCS", "gross", "net", "si", "PRICE", "UNIT", "OTY", "DESCRIPTIONS",
                                    "SR.N", "UnitConv.", "Unit.Cost", "Tot.Cost", "Discount", "Gross Total", "Ex.Tax", "Vendor Ref.", "St.Bin", "St.Lo", "S", "S.No", "Seq", "Taskcard/Interval",
                                    "Item", "R. (Op)", "Step", "Panel No", "Panel Description", "Affected Taskcard", "Time", "Sr.", "CGST", "SGST", "IGST", "Qty /", "Total gross /", "Item /Producto",
                                    "No. /No."], "isDeleted": false, "functionNames": [["requestData", "getsortedLines", "combineLines", "extractFeatures", "saveDocTrainData", "identifyTable",
                                        "extractTableData", "genrateCsv", "runTrainingForInvoice", "prepareFormData", "prepareTableData", "createItemObject", "saveErrorInvoice"]],
                                "ruleName": "OfflineOcr", "tableMapping": {
                                    "Total gross /": "Total gross", "VAT amount/IVA": "Tax Amount", "VAT": "Tax Rate", "No. /No.": "srNo",
                                    "Item /Producto": "Item", "Qty /": "Quantity", "Unit net pricel": "Unit Price", "Total net/Total": "Net Amount", "SKUDESCRIPTION": "Description Of Goods",
                                    "SKU/DESCRIPTION": "Description Of Goods", "ID": "ID", "BETRAG(EUR)": "BETRAG(EUR)", "MWST.": "MWST.", "ZWISCHENSUMME": "ZWISCHENSUMME", "RABATTE": "RABATTE",
                                    "BESCHREIBUNG": "BESCHREIBUNG", "STOCKPREIS": "STOCKPREIS", "AMOUNT(INR)": "Amount (INR)", "AMOUNT(CAD)": "Amount(CAD)", "AMOUNT(USD)": "Amount(USD)",
                                    "CHARGES(RS.)": "Charges (Rs.)", "UNITRATE": "Unit Rate", "BILLED": "Billed", "FREE": "Free", "USAGE": "Usage", "PLANNAME": "Plan Name", "RATE": "Rate",
                                    "AMT": "Amount", "PER": "Per", "AMOUNT": "Amount", "INVOICENUMBER": "Invoice Number", "DOCUMENTNUMBER": "Document Number", "DOCUMENTDATE": "Document Date",
                                    "INVOICEAMOUNT": "Invoice Amount", "DEDUCTIONS": "Deductions", "NETAMOUNT": "Net Amount", "SNO": "srNo", "SNO.": "srNo", "MATERIALCODE": "Material Code",
                                    "DESCRIPTIONOFGOODS": "Description Of Goods", "DESCRIPTIONOF": "Description Of Goods", "DESCRIPTION": "Description Of Goods", "HSNSACNO.": "HSN / SAC No",
                                    "HSNSACNO": "HSN / SAC No", "HSN/SACNO": "HSN / SAC No", "HSN/SACNO.": "HSN / SAC No", "QUANTITY": "Quantity", "UNITPRICE": "Unit Price",
                                    "SALESPRICE": "Sales Price", "DISCOUNT": "Discount", "TAXABLEVALUE": "Taxable Value", "CGSTRATE": "CGST Rate", "CGST": "CGST", "SGST/UGSTRATE": "SGST / UGST Rate",
                                    "SGST/UGST": "SGST / UGST", "TOTALVALUE": "Total Value", "IGST": "IGST", "IGSTRATE": "IGST Rate", "ITEM": "Item", "LINEPRICE": "Line Price", "SLNO": "SL NO",
                                    "PRODUCT": "Product", "TAXRATE": "Tax Rate", "TAXTYPE": "Tax Type", "TAXAMOUNT": "Tax Amount", "PRICE": "Price", "QTY": "Quantity", "QTY.": "Quantity",
                                    "ITEMCODE": "Item Code", "ITEMDESCRIPTION": "Item Description", "TAXCODE": "Tax Code", "NO": "No", "UNITPRICE(USD)": "UNIT PRICE (USD)",
                                    "TOTALPRICE(USD)": "TOTAL PRICE (USD)", "DESCRIPTIONOFSERVICES/GOODS": "Description of Services / Goods", "HSN/SAC": "HSN/SAC", "SR.No.": "SR.No.",
                                    "TAXABLEAMOUNT": "Taxable Amount", "SRNo": "SR No", "SGST": "SGST", "UNITS(KVARH)": "Units ( kVArh )", "COST(F)": "Cost(f)", "OTY": "Quantity",
                                    "ITEM/DESCRIPTION": "Item / Description", "SERIALNO": "Serial No", "RENTALFROM": "Rental From", "RENTALTO": "Rental To", "UNIT": "Unit", "SALESTAX": "Sales Tax",
                                    "TOTALPRICE": "Total Price", "HSN": "HSN / SAC No"
                                }, "langs": ["eng"], "fields": [{
                                    "_id": "5e8c4d711c51481d0743ac8a", "bottomY": 0, "topY": 0, "rightX": 0,
                                    "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": true, "value": "", "placeHolder": "", "fieldType": "string",
                                    "fieldName": "Supplier_Name"
                                }, {
                                    "_id": "5e8c4d711c51481d0743ac89", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "",
                                    "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Date"
                                },
                                {
                                    "_id": "5e8c4d711c51481d0743ac88", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false,
                                    "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "TRN_number"
                                },
                                {
                                    "_id": "5e8c4d711c51481d0743ac87", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false,
                                    "required": true, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Invoice_No"
                                }, {
                                    "_id": "5e90170b4275654305fcad14", "bottomY": 0, "topY": 0,
                                    "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "",
                                    "fieldType": "string", "fieldName": "Supplier_Address"
                                }, {
                                    "_id": "5e9072d44275654305fcae2d", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "",
                                    "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Supplier_Code"
                                },
                                {
                                    "_id": "5e9072d44275654305fcae2c", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false,
                                    "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "InvoiceTotalAmount"
                                }, {
                                    "_id": "5e9072d44275654305fcae2b", "bottomY": 0,
                                    "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "",
                                    "fieldType": "string", "fieldName": "InvTotalTaxAmt"
                                }, {
                                    "_id": "5e9072d44275654305fcae2a", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "",
                                    "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Payment_Due_Date"
                                },
                                {
                                    "_id": "5e9072d44275654305fcae29", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false,
                                    "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "PO_Number"
                                }, {
                                    "_id": "5e9072d44275654305fcae28", "bottomY": 0, "topY": 0,
                                    "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "",
                                    "fieldType": "string", "fieldName": "PO_Date"
                                }, {
                                    "_id": "5ea54c903c3d666ead88b26b", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "",
                                    "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "float", "fieldName": "Currency"
                                },
                                {
                                    "_id": "5ea54c903c3d666ead88b26a", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false,
                                    "required": false, "value": "", "placeHolder": "", "fieldType": "float", "fieldName": "Other_Charges"
                                }, {
                                    "_id": "5ea54c903c3d666ead88b269", "bottomY": 0,
                                    "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "",
                                    "fieldType": "float", "fieldName": "Discount"
                                }, {
                                    "_id": "5ea54c903c3d666ead88b268", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "",
                                    "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Country"
                                },
                                {
                                    "_id": "5ea54c903c3d666ead88b267", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false,
                                    "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Supplier_city"
                                }, {
                                    "_id": "5ea54c903c3d666ead88b266", "bottomY": 0,
                                    "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "",
                                    "fieldType": "any", "fieldName": "Supplier_Zip_Code"
                                }, {
                                    "_id": "5ea54c903c3d666ead88b265", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "",
                                    "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Customer_City"
                                },
                                {
                                    "_id": "5ea54c903c3d666ead88b264", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false,
                                    "required": false, "value": "", "placeHolder": "", "fieldType": "any", "fieldName": "Customer_Zip_Code"
                                }, {
                                    "_id": "5ea54c903c3d666ead88b263", "bottomY": 0,
                                    "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "",
                                    "fieldType": "string", "fieldName": "Customer_Address"
                                }, {
                                    "_id": "5ea54c903c3d666ead88b262", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "",
                                    "tableName": "", "isTable": false, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "float", "fieldName": "Net_Total"
                                },
                                {
                                    "_id": "5e946620e5e25861e5936fa2", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false,
                                    "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "SlNo"
                                }, {
                                    "_id": "5e946620e5e25861e5936fa1", "bottomY": 0, "topY": 0,
                                    "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false, "required": false, "value": "", "placeHolder": "",
                                    "fieldType": "string", "fieldName": "Description"
                                }, {
                                    "_id": "5e946620e5e25861e5936f9e", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "",
                                    "tableName": "Invoice", "isTable": true, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "number", "fieldName": "Quantity"
                                },
                                {
                                    "_id": "5e946620e5e25861e5936f9d", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false,
                                    "required": false, "value": "", "placeHolder": "", "fieldType": "float", "fieldName": "Rate"
                                }, {
                                    "_id": "5e946620e5e25861e5936f9b", "bottomY": 0, "topY": 0,
                                    "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false, "required": false, "value": "", "placeHolder": "",
                                    "fieldType": "float", "fieldName": "Amount"
                                }, {
                                    "_id": "5e946620e5e25861e5936f9a", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "",
                                    "tableName": "Invoice", "isTable": true, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "Product_Code"
                                },
                                {
                                    "_id": "5e946620e5e25861e5936f99", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false,
                                    "required": false, "value": "", "placeHolder": "", "fieldType": "float", "fieldName": "Tax_percent"
                                }, {
                                    "_id": "5e946620e5e25861e5936f98", "bottomY": 0, "topY": 0,
                                    "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false, "required": false, "value": "", "placeHolder": "",
                                    "fieldType": "float", "fieldName": "Tax_Amount"
                                }, {
                                    "_id": "5e946620e5e25861e5936f97", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "",
                                    "tableName": "Invoice", "isTable": true, "isDMSKey": false, "required": false, "value": "", "placeHolder": "", "fieldType": "string", "fieldName": "TRN"
                                },
                                {
                                    "_id": "5e94665ae5e25861e5936fa8", "bottomY": 0, "topY": 0, "rightX": 0, "leftX": 0, "dateFormat": "", "tableName": "Invoice", "isTable": true, "isDMSKey": false,
                                    "required": false, "value": "", "placeHolder": "", "fieldType": "float", "fieldName": "Taxable_Amount"
                                }], "isSystemDefined": false, "documentType": "Landmark"
                            };
                            // console.log("Scanfiled data",JSON.stringify(scanData));
                            // fs.writeFileSync("scanfiledPradnya.json",JSON.stringify(scanData));
                            /*Combine Lines and Words of lines here by overlapping*/
                            logger.info('Inside combine lines');
                            //  console.log("combineliness-----data--khann",JSON.stringify(fileData));
                            let itemData = _.groupBy(fileData.combineWords, 'pageNo');
                            let keys = Object.keys(itemData);
                            let sortedLines = [];
                            for (const lin of keys) {
                                let bags = itemData[lin];
                                bags.sort(function (a, b) {
                                    return a["topY"] - b["topY"] || a["leftX"] - b["leftX"];
                                });
                                let multiline = bags[0]["Name"];
                                multiline = multiline.match(/\n/g);
                                if (multiline) {
                                    bags.splice(0, 1);
                                }
                                // bags.splice(0, 1);
                                let topY = bags[0].topY, bottomY = bags[0].bottomY, leftX = bags[0].leftX;
                                let len = bags.length;
                                let line = [];
                                let firstWord = self.findFirstWord(bags, bags[0]);
                                if (firstWord.length > 0) {
                                    firstWord = _.sortBy(firstWord, 'leftX');
                                    firstWord.every(function (item) {
                                        if (leftX >= item.leftX) {
                                            line.push(item);
                                            leftX = item.leftX;
                                            bottomY = item.bottomY;
                                            topY = item.topY;
                                            bags = _.without(bags, _.findWhere(bags, { Name: item.Name, rightX: item.rightX, leftX: item.leftX, topY: item.topY, bottomY: item.bottomY }));
                                            return false;
                                        }
                                        else {
                                            return true;
                                        }
                                    });
                                }
                                else {
                                    line.push(bags[0]);
                                    bags.splice(0, 1);
                                }
                                let lineArray;
                                let j = 0;
                                while (bags.length > 0) {
                                    j++;
                                    lineArray = self.findNextLines(bags, topY, bottomY, leftX);
                                    lineArray = _.sortBy(lineArray, 'leftX');
                                    lineArray.every(function (item) {
                                        if (leftX <= item.leftX) {
                                            if (line.length > 0) {
                                                line.push(item);
                                            }
                                            leftX = item.leftX;
                                            bottomY = item.bottomY > bottomY ? item.bottomY : bottomY;
                                            bags = _.without(bags, _.findWhere(bags, { Name: item.Name, rightX: item.rightX, leftX: item.leftX, topY: item.topY, bottomY: item.bottomY }));
                                            return false;
                                        }
                                        else {
                                            return true;
                                        }
                                    });
                                    if (bags.length == 0) {
                                        sortedLines.push(line);
                                    }
                                    if (lineArray.length === 0) {
                                        sortedLines.push(line);
                                        bags.sort(function (a, b) {
                                            return a["topY"] - b["topY"] || a["leftX"] - b["leftX"];
                                        });
                                        topY = bags[0].topY;
                                        bottomY = bags[0].bottomY;
                                        leftX = bags[0].leftX;
                                        len = bags.length;
                                        line = [];
                                        let firstWord = self.findFirstWord(bags, bags[0]);
                                        if (firstWord.length > 0) {
                                            firstWord = _.sortBy(firstWord, 'leftX');
                                            firstWord.every(function (item) {
                                                if (leftX >= item.leftX) {
                                                    line.push(item);
                                                    leftX = item.leftX;
                                                    bottomY = item.bottomY;
                                                    topY = item.topY;
                                                    bags = _.without(bags, _.findWhere(bags, { Name: item.Name, rightX: item.rightX, leftX: item.leftX, topY: item.topY, bottomY: item.bottomY }));
                                                    return false;
                                                }
                                                else {
                                                    return true;
                                                }
                                            });
                                        }
                                        else {
                                            line.push(bags[0]);
                                            bags.splice(0, 1);
                                        }
                                    }
                                }
                            }
                            logger.info('Lines created successfully');
                            let sortedLinesNew = JSON.parse(JSON.stringify(sortedLines));
                            let lineWithCombineWords = [];
                            let lineWithCombineWordsNew = [];
                            var tableHeaders = [];
                            var tableHeadersW = [];
                            for (var k in scanData.tableMapping) {
                                tableHeadersW.push(k);
                                k = k.toLocaleUpperCase();
                                k = k.replace(/\s+/g, '');
                                tableHeaders.push(k);
                            }
                            for (let i = 0; i < sortedLines.length; i++) {
                                lineWithCombineWords.push(self.combineLineWords(sortedLines[i], sortedLines));
                                lineWithCombineWordsNew.push(self.combineTableHeaders(sortedLinesNew[i], tableHeaders));
                            }
                            // console.log(JSON.stringify(sortedLines));
                            fileData['Lines'] = sortedLines;
                            //fs.writeFileSync('LinesArray--11.json',JSON.stringify(sortedLines));
                            // fs.writeFileSync('linewwithCombinewords--11.json',JSON.stringify(lineWithCombineWords));
                            //fs.writeFileSync('BhaikhanPathanSahab.json',JSON.stringify(lineWithCombineWordsNew));
                            lineWithCombineWordsNew[0].push({ pagewidth: fileData.pageWidth, pageHieght: fileData.pageHeight });
                            fileData['lineWithCombineWords'] = lineWithCombineWords;
                            fileData['lineWithCombineWordsNew'] = lineWithCombineWordsNew;
                            delete fileData.combineWords;
                            let csvInfoArray = [];
                            fileData['csvInfoArray'] = csvInfoArray;
                            //  fileData['fileRefNum'] = fileData.obj.fileRefNum;
                            //  callback(null, fileData);
                            let ll = filePath.split(/\//);
                            console.log("LLLL ----------****__________>>>>>>>>>>>>>>>>>>>>", ll);
                            let namefile = ll[ll.length - 1];
                            let txtfile = namefile.replace(/.jpg|.png/g, '');
                            let output_filepath = '/var/www/cuda-fs/' + txtfile + '.txt';
                            console.log("Here is output filepth---->>>>>><<<<--------", output_filepath);
                            console.log("--------------------------------textfile created----", txtfile);
                            // fs.writeFileSync(output_filepath, JSON.stringify(lineWithCombineWordsNew));
                            resolve(lineWithCombineWordsNew)
                        }
                    }
                });

            }));

        })
    }
}
exports.WebsiteRoute = WebsiteRoute;
const websiteRouters = new WebsiteRoute();
websiteRouters.init();
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = websiteRouters.router;











